"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const assert_1 = (0, tslib_1.__importDefault)(require("assert"));
const t = (0, tslib_1.__importStar)(require(".."));
class C {
}
const fixtures = {
    null: null,
    undefined: undefined,
    string: "",
    number: 0,
    boolean: true,
    date: new Date(),
    promise: Promise.resolve(null),
    record: {},
    array: [],
    recordWithKeys: {
        a: {
            b: {
                c: "d",
            },
            e: null,
        },
        f: "g",
    },
    recordOfStrings: {
        a: "",
        b: "",
    },
    recordOfNumbers: {
        a: 0,
        b: 1,
    },
    strings: ["a", "b", "c"],
    numbers: [0, 1, 2],
    c: new C(),
};
const entries = Object.entries(fixtures);
const orNull = (t) => t;
const orUndefined = (t) => t;
const baseAsserts = [
    ["default", t.defaultAssert],
    ["node", assert_1.default],
];
describe("typed-assert", () => {
    for (const [label, baseAssert] of baseAsserts) {
        describe(label, () => {
            t.setBaseAssert(baseAssert);
            test("isUnknown", () => {
                for (const value of Object.values(fixtures)) {
                    expect(() => t.isUnknown(value)).not.toThrow();
                }
            });
            test("isNever", () => {
                expect(() => {
                    const value = "a";
                    switch (value) {
                        case "a":
                        case "b":
                            return;
                    }
                    t.isNever(value);
                }).not.toThrow();
            });
            test("isNotNull", () => {
                const v = orNull(fixtures.string);
                t.isNotNull(v);
                // v is "string"
                for (const [key, value] of entries) {
                    if (key === "null") {
                        expect(() => t.isNotNull(value)).toThrow();
                    }
                    else {
                        expect(() => t.isNotNull(value)).not.toThrow();
                    }
                }
            });
            test("isNotUndefined", () => {
                const v = orUndefined(fixtures.string);
                t.isNotUndefined(v);
                // v is "string"
                for (const [key, value] of entries) {
                    if (key === "undefined") {
                        expect(() => t.isNotUndefined(value)).toThrow();
                    }
                    else {
                        expect(() => t.isNotUndefined(value)).not.toThrow();
                    }
                }
            });
            test("isNotVoid", () => {
                const v = orNull(orUndefined(fixtures.string));
