               }
                return undefined;
            }
            function getDiscriminantPropertyAccess(expr, computedType) {
                var type = declaredType.flags & 1048576 /* TypeFlags.Union */ ? declaredType : computedType;
                if (type.flags & 1048576 /* TypeFlags.Union */) {
                    var access = getCandidateDiscriminantPropertyAccess(expr);
                    if (access) {
                        var name = getAccessedPropertyName(access);
                        if (name && isDiscriminantProperty(type, name)) {
                            return access;
                        }
                    }
                }
                return undefined;
            }
            function narrowTypeByDiscriminant(type, access, narrowType) {
                var propName = getAccessedPropertyName(access);
                if (propName === undefined) {
                    return type;
                }
                var removeNullable = strictNullChecks && ts.isOptionalChain(access) && maybeTypeOfKind(type, 98304 /* TypeFlags.Nullable */);
                var propType = getTypeOfPropertyOfType(removeNullable ? getTypeWithFacts(type, 2097152 /* TypeFacts.NEUndefinedOrNull */) : type, propName);
                if (!propType) {
                    return type;
                }
                propType = removeNullable ? getOptionalType(propType) : propType;
                var narrowedPropType = narrowType(propType);
                return filterType(type, function (t) {
                    var discriminantType = getTypeOfPropertyOrIndexSignature(t, propName);
                    return !(narrowedPropType.flags & 131072 /* TypeFlags.Never */) && isTypeComparableTo(narrowedPropType, discriminantType);
                });
            }
            function narrowTypeByDiscriminantProperty(type, access, operator, value, assumeTrue) {
                if ((operator === 36 /* SyntaxKind.EqualsEqualsEqualsToken */ || operator === 37 /* SyntaxKind.ExclamationEqualsEqualsToken */) && type.flags & 1048576 /* TypeFlags.Union */) {
                    var keyPropertyName = getKeyPropertyName(type);
                    if (keyPropertyName && keyPropertyName === getAccessedPropertyName(access)) {
                        var candidate = getConstituentTypeForKeyType(type, getTypeOfExpression(value));
                        if (candidate) {
                            return operator === (assumeTrue ? 36 /* SyntaxKind.EqualsEqualsEqualsToken */ : 37 /* SyntaxKind.ExclamationEqualsEqualsToken */) ? candidate :
                                isUnitType(getTypeOfPropertyOfType(candidate, keyPropertyName) || unknownType) ? removeType(type, candidate) :
                                    type;
                        }
                    }
                }
                return narrowTypeByDiscriminant(type, access, function (t) { return narrowTypeByEquality(t, operator, value, assumeTrue); });
            }
            function narrowTypeBySwitchOnDiscriminantProperty(type, access, switchStatement, clauseStart, clauseEnd) {
                if (clauseStart < clauseEnd && type.flags & 1048576 /* TypeFlags.Union */ && getKeyPropertyName(type) === getAccessedPropertyName(access)) {
                    var clauseTypes = getSwitchClauseTypes(switchStatement).slice(clauseStart, clauseEnd);
                    var candidate = getUnionType(ts.map(clauseTypes, function (t) { return getConstituentTypeForKeyType(type, t) || unknownType; }));
                    if (candidate !== unknownType) {
                        return candidate;
                    }
                }
                return narrowTypeByDiscriminant(type, access, function (t) { return narrowTypeBySwitchOnDiscriminant(t, switchStatement, clauseStart, clauseEnd); });
            }
            function narrowTypeByTruthiness(type, expr, assumeTrue) {
                if (isMatchingReference(reference, expr)) {
                    return type.flags & 2 /* TypeFlags.Unknown */ && assumeTrue ? nonNullUnknownType :
                        getTypeWithFacts(type, assumeTrue ? 4194304 /* TypeFacts.Truthy */ : 8388608 /* TypeFacts.Falsy */);
                }
                if (strictNullChecks && assumeTrue && optionalChainContainsReference(expr, reference)) {
                    type = getTypeWithFacts(type, 2097152 /* TypeFacts.NEUndefinedOrNull */);
                }
                var access = getDiscriminantPropertyAccess(expr, type);
                if (access) {
                    return narrowTypeByDiscriminant(type, access, function (t) { return getTypeWithFacts(t, assumeTrue ? 4194304 /* TypeFacts.Truthy */ : 8388608 /* TypeFacts.Falsy */); });
                }
                return type;
            }
            function isTypePresencePossible(type, propName, assumeTrue) {
                var prop = getPropertyOfType(type, propName);
                if (prop) {
                    return prop.flags & 16777216 /* SymbolFlags.Optional */ ? true : assumeTrue;
                }
                return getApplicableIndexInfoForName(type, propName) ? true : !assumeTrue;
            }
            function narrowByInKeyword(type, name, assumeTrue) {
                if (type.flags & 1048576 /* TypeFlags.Union */
                    || type.flags & 524288 /* TypeFlags.Object */ && declaredType !== type
                    || ts.isThisTypeParameter(type)
                    || type.flags & 2097152 /* TypeFlags.Intersection */ && ts.every(type.types, function (t) { return t.symbol !== globalThisSymbol; })) {
                    return filterType(type, function (t) { return isTypePresencePossible(t, name, assumeTrue); });
                }
                return type;
            }
            function narrowTypeByBinaryExpression(type, expr, assumeTrue) {
                switch (expr.operatorToken.kind) {
                    case 63 /* SyntaxKind.EqualsToken */:
                    case 75 /* SyntaxKind.BarBarEqualsToken */:
                    case 76 /* SyntaxKind.AmpersandAmpersandEqualsToken */:
                    case 77 /* SyntaxKind.QuestionQuestionEqualsToken */:
                        return narrowTypeByTruthiness(narrowType(type, expr.right, assumeTrue), expr.left, assumeTrue);
                    case 34 /* SyntaxKind.EqualsEqualsToken */:
                    case 35 /* SyntaxKind.ExclamationEqualsToken */:
                    case 36 /* SyntaxKind.EqualsEqualsEqualsToken */:
                    case 37 /* SyntaxKind.ExclamationEqualsEqualsToken */:
                        var operator = expr.operatorToken.kind;
                        var left = getReferenceCandidate(expr.left);
                        var right = getReferenceCandidate(expr.right);
                        if (left.kind === 216 /* SyntaxKind.TypeOfExpression */ && ts.isStringLiteralLike(right)) {
                            return narrowTypeByTypeof(type, left, operator, right, assumeTrue);
                        }
                        if (right.kind === 216 /* SyntaxKind.TypeOfExpression */ && ts.isStringLiteralLike(left)) {
                            return narrowTypeByTypeof(type, right, operator, left, assumeTrue);
                        }
                        if (isMatchingReference(reference, left)) {
                            return narrowTypeByEquality(type, operator, right, assumeTrue);
                        }
                        if (isMatchingReference(reference, right)) {
                            return narrowTypeByEquality(type, operator, left, assumeTrue);
                        }
                        if (strictNullChecks) {
                            if (optionalChainContainsReference(left, reference)) {
                                type = narrowTypeByOptionalChainContainment(type, operator, right, assumeTrue);
                            }
                            else if (optionalChainContainsReference(right, reference)) {
                                type = narrowTypeByOptionalChainContainment(type, operator, left, assumeTrue);
                            }
                        }
                        var leftAccess = getDiscriminantPropertyAccess(left, type);
                        if (leftAccess) {
                            return narrowTypeByDiscriminantProperty(type, leftAccess, operator, right, assumeTrue);
                        }
                        var rightAccess = getDiscriminantPropertyAccess(right, type);
                        if (rightAccess) {
                            return narrowTypeByDiscriminantProperty(type, rightAccess, operator, left, assumeTrue);
                        }
                        if (isMatchingConstructorReference(left)) {
                            return narrowTypeByConstructor(type, operator, right, assumeTrue);
                        }
                        if (isMatchingConstructorReference(right)) {
                            return narrowTypeByConstructor(type, operator, left, assumeTrue);
                        }
                        break;
                    case 102 /* SyntaxKind.InstanceOfKeyword */:
                        return narrowTypeByInstanceof(type, expr, assumeTrue);
                    case 101 /* SyntaxKind.InKeyword */:
                        if (ts.isPrivateIdentifier(expr.left)) {
                            return narrowTypeByPrivateIdentifierInInExpression(type, expr, assumeTrue);
                        }
                        var target = getReferenceCandidate(expr.right);
                        var leftType = getTypeOfNode(expr.left);
                        if (leftType.flags & 128 /* TypeFlags.StringLiteral */) {
                            var name = ts.escapeLeadingUnderscores(leftType.value);
                            if (containsMissingType(type) && ts.isAccessExpression(reference) && isMatchingReference(reference.expression, target) &&
                                getAccessedPropertyName(reference) === name) {
                                return getTypeWithFacts(type, assumeTrue ? 524288 /* TypeFacts.NEUndefined */ : 65536 /* TypeFacts.EQUndefined */);
                            }
                            if (isMatchingReference(reference, target)) {
                                return narrowByInKeyword(type, name, assumeTrue);
                            }
                        }
                        break;
                    case 27 /* SyntaxKind.CommaToken */:
                        return narrowType(type, expr.right, assumeTrue);
                    // Ordinarily we won't see && and || expressions in control flow analysis because the Binder breaks those
                    // expressions down to individual conditional control flows. However, we may encounter them when analyzing
                    // aliased conditional expressions.
                    case 55 /* SyntaxKind.AmpersandAmpersandToken */:
                        return assumeTrue ?
                            narrowType(narrowType(type, expr.left, /*assumeTrue*/ true), expr.right, /*assumeTrue*/ true) :
                            getUnionType([narrowType(type, expr.left, /*assumeTrue*/ false), narrowType(type, expr.right, /*assumeTrue*/ false)]);
                    case 56 /* SyntaxKind.BarBarToken */:
                        return assumeTrue ?
                            getUnionType([narrowType(type, expr.left, /*assumeTrue*/ true), narrowType(type, expr.right, /*assumeTrue*/ true)]) :
                            narrowType(narrowType(type, expr.left, /*assumeTrue*/ false), expr.right, /*assumeTrue*/ false);
                }
                return type;
            }
            function narrowTypeByPrivateIdentifierInInExpression(type, expr, assumeTrue) {
                var target = getReferenceCandidate(expr.right);
                if (!isMatchingReference(reference, target)) {
                    return type;
                }
                ts.Debug.assertNode(expr.left, ts.isPrivateIdentifier);
                var symbol = getSymbolForPrivateIdentifierExpression(expr.left);
                if (symbol === undefined) {
                    return type;
                }
                var classSymbol = symbol.parent;
                var targetType = ts.hasStaticModifier(ts.Debug.checkDefined(symbol.valueDeclaration, "should always have a declaration"))
                    ? getTypeOfSymbol(classSymbol)
                    : getDeclaredTypeOfSymbol(classSymbol);
                return getNarrowedType(type, targetType, assumeTrue, isTypeDerivedFrom);
            }
            function narrowTypeByOptionalChainContainment(type, operator, value, assumeTrue) {
                // We are in a branch of obj?.foo === value (or any one of the other equality operators). We narrow obj as follows:
                // When operator is === and type of value excludes undefined, null and undefined is removed from type of obj in true branch.
                // When operator is !== and type of value excludes undefined, null and undefined is removed from type of obj in false branch.
                // When operator is == and type of value excludes null and undefined, null and undefined is removed from type of obj in true branch.
                // When operator is != and type of value excludes null and undefined, null and undefined is removed from type of obj in false branch.
                // When operator is === and type of value is undefined, null and undefined is removed from type of obj in false branch.
                // When operator is !== and type of value is undefined, null and undefined is removed from type of obj in true branch.
                // When operator is == and type of value is null or undefined, null and undefined is removed from type of obj in false branch.
                // When operator is != and type of value is null or undefined, null and undefined is removed from type of obj in true branch.
                var equalsOperator = operator === 34 /* SyntaxKind.EqualsEqualsToken */ || operator === 36 /* SyntaxKind.EqualsEqualsEqualsToken */;
                var nullableFlags = operator === 34 /* SyntaxKind.EqualsEqualsToken */ || operator === 35 /* SyntaxKind.ExclamationEqualsToken */ ? 98304 /* TypeFlags.Nullable */ : 32768 /* TypeFlags.Undefined */;
                var valueType = getTypeOfExpression(value);
                // Note that we include any and unknown in the exclusion test because their domain includes null and undefined.
                var removeNullable = equalsOperator !== assumeTrue && everyType(valueType, function (t) { return !!(t.flags & nullableFlags); }) ||
                    equalsOperator === assumeTrue && everyType(valueType, function (t) { return !(t.flags & (3 /* TypeFlags.AnyOrUnknown */ | nullableFlags)); });
                return removeNullable ? getTypeWithFacts(type, 2097152 /* TypeFacts.NEUndefinedOrNull */) : type;
            }
            function narrowTypeByEquality(type, operator, value, assumeTrue) {
                if (type.flags & 1 /* TypeFlags.Any */) {
                    return type;
                }
                if (operator === 35 /* SyntaxKind.ExclamationEqualsToken */ || operator === 37 /* SyntaxKind.ExclamationEqualsEqualsToken */) {
                    assumeTrue = !assumeTrue;
                }
                var valueType = getTypeOfExpression(value);
                if (assumeTrue && (type.flags & 2 /* TypeFlags.Unknown */) && (operator === 34 /* SyntaxKind.EqualsEqualsToken */ || operator === 35 /* SyntaxKind.ExclamationEqualsToken */) && (valueType.flags & 65536 /* TypeFlags.Null */)) {
                    return getUnionType([nullType, undefinedType]);
                }
                if ((type.flags & 2 /* TypeFlags.Unknown */) && assumeTrue && (operator === 36 /* SyntaxKind.EqualsEqualsEqualsToken */ || operator === 37 /* SyntaxKind.ExclamationEqualsEqualsToken */)) {
                    if (valueType.flags & (131068 /* TypeFlags.Primitive */ | 67108864 /* TypeFlags.NonPrimitive */)) {
                        return valueType;
                    }
                    if (valueType.flags & 524288 /* TypeFlags.Object */) {
                        return nonPrimitiveType;
                    }
                    return type;
                }
                if (valueType.flags & 98304 /* TypeFlags.Nullable */) {
                    if (!strictNullChecks) {
                        return type;
                    }
                    var doubleEquals = operator === 34 /* SyntaxKind.EqualsEqualsToken */ || operator === 35 /* SyntaxKind.ExclamationEqualsToken */;
                    var facts = doubleEquals ?
                        assumeTrue ? 262144 /* TypeFacts.EQUndefinedOrNull */ : 2097152 /* TypeFacts.NEUndefinedOrNull */ :
                        valueType.flags & 65536 /* TypeFlags.Null */ ?
                            assumeTrue ? 131072 /* TypeFacts.EQNull */ : 1048576 /* TypeFacts.NENull */ :
                            assumeTrue ? 65536 /* TypeFacts.EQUndefined */ : 524288 /* TypeFacts.NEUndefined */;
                    return type.flags & 2 /* TypeFlags.Unknown */ && facts & (1048576 /* TypeFacts.NENull */ | 2097152 /* TypeFacts.NEUndefinedOrNull */) ? nonNullUnknownType : getTypeWithFacts(type, facts);
                }
                if (assumeTrue) {
                    var filterFn = operator === 34 /* SyntaxKind.EqualsEqualsToken */ ?
                        function (t) { return areTypesComparable(t, valueType) || isCoercibleUnderDoubleEquals(t, valueType); } :
                        function (t) { return areTypesComparable(t, valueType); };
                    return replacePrimitivesWithLiterals(filterType(type, filterFn), valueType);
                }
                if (isUnitType(valueType)) {
                    return filterType(type, function (t) { return !(isUnitLikeType(t) && areTypesComparable(t, valueType)); });
                }
                return type;
            }
            function narrowTypeByTypeof(type, typeOfExpr, operator, literal, assumeTrue) {
                // We have '==', '!=', '===', or !==' operator with 'typeof xxx' and string literal operands
                if (operator === 35 /* SyntaxKind.ExclamationEqualsToken */ || operator === 37 /* SyntaxKind.ExclamationEqualsEqualsToken */) {
                    assumeTrue = !assumeTrue;
                }
                var target = getReferenceCandidate(typeOfExpr.expression);
                if (!isMatchingReference(reference, target)) {
                    if (strictNullChecks && optionalChainContainsReference(target, reference) && assumeTrue === (literal.text !== "undefined")) {
                        return getTypeWithFacts(type, 2097152 /* TypeFacts.NEUndefinedOrNull */);
                    }
                    return type;
                }
                if (type.flags & 1 /* TypeFlags.Any */ && literal.text === "function") {
                    return type;
                }
                if (assumeTrue && type.flags & 2 /* TypeFlags.Unknown */ && literal.text === "object") {
                    // The non-null unknown type is used to track whether a previous narrowing operation has removed the null type
                    // from the unknown type. For example, the expression `x && typeof x === 'object'` first narrows x to the non-null
                    // unknown type, and then narrows that to the non-primitive type.
                    return type === nonNullUnknownType ? nonPrimitiveType : getUnionType([nonPrimitiveType, nullType]);
                }
                var facts = assumeTrue ?
                    typeofEQFacts.get(literal.text) || 128 /* TypeFacts.TypeofEQHostObject */ :
                    typeofNEFacts.get(literal.text) || 32768 /* TypeFacts.TypeofNEHostObject */;
                var impliedType = getImpliedTypeFromTypeofGuard(type, literal.text);
                return getTypeWithFacts(assumeTrue && impliedType ? mapType(type, narrowUnionMemberByTypeof(impliedType)) : type, facts);
            }
            function narrowTypeBySwitchOptionalChainContainment(type, switchStatement, clauseStart, clauseEnd, clauseCheck) {
                var everyClauseChecks = clauseStart !== clauseEnd && ts.every(getSwitchClauseTypes(switchStatement).slice(clauseStart, clauseEnd), clauseCheck);
                return everyClauseChecks ? getTypeWithFacts(type, 2097152 /* TypeFacts.NEUndefinedOrNull */) : type;
            }
            function narrowTypeBySwitchOnDiscriminant(type, switchStatement, clauseStart, clauseEnd) {
                // We only narrow if all case expressions specify
                // values with unit types, except for the case where
                // `type` is unknown. In this instance we map object
                // types to the nonPrimitive type and narrow with that.
                var switchTypes = getSwitchClauseTypes(switchStatement);
                if (!switchTypes.length) {
                    return type;
                }
                var clauseTypes = switchTypes.slice(clauseStart, clauseEnd);
                var hasDefaultClause = clauseStart === clauseEnd || ts.contains(clauseTypes, neverType);
                if ((type.flags & 2 /* TypeFlags.Unknown */) && !hasDefaultClause) {
                    var groundClauseTypes = void 0;
                    for (var i = 0; i < clauseTypes.length; i += 1) {
                        var t = clauseTypes[i];
                        if (t.flags & (131068 /* TypeFlags.Primitive */ | 67108864 /* TypeFlags.NonPrimitive */)) {
                            if (groundClauseTypes !== undefined) {
                                groundClauseTypes.push(t);
                            }
                        }
                        else if (t.flags & 524288 /* TypeFlags.Object */) {
                            if (groundClauseTypes === undefined) {
                                groundClauseTypes = clauseTypes.slice(0, i);
                            }
                            groundClauseTypes.push(nonPrimitiveType);
                        }
                        else {
                            return type;
                        }
                    }
                    return getUnionType(groundClauseTypes === undefined ? clauseTypes : groundClauseTypes);
                }
                var discriminantType = getUnionType(clauseTypes);
                var caseType = discriminantType.flags & 131072 /* TypeFlags.Never */ ? neverType :
                    replacePrimitivesWithLiterals(filterType(type, function (t) { return areTypesComparable(discriminantType, t); }), discriminantType);
                if (!hasDefaultClause) {
                    return caseType;
                }
                var defaultType = filterType(type, function (t) { return !(isUnitLikeType(t) && ts.contains(switchTypes, getRegularTypeOfLiteralType(extractUnitType(t)))); });
                return caseType.flags & 131072 /* TypeFlags.Never */ ? defaultType : getUnionType([caseType, defaultType]);
            }
            function getImpliedTypeFromTypeofGuard(type, text) {
                switch (text) {
                    case "function":
                        return type.flags & 1 /* TypeFlags.Any */ ? type : globalFunctionType;
                    case "object":
                        return type.flags & 2 /* TypeFlags.Unknown */ ? getUnionType([nonPrimitiveType, nullType]) : type;
                    default:
                        return typeofTypesByName.get(text);
                }
            }
            // When narrowing a union type by a `typeof` guard using type-facts alone, constituent types that are
            // super-types of the implied guard will be retained in the final type: this is because type-facts only
            // filter. Instead, we would like to replace those union constituents with the more precise type implied by
            // the guard. For example: narrowing `{} | undefined` by `"boolean"` should produce the type `boolean`, not
            // the filtered type `{}`. For this reason we narrow constituents of the union individually, in addition to
            // filtering by type-facts.
            function narrowUnionMemberByTypeof(candidate) {
                return function (type) {
                    if (isTypeSubtypeOf(type, candidate)) {
                        return type;
                    }
                    if (isTypeSubtypeOf(candidate, type)) {
                        return candidate;
                    }
                    if (type.flags & 465829888 /* TypeFlags.Instantiable */) {
                        var constraint = getBaseConstraintOfType(type) || anyType;
                        if (isTypeSubtypeOf(candidate, constraint)) {
                            return getIntersectionType([type, candidate]);
                        }
                    }
                    return type;
                };
            }
            function narrowBySwitchOnTypeOf(type, switchStatement, clauseStart, clauseEnd) {
                var switchWitnesses = getSwitchClauseTypeOfWitnesses(switchStatement, /*retainDefault*/ true);
                if (!switchWitnesses.length) {
                    return type;
                }
                //  Equal start and end denotes implicit fallthrough; undefined marks explicit default clause
                var defaultCaseLocation = ts.findIndex(switchWitnesses, function (elem) { return elem === undefined; });
                var hasDefaultClause = clauseStart === clauseEnd || (defaultCaseLocation >= clauseStart && defaultCaseLocation < clauseEnd);
                var clauseWitnesses;
                var switchFacts;
                if (defaultCaseLocation > -1) {
                    // We no longer need the undefined denoting an explicit default case. Remove the undefined and
                    // fix-up clauseStart and clauseEnd.  This means that we don't have to worry about undefined in the
                    // witness array.
                    var witnesses = switchWitnesses.filter(function (witness) { return witness !== undefined; });
                    // The adjusted clause start and end after removing the `default` statement.
                    var fixedClauseStart = defaultCaseLocation < clauseStart ? clauseStart - 1 : clauseStart;
                    var fixedClauseEnd = defaultCaseLocation < clauseEnd ? clauseEnd - 1 : clauseEnd;
                    clauseWitnesses = witnesses.slice(fixedClauseStart, fixedClauseEnd);
                    switchFacts = getFactsFromTypeofSwitch(fixedClauseStart, fixedClauseEnd, witnesses, hasDefaultClause);
                }
                else {
                    clauseWitnesses = switchWitnesses.slice(clauseStart, clauseEnd);
                    switchFacts = getFactsFromTypeofSwitch(clauseStart, clauseEnd, switchWitnesses, hasDefaultClause);
                }
                if (hasDefaultClause) {
                    return filterType(type, function (t) { return (getTypeFacts(t) & switchFacts) === switchFacts; });
                }
                /*
                  The implied type is the raw type suggested by a
                  value being caught in this clause.

                  When the clause contains a default case we ignore
                  the implied type and try to narrow using any facts
                  we can learn: see `switchFacts`.

                  Example:
                  switch (typeof x) {
                      case 'number':
                      case 'string': break;
                      default: break;
                      case 'number':
                      case 'boolean': break
                  }

                  In the first clause (case `number` and `string`) the
                  implied type is number | string.

                  In the default clause we de not compute an implied type.

                  In the third clause (case `number` and `boolean`)
                  the naive implied type is number | boolean, however
                  we use the type facts to narrow the implied type to
                  boolean. We know that number cannot be selected
                  because it is caught in the first clause.
                */
                var impliedType = getTypeWithFacts(getUnionType(clauseWitnesses.map(function (text) { return getImpliedTypeFromTypeofGuard(type, text) || type; })), switchFacts);
                return getTypeWithFacts(mapType(type, narrowUnionMemberByTypeof(impliedType)), switchFacts);
            }
            function isMatchingConstructorReference(expr) {
                return (ts.isPropertyAccessExpression(expr) && ts.idText(expr.name) === "constructor" ||
                    ts.isElementAccessExpression(expr) && ts.isStringLiteralLike(expr.argumentExpression) && expr.argumentExpression.text === "constructor") &&
                    isMatchingReference(reference, expr.expression);
            }
            function narrowTypeByConstructor(type, operator, identifier, assumeTrue) {
                // Do not narrow when checking inequality.
                if (assumeTrue ? (operator !== 34 /* SyntaxKind.EqualsEqualsToken */ && operator !== 36 /* SyntaxKind.EqualsEqualsEqualsToken */) : (operator !== 35 /* SyntaxKind.ExclamationEqualsToken */ && operator !== 37 /* SyntaxKind.ExclamationEqualsEqualsToken */)) {
                    return type;
                }
                // Get the type of the constructor identifier expression, if it is not a function then do not narrow.
                var identifierType = getTypeOfExpression(identifier);
                if (!isFunctionType(identifierType) && !isConstructorType(identifierType)) {
                    return type;
                }
                // Get the prototype property of the type identifier so we can find out its type.
                var prototypeProperty = getPropertyOfType(identifierType, "prototype");
                if (!prototypeProperty) {
                    return type;
                }
                // Get the type of the prototype, if it is undefined, or the global `Object` or `Function` types then do not narrow.
                var prototypeType = getTypeOfSymbol(prototypeProperty);
                var candidate = !isTypeAny(prototypeType) ? prototypeType : undefined;
                if (!candidate || candidate === globalObjectType || candidate === globalFunctionType) {
                    return type;
                }
                // If the type that is being narrowed is `any` then just return the `candidate` type since every type is a subtype of `any`.
                if (isTypeAny(type)) {
                    return candidate;
                }
                // Filter out types that are not considered to be "constructed by" the `candidate` type.
                return filterType(type, function (t) { return isConstructedBy(t, candidate); });
                function isConstructedBy(source, target) {
                    // If either the source or target type are a class type then we need to check that they are the same exact type.
                    // This is because you may have a class `A` that defines some set of properties, and another class `B`
                    // that defines the same set of properties as class `A`, in that case they are structurally the same
                    // type, but when you do something like `instanceOfA.constructor === B` it will return false.
                    if (source.flags & 524288 /* TypeFlags.Object */ && ts.getObjectFlags(source) & 1 /* ObjectFlags.Class */ ||
                        target.flags & 524288 /* TypeFlags.Object */ && ts.getObjectFlags(target) & 1 /* ObjectFlags.Class */) {
                        return source.symbol === target.symbol;
                    }
                    // For all other types just check that the `source` type is a subtype of the `target` type.
                    return isTypeSubtypeOf(source, target);
                }
            }
            function narrowTypeByInstanceof(type, expr, assumeTrue) {
                var left = getReferenceCandidate(expr.left);
                if (!isMatchingReference(reference, left)) {
                    if (assumeTrue && strictNullChecks && optionalChainContainsReference(left, reference)) {
                        return getTypeWithFacts(type, 2097152 /* TypeFacts.NEUndefinedOrNull */);
                    }
                    return type;
                }
                // Check that right operand is a function type with a prototype property
                var rightType = getTypeOfExpression(expr.right);
                if (!isTypeDerivedFrom(rightType, globalFunctionType)) {
                    return type;
                }
                var targetType;
                var prototypeProperty = getPropertyOfType(rightType, "prototype");
                if (prototypeProperty) {
                    // Target type is type of the prototype property
                    var prototypePropertyType = getTypeOfSymbol(prototypeProperty);
                    if (!isTypeAny(prototypePropertyType)) {
                        targetType = prototypePropertyType;
                    }
                }
                // Don't narrow from 'any' if the target type is exactly 'Object' or 'Function'
                if (isTypeAny(type) && (targetType === globalObjectType || targetType === globalFunctionType)) {
                    return type;
                }
                if (!targetType) {
                    var constructSignatures = getSignaturesOfType(rightType, 1 /* SignatureKind.Construct */);
                    targetType = constructSignatures.length ?
                        getUnionType(ts.map(constructSignatures, function (signature) { return getReturnTypeOfSignature(getErasedSignature(signature)); })) :
                        emptyObjectType;
                }
                // We can't narrow a union based off instanceof without negated types see #31576 for more info
                if (!assumeTrue && rightType.flags & 1048576 /* TypeFlags.Union */) {
                    var nonConstructorTypeInUnion = ts.find(rightType.types, function (t) { return !isConstructorType(t); });
                    if (!nonConstructorTypeInUnion)
                        return type;
                }
                return getNarrowedType(type, targetType, assumeTrue, isTypeDerivedFrom);
            }
            function getNarrowedType(type, candidate, assumeTrue, isRelated) {
                if (!assumeTrue) {
                    return filterType(type, function (t) { return !isRelated(t, candidate); });
                }
                // If the current type is a union type, remove all constituents that couldn't be instances of
                // the candidate type. If one or more constituents remain, return a union of those.
                if (type.flags & 1048576 /* TypeFlags.Union */) {
                    var assignableType = filterType(type, function (t) { return isRelated(t, candidate); });
                    if (!(assignableType.flags & 131072 /* TypeFlags.Never */)) {
                        return assignableType;
                    }
                }
                // If the candidate type is a subtype of the target type, narrow to the candidate type.
                // Otherwise, if the target type is assignable to the candidate type, keep the target type.
                // Otherwise, if the candidate type is assignable to the target type, narrow to the candidate
                // type. Otherwise, the types are completely unrelated, so narrow to an intersection of the
                // two types.
                return isTypeSubtypeOf(candidate, type) ? candidate :
                    isTypeAssignableTo(type, candidate) ? type :
                        isTypeAssignableTo(candidate, type) ? candidate :
                            getIntersectionType([type, candidate]);
            }
            function narrowTypeByCallExpression(type, callExpression, assumeTrue) {
                if (hasMatchingArgument(callExpression, reference)) {
                    var signature = assumeTrue || !ts.isCallChain(callExpression) ? getEffectsSignature(callExpression) : undefined;
                    var predicate = signature && getTypePredicateOfSignature(signature);
                    if (predicate && (predicate.kind === 0 /* TypePredicateKind.This */ || predicate.kind === 1 /* TypePredicateKind.Identifier */)) {
                        return narrowTypeByTypePredicate(type, predicate, callExpression, assumeTrue);
                    }
                }
                if (containsMissingType(type) && ts.isAccessExpression(reference) && ts.isPropertyAccessExpression(callExpression.expression)) {
                    var callAccess = callExpression.expression;
                    if (isMatchingReference(reference.expression, getReferenceCandidate(callAccess.expression)) &&
                        ts.isIdentifier(callAccess.name) && callAccess.name.escapedText === "hasOwnProperty" && callExpression.arguments.length === 1) {
                        var argument = callExpression.arguments[0];
                        if (ts.isStringLiteralLike(argument) && getAccessedPropertyName(reference) === ts.escapeLeadingUnderscores(argument.text)) {
                            return getTypeWithFacts(type, assumeTrue ? 524288 /* TypeFacts.NEUndefined */ : 65536 /* TypeFacts.EQUndefined */);
                        }
                    }
                }
                return type;
            }
            function narrowTypeByTypePredicate(type, predicate, callExpression, assumeTrue) {
                // Don't narrow from 'any' if the predicate type is exactly 'Object' or 'Function'
                if (predicate.type && !(isTypeAny(type) && (predicate.type === globalObjectType || predicate.type === globalFunctionType))) {
                    var predicateArgument = getTypePredicateArgument(predicate, callExpression);
                    if (predicateArgument) {
                        if (isMatchingReference(reference, predicateArgument)) {
                            return getNarrowedType(type, predicate.type, assumeTrue, isTypeSubtypeOf);
                        }
                        if (strictNullChecks && assumeTrue && optionalChainContainsReference(predicateArgument, reference) &&
                            !(getTypeFacts(predicate.type) & 65536 /* TypeFacts.EQUndefined */)) {
                            type = getTypeWithFacts(type, 2097152 /* TypeFacts.NEUndefinedOrNull */);
                        }
                        var access = getDiscriminantPropertyAccess(predicateArgument, type);
                        if (access) {
                            return narrowTypeByDiscriminant(type, access, function (t) { return getNarrowedType(t, predicate.type, assumeTrue, isTypeSubtypeOf); });
                        }
                    }
                }
                return type;
            }
            // Narrow the given type based on the given expression having the assumed boolean value. The returned type
            // will be a subtype or the same type as the argument.
            function narrowType(type, expr, assumeTrue) {
                // for `a?.b`, we emulate a synthetic `a !== null && a !== undefined` condition for `a`
                if (ts.isExpressionOfOptionalChainRoot(expr) ||
                    ts.isBinaryExpression(expr.parent) && expr.parent.operatorToken.kind === 60 /* SyntaxKind.QuestionQuestionToken */ && expr.parent.left === expr) {
                    return narrowTypeByOptionality(type, expr, assumeTrue);
                }
                switch (expr.kind) {
                    case 79 /* SyntaxKind.Identifier */:
                        // When narrowing a reference to a const variable, non-assigned parameter, or readonly property, we inline
                        // up to five levels of aliased conditional expressions that are themselves declared as const variables.
                        if (!isMatchingReference(reference, expr) && inlineLevel < 5) {
                            var symbol = getResolvedSymbol(expr);
                            if (isConstVariable(symbol)) {
                                var declaration = symbol.valueDeclaration;
                                if (declaration && ts.isVariableDeclaration(declaration) && !declaration.type && declaration.initializer && isConstantReference(reference)) {
                                    inlineLevel++;
                                    var result = narrowType(type, declaration.initializer, assumeTrue);
                                    inlineLevel--;
                                    return result;
                                }
                            }
                        }
                    // falls through
                    case 108 /* SyntaxKind.ThisKeyword */:
                    case 106 /* SyntaxKind.SuperKeyword */:
                    case 206 /* SyntaxKind.PropertyAccessExpression */:
                    case 207 /* SyntaxKind.ElementAccessExpression */:
                        return narrowTypeByTruthiness(type, expr, assumeTrue);
                    case 208 /* SyntaxKind.CallExpression */:
                        return narrowTypeByCallExpression(type, expr, assumeTrue);
                    case 212 /* SyntaxKind.ParenthesizedExpression */:
                    case 230 /* SyntaxKind.NonNullExpression */:
                        return narrowType(type, expr.expression, assumeTrue);
                    case 221 /* SyntaxKind.BinaryExpression */:
                        return narrowTypeByBinaryExpression(type, expr, assumeTrue);
                    case 219 /* SyntaxKind.PrefixUnaryExpression */:
                        if (expr.operator === 53 /* SyntaxKind.ExclamationToken */) {
                            return narrowType(type, expr.operand, !assumeTrue);
                        }
                        break;
                }
                return type;
            }
            function narrowTypeByOptionality(type, expr, assumePresent) {
                if (isMatchingReference(reference, expr)) {
                    return getTypeWithFacts(type, assumePresent ? 2097152 /* TypeFacts.NEUndefinedOrNull */ : 262144 /* TypeFacts.EQUndefinedOrNull */);
                }
                var access = getDiscriminantPropertyAccess(expr, type);
                if (access) {
                    return narrowTypeByDiscriminant(type, access, function (t) { return getTypeWithFacts(t, assumePresent ? 2097152 /* TypeFacts.NEUndefinedOrNull */ : 262144 /* TypeFacts.EQUndefinedOrNull */); });
                }
                return type;
            }
        }
        function getTypeOfSymbolAtLocation(symbol, location) {
            symbol = symbol.exportSymbol || symbol;
            // If we have an identifier or a property access at the given location, if the location is
            // an dotted name expression, and if the location is not an assignment target, obtain the type
            // of the expression (which will reflect control flow analysis). If the expression indeed
            // resolved to the given symbol, return the narrowed type.
            if (location.kind === 79 /* SyntaxKind.Identifier */ || location.kind === 80 /* SyntaxKind.PrivateIdentifier */) {
                if (ts.isRightSideOfQualifiedNameOrPropertyAccess(location)) {
                    location = location.parent;
                }
                if (ts.isExpressionNode(location) && (!ts.isAssignmentTarget(location) || ts.isWriteAccess(location))) {
                    var type = getTypeOfExpression(location);
                    if (getExportSymbolOfValueSymbolIfExported(getNodeLinks(location).resolvedSymbol) === symbol) {
                        return type;
                    }
                }
            }
            if (ts.isDeclarationName(location) && ts.isSetAccessor(location.parent) && getAnnotatedAccessorTypeNode(location.parent)) {
                return getWriteTypeOfAccessors(location.parent.symbol);
            }
            // The location isn't a reference to the given symbol, meaning we're being asked
            // a hypothetical question of what type the symbol would have if there was a reference
            // to it at the given location. Since we have no control flow information for the
            // hypothetical reference (control flow information is created and attached by the
            // binder), we simply return the declared type of the symbol.
            return getNonMissingTypeOfSymbol(symbol);
        }
        function getControlFlowContainer(node) {
            return ts.findAncestor(node.parent, function (node) {
                return ts.isFunctionLike(node) && !ts.getImmediatelyInvokedFunctionExpression(node) ||
                    node.kind === 262 /* SyntaxKind.ModuleBlock */ ||
                    node.kind === 305 /* SyntaxKind.SourceFile */ ||
                    node.kind === 167 /* SyntaxKind.PropertyDeclaration */;
            });
        }
        // Check if a parameter or catch variable is assigned anywhere
        function isSymbolAssigned(symbol) {
            if (!symbol.valueDeclaration) {
                return false;
            }
            var parent = ts.getRootDeclaration(symbol.valueDeclaration).parent;
            var links = getNodeLinks(parent);
            if (!(links.flags & 8388608 /* NodeCheckFlags.AssignmentsMarked */)) {
                links.flags |= 8388608 /* NodeCheckFlags.AssignmentsMarked */;
                if (!hasParentWithAssignmentsMarked(parent)) {
                    markNodeAssignments(parent);
                }
            }
            return symbol.isAssigned || false;
        }
        function hasParentWithAssignmentsMarked(node) {
            return !!ts.findAncestor(node.parent, function (node) {
                return (ts.isFunctionLike(node) || ts.isCatchClause(node)) && !!(getNodeLinks(node).flags & 8388608 /* NodeCheckFlags.AssignmentsMarked */);
            });
        }
        function markNodeAssignments(node) {
            if (node.kind === 79 /* SyntaxKind.Identifier */) {
                if (ts.isAssignmentTarget(node)) {
                    var symbol = getResolvedSymbol(node);
                    if (ts.isParameterOrCatchClauseVariable(symbol)) {
                        symbol.isAssigned = true;
                    }
                }
            }
            else {
                ts.forEachChild(node, markNodeAssignments);
            }
        }
        function isConstVariable(symbol) {
            return symbol.flags & 3 /* SymbolFlags.Variable */ && (getDeclarationNodeFlagsFromSymbol(symbol) & 2 /* NodeFlags.Const */) !== 0;
        }
        /** remove undefined from the annotated type of a parameter when there is an initializer (that doesn't include undefined) */
        function removeOptionalityFromDeclaredType(declaredType, declaration) {
            if (pushTypeResolution(declaration.symbol, 2 /* TypeSystemPropertyName.DeclaredType */)) {
                var annotationIncludesUndefined = strictNullChecks &&
                    declaration.kind === 164 /* SyntaxKind.Parameter */ &&
                    declaration.initializer &&
                    getFalsyFlags(declaredType) & 32768 /* TypeFlags.Undefined */ &&
                    !(getFalsyFlags(checkExpression(declaration.initializer)) & 32768 /* TypeFlags.Undefined */);
                popTypeResolution();
                return annotationIncludesUndefined ? getTypeWithFacts(declaredType, 524288 /* TypeFacts.NEUndefined */) : declaredType;
            }
            else {
                reportCircularityError(declaration.symbol);
                return declaredType;
            }
        }
        function isConstraintPosition(type, node) {
            var parent = node.parent;
            // In an element access obj[x], we consider obj to be in a constraint position, except when obj is of
            // a generic type without a nullable constraint and x is a generic type. This is because when both obj
            // and x are of generic types T and K, we want the resulting type to be T[K].
            return parent.kind === 206 /* SyntaxKind.PropertyAccessExpression */ ||
                parent.kind === 161 /* SyntaxKind.QualifiedName */ ||
                parent.kind === 208 /* SyntaxKind.CallExpression */ && parent.expression === node ||
                parent.kind === 207 /* SyntaxKind.ElementAccessExpression */ && parent.expression === node &&
                    !(someType(type, isGenericTypeWithoutNullableConstraint) && isGenericIndexType(getTypeOfExpression(parent.argumentExpression)));
        }
        function isGenericTypeWithUnionConstraint(type) {
            return !!(type.flags & 465829888 /* TypeFlags.Instantiable */ && getBaseConstraintOrType(type).flags & (98304 /* TypeFlags.Nullable */ | 1048576 /* TypeFlags.Union */));
        }
        function isGenericTypeWithoutNullableConstraint(type) {
            return !!(type.flags & 465829888 /* TypeFlags.Instantiable */ && !maybeTypeOfKind(getBaseConstraintOrType(type), 98304 /* TypeFlags.Nullable */));
        }
        function hasContextualTypeWithNoGenericTypes(node, checkMode) {
            // Computing the contextual type for a child of a JSX element involves resolving the type of the
            // element's tag name, so we exclude that here to avoid circularities.
            // If check mode has `CheckMode.RestBindingElement`, we skip binding pattern contextual types,
            // as we want the type of a rest element to be generic when possible.
            var contextualType = (ts.isIdentifier(node) || ts.isPropertyAccessExpression(node) || ts.isElementAccessExpression(node)) &&
                !((ts.isJsxOpeningElement(node.parent) || ts.isJsxSelfClosingElement(node.parent)) && node.parent.tagName === node) &&
                (checkMode && checkMode & 64 /* CheckMode.RestBindingElement */ ?
                    getContextualType(node, 8 /* ContextFlags.SkipBindingPatterns */)
                    : getContextualType(node));
            return contextualType && !isGenericType(contextualType);
        }
        function getNarrowableTypeForReference(type, reference, checkMode) {
            // When the type of a reference is or contains an instantiable type with a union type constraint, and
            // when the reference is in a constraint position (where it is known we'll obtain the apparent type) or
            // has a contextual type containing no top-level instantiables (meaning constraints will determine
            // assignability), we substitute constraints for all instantiables in the type of the reference to give
            // control flow analysis an opportunity to narrow it further. For example, for a reference of a type
            // parameter type 'T extends string | undefined' with a contextual type 'string', we substitute
            // 'string | undefined' to give control flow analysis the opportunity to narrow to type 'string'.
            var substituteConstraints = !(checkMode && checkMode & 2 /* CheckMode.Inferential */) &&
                someType(type, isGenericTypeWithUnionConstraint) &&
                (isConstraintPosition(type, reference) || hasContextualTypeWithNoGenericTypes(reference, checkMode));
            return substituteConstraints ? mapType(type, function (t) { return t.flags & 465829888 /* TypeFlags.Instantiable */ ? getBaseConstraintOrType(t) : t; }) : type;
        }
        function isExportOrExportExpression(location) {
            return !!ts.findAncestor(location, function (n) {
                var parent = n.parent;
                if (parent === undefined) {
                    return "quit";
                }
                if (ts.isExportAssignment(parent)) {
                    return parent.expression === n && ts.isEntityNameExpression(n);
                }
                if (ts.isExportSpecifier(parent)) {
                    return parent.name === n || parent.propertyName === n;
                }
                return false;
            });
        }
        function markAliasReferenced(symbol, location) {
            if (isNonLocalAlias(symbol, /*excludes*/ 111551 /* SymbolFlags.Value */) && !isInTypeQuery(location) && !getTypeOnlyAliasDeclaration(symbol)) {
                var target = resolveAlias(symbol);
                if (target.flags & 111551 /* SymbolFlags.Value */) {
                    // An alias resolving to a const enum cannot be elided if (1) 'isolatedModules' is enabled
                    // (because the const enum value will not be inlined), or if (2) the alias is an export
                    // of a const enum declaration that will be preserved.
                    if (compilerOptions.isolatedModules ||
                        ts.shouldPreserveConstEnums(compilerOptions) && isExportOrExportExpression(location) ||
                        !isConstEnumOrConstEnumOnlyModule(target)) {
                        markAliasSymbolAsReferenced(symbol);
                    }
                    else {
                        markConstEnumAliasAsReferenced(symbol);
                    }
                }
            }
        }
        function getNarrowedTypeOfSymbol(symbol, location) {
            var declaration = symbol.valueDeclaration;
            if (declaration) {
                // If we have a non-rest binding element with no initializer declared as a const variable or a const-like
                // parameter (a parameter for which there are no assignments in the function body), and if the parent type
                // for the destructuring is a union type, one or more of the binding elements may represent discriminant
                // properties, and we want the effects of conditional checks on such discriminants to affect the types of
                // other binding elements from the same destructuring. Consider:
                //
                //   type Action =
                //       | { kind: 'A', payload: number }
                //       | { kind: 'B', payload: string };
                //
                //   function f({ kind, payload }: Action) {
                //       if (kind === 'A') {
                //           payload.toFixed();
                //       }
                //       if (kind === 'B') {
                //           payload.toUpperCase();
                //       }
                //   }
                //
                // Above, we want the conditional checks on 'kind' to affect the type of 'payload'. To facilitate this, we use
                // the binding pattern AST instance for '{ kind, payload }' as a pseudo-reference and narrow this reference
                // as if it occurred in the specified location. We then recompute the narrowed binding element type by
                // destructuring from the narrowed parent type.
                if (ts.isBindingElement(declaration) && !declaration.initializer && !declaration.dotDotDotToken && declaration.parent.elements.length >= 2) {
                    var parent = declaration.parent.parent;
                    if (parent.kind === 254 /* SyntaxKind.VariableDeclaration */ && ts.getCombinedNodeFlags(declaration) & 2 /* NodeFlags.Const */ || parent.kind === 164 /* SyntaxKind.Parameter */) {
                        var links = getNodeLinks(parent);
                        if (!(links.flags & 268435456 /* NodeCheckFlags.InCheckIdentifier */)) {
                            links.flags |= 268435456 /* NodeCheckFlags.InCheckIdentifier */;
                            var parentType = getTypeForBindingElementParent(parent, 0 /* CheckMode.Normal */);
                            links.flags &= ~268435456 /* NodeCheckFlags.InCheckIdentifier */;
                            if (parentType && parentType.flags & 1048576 /* TypeFlags.Union */ && !(parent.kind === 164 /* SyntaxKind.Parameter */ && isSymbolAssigned(symbol))) {
                                var pattern = declaration.parent;
                                var narrowedType = getFlowTypeOfReference(pattern, parentType, parentType, /*flowContainer*/ undefined, location.flowNode);
                                if (narrowedType.flags & 131072 /* TypeFlags.Never */) {
                                    return neverType;
                                }
                                return getBindingElementTypeFromParentType(declaration, narrowedType);
                            }
                        }
                    }
                }
                // If we have a const-like parameter with no type annotation or initializer, and if the parameter is contextually
                // typed by a signature with a single rest parameter of a union of tuple types, one or more of the parameters may
                // represent discriminant tuple elements, and we want the effects of conditional checks on such discriminants to
                // affect the types of other parameters in the same parameter list. Consider:
                //
                //   type Action = [kind: 'A', payload: number] | [kind: 'B', payload: string];
                //
                //   const f: (...args: Action) => void = (kind, payload) => {
                //       if (kind === 'A') {
                //           payload.toFixed();
                //       }
                //       if (kind === 'B') {
                //           payload.toUpperCase();
                //       }
                //   }
                //
                // Above, we want the conditional checks on 'kind' to affect the type of 'payload'. To facilitate this, we use
                // the arrow function AST node for '(kind, payload) => ...' as a pseudo-reference and narrow this reference as
                // if it occurred in the specified location. We then recompute the narrowed parameter type by indexing into the
                // narrowed tuple type.
                if (ts.isParameter(declaration) && !declaration.type && !declaration.initializer && !declaration.dotDotDotToken) {
                    var func = declaration.parent;
                    if (func.parameters.length >= 2 && isContextSensitiveFunctionOrObjectLiteralMethod(func)) {
                        var contextualSignature = getContextualSignature(func);
                        if (contextualSignature && contextualSignature.parameters.length === 1 && signatureHasRestParameter(contextualSignature)) {
                            var restType = getReducedApparentType(getTypeOfSymbol(contextualSignature.parameters[0]));
                            if (restType.flags & 1048576 /* TypeFlags.Union */ && everyType(restType, isTupleType) && !isSymbolAssigned(symbol)) {
                                var narrowedType = getFlowTypeOfReference(func, restType, restType, /*flowContainer*/ undefined, location.flowNode);
                                var index = func.parameters.indexOf(declaration) - (ts.getThisParameter(func) ? 1 : 0);
                                return getIndexedAccessType(narrowedType, getNumberLiteralType(index));
                            }
                        }
                    }
                }
            }
            return getTypeOfSymbol(symbol);
        }
        function checkIdentifier(node, checkMode) {
            if (ts.isThisInTypeQuery(node)) {
                return checkThisExpression(node);
            }
            var symbol = getResolvedSymbol(node);
            if (symbol === unknownSymbol) {
                return errorType;
            }
            // As noted in ECMAScript 6 language spec, arrow functions never have an arguments objects.
            // Although in down-level emit of arrow function, we emit it using function expression which means that
            // arguments objects will be bound to the inner object; emitting arrow function natively in ES6, arguments objects
            // will be bound to non-arrow function that contain this arrow function. This results in inconsistent behavior.
            // To avoid that we will give an error to users if they use arguments objects in arrow function so that they
            // can explicitly bound arguments objects
            if (symbol === argumentsSymbol) {
                if (isInPropertyInitializerOrClassStaticBlock(node)) {
                    error(node, ts.Diagnostics.arguments_cannot_be_referenced_in_property_initializers);
                    return errorType;
                }
                var container = ts.getContainingFunction(node);
                if (languageVersion < 2 /* ScriptTarget.ES2015 */) {
                    if (container.kind === 214 /* SyntaxKind.ArrowFunction */) {
                        error(node, ts.Diagnostics.The_arguments_object_cannot_be_referenced_in_an_arrow_function_in_ES3_and_ES5_Consider_using_a_standard_function_expression);
                    }
                    else if (ts.hasSyntacticModifier(container, 256 /* ModifierFlags.Async */)) {
                        error(node, ts.Diagnostics.The_arguments_object_cannot_be_referenced_in_an_async_function_or_method_in_ES3_and_ES5_Consider_using_a_standard_function_or_method);
                    }
                }
                getNodeLinks(container).flags |= 8192 /* NodeCheckFlags.CaptureArguments */;
                return getTypeOfSymbol(symbol);
            }
            // We should only mark aliases as referenced if there isn't a local value declaration
            // for the symbol. Also, don't mark any property access expression LHS - checkPropertyAccessExpression will handle that
            if (!(node.parent && ts.isPropertyAccessExpression(node.parent) && node.parent.expression === node)) {
                markAliasReferenced(symbol, node);
            }
            var localOrExportSymbol = getExportSymbolOfValueSymbolIfExported(symbol);
            var targetSymbol = checkDeprecatedAliasedSymbol(localOrExportSymbol, node);
            if (isDeprecatedSymbol(targetSymbol) && isUncalledFunctionReference(node, targetSymbol) && targetSymbol.declarations) {
                addDeprecatedSuggestion(node, targetSymbol.declarations, node.escapedText);
            }
            var declaration = localOrExportSymbol.valueDeclaration;
            if (declaration && localOrExportSymbol.flags & 32 /* SymbolFlags.Class */) {
                // Due to the emit for class decorators, any reference to the class from inside of the class body
                // must instead be rewritten to point to a temporary variable to avoid issues with the double-bind
                // behavior of class names in ES6.
                if (declaration.kind === 257 /* SyntaxKind.ClassDeclaration */
                    && ts.nodeIsDecorated(declaration)) {
                    var container = ts.getContainingClass(node);
                    while (container !== undefined) {
                        if (container === declaration && container.name !== node) {
                            getNodeLinks(declaration).flags |= 16777216 /* NodeCheckFlags.ClassWithConstructorReference */;
                            getNodeLinks(node).flags |= 33554432 /* NodeCheckFlags.ConstructorReferenceInClass */;
                            break;
                        }
                        container = ts.getContainingClass(container);
                    }
                }
                else if (declaration.kind === 226 /* SyntaxKind.ClassExpression */) {
                    // When we emit a class expression with static members that contain a reference
                    // to the constructor in the initializer, we will need to substitute that
                    // binding with an alias as the class name is not in scope.
                    var container = ts.getThisContainer(node, /*includeArrowFunctions*/ false);
                    while (container.kind !== 305 /* SyntaxKind.SourceFile */) {
                        if (container.parent === declaration) {
                            if (ts.isPropertyDeclaration(container) && ts.isStatic(container) || ts.isClassStaticBlockDeclaration(container)) {
                                getNodeLinks(declaration).flags |= 16777216 /* NodeCheckFlags.ClassWithConstructorReference */;
                                getNodeLinks(node).flags |= 33554432 /* NodeCheckFlags.ConstructorReferenceInClass */;
                            }
                            break;
                        }
                        container = ts.getThisContainer(container, /*includeArrowFunctions*/ false);
                    }
                }
            }
            checkNestedBlockScopedBinding(node, symbol);
            var type = getNarrowedTypeOfSymbol(localOrExportSymbol, node);
            var assignmentKind = ts.getAssignmentTargetKind(node);
            if (assignmentKind) {
                if (!(localOrExportSymbol.flags & 3 /* SymbolFlags.Variable */) &&
                    !(ts.isInJSFile(node) && localOrExportSymbol.flags & 512 /* SymbolFlags.ValueModule */)) {
                    var assignmentError = localOrExportSymbol.flags & 384 /* SymbolFlags.Enum */ ? ts.Diagnostics.Cannot_assign_to_0_because_it_is_an_enum
                        : localOrExportSymbol.flags & 32 /* SymbolFlags.Class */ ? ts.Diagnostics.Cannot_assign_to_0_because_it_is_a_class
                            : localOrExportSymbol.flags & 1536 /* SymbolFlags.Module */ ? ts.Diagnostics.Cannot_assign_to_0_because_it_is_a_namespace
                                : localOrExportSymbol.flags & 16 /* SymbolFlags.Function */ ? ts.Diagnostics.Cannot_assign_to_0_because_it_is_a_function
                                    : localOrExportSymbol.flags & 2097152 /* SymbolFlags.Alias */ ? ts.Diagnostics.Cannot_assign_to_0_because_it_is_an_import
                                        : ts.Diagnostics.Cannot_assign_to_0_because_it_is_not_a_variable;
                    error(node, assignmentError, symbolToString(symbol));
                    return errorType;
                }
                if (isReadonlySymbol(localOrExportSymbol)) {
                    if (localOrExportSymbol.flags & 3 /* SymbolFlags.Variable */) {
                        error(node, ts.Diagnostics.Cannot_assign_to_0_because_it_is_a_constant, symbolToString(symbol));
                    }
                    else {
                        error(node, ts.Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property, symbolToString(symbol));
                    }
                    return errorType;
                }
            }
            var isAlias = localOrExportSymbol.flags & 2097152 /* SymbolFlags.Alias */;
            // We only narrow variables and parameters occurring in a non-assignment position. For all other
            // entities we simply return the declared type.
            if (localOrExportSymbol.flags & 3 /* SymbolFlags.Variable */) {
                if (assignmentKind === 1 /* AssignmentKind.Definite */) {
                    return type;
                }
            }
            else if (isAlias) {
                declaration = getDeclarationOfAliasSymbol(symbol);
            }
            else {
                return type;
            }
            if (!declaration) {
                return type;
            }
            type = getNarrowableTypeForReference(type, node, checkMode);
            // The declaration container is the innermost function that encloses the declaration of the variable
            // or parameter. The flow container is the innermost function starting with which we analyze the control
            // flow graph to determine the control flow based type.
            var isParameter = ts.getRootDeclaration(declaration).kind === 164 /* SyntaxKind.Parameter */;
            var declarationContainer = getControlFlowContainer(declaration);
            var flowContainer = getControlFlowContainer(node);
            var isOuterVariable = flowContainer !== declarationContainer;
            var isSpreadDestructuringAssignmentTarget = node.parent && node.parent.parent && ts.isSpreadAssignment(node.parent) && isDestructuringAssignmentTarget(node.parent.parent);
            var isModuleExports = symbol.flags & 134217728 /* SymbolFlags.ModuleExports */;
            // When the control flow originates in a function expression or arrow function and we are referencing
            // a const variable or parameter from an outer function, we extend the origin of the control flow
            // analysis to include the immediately enclosing function.
            while (flowContainer !== declarationContainer && (flowContainer.kind === 213 /* SyntaxKind.FunctionExpression */ ||
                flowContainer.kind === 214 /* SyntaxKind.ArrowFunction */ || ts.isObjectLiteralOrClassExpressionMethodOrAccessor(flowContainer)) &&
                (isConstVariable(localOrExportSymbol) && type !== autoArrayType || isParameter && !isSymbolAssigned(localOrExportSymbol))) {
                flowContainer = getControlFlowContainer(flowContainer);
            }
            // We only look for uninitialized variables in strict null checking mode, and only when we can analyze
            // the entire control flow graph from the variable's declaration (i.e. when the flow container and
            // declaration container are the same).
            var assumeInitialized = isParameter || isAlias || isOuterVariable || isSpreadDestructuringAssignmentTarget || isModuleExports || ts.isBindingElement(declaration) ||
                type !== autoType && type !== autoArrayType && (!strictNullChecks || (type.flags & (3 /* TypeFlags.AnyOrUnknown */ | 16384 /* TypeFlags.Void */)) !== 0 ||
                    isInTypeQuery(node) || node.parent.kind === 275 /* SyntaxKind.ExportSpecifier */) ||
                node.parent.kind === 230 /* SyntaxKind.NonNullExpression */ ||
                declaration.kind === 254 /* SyntaxKind.VariableDeclaration */ && declaration.exclamationToken ||
                declaration.flags & 16777216 /* NodeFlags.Ambient */;
            var initialType = assumeInitialized ? (isParameter ? removeOptionalityFromDeclaredType(type, declaration) : type) :
                type === autoType || type === autoArrayType ? undefinedType :
                    getOptionalType(type);
            var flowType = getFlowTypeOfReference(node, type, initialType, flowContainer);
            // A variable is considered uninitialized when it is possible to analyze the entire control flow graph
            // from declaration to use, and when the variable's declared type doesn't include undefined but the
            // control flow based type does include undefined.
            if (!isEvolvingArrayOperationTarget(node) && (type === autoType || type === autoArrayType)) {
                if (flowType === autoType || flowType === autoArrayType) {
                    if (noImplicitAny) {
                        error(ts.getNameOfDeclaration(declaration), ts.Diagnostics.Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined, symbolToString(symbol), typeToString(flowType));
                        error(node, ts.Diagnostics.Variable_0_implicitly_has_an_1_type, symbolToString(symbol), typeToString(flowType));
                    }
                    return convertAutoToAny(flowType);
                }
            }
            else if (!assumeInitialized && !(getFalsyFlags(type) & 32768 /* TypeFlags.Undefined */) && getFalsyFlags(flowType) & 32768 /* TypeFlags.Undefined */) {
                error(node, ts.Diagnostics.Variable_0_is_used_before_being_assigned, symbolToString(symbol));
                // Return the declared type to reduce follow-on errors
                return type;
            }
            return assignmentKind ? getBaseTypeOfLiteralType(flowType) : flowType;
        }
        function isInsideFunctionOrInstancePropertyInitializer(node, threshold) {
            return !!ts.findAncestor(node, function (n) { return n === threshold ? "quit" : ts.isFunctionLike(n) || (n.parent && ts.isPropertyDeclaration(n.parent) && !ts.hasStaticModifier(n.parent) && n.parent.initializer === n); });
        }
        function getPartOfForStatementContainingNode(node, container) {
            return ts.findAncestor(node, function (n) { return n === container ? "quit" : n === container.initializer || n === container.condition || n === container.incrementor || n === container.statement; });
        }
        function getEnclosingIterationStatement(node) {
            return ts.findAncestor(node, function (n) { return (!n || ts.nodeStartsNewLexicalEnvironment(n)) ? "quit" : ts.isIterationStatement(n, /*lookInLabeledStatements*/ false); });
        }
        function checkNestedBlockScopedBinding(node, symbol) {
            if (languageVersion >= 2 /* ScriptTarget.ES2015 */ ||
                (symbol.flags & (2 /* SymbolFlags.BlockScopedVariable */ | 32 /* SymbolFlags.Class */)) === 0 ||
                !symbol.valueDeclaration ||
                ts.isSourceFile(symbol.valueDeclaration) ||
                symbol.valueDeclaration.parent.kind === 292 /* SyntaxKind.CatchClause */) {
                return;
            }
            // 1. walk from the use site up to the declaration and check
            // if there is anything function like between declaration and use-site (is binding/class is captured in function).
            // 2. walk from the declaration up to the boundary of lexical environment and check
            // if there is an iteration statement in between declaration and boundary (is binding/class declared inside iteration statement)
            var container = ts.getEnclosingBlockScopeContainer(symbol.valueDeclaration);
            var isCaptured = isInsideFunctionOrInstancePropertyInitializer(node, container);
            var enclosingIterationStatement = getEnclosingIterationStatement(container);
            if (enclosingIterationStatement) {
                if (isCaptured) {
                    // mark iteration statement as containing block-scoped binding captured in some function
                    var capturesBlockScopeBindingInLoopBody = true;
                    if (ts.isForStatement(container)) {
                        var varDeclList = ts.getAncestor(symbol.valueDeclaration, 255 /* SyntaxKind.VariableDeclarationList */);
                        if (varDeclList && varDeclList.parent === container) {
                            var part = getPartOfForStatementContainingNode(node.parent, container);
                            if (part) {
                                var links = getNodeLinks(part);
                                links.flags |= 131072 /* NodeCheckFlags.ContainsCapturedBlockScopeBinding */;
                                var capturedBindings = links.capturedBlockScopeBindings || (links.capturedBlockScopeBindings = []);
                                ts.pushIfUnique(capturedBindings, symbol);
                                if (part === container.initializer) {
                                    capturesBlockScopeBindingInLoopBody = false; // Initializer is outside of loop body
                                }
                            }
                        }
                    }
                    if (capturesBlockScopeBindingInLoopBody) {
                        getNodeLinks(enclosingIterationStatement).flags |= 65536 /* NodeCheckFlags.LoopWithCapturedBlockScopedBinding */;
                    }
                }
                // mark variables that are declared in loop initializer and reassigned inside the body of ForStatement.
                // if body of ForStatement will be converted to function then we'll need a extra machinery to propagate reassigned values back.
                if (ts.isForStatement(container)) {
                    var varDeclList = ts.getAncestor(symbol.valueDeclaration, 255 /* SyntaxKind.VariableDeclarationList */);
                    if (varDeclList && varDeclList.parent === container && isAssignedInBodyOfForStatement(node, container)) {
                        getNodeLinks(symbol.valueDeclaration).flags |= 4194304 /* NodeCheckFlags.NeedsLoopOutParameter */;
                    }
                }
                // set 'declared inside loop' bit on the block-scoped binding
                getNodeLinks(symbol.valueDeclaration).flags |= 524288 /* NodeCheckFlags.BlockScopedBindingInLoop */;
            }
            if (isCaptured) {
                getNodeLinks(symbol.valueDeclaration).flags |= 262144 /* NodeCheckFlags.CapturedBlockScopedBinding */;
            }
        }
        function isBindingCapturedByNode(node, decl) {
            var links = getNodeLinks(node);
            return !!links && ts.contains(links.capturedBlockScopeBindings, getSymbolOfNode(decl));
        }
        function isAssignedInBodyOfForStatement(node, container) {
            // skip parenthesized nodes
            var current = node;
            while (current.parent.kind === 212 /* SyntaxKind.ParenthesizedExpression */) {
                current = current.parent;
            }
            // check if node is used as LHS in some assignment expression
            var isAssigned = false;
            if (ts.isAssignmentTarget(current)) {
                isAssigned = true;
            }
            else if ((current.parent.kind === 219 /* SyntaxKind.PrefixUnaryExpression */ || current.parent.kind === 220 /* SyntaxKind.PostfixUnaryExpression */)) {
                var expr = current.parent;
                isAssigned = expr.operator === 45 /* SyntaxKind.PlusPlusToken */ || expr.operator === 46 /* SyntaxKind.MinusMinusToken */;
            }
            if (!isAssigned) {
                return false;
            }
            // at this point we know that node is the target of assignment
            // now check that modification happens inside the statement part of the ForStatement
            return !!ts.findAncestor(current, function (n) { return n === container ? "quit" : n === container.statement; });
        }
        function captureLexicalThis(node, container) {
            getNodeLinks(node).flags |= 2 /* NodeCheckFlags.LexicalThis */;
            if (container.kind === 167 /* SyntaxKind.PropertyDeclaration */ || container.kind === 171 /* SyntaxKind.Constructor */) {
                var classNode = container.parent;
                getNodeLinks(classNode).flags |= 4 /* NodeCheckFlags.CaptureThis */;
            }
            else {
                getNodeLinks(container).flags |= 4 /* NodeCheckFlags.CaptureThis */;
            }
        }
        function findFirstSuperCall(node) {
            return ts.isSuperCall(node) ? node :
                ts.isFunctionLike(node) ? undefined :
                    ts.forEachChild(node, findFirstSuperCall);
        }
        /**
         * Check if the given class-declaration extends null then return true.
         * Otherwise, return false
         * @param classDecl a class declaration to check if it extends null
         */
        function classDeclarationExtendsNull(classDecl) {
            var classSymbol = getSymbolOfNode(classDecl);
            var classInstanceType = getDeclaredTypeOfSymbol(classSymbol);
            var baseConstructorType = getBaseConstructorTypeOfClass(classInstanceType);
            return baseConstructorType === nullWideningType;
        }
        function checkThisBeforeSuper(node, container, diagnosticMessage) {
            var containingClassDecl = container.parent;
            var baseTypeNode = ts.getClassExtendsHeritageElement(containingClassDecl);
            // If a containing class does not have extends clause or the class extends null
            // skip checking whether super statement is called before "this" accessing.
            if (baseTypeNode && !classDeclarationExtendsNull(containingClassDecl)) {
                if (node.flowNode && !isPostSuperFlowNode(node.flowNode, /*noCacheCheck*/ false)) {
                    error(node, diagnosticMessage);
                }
            }
        }
        function checkThisInStaticClassFieldInitializerInDecoratedClass(thisExpression, container) {
            if (ts.isPropertyDeclaration(container) && ts.hasStaticModifier(container) &&
                container.initializer && ts.textRangeContainsPositionInclusive(container.initializer, thisExpression.pos) && ts.length(container.parent.decorators)) {
                error(thisExpression, ts.Diagnostics.Cannot_use_this_in_a_static_property_initializer_of_a_decorated_class);
            }
        }
        function checkThisExpression(node) {
            var isNodeInTypeQuery = isInTypeQuery(node);
            // Stop at the first arrow function so that we can
            // tell whether 'this' needs to be captured.
            var container = ts.getThisContainer(node, /* includeArrowFunctions */ true);
            var capturedByArrowFunction = false;
            if (container.kind === 171 /* SyntaxKind.Constructor */) {
                checkThisBeforeSuper(node, container, ts.Diagnostics.super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class);
            }
            // Now skip arrow functions to get the "real" owner of 'this'.
            if (container.kind === 214 /* SyntaxKind.ArrowFunction */) {
                container = ts.getThisContainer(container, /* includeArrowFunctions */ false);
                capturedByArrowFunction = true;
            }
            checkThisInStaticClassFieldInitializerInDecoratedClass(node, container);
            switch (container.kind) {
                case 261 /* SyntaxKind.ModuleDeclaration */:
                    error(node, ts.Diagnostics.this_cannot_be_referenced_in_a_module_or_namespace_body);
                    // do not return here so in case if lexical this is captured - it will be reflected in flags on NodeLinks
                    break;
                case 260 /* SyntaxKind.EnumDeclaration */:
                    error(node, ts.Diagnostics.this_cannot_be_referenced_in_current_location);
                    // do not return here so in case if lexical this is captured - it will be reflected in flags on NodeLinks
                    break;
                case 171 /* SyntaxKind.Constructor */:
                    if (isInConstructorArgumentInitializer(node, container)) {
                        error(node, ts.Diagnostics.this_cannot_be_referenced_in_constructor_arguments);
                        // do not return here so in case if lexical this is captured - it will be reflected in flags on NodeLinks
                    }
                    break;
                case 162 /* SyntaxKind.ComputedPropertyName */:
                    error(node, ts.Diagnostics.this_cannot_be_referenced_in_a_computed_property_name);
                    break;
            }
            // When targeting es6, mark that we'll need to capture `this` in its lexically bound scope.
            if (!isNodeInTypeQuery && capturedByArrowFunction && languageVersion < 2 /* ScriptTarget.ES2015 */) {
                captureLexicalThis(node, container);
            }
            var type = tryGetThisTypeAt(node, /*includeGlobalThis*/ true, container);
            if (noImplicitThis) {
                var globalThisType_1 = getTypeOfSymbol(globalThisSymbol);
                if (type === globalThisType_1 && capturedByArrowFunction) {
                    error(node, ts.Diagnostics.The_containing_arrow_function_captures_the_global_value_of_this);
                }
                else if (!type) {
                    // With noImplicitThis, functions may not reference 'this' if it has type 'any'
                    var diag = error(node, ts.Diagnostics.this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation);
                    if (!ts.isSourceFile(container)) {
                        var outsideThis = tryGetThisTypeAt(container);
                        if (outsideThis && outsideThis !== globalThisType_1) {
                            ts.addRelatedInfo(diag, ts.createDiagnosticForNode(container, ts.Diagnostics.An_outer_value_of_this_is_shadowed_by_this_container));
                        }
                    }
                }
            }
            return type || anyType;
        }
        function tryGetThisTypeAt(node, includeGlobalThis, container) {
            if (includeGlobalThis === void 0) { includeGlobalThis = true; }
            if (container === void 0) { container = ts.getThisContainer(node, /*includeArrowFunctions*/ false); }
            var isInJS = ts.isInJSFile(node);
            if (ts.isFunctionLike(container) &&
                (!isInParameterInitializerBeforeContainingFunction(node) || ts.getThisParameter(container))) {
                var thisType = getThisTypeOfDeclaration(container) || isInJS && getTypeForThisExpressionFromJSDoc(container);
                // Note: a parameter initializer should refer to class-this unless function-this is explicitly annotated.
                // If this is a function in a JS file, it might be a class method.
                if (!thisType) {
                    var className = getClassNameFromPrototypeMethod(container);
                    if (isInJS && className) {
                        var classSymbol = checkExpression(className).symbol;
                        if (classSymbol && classSymbol.members && (classSymbol.flags & 16 /* SymbolFlags.Function */)) {
                            thisType = getDeclaredTypeOfSymbol(classSymbol).thisType;
                        }
                    }
                    else if (isJSConstructor(container)) {
                        thisType = getDeclaredTypeOfSymbol(getMergedSymbol(container.symbol)).thisType;
                    }
                    thisType || (thisType = getContextualThisParameterType(container));
                }
                if (thisType) {
                    return getFlowTypeOfReference(node, thisType);
                }
            }
            if (ts.isClassLike(container.parent)) {
                var symbol = getSymbolOfNode(container.parent);
                var type = ts.isStatic(container) ? getTypeOfSymbol(symbol) : getDeclaredTypeOfSymbol(symbol).thisType;
                return getFlowTypeOfReference(node, type);
            }
            if (ts.isSourceFile(container)) {
                // look up in the source file's locals or exports
                if (container.commonJsModuleIndicator) {
                    var fileSymbol = getSymbolOfNode(container);
                    return fileSymbol && getTypeOfSymbol(fileSymbol);
                }
                else if (container.externalModuleIndicator) {
                    // TODO: Maybe issue a better error than 'object is possibly undefined'
                    return undefinedType;
                }
                else if (includeGlobalThis) {
                    return getTypeOfSymbol(globalThisSymbol);
                }
            }
        }
        function getExplicitThisType(node) {
            var container = ts.getThisContainer(node, /*includeArrowFunctions*/ false);
            if (ts.isFunctionLike(container)) {
                var signature = getSignatureFromDeclaration(container);
                if (signature.thisParameter) {
                    return getExplicitTypeOfSymbol(signature.thisParameter);
                }
            }
            if (ts.isClassLike(container.parent)) {
                var symbol = getSymbolOfNode(container.parent);
                return ts.isStatic(container) ? getTypeOfSymbol(symbol) : getDeclaredTypeOfSymbol(symbol).thisType;
            }
        }
        function getClassNameFromPrototypeMethod(container) {
            // Check if it's the RHS of a x.prototype.y = function [name]() { .... }
            if (container.kind === 213 /* SyntaxKind.FunctionExpression */ &&
                ts.isBinaryExpression(container.parent) &&
                ts.getAssignmentDeclarationKind(container.parent) === 3 /* AssignmentDeclarationKind.PrototypeProperty */) {
                // Get the 'x' of 'x.prototype.y = container'
                return container.parent // x.prototype.y = container
                    .left // x.prototype.y
                    .expression // x.prototype
                    .expression; // x
            }
            // x.prototype = { method() { } }
            else if (container.kind === 169 /* SyntaxKind.MethodDeclaration */ &&
                container.parent.kind === 205 /* SyntaxKind.ObjectLiteralExpression */ &&
                ts.isBinaryExpression(container.parent.parent) &&
                ts.getAssignmentDeclarationKind(container.parent.parent) === 6 /* AssignmentDeclarationKind.Prototype */) {
                return container.parent.parent.left.expression;
            }
            // x.prototype = { method: function() { } }
            else if (container.kind === 213 /* SyntaxKind.FunctionExpression */ &&
                container.parent.kind === 296 /* SyntaxKind.PropertyAssignment */ &&
                container.parent.parent.kind === 205 /* SyntaxKind.ObjectLiteralExpression */ &&
                ts.isBinaryExpression(container.parent.parent.parent) &&
                ts.getAssignmentDeclarationKind(container.parent.parent.parent) === 6 /* AssignmentDeclarationKind.Prototype */) {
                return container.parent.parent.parent.left.expression;
            }
            // Object.defineProperty(x, "method", { value: function() { } });
            // Object.defineProperty(x, "method", { set: (x: () => void) => void });
            // Object.defineProperty(x, "method", { get: () => function() { }) });
            else if (container.kind === 213 /* SyntaxKind.FunctionExpression */ &&
                ts.isPropertyAssignment(container.parent) &&
                ts.isIdentifier(container.parent.name) &&
                (container.parent.name.escapedText === "value" || container.parent.name.escapedText === "get" || container.parent.name.escapedText === "set") &&
                ts.isObjectLiteralExpression(container.parent.parent) &&
                ts.isCallExpression(container.parent.parent.parent) &&
                container.parent.parent.parent.arguments[2] === container.parent.parent &&
                ts.getAssignmentDeclarationKind(container.parent.parent.parent) === 9 /* AssignmentDeclarationKind.ObjectDefinePrototypeProperty */) {
                return container.parent.parent.parent.arguments[0].expression;
            }
            // Object.defineProperty(x, "method", { value() { } });
            // Object.defineProperty(x, "method", { set(x: () => void) {} });
            // Object.defineProperty(x, "method", { get() { return () => {} } });
            else if (ts.isMethodDeclaration(container) &&
                ts.isIdentifier(container.name) &&
                (container.name.escapedText === "value" || container.name.escapedText === "get" || container.name.escapedText === "set") &&
                ts.isObjectLiteralExpression(container.parent) &&
                ts.isCallExpression(container.parent.parent) &&
                container.parent.parent.arguments[2] === container.parent &&
                ts.getAssignmentDeclarationKind(container.parent.parent) === 9 /* AssignmentDeclarationKind.ObjectDefinePrototypeProperty */) {
                return container.parent.parent.arguments[0].expression;
            }
        }
        function getTypeForThisExpressionFromJSDoc(node) {
            var jsdocType = ts.getJSDocType(node);
            if (jsdocType && jsdocType.kind === 317 /* SyntaxKind.JSDocFunctionType */) {
                var jsDocFunctionType = jsdocType;
                if (jsDocFunctionType.parameters.length > 0 &&
                    jsDocFunctionType.parameters[0].name &&
                    jsDocFunctionType.parameters[0].name.escapedText === "this" /* InternalSymbolName.This */) {
                    return getTypeFromTypeNode(jsDocFunctionType.parameters[0].type);
                }
            }
            var thisTag = ts.getJSDocThisTag(node);
            if (thisTag && thisTag.typeExpression) {
                return getTypeFromTypeNode(thisTag.typeExpression);
            }
        }
        function isInConstructorArgumentInitializer(node, constructorDecl) {
            return !!ts.findAncestor(node, function (n) { return ts.isFunctionLikeDeclaration(n) ? "quit" : n.kind === 164 /* SyntaxKind.Parameter */ && n.parent === constructorDecl; });
        }
        function checkSuperExpression(node) {
            var isCallExpression = node.parent.kind === 208 /* SyntaxKind.CallExpression */ && node.parent.expression === node;
            var immediateContainer = ts.getSuperContainer(node, /*stopOnFunctions*/ true);
            var container = immediateContainer;
            var needToCaptureLexicalThis = false;
            // adjust the container reference in case if super is used inside arrow functions with arbitrarily deep nesting
            if (!isCallExpression) {
                while (container && container.kind === 214 /* SyntaxKind.ArrowFunction */) {
                    container = ts.getSuperContainer(container, /*stopOnFunctions*/ true);
                    needToCaptureLexicalThis = languageVersion < 2 /* ScriptTarget.ES2015 */;
                }
            }
            var canUseSuperExpression = isLegalUsageOfSuperExpression(container);
            var nodeCheckFlag = 0;
            if (!canUseSuperExpression) {
                // issue more specific error if super is used in computed property name
                // class A { foo() { return "1" }}
                // class B {
                //     [super.foo()]() {}
                // }
                var current = ts.findAncestor(node, function (n) { return n === container ? "quit" : n.kind === 162 /* SyntaxKind.ComputedPropertyName */; });
                if (current && current.kind === 162 /* SyntaxKind.ComputedPropertyName */) {
                    error(node, ts.Diagnostics.super_cannot_be_referenced_in_a_computed_property_name);
                }
                else if (isCallExpression) {
                    error(node, ts.Diagnostics.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors);
                }
                else if (!container || !container.parent || !(ts.isClassLike(container.parent) || container.parent.kind === 205 /* SyntaxKind.ObjectLiteralExpression */)) {
                    error(node, ts.Diagnostics.super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions);
                }
                else {
                    error(node, ts.Diagnostics.super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class);
                }
                return errorType;
            }
            if (!isCallExpression && immediateContainer.kind === 171 /* SyntaxKind.Constructor */) {
                checkThisBeforeSuper(node, container, ts.Diagnostics.super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class);
            }
            if (ts.isStatic(container) || isCallExpression) {
                nodeCheckFlag = 512 /* NodeCheckFlags.SuperStatic */;
                if (!isCallExpression &&
                    languageVersion >= 2 /* ScriptTarget.ES2015 */ && languageVersion <= 8 /* ScriptTarget.ES2021 */ &&
                    (ts.isPropertyDeclaration(container) || ts.isClassStaticBlockDeclaration(container))) {
                    // for `super.x` or `super[x]` in a static initializer, mark all enclosing
                    // block scope containers so that we can report potential collisions with
                    // `Reflect`.
                    ts.forEachEnclosingBlockScopeContainer(node.parent, function (current) {
                        if (!ts.isSourceFile(current) || ts.isExternalOrCommonJsModule(current)) {
                            getNodeLinks(current).flags |= 134217728 /* NodeCheckFlags.ContainsSuperPropertyInStaticInitializer */;
                        }
                    });
                }
            }
            else {
                nodeCheckFlag = 256 /* NodeCheckFlags.SuperInstance */;
            }
            getNodeLinks(node).flags |= nodeCheckFlag;
            // Due to how we emit async functions, we need to specialize the emit for an async method that contains a `super` reference.
            // This is due to the fact that we emit the body of an async function inside of a generator function. As generator
            // functions cannot reference `super`, we emit a helper inside of the method body, but outside of the generator. This helper
            // uses an arrow function, which is permitted to reference `super`.
            //
            // There are two primary ways we can access `super` from within an async method. The first is getting the value of a property
            // or indexed access on super, either as part of a right-hand-side expression or call expression. The second is when setting the value
            // of a property or indexed access, either as part of an assignment expression or destructuring assignment.
            //
            // The simplest case is reading a value, in which case we will emit something like the following:
            //
            //  // ts
            //  ...
            //  async asyncMethod() {
            //    let x = await super.asyncMethod();
            //    return x;
            //  }
            //  ...
            //
            //  // js
            //  ...
            //  asyncMethod() {
            //      const _super = Object.create(null, {
            //        asyncMethod: { get: () => super.asyncMethod },
            //      });
            //      return __awaiter(this, arguments, Promise, function *() {
            //          let x = yield _super.asyncMethod.call(this);
            //          return x;
            //      });
            //  }
            //  ...
            //
            // The more complex case is when we wish to assign a value, especially as part of a destructuring assignment. As both cases
            // are legal in ES6, but also likely less frequent, we only emit setters if there is an assignment:
            //
            //  // ts
            //  ...
            //  async asyncMethod(ar: Promise<any[]>) {
            //      [super.a, super.b] = await ar;
            //  }
            //  ...
            //
            //  // js
            //  ...
            //  asyncMethod(ar) {
            //      const _super = Object.create(null, {
            //        a: { get: () => super.a, set: (v) => super.a = v },
            //        b: { get: () => super.b, set: (v) => super.b = v }
            //      };
            //      return __awaiter(this, arguments, Promise, function *() {
            //          [_super.a, _super.b] = yield ar;
            //      });
            //  }
            //  ...
            //
            // Creating an object that has getter and setters instead of just an accessor function is required for destructuring assignments
            // as a call expression cannot be used as the target of a destructuring assignment while a property access can.
            //
            // For element access expressions (`super[x]`), we emit a generic helper that forwards the element access in both situations.
            if (container.kind === 169 /* SyntaxKind.MethodDeclaration */ && ts.hasSyntacticModifier(container, 256 /* ModifierFlags.Async */)) {
                if (ts.isSuperProperty(node.parent) && ts.isAssignmentTarget(node.parent)) {
                    getNodeLinks(container).flags |= 4096 /* NodeCheckFlags.AsyncMethodWithSuperBinding */;
                }
                else {
                    getNodeLinks(container).flags |= 2048 /* NodeCheckFlags.AsyncMethodWithSuper */;
                }
            }
            if (needToCaptureLexicalThis) {
                // call expressions are allowed only in constructors so they should always capture correct 'this'
                // super property access expressions can also appear in arrow functions -
                // in this case they should also use correct lexical this
                captureLexicalThis(node.parent, container);
            }
            if (container.parent.kind === 205 /* SyntaxKind.ObjectLiteralExpression */) {
                if (languageVersion < 2 /* ScriptTarget.ES2015 */) {
                    error(node, ts.Diagnostics.super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_higher);
                    return errorType;
                }
                else {
                    // for object literal assume that type of 'super' is 'any'
                    return anyType;
                }
            }
            // at this point the only legal case for parent is ClassLikeDeclaration
            var classLikeDeclaration = container.parent;
            if (!ts.getClassExtendsHeritageElement(classLikeDeclaration)) {
                error(node, ts.Diagnostics.super_can_only_be_referenced_in_a_derived_class);
                return errorType;
            }
            var classType = getDeclaredTypeOfSymbol(getSymbolOfNode(classLikeDeclaration));
            var baseClassType = classType && getBaseTypes(classType)[0];
            if (!baseClassType) {
                return errorType;
            }
            if (container.kind === 171 /* SyntaxKind.Constructor */ && isInConstructorArgumentInitializer(node, container)) {
                // issue custom error message for super property access in constructor arguments (to be aligned with old compiler)
                error(node, ts.Diagnostics.super_cannot_be_referenced_in_constructor_arguments);
                return errorType;
            }
            return nodeCheckFlag === 512 /* NodeCheckFlags.SuperStatic */
                ? getBaseConstructorTypeOfClass(classType)
                : getTypeWithThisArgument(baseClassType, classType.thisType);
            function isLegalUsageOfSuperExpression(container) {
                if (!container) {
                    return false;
                }
                if (isCallExpression) {
                    // TS 1.0 SPEC (April 2014): 4.8.1
                    // Super calls are only permitted in constructors of derived classes
                    return container.kind === 171 /* SyntaxKind.Constructor */;
                }
                else {
                    // TS 1.0 SPEC (April 2014)
                    // 'super' property access is allowed
                    // - In a constructor, instance member function, instance member accessor, or instance member variable initializer where this references a derived class instance
                    // - In a static member function or static member accessor
                    // topmost container must be something that is directly nested in the class declaration\object literal expression
                    if (ts.isClassLike(container.parent) || container.parent.kind === 205 /* SyntaxKind.ObjectLiteralExpression */) {
                        if (ts.isStatic(container)) {
                            return container.kind === 169 /* SyntaxKind.MethodDeclaration */ ||
                                container.kind === 168 /* SyntaxKind.MethodSignature */ ||
                                container.kind === 172 /* SyntaxKind.GetAccessor */ ||
                                container.kind === 173 /* SyntaxKind.SetAccessor */ ||
                                container.kind === 167 /* SyntaxKind.PropertyDeclaration */ ||
                                container.kind === 170 /* SyntaxKind.ClassStaticBlockDeclaration */;
                        }
                        else {
                            return container.kind === 169 /* SyntaxKind.MethodDeclaration */ ||
                                container.kind === 168 /* SyntaxKind.MethodSignature */ ||
                                container.kind === 172 /* SyntaxKind.GetAccessor */ ||
                                container.kind === 173 /* SyntaxKind.SetAccessor */ ||
                                container.kind === 167 /* SyntaxKind.PropertyDeclaration */ ||
                                container.kind === 166 /* SyntaxKind.PropertySignature */ ||
                                container.kind === 171 /* SyntaxKind.Constructor */;
                        }
                    }
                }
                return false;
            }
        }
        function getContainingObjectLiteral(func) {
            return (func.kind === 169 /* SyntaxKind.MethodDeclaration */ ||
                func.kind === 172 /* SyntaxKind.GetAccessor */ ||
                func.kind === 173 /* SyntaxKind.SetAccessor */) && func.parent.kind === 205 /* SyntaxKind.ObjectLiteralExpression */ ? func.parent :
                func.kind === 213 /* SyntaxKind.FunctionExpression */ && func.parent.kind === 296 /* SyntaxKind.PropertyAssignment */ ? func.parent.parent :
                    undefined;
        }
        function getThisTypeArgument(type) {
            return ts.getObjectFlags(type) & 4 /* ObjectFlags.Reference */ && type.target === globalThisType ? getTypeArguments(type)[0] : undefined;
        }
        function getThisTypeFromContextualType(type) {
            return mapType(type, function (t) {
                return t.flags & 2097152 /* TypeFlags.Intersection */ ? ts.forEach(t.types, getThisTypeArgument) : getThisTypeArgument(t);
            });
        }
        function getContextualThisParameterType(func) {
            if (func.kind === 214 /* SyntaxKind.ArrowFunction */) {
                return undefined;
            }
            if (isContextSensitiveFunctionOrObjectLiteralMethod(func)) {
                var contextualSignature = getContextualSignature(func);
                if (contextualSignature) {
                    var thisParameter = contextualSignature.thisParameter;
                    if (thisParameter) {
                        return getTypeOfSymbol(thisParameter);
                    }
                }
            }
            var inJs = ts.isInJSFile(func);
            if (noImplicitThis || inJs) {
                var containingLiteral = getContainingObjectLiteral(func);
                if (containingLiteral) {
                    // We have an object literal method. Check if the containing object literal has a contextual type
                    // that includes a ThisType<T>. If so, T is the contextual type for 'this'. We continue looking in
                    // any directly enclosing object literals.
                    var contextualType = getApparentTypeOfContextualType(containingLiteral);
                    var literal = containingLiteral;
                    var type = contextualType;
                    while (type) {
                        var thisType = getThisTypeFromContextualType(type);
                        if (thisType) {
                            return instantiateType(thisType, getMapperFromContext(getInferenceContext(containingLiteral)));
                        }
                        if (literal.parent.kind !== 296 /* SyntaxKind.PropertyAssignment */) {
                            break;
                        }
                        literal = literal.parent.parent;
                        type = getApparentTypeOfContextualType(literal);
                    }
                    // There was no contextual ThisType<T> for the containing object literal, so the contextual type
                    // for 'this' is the non-null form of the contextual type for the containing object literal or
                    // the type of the object literal itself.
                    return getWidenedType(contextualType ? getNonNullableType(contextualType) : checkExpressionCached(containingLiteral));
                }
                // In an assignment of the form 'obj.xxx = function(...)' or 'obj[xxx] = function(...)', the
                // contextual type for 'this' is 'obj'.
                var parent = ts.walkUpParenthesizedExpressions(func.parent);
                if (parent.kind === 221 /* SyntaxKind.BinaryExpression */ && parent.operatorToken.kind === 63 /* SyntaxKind.EqualsToken */) {
                    var target = parent.left;
                    if (ts.isAccessExpression(target)) {
                        var expression = target.expression;
                        // Don't contextually type `this` as `exports` in `exports.Point = function(x, y) { this.x = x; this.y = y; }`
                        if (inJs && ts.isIdentifier(expression)) {
                            var sourceFile = ts.getSourceFileOfNode(parent);
                            if (sourceFile.commonJsModuleIndicator && getResolvedSymbol(expression) === sourceFile.symbol) {
                                return undefined;
                            }
                        }
                        return getWidenedType(checkExpressionCached(expression));
                    }
                }
            }
            return undefined;
        }
        // Return contextual type of parameter or undefined if no contextual type is available
        function getContextuallyTypedParameterType(parameter) {
            var func = parameter.parent;
            if (!isContextSensitiveFunctionOrObjectLiteralMethod(func)) {
                return undefined;
            }
            var iife = ts.getImmediatelyInvokedFunctionExpression(func);
            if (iife && iife.arguments) {
                var args = getEffectiveCallArguments(iife);
                var indexOfParameter = func.parameters.indexOf(parameter);
                if (parameter.dotDotDotToken) {
                    return getSpreadArgumentType(args, indexOfParameter, args.length, anyType, /*context*/ undefined, 0 /* CheckMode.Normal */);
                }
                var links = getNodeLinks(iife);
                var cached = links.resolvedSignature;
                links.resolvedSignature = anySignature;
                var type = indexOfParameter < args.length ?
                    getWidenedLiteralType(checkExpression(args[indexOfParameter])) :
                    parameter.initializer ? undefined : undefinedWideningType;
                links.resolvedSignature = cached;
                return type;
            }
            var contextualSignature = getContextualSignature(func);
            if (contextualSignature) {
                var index = func.parameters.indexOf(parameter) - (ts.getThisParameter(func) ? 1 : 0);
                return parameter.dotDotDotToken && ts.lastOrUndefined(func.parameters) === parameter ?
                    getRestTypeAtPosition(contextualSignature, index) :
                    tryGetTypeAtPosition(contextualSignature, index);
            }
        }
        function getContextualTypeForVariableLikeDeclaration(declaration) {
            var typeNode = ts.getEffectiveTypeAnnotationNode(declaration);
            if (typeNode) {
                return getTypeFromTypeNode(typeNode);
            }
            switch (declaration.kind) {
                case 164 /* SyntaxKind.Parameter */:
                    return getContextuallyTypedParameterType(declaration);
                case 203 /* SyntaxKind.BindingElement */:
                    return getContextualTypeForBindingElement(declaration);
                case 167 /* SyntaxKind.PropertyDeclaration */:
                    if (ts.isStatic(declaration)) {
                        return getContextualTypeForStaticPropertyDeclaration(declaration);
                    }
                // By default, do nothing and return undefined - only the above cases have context implied by a parent
            }
        }
        function getContextualTypeForBindingElement(declaration) {
            var parent = declaration.parent.parent;
            var name = declaration.propertyName || declaration.name;
            var parentType = getContextualTypeForVariableLikeDeclaration(parent) ||
                parent.kind !== 203 /* SyntaxKind.BindingElement */ && parent.initializer && checkDeclarationInitializer(parent, declaration.dotDotDotToken ? 64 /* CheckMode.RestBindingElement */ : 0 /* CheckMode.Normal */);
            if (!parentType || ts.isBindingPattern(name) || ts.isComputedNonLiteralName(name))
                return undefined;
            if (parent.name.kind === 202 /* SyntaxKind.ArrayBindingPattern */) {
                var index = ts.indexOfNode(declaration.parent.elements, declaration);
                if (index < 0)
                    return undefined;
                return getContextualTypeForElementExpression(parentType, index);
            }
            var nameType = getLiteralTypeFromPropertyName(name);
            if (isTypeUsableAsPropertyName(nameType)) {
                var text = getPropertyNameFromType(nameType);
                return getTypeOfPropertyOfType(parentType, text);
            }
        }
        function getContextualTypeForStaticPropertyDeclaration(declaration) {
            var parentType = ts.isExpression(declaration.parent) && getContextualType(declaration.parent);
            if (!parentType)
                return undefined;
            return getTypeOfPropertyOfContextualType(parentType, getSymbolOfNode(declaration).escapedName);
        }
        // In a variable, parameter or property declaration with a type annotation,
        //   the contextual type of an initializer expression is the type of the variable, parameter or property.
        // Otherwise, in a parameter declaration of a contextually typed function expression,
        //   the contextual type of an initializer expression is the contextual type of the parameter.
        // Otherwise, in a variable or parameter declaration with a binding pattern name,
        //   the contextual type of an initializer expression is the type implied by the binding pattern.
        // Otherwise, in a binding pattern inside a variable or parameter declaration,
        //   the contextual type of an initializer expression is the type annotation of the containing declaration, if present.
        function getContextualTypeForInitializerExpression(node, contextFlags) {
            var declaration = node.parent;
            if (ts.hasInitializer(declaration) && node === declaration.initializer) {
                var result = getContextualTypeForVariableLikeDeclaration(declaration);
                if (result) {
                    return result;
                }
                if (!(contextFlags & 8 /* ContextFlags.SkipBindingPatterns */) && ts.isBindingPattern(declaration.name)) { // This is less a contextual type and more an implied shape - in some cases, this may be undesirable
                    return getTypeFromBindingPattern(declaration.name, /*includePatternInType*/ true, /*reportErrors*/ false);
                }
            }
            return undefined;
        }
        function getContextualTypeForReturnExpression(node) {
            var func = ts.getContainingFunction(node);
            if (func) {
                var contextualReturnType = getContextualReturnType(func);
                if (contextualReturnType) {
                    var functionFlags = ts.getFunctionFlags(func);
                    if (functionFlags & 1 /* FunctionFlags.Generator */) { // Generator or AsyncGenerator function
                        var use = functionFlags & 2 /* FunctionFlags.Async */ ? 2 /* IterationUse.AsyncGeneratorReturnType */ : 1 /* IterationUse.GeneratorReturnType */;
                        var iterationTypes = getIterationTypesOfIterable(contextualReturnType, use, /*errorNode*/ undefined);
                        if (!iterationTypes) {
                            return undefined;
                        }
                        contextualReturnType = iterationTypes.returnType;
                        // falls through to unwrap Promise for AsyncGenerators
                    }
                    if (functionFlags & 2 /* FunctionFlags.Async */) { // Async function or AsyncGenerator function
                        // Get the awaited type without the `Awaited<T>` alias
                        var contextualAwaitedType = mapType(contextualReturnType, getAwaitedTypeNoAlias);
                        return contextualAwaitedType && getUnionType([contextualAwaitedType, createPromiseLikeType(contextualAwaitedType)]);
                    }
                    return contextualReturnType; // Regular function or Generator function
                }
            }
            return undefined;
        }
        function getContextualTypeForAwaitOperand(node, contextFlags) {
            var contextualType = getContextualType(node, contextFlags);
            if (contextualType) {
                var contextualAwaitedType = getAwaitedTypeNoAlias(contextualType);
                return contextualAwaitedType && getUnionType([contextualAwaitedType, createPromiseLikeType(contextualAwaitedType)]);
            }
            return undefined;
        }
        function getContextualTypeForYieldOperand(node) {
            var func = ts.getContainingFunction(node);
            if (func) {
                var functionFlags = ts.getFunctionFlags(func);
                var contextualReturnType = getContextualReturnType(func);
                if (contextualReturnType) {
                    return node.asteriskToken
                        ? contextualReturnType
                        : getIterationTypeOfGeneratorFunctionReturnType(0 /* IterationTypeKind.Yield */, contextualReturnType, (functionFlags & 2 /* FunctionFlags.Async */) !== 0);
                }
            }
            return undefined;
        }
        function isInParameterInitializerBeforeContainingFunction(node) {
            var inBindingInitializer = false;
            while (node.parent && !ts.isFunctionLike(node.parent)) {
                if (ts.isParameter(node.parent) && (inBindingInitializer || node.parent.initializer === node)) {
                    return true;
                }
                if (ts.isBindingElement(node.parent) && node.parent.initializer === node) {
                    inBindingInitializer = true;
                }
                node = node.parent;
            }
            return false;
        }
        function getContextualIterationType(kind, functionDecl) {
            var isAsync = !!(ts.getFunctionFlags(functionDecl) & 2 /* FunctionFlags.Async */);
            var contextualReturnType = getContextualReturnType(functionDecl);
            if (contextualReturnType) {
                return getIterationTypeOfGeneratorFunctionReturnType(kind, contextualReturnType, isAsync)
                    || undefined;
            }
            return undefined;
        }
        function getContextualReturnType(functionDecl) {
            // If the containing function has a return type annotation, is a constructor, or is a get accessor whose
            // corresponding set accessor has a type annotation, return statements in the function are contextually typed
            var returnType = getReturnTypeFromAnnotation(functionDecl);
            if (returnType) {
                return returnType;
            }
            // Otherwise, if the containing function is contextually typed by a function type with exactly one call signature
            // and that call signature is non-generic, return statements are contextually typed by the return type of the signature
            var signature = getContextualSignatureForFunctionLikeDeclaration(functionDecl);
            if (signature && !isResolvingReturnTypeOfSignature(signature)) {
                return getReturnTypeOfSignature(signature);
            }
            var iife = ts.getImmediatelyInvokedFunctionExpression(functionDecl);
            if (iife) {
                return getContextualType(iife);
            }
            return undefined;
        }
        // In a typed function call, an argument or substitution expression is contextually typed by the type of the corresponding parameter.
        function getContextualTypeForArgument(callTarget, arg) {
            var args = getEffectiveCallArguments(callTarget);
            var argIndex = args.indexOf(arg); // -1 for e.g. the expression of a CallExpression, or the tag of a TaggedTemplateExpression
            return argIndex === -1 ? undefined : getContextualTypeForArgumentAtIndex(callTarget, argIndex);
        }
        function getContextualTypeForArgumentAtIndex(callTarget, argIndex) {
            if (ts.isImportCall(callTarget)) {
                return argIndex === 0 ? stringType :
                    argIndex === 1 ? getGlobalImportCallOptionsType(/*reportErrors*/ false) :
                        anyType;
            }
            // If we're already in the process of resolving the given signature, don't resolve again as
            // that could cause infinite recursion. Instead, return anySignature.
            var signature = getNodeLinks(callTarget).resolvedSignature === resolvingSignature ? resolvingSignature : getResolvedSignature(callTarget);
            if (ts.isJsxOpeningLikeElement(callTarget) && argIndex === 0) {
                return getEffectiveFirstArgumentForJsxSignature(signature, callTarget);
            }
            var restIndex = signature.parameters.length - 1;
            return signatureHasRestParameter(signature) && argIndex >= restIndex ?
                getIndexedAccessType(getTypeOfSymbol(signature.parameters[restIndex]), getNumberLiteralType(argIndex - restIndex), 256 /* AccessFlags.Contextual */) :
                getTypeAtPosition(signature, argIndex);
        }
        function getContextualTypeForSubstitutionExpression(template, substitutionExpression) {
            if (template.parent.kind === 210 /* SyntaxKind.TaggedTemplateExpression */) {
                return getContextualTypeForArgument(template.parent, substitutionExpression);
            }
            return undefined;
        }
        function getContextualTypeForBinaryOperand(node, contextFlags) {
            var binaryExpression = node.parent;
            var left = binaryExpression.left, operatorToken = binaryExpression.operatorToken, right = binaryExpression.right;
            switch (operatorToken.kind) {
                case 63 /* SyntaxKind.EqualsToken */:
                case 76 /* SyntaxKind.AmpersandAmpersandEqualsToken */:
                case 75 /* SyntaxKind.BarBarEqualsToken */:
                case 77 /* SyntaxKind.QuestionQuestionEqualsToken */:
                    return node === right ? getContextualTypeForAssignmentDeclaration(binaryExpression) : undefined;
                case 56 /* SyntaxKind.BarBarToken */:
                case 60 /* SyntaxKind.QuestionQuestionToken */:
                    // When an || expression has a contextual type, the operands are contextually typed by that type, except
                    // when that type originates in a binding pattern, the right operand is contextually typed by the type of
                    // the left operand. When an || expression has no contextual type, the right operand is contextually typed
                    // by the type of the left operand, except for the special case of Javascript declarations of the form
                    // `namespace.prop = namespace.prop || {}`.
                    var type = getContextualType(binaryExpression, contextFlags);
                    return node === right && (type && type.pattern || !type && !ts.isDefaultedExpandoInitializer(binaryExpression)) ?
                        getTypeOfExpression(left) : type;
                case 55 /* SyntaxKind.AmpersandAmpersandToken */:
                case 27 /* SyntaxKind.CommaToken */:
                    return node === right ? getContextualType(binaryExpression, contextFlags) : undefined;
                default:
                    return undefined;
            }
        }
        /**
         * Try to find a resolved symbol for an expression without also resolving its type, as
         * getSymbolAtLocation would (as that could be reentrant into contextual typing)
         */
        function getSymbolForExpression(e) {
            if (e.symbol) {
                return e.symbol;
            }
            if (ts.isIdentifier(e)) {
                return getResolvedSymbol(e);
            }
            if (ts.isPropertyAccessExpression(e)) {
                var lhsType = getTypeOfExpression(e.expression);
                return ts.isPrivateIdentifier(e.name) ? tryGetPrivateIdentifierPropertyOfType(lhsType, e.name) : getPropertyOfType(lhsType, e.name.escapedText);
            }
            return undefined;
            function tryGetPrivateIdentifierPropertyOfType(type, id) {
                var lexicallyScopedSymbol = lookupSymbolForPrivateIdentifierDeclaration(id.escapedText, id);
                return lexicallyScopedSymbol && getPrivateIdentifierPropertyOfType(type, lexicallyScopedSymbol);
            }
        }
        // In an assignment expression, the right operand is contextually typed by the type of the left operand.
        // Don't do this for assignment declarations unless there is a type tag on the assignment, to avoid circularity from checking the right operand.
        function getContextualTypeForAssignmentDeclaration(binaryExpression) {
            var _a, _b;
            var kind = ts.getAssignmentDeclarationKind(binaryExpression);
            switch (kind) {
                case 0 /* AssignmentDeclarationKind.None */:
                case 4 /* AssignmentDeclarationKind.ThisProperty */:
                    var lhsSymbol = getSymbolForExpression(binaryExpression.left);
                    var decl = lhsSymbol && lhsSymbol.valueDeclaration;
                    // Unannotated, uninitialized property declarations have a type implied by their usage in the constructor.
                    // We avoid calling back into `getTypeOfExpression` and reentering contextual typing to avoid a bogus circularity error in that case.
                    if (decl && (ts.isPropertyDeclaration(decl) || ts.isPropertySignature(decl))) {
                        var overallAnnotation = ts.getEffectiveTypeAnnotationNode(decl);
                        return (overallAnnotation && instantiateType(getTypeFromTypeNode(overallAnnotation), getSymbolLinks(lhsSymbol).mapper)) ||
                            (decl.initializer && getTypeOfExpression(binaryExpression.left));
                    }
                    if (kind === 0 /* AssignmentDeclarationKind.None */) {
                        return getTypeOfExpression(binaryExpression.left);
                    }
                    return getContextualTypeForThisPropertyAssignment(binaryExpression);
                case 5 /* AssignmentDeclarationKind.Property */:
                    if (isPossiblyAliasedThisProperty(binaryExpression, kind)) {
                        return getContextualTypeForThisPropertyAssignment(binaryExpression);
                    }
                    // If `binaryExpression.left` was assigned a symbol, then this is a new declaration; otherwise it is an assignment to an existing declaration.
                    // See `bindStaticPropertyAssignment` in `binder.ts`.
                    else if (!binaryExpression.left.symbol) {
                        return getTypeOfExpression(binaryExpression.left);
                    }
                    else {
                        var decl_1 = binaryExpression.left.symbol.valueDeclaration;
                        if (!decl_1) {
                            return undefined;
                        }
                        var lhs = ts.cast(binaryExpression.left, ts.isAccessExpression);
                        var overallAnnotation = ts.getEffectiveTypeAnnotationNode(decl_1);
                        if (overallAnnotation) {
                            return getTypeFromTypeNode(overallAnnotation);
                        }
                        else if (ts.isIdentifier(lhs.expression)) {
                            var id = lhs.expression;
                            var parentSymbol = resolveName(id, id.escapedText, 111551 /* SymbolFlags.Value */, undefined, id.escapedText, /*isUse*/ true);
                            if (parentSymbol) {
                                var annotated_1 = parentSymbol.valueDeclaration && ts.getEffectiveTypeAnnotationNode(parentSymbol.valueDeclaration);
                                if (annotated_1) {
                                    var nameStr = ts.getElementOrPropertyAccessName(lhs);
                                    if (nameStr !== undefined) {
                                        return getTypeOfPropertyOfContextualType(getTypeFromTypeNode(annotated_1), nameStr);
                                    }
                                }
                                return undefined;
                            }
                        }
                        return ts.isInJSFile(decl_1) ? undefined : getTypeOfExpression(binaryExpression.left);
                    }
                case 1 /* AssignmentDeclarationKind.ExportsProperty */:
                case 6 /* AssignmentDeclarationKind.Prototype */:
                case 3 /* AssignmentDeclarationKind.PrototypeProperty */:
                    var valueDeclaration = (_a = binaryExpression.left.symbol) === null || _a === void 0 ? void 0 : _a.valueDeclaration;
                // falls through
                case 2 /* AssignmentDeclarationKind.ModuleExports */:
                    valueDeclaration || (valueDeclaration = (_b = binaryExpression.symbol) === null || _b === void 0 ? void 0 : _b.valueDeclaration);
                    var annotated = valueDeclaration && ts.getEffectiveTypeAnnotationNode(valueDeclaration);
                    return annotated ? getTypeFromTypeNode(annotated) : undefined;
                case 7 /* AssignmentDeclarationKind.ObjectDefinePropertyValue */:
                case 8 /* AssignmentDeclarationKind.ObjectDefinePropertyExports */:
                case 9 /* AssignmentDeclarationKind.ObjectDefinePrototypeProperty */:
                    return ts.Debug.fail("Does not apply");
                default:
                    return ts.Debug.assertNever(kind);
            }
        }
        function isPossiblyAliasedThisProperty(declaration, kind) {
            if (kind === void 0) { kind = ts.getAssignmentDeclarationKind(declaration); }
            if (kind === 4 /* AssignmentDeclarationKind.ThisProperty */) {
                return true;
            }
            if (!ts.isInJSFile(declaration) || kind !== 5 /* AssignmentDeclarationKind.Property */ || !ts.isIdentifier(declaration.left.expression)) {
                return false;
            }
            var name = declaration.left.expression.escapedText;
            var symbol = resolveName(declaration.left, name, 111551 /* SymbolFlags.Value */, undefined, undefined, /*isUse*/ true, /*excludeGlobals*/ true);
            return ts.isThisInitializedDeclaration(symbol === null || symbol === void 0 ? void 0 : symbol.valueDeclaration);
        }
        function getContextualTypeForThisPropertyAssignment(binaryExpression) {
            if (!binaryExpression.symbol)
                return getTypeOfExpression(binaryExpression.left);
            if (binaryExpression.symbol.valueDeclaration) {
                var annotated = ts.getEffectiveTypeAnnotationNode(binaryExpression.symbol.valueDeclaration);
                if (annotated) {
                    var type = getTypeFromTypeNode(annotated);
                    if (type) {
                        return type;
                    }
                }
            }
            var thisAccess = ts.cast(binaryExpression.left, ts.isAccessExpression);
            if (!ts.isObjectLiteralMethod(ts.getThisContainer(thisAccess.expression, /*includeArrowFunctions*/ false))) {
                return undefined;
            }
            var thisType = checkThisExpression(thisAccess.expression);
            var nameStr = ts.getElementOrPropertyAccessName(thisAccess);
            return nameStr !== undefined && getTypeOfPropertyOfContextualType(thisType, nameStr) || undefined;
        }
        function isCircularMappedProperty(symbol) {
            return !!(ts.getCheckFlags(symbol) & 262144 /* CheckFlags.Mapped */ && !symbol.type && findResolutionCycleStartIndex(symbol, 0 /* TypeSystemPropertyName.Type */) >= 0);
        }
        function getTypeOfPropertyOfContextualType(type, name, nameType) {
            return mapType(type, function (t) {
                var _a;
                if (isGenericMappedType(t) && !t.declaration.nameType) {
                    var constraint = getConstraintTypeFromMappedType(t);
                    var constraintOfConstraint = getBaseConstraintOfType(constraint) || constraint;
                    var propertyNameType = nameType || getStringLiteralType(ts.unescapeLeadingUnderscores(name));
                    if (isTypeAssignableTo(propertyNameType, constraintOfConstraint)) {
                        return substituteIndexedMappedType(t, propertyNameType);
                    }
                }
                else if (t.flags & 3670016 /* TypeFlags.StructuredType */) {
                    var prop = getPropertyOfType(t, name);
                    if (prop) {
                        return isCircularMappedProperty(prop) ? undefined : getTypeOfSymbol(prop);
                    }
                    if (isTupleType(t)) {
                        var restType = getRestTypeOfTupleType(t);
                        if (restType && ts.isNumericLiteralName(name) && +name >= 0) {
                            return restType;
                        }
                    }
                    return (_a = findApplicableIndexInfo(getIndexInfosOfStructuredType(t), nameType || getStringLiteralType(ts.unescapeLeadingUnderscores(name)))) === null || _a === void 0 ? void 0 : _a.type;
                }
                return undefined;
            }, /*noReductions*/ true);
        }
        // In an object literal contextually typed by a type T, the contextual type of a property assignment is the type of
        // the matching property in T, if one exists. Otherwise, it is the type of the numeric index signature in T, if one
        // exists. Otherwise, it is the type of the string index signature in T, if one exists.
        function getContextualTypeForObjectLiteralMethod(node, contextFlags) {
            ts.Debug.assert(ts.isObjectLiteralMethod(node));
            if (node.flags & 33554432 /* NodeFlags.InWithStatement */) {
                // We cannot answer semantic questions within a with block, do not proceed any further
                return undefined;
            }
            return getContextualTypeForObjectLiteralElement(node, contextFlags);
        }
        function getContextualTypeForObjectLiteralElement(element, contextFlags) {
            var objectLiteral = element.parent;
            var propertyAssignmentType = ts.isPropertyAssignment(element) && getContextualTypeForVariableLikeDeclaration(element);
            if (propertyAssignmentType) {
                return propertyAssignmentType;
            }
            var type = getApparentTypeOfContextualType(objectLiteral, contextFlags);
            if (type) {
                if (hasBindableName(element)) {
                    // For a (non-symbol) computed property, there is no reason to look up the name
                    // in the type. It will just be "__computed", which does not appear in any
                    // SymbolTable.
                    var symbol = getSymbolOfNode(element);
                    return getTypeOfPropertyOfContextualType(type, symbol.escapedName, getSymbolLinks(symbol).nameType);
                }
                if (element.name) {
                    var nameType_2 = getLiteralTypeFromPropertyName(element.name);
                    // We avoid calling getApplicableIndexInfo here because it performs potentially expensive intersection reduction.
                    return mapType(type, function (t) { var _a; return (_a = findApplicableIndexInfo(getIndexInfosOfStructuredType(t), nameType_2)) === null || _a === void 0 ? void 0 : _a.type; }, /*noReductions*/ true);
                }
            }
            return undefined;
        }
        // In an array literal contextually typed by a type T, the contextual type of an element expression at index N is
        // the type of the property with the numeric name N in T, if one exists. Otherwise, if T has a numeric index signature,
        // it is the type of the numeric index signature in T. Otherwise, in ES6 and higher, the contextual type is the iterated
        // type of T.
        function getContextualTypeForElementExpression(arrayContextualType, index) {
            return arrayContextualType && (getTypeOfPropertyOfContextualType(arrayContextualType, "" + index)
                || mapType(arrayContextualType, function (t) { return getIteratedTypeOrElementType(1 /* IterationUse.Element */, t, undefinedType, /*errorNode*/ undefined, /*checkAssignability*/ false); }, 
                /*noReductions*/ true));
        }
        // In a contextually typed conditional expression, the true/false expressions are contextually typed by the same type.
        function getContextualTypeForConditionalOperand(node, contextFlags) {
            var conditional = node.parent;
            return node === conditional.whenTrue || node === conditional.whenFalse ? getContextualType(conditional, contextFlags) : undefined;
        }
        function getContextualTypeForChildJsxExpression(node, child) {
            var attributesType = getApparentTypeOfContextualType(node.openingElement.tagName);
            // JSX expression is in children of JSX Element, we will look for an "children" attribute (we get the name from JSX.ElementAttributesProperty)
            var jsxChildrenPropertyName = getJsxElementChildrenPropertyName(getJsxNamespaceAt(node));
            if (!(attributesType && !isTypeAny(attributesType) && jsxChildrenPropertyName && jsxChildrenPropertyName !== "")) {
                return undefined;
            }
            var realChildren = ts.getSemanticJsxChildren(node.children);
            var childIndex = realChildren.indexOf(child);
            var childFieldType = getTypeOfPropertyOfContextualType(attributesType, jsxChildrenPropertyName);
            return childFieldType && (realChildren.length === 1 ? childFieldType : mapType(childFieldType, function (t) {
                if (isArrayLikeType(t)) {
                    return getIndexedAccessType(t, getNumberLiteralType(childIndex));
                }
                else {
                    return t;
                }
            }, /*noReductions*/ true));
        }
        function getContextualTypeForJsxExpression(node) {
            var exprParent = node.parent;
            return ts.isJsxAttributeLike(exprParent)
                ? getContextualType(node)
                : ts.isJsxElement(exprParent)
                    ? getContextualTypeForChildJsxExpression(exprParent, node)
                    : undefined;
        }
        function getContextualTypeForJsxAttribute(attribute) {
            // When we trying to resolve JsxOpeningLikeElement as a stateless function element, we will already give its attributes a contextual type
            // which is a type of the parameter of the signature we are trying out.
            // If there is no contextual type (e.g. we are trying to resolve stateful component), get attributes type from resolving element's tagName
            if (ts.isJsxAttribute(attribute)) {
                var attributesType = getApparentTypeOfContextualType(attribute.parent);
                if (!attributesType || isTypeAny(attributesType)) {
                    return undefined;
                }
                return getTypeOfPropertyOfContextualType(attributesType, attribute.name.escapedText);
            }
            else {
                return getContextualType(attribute.parent);
            }
        }
        // Return true if the given expression is possibly a discriminant value. We limit the kinds of
        // expressions we check to those that don't depend on their contextual type in order not to cause
        // recursive (and possibly infinite) invocations of getContextualType.
        function isPossiblyDiscriminantValue(node) {
            switch (node.kind) {
                case 10 /* SyntaxKind.StringLiteral */:
                case 8 /* SyntaxKind.NumericLiteral */:
                case 9 /* SyntaxKind.BigIntLiteral */:
                case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
                case 110 /* SyntaxKind.TrueKeyword */:
                case 95 /* SyntaxKind.FalseKeyword */:
                case 104 /* SyntaxKind.NullKeyword */:
                case 79 /* SyntaxKind.Identifier */:
                case 153 /* SyntaxKind.UndefinedKeyword */:
                    return true;
                case 206 /* SyntaxKind.PropertyAccessExpression */:
                case 212 /* SyntaxKind.ParenthesizedExpression */:
                    return isPossiblyDiscriminantValue(node.expression);
                case 288 /* SyntaxKind.JsxExpression */:
                    return !node.expression || isPossiblyDiscriminantValue(node.expression);
            }
            return false;
        }
        function discriminateContextualTypeByObjectMembers(node, contextualType) {
            return getMatchingUnionConstituentForObjectLiteral(contextualType, node) || discriminateTypeByDiscriminableItems(contextualType, ts.concatenate(ts.map(ts.filter(node.properties, function (p) { return !!p.symbol && p.kind === 296 /* SyntaxKind.PropertyAssignment */ && isPossiblyDiscriminantValue(p.initializer) && isDiscriminantProperty(contextualType, p.symbol.escapedName); }), function (prop) { return [function () { return getContextFreeTypeOfExpression(prop.initializer); }, prop.symbol.escapedName]; }), ts.map(ts.filter(getPropertiesOfType(contextualType), function (s) { var _a; return !!(s.flags & 16777216 /* SymbolFlags.Optional */) && !!((_a = node === null || node === void 0 ? void 0 : node.symbol) === null || _a === void 0 ? void 0 : _a.members) && !node.symbol.members.has(s.escapedName) && isDiscriminantProperty(contextualType, s.escapedName); }), function (s) { return [function () { return undefinedType; }, s.escapedName]; })), isTypeAssignableTo, contextualType);
        }
        function discriminateContextualTypeByJSXAttributes(node, contextualType) {
            return discriminateTypeByDiscriminableItems(contextualType, ts.concatenate(ts.map(ts.filter(node.properties, function (p) { return !!p.symbol && p.kind === 285 /* SyntaxKind.JsxAttribute */ && isDiscriminantProperty(contextualType, p.symbol.escapedName) && (!p.initializer || isPossiblyDiscriminantValue(p.initializer)); }), function (prop) { return [!prop.initializer ? (function () { return trueType; }) : (function () { return getContextFreeTypeOfExpression(prop.initializer); }), prop.symbol.escapedName]; }), ts.map(ts.filter(getPropertiesOfType(contextualType), function (s) { var _a; return !!(s.flags & 16777216 /* SymbolFlags.Optional */) && !!((_a = node === null || node === void 0 ? void 0 : node.symbol) === null || _a === void 0 ? void 0 : _a.members) && !node.symbol.members.has(s.escapedName) && isDiscriminantProperty(contextualType, s.escapedName); }), function (s) { return [function () { return undefinedType; }, s.escapedName]; })), isTypeAssignableTo, contextualType);
        }
        // Return the contextual type for a given expression node. During overload resolution, a contextual type may temporarily
        // be "pushed" onto a node using the contextualType property.
        function getApparentTypeOfContextualType(node, contextFlags) {
            var contextualType = ts.isObjectLiteralMethod(node) ?
                getContextualTypeForObjectLiteralMethod(node, contextFlags) :
                getContextualType(node, contextFlags);
            var instantiatedType = instantiateContextualType(contextualType, node, contextFlags);
            if (instantiatedType && !(contextFlags && contextFlags & 2 /* ContextFlags.NoConstraints */ && instantiatedType.flags & 8650752 /* TypeFlags.TypeVariable */)) {
                var apparentType = mapType(instantiatedType, getApparentType, /*noReductions*/ true);
                return apparentType.flags & 1048576 /* TypeFlags.Union */ && ts.isObjectLiteralExpression(node) ? discriminateContextualTypeByObjectMembers(node, apparentType) :
                    apparentType.flags & 1048576 /* TypeFlags.Union */ && ts.isJsxAttributes(node) ? discriminateContextualTypeByJSXAttributes(node, apparentType) :
                        apparentType;
            }
        }
        // If the given contextual type contains instantiable types and if a mapper representing
        // return type inferences is available, instantiate those types using that mapper.
        function instantiateContextualType(contextualType, node, contextFlags) {
            if (contextualType && maybeTypeOfKind(contextualType, 465829888 /* TypeFlags.Instantiable */)) {
                var inferenceContext = getInferenceContext(node);
                // If no inferences have been made, nothing is gained from instantiating as type parameters
                // would just be replaced with their defaults similar to the apparent type.
                if (inferenceContext && ts.some(inferenceContext.inferences, hasInferenceCandidates)) {
                    // For contextual signatures we incorporate all inferences made so far, e.g. from return
                    // types as well as arguments to the left in a function call.
                    if (contextFlags && contextFlags & 1 /* ContextFlags.Signature */) {
                        return instantiateInstantiableTypes(contextualType, inferenceContext.nonFixingMapper);
                    }
                    // For other purposes (e.g. determining whether to produce literal types) we only
                    // incorporate inferences made from the return type in a function call. We remove
                    // the 'boolean' type from the contextual type such that contextually typed boolean
                    // literals actually end up widening to 'boolean' (see #48363).
                    if (inferenceContext.returnMapper) {
                        var type = instantiateInstantiableTypes(contextualType, inferenceContext.returnMapper);
                        return type.flags & 1048576 /* TypeFlags.Union */ && containsType(type.types, regularFalseType) && containsType(type.types, regularTrueType) ?
                            filterType(type, function (t) { return t !== regularFalseType && t !== regularTrueType; }) :
                            type;
                    }
                }
            }
            return contextualType;
        }
        // This function is similar to instantiateType, except that (a) it only instantiates types that
        // are classified as instantiable (i.e. it doesn't instantiate object types), and (b) it performs
        // no reductions on instantiated union types.
        function instantiateInstantiableTypes(type, mapper) {
            if (type.flags & 465829888 /* TypeFlags.Instantiable */) {
                return instantiateType(type, mapper);
            }
            if (type.flags & 1048576 /* TypeFlags.Union */) {
                return getUnionType(ts.map(type.types, function (t) { return instantiateInstantiableTypes(t, mapper); }), 0 /* UnionReduction.None */);
            }
            if (type.flags & 2097152 /* TypeFlags.Intersection */) {
                return getIntersectionType(ts.map(type.types, function (t) { return instantiateInstantiableTypes(t, mapper); }));
            }
            return type;
        }
        /**
         * Whoa! Do you really want to use this function?
         *
         * Unless you're trying to get the *non-apparent* type for a
         * value-literal type or you're authoring relevant portions of this algorithm,
         * you probably meant to use 'getApparentTypeOfContextualType'.
         * Otherwise this may not be very useful.
         *
         * In cases where you *are* working on this function, you should understand
         * when it is appropriate to use 'getContextualType' and 'getApparentTypeOfContextualType'.
         *
         *   - Use 'getContextualType' when you are simply going to propagate the result to the expression.
         *   - Use 'getApparentTypeOfContextualType' when you're going to need the members of the type.
         *
         * @param node the expression whose contextual type will be returned.
         * @returns the contextual type of an expression.
         */
        function getContextualType(node, contextFlags) {
            if (node.flags & 33554432 /* NodeFlags.InWithStatement */) {
                // We cannot answer semantic questions within a with block, do not proceed any further
                return undefined;
            }
            if (node.contextualType) {
                return node.contextualType;
            }
            var parent = node.parent;
            switch (parent.kind) {
                case 254 /* SyntaxKind.VariableDeclaration */:
                case 164 /* SyntaxKind.Parameter */:
                case 167 /* SyntaxKind.PropertyDeclaration */:
                case 166 /* SyntaxKind.PropertySignature */:
                case 203 /* SyntaxKind.BindingElement */:
                    return getContextualTypeForInitializerExpression(node, contextFlags);
                case 214 /* SyntaxKind.ArrowFunction */:
                case 247 /* SyntaxKind.ReturnStatement */:
                    return getContextualTypeForReturnExpression(node);
                case 224 /* SyntaxKind.YieldExpression */:
                    return getContextualTypeForYieldOperand(parent);
                case 218 /* SyntaxKind.AwaitExpression */:
                    return getContextualTypeForAwaitOperand(parent, contextFlags);
                case 208 /* SyntaxKind.CallExpression */:
                case 209 /* SyntaxKind.NewExpression */:
                    return getContextualTypeForArgument(parent, node);
                case 211 /* SyntaxKind.TypeAssertionExpression */:
                case 229 /* SyntaxKind.AsExpression */:
                    return ts.isConstTypeReference(parent.type) ? tryFindWhenConstTypeReference(parent) : getTypeFromTypeNode(parent.type);
                case 221 /* SyntaxKind.BinaryExpression */:
                    return getContextualTypeForBinaryOperand(node, contextFlags);
                case 296 /* SyntaxKind.PropertyAssignment */:
                case 297 /* SyntaxKind.ShorthandPropertyAssignment */:
                    return getContextualTypeForObjectLiteralElement(parent, contextFlags);
                case 298 /* SyntaxKind.SpreadAssignment */:
                    return getContextualType(parent.parent, contextFlags);
                case 204 /* SyntaxKind.ArrayLiteralExpression */: {
                    var arrayLiteral = parent;
                    var type = getApparentTypeOfContextualType(arrayLiteral, contextFlags);
                    return getContextualTypeForElementExpression(type, ts.indexOfNode(arrayLiteral.elements, node));
                }
                case 222 /* SyntaxKind.ConditionalExpression */:
                    return getContextualTypeForConditionalOperand(node, contextFlags);
                case 233 /* SyntaxKind.TemplateSpan */:
                    ts.Debug.assert(parent.parent.kind === 223 /* SyntaxKind.TemplateExpression */);
                    return getContextualTypeForSubstitutionExpression(parent.parent, node);
                case 212 /* SyntaxKind.ParenthesizedExpression */: {
                    // Like in `checkParenthesizedExpression`, an `/** @type {xyz} */` comment before a parenthesized expression acts as a type cast.
                    var tag = ts.isInJSFile(parent) ? ts.getJSDocTypeTag(parent) : undefined;
                    return !tag ? getContextualType(parent, contextFlags) :
                        ts.isJSDocTypeTag(tag) && ts.isConstTypeReference(tag.typeExpression.type) ? tryFindWhenConstTypeReference(parent) :
                            getTypeFromTypeNode(tag.typeExpression.type);
                }
                case 230 /* SyntaxKind.NonNullExpression */:
                    return getContextualType(parent, contextFlags);
                case 271 /* SyntaxKind.ExportAssignment */:
                    return tryGetTypeFromEffectiveTypeNode(parent);
                case 288 /* SyntaxKind.JsxExpression */:
                    return getContextualTypeForJsxExpression(parent);
                case 285 /* SyntaxKind.JsxAttribute */:
                case 287 /* SyntaxKind.JsxSpreadAttribute */:
                    return getContextualTypeForJsxAttribute(parent);
                case 280 /* SyntaxKind.JsxOpeningElement */:
                case 279 /* SyntaxKind.JsxSelfClosingElement */:
                    return getContextualJsxElementAttributesType(parent, contextFlags);
            }
            return undefined;
            function tryFindWhenConstTypeReference(node) {
                return getContextualType(node);
            }
        }
        function getInferenceContext(node) {
            var ancestor = ts.findAncestor(node, function (n) { return !!n.inferenceContext; });
            return ancestor && ancestor.inferenceContext;
        }
        function getContextualJsxElementAttributesType(node, contextFlags) {
            if (ts.isJsxOpeningElement(node) && node.parent.contextualType && contextFlags !== 4 /* ContextFlags.Completions */) {
                // Contextually applied type is moved from attributes up to the outer jsx attributes so when walking up from the children they get hit
                // _However_ to hit them from the _attributes_ we must look for them here; otherwise we'll used the declared type
                // (as below) instead!
                return node.parent.contextualType;
            }
            return getContextualTypeForArgumentAtIndex(node, 0);
        }
        function getEffectiveFirstArgumentForJsxSignature(signature, node) {
            return getJsxReferenceKind(node) !== 0 /* JsxReferenceKind.Component */
                ? getJsxPropsTypeFromCallSignature(signature, node)
                : getJsxPropsTypeFromClassType(signature, node);
        }
        function getJsxPropsTypeFromCallSignature(sig, context) {
            var propsType = getTypeOfFirstParameterOfSignatureWithFallback(sig, unknownType);
            propsType = getJsxManagedAttributesFromLocatedAttributes(context, getJsxNamespaceAt(context), propsType);
            var intrinsicAttribs = getJsxType(JsxNames.IntrinsicAttributes, context);
            if (!isErrorType(intrinsicAttribs)) {
                propsType = intersectTypes(intrinsicAttribs, propsType);
            }
            return propsType;
        }
        function getJsxPropsTypeForSignatureFromMember(sig, forcedLookupLocation) {
            if (sig.compositeSignatures) {
                // JSX Elements using the legacy `props`-field based lookup (eg, react class components) need to treat the `props` member as an input
                // instead of an output position when resolving the signature. We need to go back to the input signatures of the composite signature,
                // get the type of `props` on each return type individually, and then _intersect them_, rather than union them (as would normally occur
                // for a union signature). It's an unfortunate quirk of looking in the output of the signature for the type we want to use for the input.
                // The default behavior of `getTypeOfFirstParameterOfSignatureWithFallback` when no `props` member name is defined is much more sane.
                var results = [];
                for (var _i = 0, _a = sig.compositeSignatures; _i < _a.length; _i++) {
                    var signature = _a[_i];
                    var instance = getReturnTypeOfSignature(signature);
                    if (isTypeAny(instance)) {
                        return instance;
                    }
                    var propType = getTypeOfPropertyOfType(instance, forcedLookupLocation);
                    if (!propType) {
                        return;
                    }
                    results.push(propType);
                }
                return getIntersectionType(results); // Same result for both union and intersection signatures
            }
            var instanceType = getReturnTypeOfSignature(sig);
            return isTypeAny(instanceType) ? instanceType : getTypeOfPropertyOfType(instanceType, forcedLookupLocation);
        }
        function getStaticTypeOfReferencedJsxConstructor(context) {
            if (isJsxIntrinsicIdentifier(context.tagName)) {
                var result = getIntrinsicAttributesTypeFromJsxOpeningLikeElement(context);
                var fakeSignature = createSignatureForJSXIntrinsic(context, result);
                return getOrCreateTypeFromSignature(fakeSignature);
            }
            var tagType = checkExpressionCached(context.tagName);
            if (tagType.flags & 128 /* TypeFlags.StringLiteral */) {
                var result = getIntrinsicAttributesTypeFromStringLiteralType(tagType, context);
                if (!result) {
                    return errorType;
                }
                var fakeSignature = createSignatureForJSXIntrinsic(context, result);
                return getOrCreateTypeFromSignature(fakeSignature);
            }
            return tagType;
        }
        function getJsxManagedAttributesFromLocatedAttributes(context, ns, attributesType) {
            var managedSym = getJsxLibraryManagedAttributes(ns);
            if (managedSym) {
                var declaredManagedType = getDeclaredTypeOfSymbol(managedSym); // fetches interface type, or initializes symbol links type parmaeters
                var ctorType = getStaticTypeOfReferencedJsxConstructor(context);
                if (managedSym.flags & 524288 /* SymbolFlags.TypeAlias */) {
                    var params = getSymbolLinks(managedSym).typeParameters;
                    if (ts.length(params) >= 2) {
                        var args = fillMissingTypeArguments([ctorType, attributesType], params, 2, ts.isInJSFile(context));
                        return getTypeAliasInstantiation(managedSym, args);
                    }
                }
                if (ts.length(declaredManagedType.typeParameters) >= 2) {
                    var args = fillMissingTypeArguments([ctorType, attributesType], declaredManagedType.typeParameters, 2, ts.isInJSFile(context));
                    return createTypeReference(declaredManagedType, args);
                }
            }
            return attributesType;
        }
        function getJsxPropsTypeFromClassType(sig, context) {
            var ns = getJsxNamespaceAt(context);
            var forcedLookupLocation = getJsxElementPropertiesName(ns);
            var attributesType = forcedLookupLocation === undefined
                // If there is no type ElementAttributesProperty, return the type of the first parameter of the signature, which should be the props type
                ? getTypeOfFirstParameterOfSignatureWithFallback(sig, unknownType)
                : forcedLookupLocation === ""
                    // If there is no e.g. 'props' member in ElementAttributesProperty, use the element class type instead
                    ? getReturnTypeOfSignature(sig)
                    // Otherwise get the type of the property on the signature return type
                    : getJsxPropsTypeForSignatureFromMember(sig, forcedLookupLocation);
            if (!attributesType) {
                // There is no property named 'props' on this instance type
                if (!!forcedLookupLocation && !!ts.length(context.attributes.properties)) {
                    error(context, ts.Diagnostics.JSX_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property, ts.unescapeLeadingUnderscores(forcedLookupLocation));
                }
                return unknownType;
            }
            attributesType = getJsxManagedAttributesFromLocatedAttributes(context, ns, attributesType);
            if (isTypeAny(attributesType)) {
                // Props is of type 'any' or unknown
                return attributesType;
            }
            else {
                // Normal case -- add in IntrinsicClassElements<T> and IntrinsicElements
                var apparentAttributesType = attributesType;
                var intrinsicClassAttribs = getJsxType(JsxNames.IntrinsicClassAttributes, context);
                if (!isErrorType(intrinsicClassAttribs)) {
                    var typeParams = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(intrinsicClassAttribs.symbol);
                    var hostClassType = getReturnTypeOfSignature(sig);
                    apparentAttributesType = intersectTypes(typeParams
                        ? createTypeReference(intrinsicClassAttribs, fillMissingTypeArguments([hostClassType], typeParams, getMinTypeArgumentCount(typeParams), ts.isInJSFile(context)))
                        : intrinsicClassAttribs, apparentAttributesType);
                }
                var intrinsicAttribs = getJsxType(JsxNames.IntrinsicAttributes, context);
                if (!isErrorType(intrinsicAttribs)) {
                    apparentAttributesType = intersectTypes(intrinsicAttribs, apparentAttributesType);
                }
                return apparentAttributesType;
            }
        }
        function getIntersectedSignatures(signatures) {
            return ts.getStrictOptionValue(compilerOptions, "noImplicitAny")
                ? ts.reduceLeft(signatures, function (left, right) {
                    return left === right || !left ? left
                        : compareTypeParametersIdentical(left.typeParameters, right.typeParameters) ? combineSignaturesOfIntersectionMembers(left, right)
                            : undefined;
                })
                : undefined;
        }
        function combineIntersectionThisParam(left, right, mapper) {
            if (!left || !right) {
                return left || right;
            }
            // A signature `this` type might be a read or a write position... It's very possible that it should be invariant
            // and we should refuse to merge signatures if there are `this` types and they do not match. However, so as to be
            // pessimistic when contextual typing, for now, we'll union the `this` types.
            var thisType = getUnionType([getTypeOfSymbol(left), instantiateType(getTypeOfSymbol(right), mapper)]);
            return createSymbolWithType(left, thisType);
        }
        function combineIntersectionParameters(left, right, mapper) {
            var leftCount = getParameterCount(left);
            var rightCount = getParameterCount(right);
            var longest = leftCount >= rightCount ? left : right;
            var shorter = longest === left ? right : left;
            var longestCount = longest === left ? leftCount : rightCount;
            var eitherHasEffectiveRest = (hasEffectiveRestParameter(left) || hasEffectiveRestParameter(right));
            var needsExtraRestElement = eitherHasEffectiveRest && !hasEffectiveRestParameter(longest);
            var params = new Array(longestCount + (needsExtraRestElement ? 1 : 0));
            for (var i = 0; i < longestCount; i++) {
                var longestParamType = tryGetTypeAtPosition(longest, i);
                if (longest === right) {
                    longestParamType = instantiateType(longestParamType, mapper);
                }
                var shorterParamType = tryGetTypeAtPosition(shorter, i) || unknownType;
                if (shorter === right) {
                    shorterParamType = instantiateType(shorterParamType, mapper);
                }
                var unionParamType = getUnionType([longestParamType, shorterParamType]);
                var isRestParam = eitherHasEffectiveRest && !needsExtraRestElement && i === (longestCount - 1);
                var isOptional = i >= getMinArgumentCount(longest) && i >= getMinArgumentCount(shorter);
                var leftName = i >= leftCount ? undefined : getParameterNameAtPosition(left, i);
                var rightName = i >= rightCount ? undefined : getParameterNameAtPosition(right, i);
                var paramName = leftName === rightName ? leftName :
                    !leftName ? rightName :
                        !rightName ? leftName :
                            undefined;
                var paramSymbol = createSymbol(1 /* SymbolFlags.FunctionScopedVariable */ | (isOptional && !isRestParam ? 16777216 /* SymbolFlags.Optional */ : 0), paramName || "arg".concat(i));
                paramSymbol.type = isRestParam ? createArrayType(unionParamType) : unionParamType;
                params[i] = paramSymbol;
            }
            if (needsExtraRestElement) {
                var restParamSymbol = createSymbol(1 /* SymbolFlags.FunctionScopedVariable */, "args");
                restParamSymbol.type = createArrayType(getTypeAtPosition(shorter, longestCount));
                if (shorter === right) {
                    restParamSymbol.type = instantiateType(restParamSymbol.type, mapper);
                }
                params[longestCount] = restParamSymbol;
            }
            return params;
        }
        function combineSignaturesOfIntersectionMembers(left, right) {
            var typeParams = left.typeParameters || right.typeParameters;
            var paramMapper;
            if (left.typeParameters && right.typeParameters) {
                paramMapper = createTypeMapper(right.typeParameters, left.typeParameters);
                // We just use the type parameter defaults from the first signature
            }
            var declaration = left.declaration;
            var params = combineIntersectionParameters(left, right, paramMapper);
            var thisParam = combineIntersectionThisParam(left.thisParameter, right.thisParameter, paramMapper);
            var minArgCount = Math.max(left.minArgumentCount, right.minArgumentCount);
            var result = createSignature(declaration, typeParams, thisParam, params, 
            /*resolvedReturnType*/ undefined, 
            /*resolvedTypePredicate*/ undefined, minArgCount, (left.flags | right.flags) & 39 /* SignatureFlags.PropagatingFlags */);
            result.compositeKind = 2097152 /* TypeFlags.Intersection */;
            result.compositeSignatures = ts.concatenate(left.compositeKind === 2097152 /* TypeFlags.Intersection */ && left.compositeSignatures || [left], [right]);
            if (paramMapper) {
                result.mapper = left.compositeKind === 2097152 /* TypeFlags.Intersection */ && left.mapper && left.compositeSignatures ? combineTypeMappers(left.mapper, paramMapper) : paramMapper;
            }
            return result;
        }
        // If the given type is an object or union type with a single signature, and if that signature has at
        // least as many parameters as the given function, return the signature. Otherwise return undefined.
        function getContextualCallSignature(type, node) {
            var signatures = getSignaturesOfType(type, 0 /* SignatureKind.Call */);
            var applicableByArity = ts.filter(signatures, function (s) { return !isAritySmaller(s, node); });
            return applicableByArity.length === 1 ? applicableByArity[0] : getIntersectedSignatures(applicableByArity);
        }
        /** If the contextual signature has fewer parameters than the function expression, do not use it */
        function isAritySmaller(signature, target) {
            var targetParameterCount = 0;
            for (; targetParameterCount < target.parameters.length; targetParameterCount++) {
                var param = target.parameters[targetParameterCount];
                if (param.initializer || param.questionToken || param.dotDotDotToken || isJSDocOptionalParameter(param)) {
                    break;
                }
            }
            if (target.parameters.length && ts.parameterIsThisKeyword(target.parameters[0])) {
                targetParameterCount--;
            }
            return !hasEffectiveRestParameter(signature) && getParameterCount(signature) < targetParameterCount;
        }
        function getContextualSignatureForFunctionLikeDeclaration(node) {
            // Only function expressions, arrow functions, and object literal methods are contextually typed.
            return ts.isFunctionExpressionOrArrowFunction(node) || ts.isObjectLiteralMethod(node)
                ? getContextualSignature(node)
                : undefined;
        }
        // Return the contextual signature for a given expression node. A contextual type provides a
        // contextual signature if it has a single call signature and if that call signature is non-generic.
        // If the contextual type is a union type, get the signature from each type possible and if they are
        // all identical ignoring their return type, the result is same signature but with return type as
        // union type of return types from these signatures
        function getContextualSignature(node) {
            ts.Debug.assert(node.kind !== 169 /* SyntaxKind.MethodDeclaration */ || ts.isObjectLiteralMethod(node));
            var typeTagSignature = getSignatureOfTypeTag(node);
            if (typeTagSignature) {
                return typeTagSignature;
            }
            var type = getApparentTypeOfContextualType(node, 1 /* ContextFlags.Signature */);
            if (!type) {
                return undefined;
            }
            if (!(type.flags & 1048576 /* TypeFlags.Union */)) {
                return getContextualCallSignature(type, node);
            }
            var signatureList;
            var types = type.types;
            for (var _i = 0, types_19 = types; _i < types_19.length; _i++) {
                var current = types_19[_i];
                var signature = getContextualCallSignature(current, node);
                if (signature) {
                    if (!signatureList) {
                        // This signature will contribute to contextual union signature
                        signatureList = [signature];
                    }
                    else if (!compareSignaturesIdentical(signatureList[0], signature, /*partialMatch*/ false, /*ignoreThisTypes*/ true, /*ignoreReturnTypes*/ true, compareTypesIdentical)) {
                        // Signatures aren't identical, do not use
                        return undefined;
                    }
                    else {
                        // Use this signature for contextual union signature
                        signatureList.push(signature);
                    }
                }
            }
            // Result is union of signatures collected (return type is union of return types of this signature set)
            if (signatureList) {
                return signatureList.length === 1 ? signatureList[0] : createUnionSignature(signatureList[0], signatureList);
            }
        }
        function checkSpreadExpression(node, checkMode) {
            if (languageVersion < 2 /* ScriptTarget.ES2015 */) {
                checkExternalEmitHelpers(node, compilerOptions.downlevelIteration ? 1536 /* ExternalEmitHelpers.SpreadIncludes */ : 1024 /* ExternalEmitHelpers.SpreadArray */);
            }
            var arrayOrIterableType = checkExpression(node.expression, checkMode);
            return checkIteratedTypeOrElementType(33 /* IterationUse.Spread */, arrayOrIterableType, undefinedType, node.expression);
        }
        function checkSyntheticExpression(node) {
            return node.isSpread ? getIndexedAccessType(node.type, numberType) : node.type;
        }
        function hasDefaultValue(node) {
            return (node.kind === 203 /* SyntaxKind.BindingElement */ && !!node.initializer) ||
                (node.kind === 221 /* SyntaxKind.BinaryExpression */ && node.operatorToken.kind === 63 /* SyntaxKind.EqualsToken */);
        }
        function checkArrayLiteral(node, checkMode, forceTuple) {
            var elements = node.elements;
            var elementCount = elements.length;
            var elementTypes = [];
            var elementFlags = [];
            var contextualType = getApparentTypeOfContextualType(node);
            var inDestructuringPattern = ts.isAssignmentTarget(node);
            var inConstContext = isConstContext(node);
            var hasOmittedExpression = false;
            for (var i = 0; i < elementCount; i++) {
                var e = elements[i];
                if (e.kind === 225 /* SyntaxKind.SpreadElement */) {
                    if (languageVersion < 2 /* ScriptTarget.ES2015 */) {
                        checkExternalEmitHelpers(e, compilerOptions.downlevelIteration ? 1536 /* ExternalEmitHelpers.SpreadIncludes */ : 1024 /* ExternalEmitHelpers.SpreadArray */);
                    }
                    var spreadType = checkExpression(e.expression, checkMode, forceTuple);
                    if (isArrayLikeType(spreadType)) {
                        elementTypes.push(spreadType);
                        elementFlags.push(8 /* ElementFlags.Variadic */);
                    }
                    else if (inDestructuringPattern) {
                        // Given the following situation:
                        //    var c: {};
                        //    [...c] = ["", 0];
                        //
                        // c is represented in the tree as a spread element in an array literal.
                        // But c really functions as a rest element, and its purpose is to provide
                        // a contextual type for the right hand side of the assignment. Therefore,
                        // instead of calling checkExpression on "...c", which will give an error
                        // if c is not iterable/array-like, we need to act as if we are trying to
                        // get the contextual element type from it. So we do something similar to
                        // getContextualTypeForElementExpression, which will crucially not error
                        // if there is no index type / iterated type.
                        var restElementType = getIndexTypeOfType(spreadType, numberType) ||
                            getIteratedTypeOrElementType(65 /* IterationUse.Destructuring */, spreadType, undefinedType, /*errorNode*/ undefined, /*checkAssignability*/ false) ||
                            unknownType;
                        elementTypes.push(restElementType);
                        elementFlags.push(4 /* ElementFlags.Rest */);
                    }
                    else {
                        elementTypes.push(checkIteratedTypeOrElementType(33 /* IterationUse.Spread */, spreadType, undefinedType, e.expression));
                        elementFlags.push(4 /* ElementFlags.Rest */);
                    }
                }
                else if (exactOptionalPropertyTypes && e.kind === 227 /* SyntaxKind.OmittedExpression */) {
                    hasOmittedExpression = true;
                    elementTypes.push(missingType);
                    elementFlags.push(2 /* ElementFlags.Optional */);
                }
                else {
                    var elementContextualType = getContextualTypeForElementExpression(contextualType, elementTypes.length);
                    var type = checkExpressionForMutableLocation(e, checkMode, elementContextualType, forceTuple);
                    elementTypes.push(addOptionality(type, /*isProperty*/ true, hasOmittedExpression));
                    elementFlags.push(hasOmittedExpression ? 2 /* ElementFlags.Optional */ : 1 /* ElementFlags.Required */);
                    if (contextualType && someType(contextualType, isTupleLikeType) && checkMode && checkMode & 2 /* CheckMode.Inferential */ && !(checkMode & 4 /* CheckMode.SkipContextSensitive */) && isContextSensitive(e)) {
                        var inferenceContext = getInferenceContext(node);
                        ts.Debug.assert(inferenceContext); // In CheckMode.Inferential we should always have an inference context
                        addIntraExpressionInferenceSite(inferenceContext, e, type);
                    }
                }
            }
            if (inDestructuringPattern) {
                return createTupleType(elementTypes, elementFlags);
            }
            if (forceTuple || inConstContext || contextualType && someType(contextualType, isTupleLikeType)) {
                return createArrayLiteralType(createTupleType(elementTypes, elementFlags, /*readonly*/ inConstContext));
            }
            return createArrayLiteralType(createArrayType(elementTypes.length ?
                getUnionType(ts.sameMap(elementTypes, function (t, i) { return elementFlags[i] & 8 /* ElementFlags.Variadic */ ? getIndexedAccessTypeOrUndefined(t, numberType) || anyType : t; }), 2 /* UnionReduction.Subtype */) :
                strictNullChecks ? implicitNeverType : undefinedWideningType, inConstContext));
        }
        function createArrayLiteralType(type) {
            if (!(ts.getObjectFlags(type) & 4 /* ObjectFlags.Reference */)) {
                return type;
            }
            var literalType = type.literalType;
            if (!literalType) {
                literalType = type.literalType = cloneTypeReference(type);
                literalType.objectFlags |= 16384 /* ObjectFlags.ArrayLiteral */ | 131072 /* ObjectFlags.ContainsObjectOrArrayLiteral */;
            }
            return literalType;
        }
        function isNumericName(name) {
            switch (name.kind) {
                case 162 /* SyntaxKind.ComputedPropertyName */:
                    return isNumericComputedName(name);
                case 79 /* SyntaxKind.Identifier */:
                    return ts.isNumericLiteralName(name.escapedText);
                case 8 /* SyntaxKind.NumericLiteral */:
                case 10 /* SyntaxKind.StringLiteral */:
                    return ts.isNumericLiteralName(name.text);
                default:
                    return false;
            }
        }
        function isNumericComputedName(name) {
            // It seems odd to consider an expression of type Any to result in a numeric name,
            // but this behavior is consistent with checkIndexedAccess
            return isTypeAssignableToKind(checkComputedPropertyName(name), 296 /* TypeFlags.NumberLike */);
        }
        function checkComputedPropertyName(node) {
            var links = getNodeLinks(node.expression);
            if (!links.resolvedType) {
                if ((ts.isTypeLiteralNode(node.parent.parent) || ts.isClassLike(node.parent.parent) || ts.isInterfaceDeclaration(node.parent.parent))
                    && ts.isBinaryExpression(node.expression) && node.expression.operatorToken.kind === 101 /* SyntaxKind.InKeyword */
                    && node.parent.kind !== 172 /* SyntaxKind.GetAccessor */ && node.parent.kind !== 173 /* SyntaxKind.SetAccessor */) {
                    return links.resolvedType = errorType;
                }
                links.resolvedType = checkExpression(node.expression);
                // The computed property name of a non-static class field within a loop must be stored in a block-scoped binding.
                // (It needs to be bound at class evaluation time.)
                if (ts.isPropertyDeclaration(node.parent) && !ts.hasStaticModifier(node.parent) && ts.isClassExpression(node.parent.parent)) {
                    var container = ts.getEnclosingBlockScopeContainer(node.parent.parent);
                    var enclosingIterationStatement = getEnclosingIterationStatement(container);
                    if (enclosingIterationStatement) {
                        // The computed field name will use a block scoped binding which can be unique for each iteration of the loop.
                        getNodeLinks(enclosingIterationStatement).flags |= 65536 /* NodeCheckFlags.LoopWithCapturedBlockScopedBinding */;
                        // The generated variable which stores the computed field name must be block-scoped.
                        getNodeLinks(node).flags |= 524288 /* NodeCheckFlags.BlockScopedBindingInLoop */;
                        // The generated variable which stores the class must be block-scoped.
                        getNodeLinks(node.parent.parent).flags |= 524288 /* NodeCheckFlags.BlockScopedBindingInLoop */;
                    }
                }
                // This will allow types number, string, symbol or any. It will also allow enums, the unknown
                // type, and any union of these types (like string | number).
                if (links.resolvedType.flags & 98304 /* TypeFlags.Nullable */ ||
                    !isTypeAssignableToKind(links.resolvedType, 402653316 /* TypeFlags.StringLike */ | 296 /* TypeFlags.NumberLike */ | 12288 /* TypeFlags.ESSymbolLike */) &&
                        !isTypeAssignableTo(links.resolvedType, stringNumberSymbolType)) {
                    error(node, ts.Diagnostics.A_computed_property_name_must_be_of_type_string_number_symbol_or_any);
                }
            }
            return links.resolvedType;
        }
        function isSymbolWithNumericName(symbol) {
            var _a;
            var firstDecl = (_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a[0];
            return ts.isNumericLiteralName(symbol.escapedName) || (firstDecl && ts.isNamedDeclaration(firstDecl) && isNumericName(firstDecl.name));
        }
        function isSymbolWithSymbolName(symbol) {
            var _a;
            var firstDecl = (_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a[0];
            return ts.isKnownSymbol(symbol) || (firstDecl && ts.isNamedDeclaration(firstDecl) && ts.isComputedPropertyName(firstDecl.name) &&
                isTypeAssignableToKind(checkComputedPropertyName(firstDecl.name), 4096 /* TypeFlags.ESSymbol */));
        }
        function getObjectLiteralIndexInfo(node, offset, properties, keyType) {
            var propTypes = [];
            for (var i = offset; i < properties.length; i++) {
                var prop = properties[i];
                if (keyType === stringType && !isSymbolWithSymbolName(prop) ||
                    keyType === numberType && isSymbolWithNumericName(prop) ||
                    keyType === esSymbolType && isSymbolWithSymbolName(prop)) {
                    propTypes.push(getTypeOfSymbol(properties[i]));
                }
            }
            var unionType = propTypes.length ? getUnionType(propTypes, 2 /* UnionReduction.Subtype */) : undefinedType;
            return createIndexInfo(keyType, unionType, isConstContext(node));
        }
        function getImmediateAliasedSymbol(symbol) {
            ts.Debug.assert((symbol.flags & 2097152 /* SymbolFlags.Alias */) !== 0, "Should only get Alias here.");
            var links = getSymbolLinks(symbol);
            if (!links.immediateTarget) {
                var node = getDeclarationOfAliasSymbol(symbol);
                if (!node)
                    return ts.Debug.fail();
                links.immediateTarget = getTargetOfAliasDeclaration(node, /*dontRecursivelyResolve*/ true);
            }
            return links.immediateTarget;
        }
        function checkObjectLiteral(node, checkMode) {
            var inDestructuringPattern = ts.isAssignmentTarget(node);
            // Grammar checking
            checkGrammarObjectLiteralExpression(node, inDestructuringPattern);
            var allPropertiesTable = strictNullChecks ? ts.createSymbolTable() : undefined;
            var propertiesTable = ts.createSymbolTable();
            var propertiesArray = [];
            var spread = emptyObjectType;
            var contextualType = getApparentTypeOfContextualType(node);
            var contextualTypeHasPattern = contextualType && contextualType.pattern &&
                (contextualType.pattern.kind === 201 /* SyntaxKind.ObjectBindingPattern */ || contextualType.pattern.kind === 205 /* SyntaxKind.ObjectLiteralExpression */);
            var inConstContext = isConstContext(node);
            var checkFlags = inConstContext ? 8 /* CheckFlags.Readonly */ : 0;
            var isInJavascript = ts.isInJSFile(node) && !ts.isInJsonFile(node);
            var enumTag = ts.getJSDocEnumTag(node);
            var isJSObjectLiteral = !contextualType && isInJavascript && !enumTag;
            var objectFlags = freshObjectLiteralFlag;
            var patternWithComputedProperties = false;
            var hasComputedStringProperty = false;
            var hasComputedNumberProperty = false;
            var hasComputedSymbolProperty = false;
            // Spreads may cause an early bail; ensure computed names are always checked (this is cached)
            // As otherwise they may not be checked until exports for the type at this position are retrieved,
            // which may never occur.
            for (var _i = 0, _a = node.properties; _i < _a.length; _i++) {
                var elem = _a[_i];
                if (elem.name && ts.isComputedPropertyName(elem.name)) {
                    checkComputedPropertyName(elem.name);
                }
            }
            var offset = 0;
            for (var _b = 0, _c = node.properties; _b < _c.length; _b++) {
                var memberDecl = _c[_b];
                var member = getSymbolOfNode(memberDecl);
                var computedNameType = memberDecl.name && memberDecl.name.kind === 162 /* SyntaxKind.ComputedPropertyName */ ?
                    checkComputedPropertyName(memberDecl.name) : undefined;
                if (memberDecl.kind === 296 /* SyntaxKind.PropertyAssignment */ ||
                    memberDecl.kind === 297 /* SyntaxKind.ShorthandPropertyAssignment */ ||
                    ts.isObjectLiteralMethod(memberDecl)) {
                    var type = memberDecl.kind === 296 /* SyntaxKind.PropertyAssignment */ ? checkPropertyAssignment(memberDecl, checkMode) :
                        // avoid resolving the left side of the ShorthandPropertyAssignment outside of the destructuring
                        // for error recovery purposes. For example, if a user wrote `{ a = 100 }` instead of `{ a: 100 }`.
                        // we don't want to say "could not find 'a'".
                        memberDecl.kind === 297 /* SyntaxKind.ShorthandPropertyAssignment */ ? checkExpressionForMutableLocation(!inDestructuringPattern && memberDecl.objectAssignmentInitializer ? memberDecl.objectAssignmentInitializer : memberDecl.name, checkMode) :
                            checkObjectLiteralMethod(memberDecl, checkMode);
                    if (isInJavascript) {
                        var jsDocType = getTypeForDeclarationFromJSDocComment(memberDecl);
                        if (jsDocType) {
                            checkTypeAssignableTo(type, jsDocType, memberDecl);
                            type = jsDocType;
                        }
                        else if (enumTag && enumTag.typeExpression) {
                            checkTypeAssignableTo(type, getTypeFromTypeNode(enumTag.typeExpression), memberDecl);
                        }
                    }
                    objectFlags |= ts.getObjectFlags(type) & 458752 /* ObjectFlags.PropagatingFlags */;
                    var nameType = computedNameType && isTypeUsableAsPropertyName(computedNameType) ? computedNameType : undefined;
                    var prop = nameType ?
                        createSymbol(4 /* SymbolFlags.Property */ | member.flags, getPropertyNameFromType(nameType), checkFlags | 4096 /* CheckFlags.Late */) :
                        createSymbol(4 /* SymbolFlags.Property */ | member.flags, member.escapedName, checkFlags);
                    if (nameType) {
                        prop.nameType = nameType;
                    }
                    if (inDestructuringPattern) {
                        // If object literal is an assignment pattern and if the assignment pattern specifies a default value
                        // for the property, make the property optional.
                        var isOptional = (memberDecl.kind === 296 /* SyntaxKind.PropertyAssignment */ && hasDefaultValue(memberDecl.initializer)) ||
                            (memberDecl.kind === 297 /* SyntaxKind.ShorthandPropertyAssignment */ && memberDecl.objectAssignmentInitializer);
                        if (isOptional) {
                            prop.flags |= 16777216 /* SymbolFlags.Optional */;
                        }
                    }
                    else if (contextualTypeHasPattern && !(ts.getObjectFlags(contextualType) & 512 /* ObjectFlags.ObjectLiteralPatternWithComputedProperties */)) {
                        // If object literal is contextually typed by the implied type of a binding pattern, and if the
                        // binding pattern specifies a default value for the property, make the property optional.
                        var impliedProp = getPropertyOfType(contextualType, member.escapedName);
                        if (impliedProp) {
                            prop.flags |= impliedProp.flags & 16777216 /* SymbolFlags.Optional */;
                        }
                        else if (!compilerOptions.suppressExcessPropertyErrors && !getIndexInfoOfType(contextualType, stringType)) {
                            error(memberDecl.name, ts.Diagnostics.Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1, symbolToString(member), typeToString(contextualType));
                        }
                    }
                    prop.declarations = member.declarations;
                    prop.parent = member.parent;
                    if (member.valueDeclaration) {
                        prop.valueDeclaration = member.valueDeclaration;
                    }
                    prop.type = type;
                    prop.target = member;
                    member = prop;
                    allPropertiesTable === null || allPropertiesTable === void 0 ? void 0 : allPropertiesTable.set(prop.escapedName, prop);
                    if (contextualType && checkMode && checkMode & 2 /* CheckMode.Inferential */ && !(checkMode & 4 /* CheckMode.SkipContextSensitive */) &&
                        (memberDecl.kind === 296 /* SyntaxKind.PropertyAssignment */ || memberDecl.kind === 169 /* SyntaxKind.MethodDeclaration */) && isContextSensitive(memberDecl)) {
                        var inferenceContext = getInferenceContext(node);
                        ts.Debug.assert(inferenceContext); // In CheckMode.Inferential we should always have an inference context
                        var inferenceNode = memberDecl.kind === 296 /* SyntaxKind.PropertyAssignment */ ? memberDecl.initializer : memberDecl;
                        addIntraExpressionInferenceSite(inferenceContext, inferenceNode, type);
                    }
                }
                else if (memberDecl.kind === 298 /* SyntaxKind.SpreadAssignment */) {
                    if (languageVersion < 2 /* ScriptTarget.ES2015 */) {
                        checkExternalEmitHelpers(memberDecl, 2 /* ExternalEmitHelpers.Assign */);
                    }
                    if (propertiesArray.length > 0) {
                        spread = getSpreadType(spread, createObjectLiteralType(), node.symbol, objectFlags, inConstContext);
                        propertiesArray = [];
                        propertiesTable = ts.createSymbolTable();
                        hasComputedStringProperty = false;
                        hasComputedNumberProperty = false;
                        hasComputedSymbolProperty = false;
                    }
                    var type = getReducedType(checkExpression(memberDecl.expression));
                    if (isValidSpreadType(type)) {
                        var mergedType = tryMergeUnionOfObjectTypeAndEmptyObject(type, inConstContext);
                        if (allPropertiesTable) {
                            checkSpreadPropOverrides(mergedType, allPropertiesTable, memberDecl);
                        }
                        offset = propertiesArray.length;
                        if (isErrorType(spread)) {
                            continue;
                        }
                        spread = getSpreadType(spread, mergedType, node.symbol, objectFlags, inConstContext);
                    }
                    else {
                        error(memberDecl, ts.Diagnostics.Spread_types_may_only_be_created_from_object_types);
                        spread = errorType;
                    }
                    continue;
                }
                else {
                    // TypeScript 1.0 spec (April 2014)
                    // A get accessor declaration is processed in the same manner as
                    // an ordinary function declaration(section 6.1) with no parameters.
                    // A set accessor declaration is processed in the same manner
                    // as an ordinary function declaration with a single parameter and a Void return type.
                    ts.Debug.assert(memberDecl.kind === 172 /* SyntaxKind.GetAccessor */ || memberDecl.kind === 173 /* SyntaxKind.SetAccessor */);
                    checkNodeDeferred(memberDecl);
                }
                if (computedNameType && !(computedNameType.flags & 8576 /* TypeFlags.StringOrNumberLiteralOrUnique */)) {
                    if (isTypeAssignableTo(computedNameType, stringNumberSymbolType)) {
                        if (isTypeAssignableTo(computedNameType, numberType)) {
                            hasComputedNumberProperty = true;
                        }
                        else if (isTypeAssignableTo(computedNameType, esSymbolType)) {
                            hasComputedSymbolProperty = true;
                        }
                        else {
                            hasComputedStringProperty = true;
                        }
                        if (inDestructuringPattern) {
                            patternWithComputedProperties = true;
                        }
                    }
                }
                else {
                    propertiesTable.set(member.escapedName, member);
                }
                propertiesArray.push(member);
            }
            // If object literal is contextually typed by the implied type of a binding pattern, augment the result
            // type with those properties for which the binding pattern specifies a default value.
            // If the object literal is spread into another object literal, skip this step and let the top-level object
            // literal handle it instead.
            if (contextualTypeHasPattern && node.parent.kind !== 298 /* SyntaxKind.SpreadAssignment */) {
                for (var _d = 0, _e = getPropertiesOfType(contextualType); _d < _e.length; _d++) {
                    var prop = _e[_d];
                    if (!propertiesTable.get(prop.escapedName) && !getPropertyOfType(spread, prop.escapedName)) {
                        if (!(prop.flags & 16777216 /* SymbolFlags.Optional */)) {
                            error(prop.valueDeclaration || prop.bindingElement, ts.Diagnostics.Initializer_provides_no_value_for_this_binding_element_and_the_binding_element_has_no_default_value);
                        }
                        propertiesTable.set(prop.escapedName, prop);
                        propertiesArray.push(prop);
                    }
                }
            }
            if (isErrorType(spread)) {
                return errorType;
            }
            if (spread !== emptyObjectType) {
                if (propertiesArray.length > 0) {
                    spread = getSpreadType(spread, createObjectLiteralType(), node.symbol, objectFlags, inConstContext);
                    propertiesArray = [];
                    propertiesTable = ts.createSymbolTable();
                    hasComputedStringProperty = false;
                    hasComputedNumberProperty = false;
                }
                // remap the raw emptyObjectType fed in at the top into a fresh empty object literal type, unique to this use site
                return mapType(spread, function (t) { return t === emptyObjectType ? createObjectLiteralType() : t; });
            }
            return createObjectLiteralType();
            function createObjectLiteralType() {
                var indexInfos = [];
                if (hasComputedStringProperty)
                    indexInfos.push(getObjectLiteralIndexInfo(node, offset, propertiesArray, stringType));
                if (hasComputedNumberProperty)
                    indexInfos.push(getObjectLiteralIndexInfo(node, offset, propertiesArray, numberType));
                if (hasComputedSymbolProperty)
                    indexInfos.push(getObjectLiteralIndexInfo(node, offset, propertiesArray, esSymbolType));
                var result = createAnonymousType(node.symbol, propertiesTable, ts.emptyArray, ts.emptyArray, indexInfos);
                result.objectFlags |= objectFlags | 128 /* ObjectFlags.ObjectLiteral */ | 131072 /* ObjectFlags.ContainsObjectOrArrayLiteral */;
                if (isJSObjectLiteral) {
                    result.objectFlags |= 4096 /* ObjectFlags.JSLiteral */;
                }
                if (patternWithComputedProperties) {
                    result.objectFlags |= 512 /* ObjectFlags.ObjectLiteralPatternWithComputedProperties */;
                }
                if (inDestructuringPattern) {
                    result.pattern = node;
                }
                return result;
            }
        }
        function isValidSpreadType(type) {
            var t = removeDefinitelyFalsyTypes(mapType(type, getBaseConstraintOrType));
            return !!(t.flags & (1 /* TypeFlags.Any */ | 67108864 /* TypeFlags.NonPrimitive */ | 524288 /* TypeFlags.Object */ | 58982400 /* TypeFlags.InstantiableNonPrimitive */) ||
                t.flags & 3145728 /* TypeFlags.UnionOrIntersection */ && ts.every(t.types, isValidSpreadType));
        }
        function checkJsxSelfClosingElementDeferred(node) {
            checkJsxOpeningLikeElementOrOpeningFragment(node);
        }
        function checkJsxSelfClosingElement(node, _checkMode) {
            checkNodeDeferred(node);
            return getJsxElementTypeAt(node) || anyType;
        }
        function checkJsxElementDeferred(node) {
            // Check attributes
            checkJsxOpeningLikeElementOrOpeningFragment(node.openingElement);
            // Perform resolution on the closing tag so that rename/go to definition/etc work
            if (isJsxIntrinsicIdentifier(node.closingElement.tagName)) {
                getIntrinsicTagSymbol(node.closingElement);
            }
            else {
                checkExpression(node.closingElement.tagName);
            }
            checkJsxChildren(node);
        }
        function checkJsxElement(node, _checkMode) {
            checkNodeDeferred(node);
            return getJsxElementTypeAt(node) || anyType;
        }
        function checkJsxFragment(node) {
            checkJsxOpeningLikeElementOrOpeningFragment(node.openingFragment);
            // by default, jsx:'react' will use jsxFactory = React.createElement and jsxFragmentFactory = React.Fragment
            // if jsxFactory compiler option is provided, ensure jsxFragmentFactory compiler option or @jsxFrag pragma is provided too
            var nodeSourceFile = ts.getSourceFileOfNode(node);
            if (ts.getJSXTransformEnabled(compilerOptions) && (compilerOptions.jsxFactory || nodeSourceFile.pragmas.has("jsx"))
                && !compilerOptions.jsxFragmentFactory && !nodeSourceFile.pragmas.has("jsxfrag")) {
                error(node, compilerOptions.jsxFactory
                    ? ts.Diagnostics.The_jsxFragmentFactory_compiler_option_must_be_provided_to_use_JSX_fragments_with_the_jsxFactory_compiler_option
                    : ts.Diagnostics.An_jsxFrag_pragma_is_required_when_using_an_jsx_pragma_with_JSX_fragments);
            }
            checkJsxChildren(node);
            return getJsxElementTypeAt(node) || anyType;
        }
        function isHyphenatedJsxName(name) {
            return ts.stringContains(name, "-");
        }
        /**
         * Returns true iff React would emit this tag name as a string rather than an identifier or qualified name
         */
        function isJsxIntrinsicIdentifier(tagName) {
            return tagName.kind === 79 /* SyntaxKind.Identifier */ && ts.isIntrinsicJsxName(tagName.escapedText);
        }
        function checkJsxAttribute(node, checkMode) {
            return node.initializer
                ? checkExpressionForMutableLocation(node.initializer, checkMode)
                : trueType; // <Elem attr /> is sugar for <Elem attr={true} />
        }
        /**
         * Get attributes type of the JSX opening-like element. The result is from resolving "attributes" property of the opening-like element.
         *
         * @param openingLikeElement a JSX opening-like element
         * @param filter a function to remove attributes that will not participate in checking whether attributes are assignable
         * @return an anonymous type (similar to the one returned by checkObjectLiteral) in which its properties are attributes property.
         * @remarks Because this function calls getSpreadType, it needs to use the same checks as checkObjectLiteral,
         * which also calls getSpreadType.
         */
        function createJsxAttributesTypeFromAttributesProperty(openingLikeElement, checkMode) {
            var attributes = openingLikeElement.attributes;
            var allAttributesTable = strictNullChecks ? ts.createSymbolTable() : undefined;
            var attributesTable = ts.createSymbolTable();
            var spread = emptyJsxObjectType;
            var hasSpreadAnyType = false;
            var typeToIntersect;
            var explicitlySpecifyChildrenAttribute = false;
            var objectFlags = 2048 /* ObjectFlags.JsxAttributes */;
            var jsxChildrenPropertyName = getJsxElementChildrenPropertyName(getJsxNamespaceAt(openingLikeElement));
            for (var _i = 0, _a = attributes.properties; _i < _a.length; _i++) {
                var attributeDecl = _a[_i];
                var member = attributeDecl.symbol;
                if (ts.isJsxAttribute(attributeDecl)) {
                    var exprType = checkJsxAttribute(attributeDecl, checkMode);
                    objectFlags |= ts.getObjectFlags(exprType) & 458752 /* ObjectFlags.PropagatingFlags */;
                    var attributeSymbol = createSymbol(4 /* SymbolFlags.Property */ | member.flags, member.escapedName);
                    attributeSymbol.declarations = member.declarations;
                    attributeSymbol.parent = member.parent;
                    if (member.valueDeclaration) {
                        attributeSymbol.valueDeclaration = member.valueDeclaration;
                    }
                    attributeSymbol.type = exprType;
                    attributeSymbol.target = member;
                    attributesTable.set(attributeSymbol.escapedName, attributeSymbol);
                    allAttributesTable === null || allAttributesTable === void 0 ? void 0 : allAttributesTable.set(attributeSymbol.escapedName, attributeSymbol);
                    if (attributeDecl.name.escapedText === jsxChildrenPropertyName) {
                        explicitlySpecifyChildrenAttribute = true;
                    }
                }
                else {
                    ts.Debug.assert(attributeDecl.kind === 287 /* SyntaxKind.JsxSpreadAttribute */);
                    if (attributesTable.size > 0) {
                        spread = getSpreadType(spread, createJsxAttributesType(), attributes.symbol, objectFlags, /*readonly*/ false);
                        attributesTable = ts.createSymbolTable();
                    }
                    var exprType = getReducedType(checkExpressionCached(attributeDecl.expression, checkMode));
                    if (isTypeAny(exprType)) {
                        hasSpreadAnyType = true;
                    }
                    if (isValidSpreadType(exprType)) {
                        spread = getSpreadType(spread, exprType, attributes.symbol, objectFlags, /*readonly*/ false);
                        if (allAttributesTable) {
                            checkSpreadPropOverrides(exprType, allAttributesTable, attributeDecl);
                        }
                    }
                    else {
                        error(attributeDecl.expression, ts.Diagnostics.Spread_types_may_only_be_created_from_object_types);
                        typeToIntersect = typeToIntersect ? getIntersectionType([typeToIntersect, exprType]) : exprType;
                    }
                }
            }
            if (!hasSpreadAnyType) {
                if (attributesTable.size > 0) {
                    spread = getSpreadType(spread, createJsxAttributesType(), attributes.symbol, objectFlags, /*readonly*/ false);
                }
            }
            // Handle children attribute
            var parent = openingLikeElement.parent.kind === 278 /* SyntaxKind.JsxElement */ ? openingLikeElement.parent : undefined;
            // We have to check that openingElement of the parent is the one we are visiting as this may not be true for selfClosingElement
            if (parent && parent.openingElement === openingLikeElement && parent.children.length > 0) {
                var childrenTypes = checkJsxChildren(parent, checkMode);
                if (!hasSpreadAnyType && jsxChildrenPropertyName && jsxChildrenPropertyName !== "") {
                    // Error if there is a attribute named "children" explicitly specified and children element.
                    // This is because children element will overwrite the value from attributes.
                    // Note: we will not warn "children" attribute overwritten if "children" attribute is specified in object spread.
                    if (explicitlySpecifyChildrenAttribute) {
                        error(attributes, ts.Diagnostics._0_are_specified_twice_The_attribute_named_0_will_be_overwritten, ts.unescapeLeadingUnderscores(jsxChildrenPropertyName));
                    }
                    var contextualType = getApparentTypeOfContextualType(openingLikeElement.attributes);
                    var childrenContextualType = contextualType && getTypeOfPropertyOfContextualType(contextualType, jsxChildrenPropertyName);
                    // If there are children in the body of JSX element, create dummy attribute "children" with the union of children types so that it will pass the attribute checking process
                    var childrenPropSymbol = createSymbol(4 /* SymbolFlags.Property */, jsxChildrenPropertyName);
                    childrenPropSymbol.type = childrenTypes.length === 1 ? childrenTypes[0] :
                        childrenContextualType && someType(childrenContextualType, isTupleLikeType) ? createTupleType(childrenTypes) :
                            createArrayType(getUnionType(childrenTypes));
                    // Fake up a property declaration for the children
                    childrenPropSymbol.valueDeclaration = ts.factory.createPropertySignature(/*modifiers*/ undefined, ts.unescapeLeadingUnderscores(jsxChildrenPropertyName), /*questionToken*/ undefined, /*type*/ undefined);
                    ts.setParent(childrenPropSymbol.valueDeclaration, attributes);
                    childrenPropSymbol.valueDeclaration.symbol = childrenPropSymbol;
                    var childPropMap = ts.createSymbolTable();
                    childPropMap.set(jsxChildrenPropertyName, childrenPropSymbol);
                    spread = getSpreadType(spread, createAnonymousType(attributes.symbol, childPropMap, ts.emptyArray, ts.emptyArray, ts.emptyArray), attributes.symbol, objectFlags, /*readonly*/ false);
                }
            }
            if (hasSpreadAnyType) {
                return anyType;
            }
            if (typeToIntersect && spread !== emptyJsxObjectType) {
                return getIntersectionType([typeToIntersect, spread]);
            }
            return typeToIntersect || (spread === emptyJsxObjectType ? createJsxAttributesType() : spread);
            /**
             * Create anonymous type from given attributes symbol table.
             * @param symbol a symbol of JsxAttributes containing attributes corresponding to attributesTable
             * @param attributesTable a symbol table of attributes property
             */
            function createJsxAttributesType() {
                objectFlags |= freshObjectLiteralFlag;
                var result = createAnonymousType(attributes.symbol, attributesTable, ts.emptyArray, ts.emptyArray, ts.emptyArray);
                result.objectFlags |= objectFlags | 128 /* ObjectFlags.ObjectLiteral */ | 131072 /* ObjectFlags.ContainsObjectOrArrayLiteral */;
                return result;
            }
        }
        function checkJsxChildren(node, checkMode) {
            var childrenTypes = [];
            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
                var child = _a[_i];
                // In React, JSX text that contains only whitespaces will be ignored so we don't want to type-check that
                // because then type of children property will have constituent of string type.
                if (child.kind === 11 /* SyntaxKind.JsxText */) {
                    if (!child.containsOnlyTriviaWhiteSpaces) {
                        childrenTypes.push(stringType);
                    }
                }
                else if (child.kind === 288 /* SyntaxKind.JsxExpression */ && !child.expression) {
                    continue; // empty jsx expressions don't *really* count as present children
                }
                else {
                    childrenTypes.push(checkExpressionForMutableLocation(child, checkMode));
                }
            }
            return childrenTypes;
        }
        function checkSpreadPropOverrides(type, props, spread) {
            for (var _i = 0, _a = getPropertiesOfType(type); _i < _a.length; _i++) {
                var right = _a[_i];
                if (!(right.flags & 16777216 /* SymbolFlags.Optional */)) {
                    var left = props.get(right.escapedName);
                    if (left) {
                        var diagnostic = error(left.valueDeclaration, ts.Diagnostics._0_is_specified_more_than_once_so_this_usage_will_be_overwritten, ts.unescapeLeadingUnderscores(left.escapedName));
                        ts.addRelatedInfo(diagnostic, ts.createDiagnosticForNode(spread, ts.Diagnostics.This_spread_always_overwrites_this_property));
                    }
                }
            }
        }
        /**
         * Check attributes property of opening-like element. This function is called during chooseOverload to get call signature of a JSX opening-like element.
         * (See "checkApplicableSignatureForJsxOpeningLikeElement" for how the function is used)
         * @param node a JSXAttributes to be resolved of its type
         */
        function checkJsxAttributes(node, checkMode) {
            return createJsxAttributesTypeFromAttributesProperty(node.parent, checkMode);
        }
        function getJsxType(name, location) {
            var namespace = getJsxNamespaceAt(location);
            var exports = namespace && getExportsOfSymbol(namespace);
            var typeSymbol = exports && getSymbol(exports, name, 788968 /* SymbolFlags.Type */);
            return typeSymbol ? getDeclaredTypeOfSymbol(typeSymbol) : errorType;
        }
        /**
         * Looks up an intrinsic tag name and returns a symbol that either points to an intrinsic
         * property (in which case nodeLinks.jsxFlags will be IntrinsicNamedElement) or an intrinsic
         * string index signature (in which case nodeLinks.jsxFlags will be IntrinsicIndexedElement).
         * May also return unknownSymbol if both of these lookups fail.
         */
        function getIntrinsicTagSymbol(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedSymbol) {
                var intrinsicElementsType = getJsxType(JsxNames.IntrinsicElements, node);
                if (!isErrorType(intrinsicElementsType)) {
                    // Property case
                    if (!ts.isIdentifier(node.tagName))
                        return ts.Debug.fail();
                    var intrinsicProp = getPropertyOfType(intrinsicElementsType, node.tagName.escapedText);
                    if (intrinsicProp) {
                        links.jsxFlags |= 1 /* JsxFlags.IntrinsicNamedElement */;
                        return links.resolvedSymbol = intrinsicProp;
                    }
                    // Intrinsic string indexer case
                    var indexSignatureType = getIndexTypeOfType(intrinsicElementsType, stringType);
                    if (indexSignatureType) {
                        links.jsxFlags |= 2 /* JsxFlags.IntrinsicIndexedElement */;
                        return links.resolvedSymbol = intrinsicElementsType.symbol;
                    }
                    // Wasn't found
                    error(node, ts.Diagnostics.Property_0_does_not_exist_on_type_1, ts.idText(node.tagName), "JSX." + JsxNames.IntrinsicElements);
                    return links.resolvedSymbol = unknownSymbol;
                }
                else {
                    if (noImplicitAny) {
                        error(node, ts.Diagnostics.JSX_element_implicitly_has_type_any_because_no_interface_JSX_0_exists, ts.unescapeLeadingUnderscores(JsxNames.IntrinsicElements));
                    }
                    return links.resolvedSymbol = unknownSymbol;
                }
            }
            return links.resolvedSymbol;
        }
        function getJsxNamespaceContainerForImplicitImport(location) {
            var file = location && ts.getSourceFileOfNode(location);
            var links = file && getNodeLinks(file);
            if (links && links.jsxImplicitImportContainer === false) {
                return undefined;
            }
            if (links && links.jsxImplicitImportContainer) {
                return links.jsxImplicitImportContainer;
            }
            var runtimeImportSpecifier = ts.getJSXRuntimeImport(ts.getJSXImplicitImportBase(compilerOptions, file), compilerOptions);
            if (!runtimeImportSpecifier) {
                return undefined;
            }
            var isClassic = ts.getEmitModuleResolutionKind(compilerOptions) === ts.ModuleResolutionKind.Classic;
            var errorMessage = isClassic
                ? ts.Diagnostics.Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_node_or_to_add_aliases_to_the_paths_option
                : ts.Diagnostics.Cannot_find_module_0_or_its_corresponding_type_declarations;
            var mod = resolveExternalModule(location, runtimeImportSpecifier, errorMessage, location);
            var result = mod && mod !== unknownSymbol ? getMergedSymbol(resolveSymbol(mod)) : undefined;
            if (links) {
                links.jsxImplicitImportContainer = result || false;
            }
            return result;
        }
        function getJsxNamespaceAt(location) {
            var links = location && getNodeLinks(location);
            if (links && links.jsxNamespace) {
                return links.jsxNamespace;
            }
            if (!links || links.jsxNamespace !== false) {
                var resolvedNamespace = getJsxNamespaceContainerForImplicitImport(location);
                if (!resolvedNamespace || resolvedNamespace === unknownSymbol) {
                    var namespaceName = getJsxNamespace(location);
                    resolvedNamespace = resolveName(location, namespaceName, 1920 /* SymbolFlags.Namespace */, /*diagnosticMessage*/ undefined, namespaceName, /*isUse*/ false);
                }
                if (resolvedNamespace) {
                    var candidate = resolveSymbol(getSymbol(getExportsOfSymbol(resolveSymbol(resolvedNamespace)), JsxNames.JSX, 1920 /* SymbolFlags.Namespace */));
                    if (candidate && candidate !== unknownSymbol) {
                        if (links) {
                            links.jsxNamespace = candidate;
                        }
                        return candidate;
                    }
                }
                if (links) {
                    links.jsxNamespace = false;
                }
            }
            // JSX global fallback
            var s = resolveSymbol(getGlobalSymbol(JsxNames.JSX, 1920 /* SymbolFlags.Namespace */, /*diagnosticMessage*/ undefined));
            if (s === unknownSymbol) {
                return undefined; // TODO: GH#18217
            }
            return s; // TODO: GH#18217
        }
        /**
         * Look into JSX namespace and then look for container with matching name as nameOfAttribPropContainer.
         * Get a single property from that container if existed. Report an error if there are more than one property.
         *
         * @param nameOfAttribPropContainer a string of value JsxNames.ElementAttributesPropertyNameContainer or JsxNames.ElementChildrenAttributeNameContainer
         *          if other string is given or the container doesn't exist, return undefined.
         */
        function getNameFromJsxElementAttributesContainer(nameOfAttribPropContainer, jsxNamespace) {
            // JSX.ElementAttributesProperty | JSX.ElementChildrenAttribute [symbol]
            var jsxElementAttribPropInterfaceSym = jsxNamespace && getSymbol(jsxNamespace.exports, nameOfAttribPropContainer, 788968 /* SymbolFlags.Type */);
            // JSX.ElementAttributesProperty | JSX.ElementChildrenAttribute [type]
            var jsxElementAttribPropInterfaceType = jsxElementAttribPropInterfaceSym && getDeclaredTypeOfSymbol(jsxElementAttribPropInterfaceSym);
            // The properties of JSX.ElementAttributesProperty | JSX.ElementChildrenAttribute
            var propertiesOfJsxElementAttribPropInterface = jsxElementAttribPropInterfaceType && getPropertiesOfType(jsxElementAttribPropInterfaceType);
            if (propertiesOfJsxElementAttribPropInterface) {
                // Element Attributes has zero properties, so the element attributes type will be the class instance type
                if (propertiesOfJsxElementAttribPropInterface.length === 0) {
                    return "";
                }
                // Element Attributes has one property, so the element attributes type will be the type of the corresponding
                // property of the class instance type
                else if (propertiesOfJsxElementAttribPropInterface.length === 1) {
                    return propertiesOfJsxElementAttribPropInterface[0].escapedName;
                }
                else if (propertiesOfJsxElementAttribPropInterface.length > 1 && jsxElementAttribPropInterfaceSym.declarations) {
                    // More than one property on ElementAttributesProperty is an error
                    error(jsxElementAttribPropInterfaceSym.declarations[0], ts.Diagnostics.The_global_type_JSX_0_may_not_have_more_than_one_property, ts.unescapeLeadingUnderscores(nameOfAttribPropContainer));
                }
            }
            return undefined;
        }
        function getJsxLibraryManagedAttributes(jsxNamespace) {
            // JSX.LibraryManagedAttributes [symbol]
            return jsxNamespace && getSymbol(jsxNamespace.exports, JsxNames.LibraryManagedAttributes, 788968 /* SymbolFlags.Type */);
        }
        /// e.g. "props" for React.d.ts,
        /// or 'undefined' if ElementAttributesProperty doesn't exist (which means all
        ///     non-intrinsic elements' attributes type is 'any'),
        /// or '' if it has 0 properties (which means every
        ///     non-intrinsic elements' attributes type is the element instance type)
        function getJsxElementPropertiesName(jsxNamespace) {
            return getNameFromJsxElementAttributesContainer(JsxNames.ElementAttributesPropertyNameContainer, jsxNamespace);
        }
        function getJsxElementChildrenPropertyName(jsxNamespace) {
            return getNameFromJsxElementAttributesContainer(JsxNames.ElementChildrenAttributeNameContainer, jsxNamespace);
        }
        function getUninstantiatedJsxSignaturesOfType(elementType, caller) {
            if (elementType.flags & 4 /* TypeFlags.String */) {
                return [anySignature];
            }
            else if (elementType.flags & 128 /* TypeFlags.StringLiteral */) {
                var intrinsicType = getIntrinsicAttributesTypeFromStringLiteralType(elementType, caller);
                if (!intrinsicType) {
                    error(caller, ts.Diagnostics.Property_0_does_not_exist_on_type_1, elementType.value, "JSX." + JsxNames.IntrinsicElements);
                    return ts.emptyArray;
                }
                else {
                    var fakeSignature = createSignatureForJSXIntrinsic(caller, intrinsicType);
                    return [fakeSignature];
                }
            }
            var apparentElemType = getApparentType(elementType);
            // Resolve the signatures, preferring constructor
            var signatures = getSignaturesOfType(apparentElemType, 1 /* SignatureKind.Construct */);
            if (signatures.length === 0) {
                // No construct signatures, try call signatures
                signatures = getSignaturesOfType(apparentElemType, 0 /* SignatureKind.Call */);
            }
            if (signatures.length === 0 && apparentElemType.flags & 1048576 /* TypeFlags.Union */) {
                // If each member has some combination of new/call signatures; make a union signature list for those
                signatures = getUnionSignatures(ts.map(apparentElemType.types, function (t) { return getUninstantiatedJsxSignaturesOfType(t, caller); }));
            }
            return signatures;
        }
        function getIntrinsicAttributesTypeFromStringLiteralType(type, location) {
            // If the elemType is a stringLiteral type, we can then provide a check to make sure that the string literal type is one of the Jsx intrinsic element type
            // For example:
            //      var CustomTag: "h1" = "h1";
            //      <CustomTag> Hello World </CustomTag>
            var intrinsicElementsType = getJsxType(JsxNames.IntrinsicElements, location);
            if (!isErrorType(intrinsicElementsType)) {
                var stringLiteralTypeName = type.value;
                var intrinsicProp = getPropertyOfType(intrinsicElementsType, ts.escapeLeadingUnderscores(stringLiteralTypeName));
                if (intrinsicProp) {
                    return getTypeOfSymbol(intrinsicProp);
                }
                var indexSignatureType = getIndexTypeOfType(intrinsicElementsType, stringType);
                if (indexSignatureType) {
                    return indexSignatureType;
                }
                return undefined;
            }
            // If we need to report an error, we already done so here. So just return any to prevent any more error downstream
            return anyType;
        }
        function checkJsxReturnAssignableToAppropriateBound(refKind, elemInstanceType, openingLikeElement) {
            if (refKind === 1 /* JsxReferenceKind.Function */) {
                var sfcReturnConstraint = getJsxStatelessElementTypeAt(openingLikeElement);
                if (sfcReturnConstraint) {
                    checkTypeRelatedTo(elemInstanceType, sfcReturnConstraint, assignableRelation, openingLikeElement.tagName, ts.Diagnostics.Its_return_type_0_is_not_a_valid_JSX_element, generateInitialErrorChain);
                }
            }
            else if (refKind === 0 /* JsxReferenceKind.Component */) {
                var classConstraint = getJsxElementClassTypeAt(openingLikeElement);
                if (classConstraint) {
                    // Issue an error if this return type isn't assignable to JSX.ElementClass, failing that
                    checkTypeRelatedTo(elemInstanceType, classConstraint, assignableRelation, openingLikeElement.tagName, ts.Diagnostics.Its_instance_type_0_is_not_a_valid_JSX_element, generateInitialErrorChain);
                }
            }
            else { // Mixed
                var sfcReturnConstraint = getJsxStatelessElementTypeAt(openingLikeElement);
                var classConstraint = getJsxElementClassTypeAt(openingLikeElement);
                if (!sfcReturnConstraint || !classConstraint) {
                    return;
                }
                var combined = getUnionType([sfcReturnConstraint, classConstraint]);
                checkTypeRelatedTo(elemInstanceType, combined, assignableRelation, openingLikeElement.tagName, ts.Diagnostics.Its_element_type_0_is_not_a_valid_JSX_element, generateInitialErrorChain);
            }
            function generateInitialErrorChain() {
                var componentName = ts.getTextOfNode(openingLikeElement.tagName);
                return ts.chainDiagnosticMessages(/* details */ undefined, ts.Diagnostics._0_cannot_be_used_as_a_JSX_component, componentName);
            }
        }
        /**
         * Get attributes type of the given intrinsic opening-like Jsx element by resolving the tag name.
         * The function is intended to be called from a function which has checked that the opening element is an intrinsic element.
         * @param node an intrinsic JSX opening-like element
         */
        function getIntrinsicAttributesTypeFromJsxOpeningLikeElement(node) {
            ts.Debug.assert(isJsxIntrinsicIdentifier(node.tagName));
            var links = getNodeLinks(node);
            if (!links.resolvedJsxElementAttributesType) {
                var symbol = getIntrinsicTagSymbol(node);
                if (links.jsxFlags & 1 /* JsxFlags.IntrinsicNamedElement */) {
                    return links.resolvedJsxElementAttributesType = getTypeOfSymbol(symbol) || errorType;
                }
                else if (links.jsxFlags & 2 /* JsxFlags.IntrinsicIndexedElement */) {
                    return links.resolvedJsxElementAttributesType =
                        getIndexTypeOfType(getJsxType(JsxNames.IntrinsicElements, node), stringType) || errorType;
                }
                else {
                    return links.resolvedJsxElementAttributesType = errorType;
                }
            }
            return links.resolvedJsxElementAttributesType;
        }
        function getJsxElementClassTypeAt(location) {
            var type = getJsxType(JsxNames.ElementClass, location);
            if (isErrorType(type))
                return undefined;
            return type;
        }
        function getJsxElementTypeAt(location) {
            return getJsxType(JsxNames.Element, location);
        }
        function getJsxStatelessElementTypeAt(location) {
            var jsxElementType = getJsxElementTypeAt(location);
            if (jsxElementType) {
                return getUnionType([jsxElementType, nullType]);
            }
        }
        /**
         * Returns all the properties of the Jsx.IntrinsicElements interface
         */
        function getJsxIntrinsicTagNamesAt(location) {
            var intrinsics = getJsxType(JsxNames.IntrinsicElements, location);
            return intrinsics ? getPropertiesOfType(intrinsics) : ts.emptyArray;
        }
        function checkJsxPreconditions(errorNode) {
            // Preconditions for using JSX
            if ((compilerOptions.jsx || 0 /* JsxEmit.None */) === 0 /* JsxEmit.None */) {
                error(errorNode, ts.Diagnostics.Cannot_use_JSX_unless_the_jsx_flag_is_provided);
            }
            if (getJsxElementTypeAt(errorNode) === undefined) {
                if (noImplicitAny) {
                    error(errorNode, ts.Diagnostics.JSX_element_implicitly_has_type_any_because_the_global_type_JSX_Element_does_not_exist);
                }
            }
        }
        function checkJsxOpeningLikeElementOrOpeningFragment(node) {
            var isNodeOpeningLikeElement = ts.isJsxOpeningLikeElement(node);
            if (isNodeOpeningLikeElement) {
                checkGrammarJsxElement(node);
            }
            checkJsxPreconditions(node);
            if (!getJsxNamespaceContainerForImplicitImport(node)) {
                // The reactNamespace/jsxFactory's root symbol should be marked as 'used' so we don't incorrectly elide its import.
                // And if there is no reactNamespace/jsxFactory's symbol in scope when targeting React emit, we should issue an error.
                var jsxFactoryRefErr = diagnostics && compilerOptions.jsx === 2 /* JsxEmit.React */ ? ts.Diagnostics.Cannot_find_name_0 : undefined;
                var jsxFactoryNamespace = getJsxNamespace(node);
                var jsxFactoryLocation = isNodeOpeningLikeElement ? node.tagName : node;
                // allow null as jsxFragmentFactory
                var jsxFactorySym = void 0;
                if (!(ts.isJsxOpeningFragment(node) && jsxFactoryNamespace === "null")) {
                    jsxFactorySym = resolveName(jsxFactoryLocation, jsxFactoryNamespace, 111551 /* SymbolFlags.Value */, jsxFactoryRefErr, jsxFactoryNamespace, /*isUse*/ true);
                }
                if (jsxFactorySym) {
                    // Mark local symbol as referenced here because it might not have been marked
                    // if jsx emit was not jsxFactory as there wont be error being emitted
                    jsxFactorySym.isReferenced = 67108863 /* SymbolFlags.All */;
                    // If react/jsxFactory symbol is alias, mark it as refereced
                    if (jsxFactorySym.flags & 2097152 /* SymbolFlags.Alias */ && !getTypeOnlyAliasDeclaration(jsxFactorySym)) {
                        markAliasSymbolAsReferenced(jsxFactorySym);
                    }
                }
                // For JsxFragment, mark jsx pragma as referenced via resolveName
                if (ts.isJsxOpeningFragment(node)) {
                    var file = ts.getSourceFileOfNode(node);
                    var localJsxNamespace = getLocalJsxNamespace(file);
                    if (localJsxNamespace) {
                        resolveName(jsxFactoryLocation, localJsxNamespace, 111551 /* SymbolFlags.Value */, jsxFactoryRefErr, localJsxNamespace, /*isUse*/ true);
                    }
                }
            }
            if (isNodeOpeningLikeElement) {
                var jsxOpeningLikeNode = node;
                var sig = getResolvedSignature(jsxOpeningLikeNode);
                checkDeprecatedSignature(sig, node);
                checkJsxReturnAssignableToAppropriateBound(getJsxReferenceKind(jsxOpeningLikeNode), getReturnTypeOfSignature(sig), jsxOpeningLikeNode);
            }
        }
        /**
         * Check if a property with the given name is known anywhere in the given type. In an object type, a property
         * is considered known if
         * 1. the object type is empty and the check is for assignability, or
         * 2. if the object type has index signatures, or
         * 3. if the property is actually declared in the object type
         *    (this means that 'toString', for example, is not usually a known property).
         * 4. In a union or intersection type,
         *    a property is considered known if it is known in any constituent type.
         * @param targetType a type to search a given name in
         * @param name a property name to search
         * @param isComparingJsxAttributes a boolean flag indicating whether we are searching in JsxAttributesType
         */
        function isKnownProperty(targetType, name, isComparingJsxAttributes) {
            if (targetType.flags & 524288 /* TypeFlags.Object */) {
                // For backwards compatibility a symbol-named property is satisfied by a string index signature. This
                // is incorrect and inconsistent with element access expressions, where it is an error, so eventually
                // we should remove this exception.
                if (getPropertyOfObjectType(targetType, name) ||
                    getApplicableIndexInfoForName(targetType, name) ||
                    isLateBoundName(name) && getIndexInfoOfType(targetType, stringType) ||
                    isComparingJsxAttributes && isHyphenatedJsxName(name)) {
                    // For JSXAttributes, if the attribute has a hyphenated name, consider that the attribute to be known.
                    return true;
                }
            }
            else if (targetType.flags & 3145728 /* TypeFlags.UnionOrIntersection */ && isExcessPropertyCheckTarget(targetType)) {
                for (var _i = 0, _a = targetType.types; _i < _a.length; _i++) {
                    var t = _a[_i];
                    if (isKnownProperty(t, name, isComparingJsxAttributes)) {
                        return true;
                    }
                }
            }
            return false;
        }
        function isExcessPropertyCheckTarget(type) {
            return !!(type.flags & 524288 /* TypeFlags.Object */ && !(ts.getObjectFlags(type) & 512 /* ObjectFlags.ObjectLiteralPatternWithComputedProperties */) ||
                type.flags & 67108864 /* TypeFlags.NonPrimitive */ ||
                type.flags & 1048576 /* TypeFlags.Union */ && ts.some(type.types, isExcessPropertyCheckTarget) ||
                type.flags & 2097152 /* TypeFlags.Intersection */ && ts.every(type.types, isExcessPropertyCheckTarget));
        }
        function checkJsxExpression(node, checkMode) {
            checkGrammarJsxExpression(node);
            if (node.expression) {
                var type = checkExpression(node.expression, checkMode);
                if (node.dotDotDotToken && type !== anyType && !isArrayType(type)) {
                    error(node, ts.Diagnostics.JSX_spread_child_must_be_an_array_type);
                }
                return type;
            }
            else {
                return errorType;
            }
        }
        function getDeclarationNodeFlagsFromSymbol(s) {
            return s.valueDeclaration ? ts.getCombinedNodeFlags(s.valueDeclaration) : 0;
        }
        /**
         * Return whether this symbol is a member of a prototype somewhere
         * Note that this is not tracked well within the compiler, so the answer may be incorrect.
         */
        function isPrototypeProperty(symbol) {
            if (symbol.flags & 8192 /* SymbolFlags.Method */ || ts.getCheckFlags(symbol) & 4 /* CheckFlags.SyntheticMethod */) {
                return true;
            }
            if (ts.isInJSFile(symbol.valueDeclaration)) {
                var parent = symbol.valueDeclaration.parent;
                return parent && ts.isBinaryExpression(parent) &&
                    ts.getAssignmentDeclarationKind(parent) === 3 /* AssignmentDeclarationKind.PrototypeProperty */;
            }
        }
        /**
         * Check whether the requested property access is valid.
         * Returns true if node is a valid property access, and false otherwise.
         * @param node The node to be checked.
         * @param isSuper True if the access is from `super.`.
         * @param type The type of the object whose property is being accessed. (Not the type of the property.)
         * @param prop The symbol for the property being accessed.
         */
        function checkPropertyAccessibility(node, isSuper, writing, type, prop, reportError) {
            if (reportError === void 0) { reportError = true; }
            var errorNode = !reportError ? undefined :
                node.kind === 161 /* SyntaxKind.QualifiedName */ ? node.right :
                    node.kind === 200 /* SyntaxKind.ImportType */ ? node :
                        node.kind === 203 /* SyntaxKind.BindingElement */ && node.propertyName ? node.propertyName : node.name;
            return checkPropertyAccessibilityAtLocation(node, isSuper, writing, type, prop, errorNode);
        }
        /**
         * Check whether the requested property can be accessed at the requested location.
         * Returns true if node is a valid property access, and false otherwise.
         * @param location The location node where we want to check if the property is accessible.
         * @param isSuper True if the access is from `super.`.
         * @param writing True if this is a write property access, false if it is a read property access.
         * @param containingType The type of the object whose property is being accessed. (Not the type of the property.)
         * @param prop The symbol for the property being accessed.
         * @param errorNode The node where we should report an invalid property access error, or undefined if we should not report errors.
         */
        function checkPropertyAccessibilityAtLocation(location, isSuper, writing, containingType, prop, errorNode) {
            var flags = ts.getDeclarationModifierFlagsFromSymbol(prop, writing);
            if (isSuper) {
                // TS 1.0 spec (April 2014): 4.8.2
                // - In a constructor, instance member function, instance member accessor, or
                //   instance member variable initializer where this references a derived class instance,
                //   a super property access is permitted and must specify a public instance member function of the base class.
                // - In a static member function or static member accessor
                //   where this references the constructor function object of a derived class,
                //   a super property access is permitted and must specify a public static member function of the base class.
                if (languageVersion < 2 /* ScriptTarget.ES2015 */) {
                    if (symbolHasNonMethodDeclaration(prop)) {
                        if (errorNode) {
                            error(errorNode, ts.Diagnostics.Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword);
                        }
                        return false;
                    }
                }
                if (flags & 128 /* ModifierFlags.Abstract */) {
                    // A method cannot be accessed in a super property access if the method is abstract.
                    // This error could mask a private property access error. But, a member
                    // cannot simultaneously be private and abstract, so this will trigger an
                    // additional error elsewhere.
                    if (errorNode) {
                        error(errorNode, ts.Diagnostics.Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression, symbolToString(prop), typeToString(getDeclaringClass(prop)));
                    }
                    return false;
                }
            }
            // Referencing abstract properties within their own constructors is not allowed
            if ((flags & 128 /* ModifierFlags.Abstract */) && symbolHasNonMethodDeclaration(prop) &&
                (ts.isThisProperty(location) || ts.isThisInitializedObjectBindingExpression(location) || ts.isObjectBindingPattern(location.parent) && ts.isThisInitializedDeclaration(location.parent.parent))) {
                var declaringClassDeclaration = ts.getClassLikeDeclarationOfSymbol(getParentOfSymbol(prop));
                if (declaringClassDeclaration && isNodeUsedDuringClassInitialization(location)) {
                    if (errorNode) {
                        error(errorNode, ts.Diagnostics.Abstract_property_0_in_class_1_cannot_be_accessed_in_the_constructor, symbolToString(prop), ts.getTextOfIdentifierOrLiteral(declaringClassDeclaration.name));
                    }
                    return false;
                }
            }
            // Public properties are otherwise accessible.
            if (!(flags & 24 /* ModifierFlags.NonPublicAccessibilityModifier */)) {
                return true;
            }
            // Property is known to be private or protected at this point
            // Private property is accessible if the property is within the declaring class
            if (flags & 8 /* ModifierFlags.Private */) {
                var declaringClassDeclaration = ts.getClassLikeDeclarationOfSymbol(getParentOfSymbol(prop));
                if (!isNodeWithinClass(location, declaringClassDeclaration)) {
                    if (errorNode) {
                        error(errorNode, ts.Diagnostics.Property_0_is_private_and_only_accessible_within_class_1, symbolToString(prop), typeToString(getDeclaringClass(prop)));
                    }
                    return false;
                }
                return true;
            }
            // Property is known to be protected at this point
            // All protected properties of a supertype are accessible in a super access
            if (isSuper) {
                return true;
            }
            // Find the first enclosing class that has the declaring classes of the protected constituents
            // of the property as base classes
            var enclosingClass = forEachEnclosingClass(location, function (enclosingDeclaration) {
                var enclosingClass = getDeclaredTypeOfSymbol(getSymbolOfNode(enclosingDeclaration));
                return isClassDerivedFromDeclaringClasses(enclosingClass, prop, writing);
            });
            // A protected property is accessible if the property is within the declaring class or classes derived from it
            if (!enclosingClass) {
                // allow PropertyAccessibility if context is in function with this parameter
                // static member access is disallowed
                enclosingClass = getEnclosingClassFromThisParameter(location);
                enclosingClass = enclosingClass && isClassDerivedFromDeclaringClasses(enclosingClass, prop, writing);
                if (flags & 32 /* ModifierFlags.Static */ || !enclosingClass) {
                    if (errorNode) {
                        error(errorNode, ts.Diagnostics.Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses, symbolToString(prop), typeToString(getDeclaringClass(prop) || containingType));
                    }
                    return false;
                }
            }
            // No further restrictions for static properties
            if (flags & 32 /* ModifierFlags.Static */) {
                return true;
            }
            if (containingType.flags & 262144 /* TypeFlags.TypeParameter */) {
                // get the original type -- represented as the type constraint of the 'this' type
                containingType = containingType.isThisType ? getConstraintOfTypeParameter(containingType) : getBaseConstraintOfType(containingType); // TODO: GH#18217 Use a different variable that's allowed to be undefined
            }
            if (!containingType || !hasBaseType(containingType, enclosingClass)) {
                if (errorNode) {
                    error(errorNode, ts.Diagnostics.Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1_This_is_an_instance_of_class_2, symbolToString(prop), typeToString(enclosingClass), typeToString(containingType));
                }
                return false;
            }
            return true;
        }
        function getEnclosingClassFromThisParameter(node) {
            var thisParameter = getThisParameterFromNodeContext(node);
            var thisType = (thisParameter === null || thisParameter === void 0 ? void 0 : thisParameter.type) && getTypeFromTypeNode(thisParameter.type);
            if (thisType && thisType.flags & 262144 /* TypeFlags.TypeParameter */) {
                thisType = getConstraintOfTypeParameter(thisType);
            }
            if (thisType && ts.getObjectFlags(thisType) & (3 /* ObjectFlags.ClassOrInterface */ | 4 /* ObjectFlags.Reference */)) {
                return getTargetType(thisType);
            }
            return undefined;
        }
        function getThisParameterFromNodeContext(node) {
            var thisContainer = ts.getThisContainer(node, /* includeArrowFunctions */ false);
            return thisContainer && ts.isFunctionLike(thisContainer) ? ts.getThisParameter(thisContainer) : undefined;
        }
        function symbolHasNonMethodDeclaration(symbol) {
            return !!forEachProperty(symbol, function (prop) { return !(prop.flags & 8192 /* SymbolFlags.Method */); });
        }
        function checkNonNullExpression(node) {
            return checkNonNullType(checkExpression(node), node);
        }
        function isNullableType(type) {
            return !!((strictNullChecks ? getFalsyFlags(type) : type.flags) & 98304 /* TypeFlags.Nullable */);
        }
        function getNonNullableTypeIfNeeded(type) {
            return isNullableType(type) ? getNonNullableType(type) : type;
        }
        function reportObjectPossiblyNullOrUndefinedError(node, flags) {
            error(node, flags & 32768 /* TypeFlags.Undefined */ ? flags & 65536 /* TypeFlags.Null */ ?
                ts.Diagnostics.Object_is_possibly_null_or_undefined :
                ts.Diagnostics.Object_is_possibly_undefined :
                ts.Diagnostics.Object_is_possibly_null);
        }
        function reportCannotInvokePossiblyNullOrUndefinedError(node, flags) {
            error(node, flags & 32768 /* TypeFlags.Undefined */ ? flags & 65536 /* TypeFlags.Null */ ?
                ts.Diagnostics.Cannot_invoke_an_object_which_is_possibly_null_or_undefined :
                ts.Diagnostics.Cannot_invoke_an_object_which_is_possibly_undefined :
                ts.Diagnostics.Cannot_invoke_an_object_which_is_possibly_null);
        }
        function checkNonNullTypeWithReporter(type, node, reportError) {
            if (strictNullChecks && type.flags & 2 /* TypeFlags.Unknown */) {
                error(node, ts.Diagnostics.Object_is_of_type_unknown);
                return errorType;
            }
            var kind = (strictNullChecks ? getFalsyFlags(type) : type.flags) & 98304 /* TypeFlags.Nullable */;
            if (kind) {
                reportError(node, kind);
                var t = getNonNullableType(type);
                return t.flags & (98304 /* TypeFlags.Nullable */ | 131072 /* TypeFlags.Never */) ? errorType : t;
            }
            return type;
        }
        function checkNonNullType(type, node) {
            return checkNonNullTypeWithReporter(type, node, reportObjectPossiblyNullOrUndefinedError);
        }
        function checkNonNullNonVoidType(type, node) {
            var nonNullType = checkNonNullType(type, node);
            if (nonNullType.flags & 16384 /* TypeFlags.Void */) {
                error(node, ts.Diagnostics.Object_is_possibly_undefined);
            }
            return nonNullType;
        }
        function checkPropertyAccessExpression(node, checkMode) {
            return node.flags & 32 /* NodeFlags.OptionalChain */ ? checkPropertyAccessChain(node, checkMode) :
                checkPropertyAccessExpressionOrQualifiedName(node, node.expression, checkNonNullExpression(node.expression), node.name, checkMode);
        }
        function checkPropertyAccessChain(node, checkMode) {
            var leftType = checkExpression(node.expression);
            var nonOptionalType = getOptionalExpressionType(leftType, node.expression);
            return propagateOptionalTypeMarker(checkPropertyAccessExpressionOrQualifiedName(node, node.expression, checkNonNullType(nonOptionalType, node.expression), node.name, checkMode), node, nonOptionalType !== leftType);
        }
        function checkQualifiedName(node, checkMode) {
            var leftType = ts.isPartOfTypeQuery(node) && ts.isThisIdentifier(node.left) ? checkNonNullType(checkThisExpression(node.left), node.left) : checkNonNullExpression(node.left);
            return checkPropertyAccessExpressionOrQualifiedName(node, node.left, leftType, node.right, checkMode);
        }
        function isMethodAccessForCall(node) {
            while (node.parent.kind === 212 /* SyntaxKind.ParenthesizedExpression */) {
                node = node.parent;
            }
            return ts.isCallOrNewExpression(node.parent) && node.parent.expression === node;
        }
        // Lookup the private identifier lexically.
        function lookupSymbolForPrivateIdentifierDeclaration(propName, location) {
            for (var containingClass = ts.getContainingClass(location); !!containingClass; containingClass = ts.getContainingClass(containingClass)) {
                var symbol = containingClass.symbol;
                var name = ts.getSymbolNameForPrivateIdentifier(symbol, propName);
                var prop = (symbol.members && symbol.members.get(name)) || (symbol.exports && symbol.exports.get(name));
                if (prop) {
                    return prop;
                }
            }
        }
        function checkGrammarPrivateIdentifierExpression(privId) {
            if (!ts.getContainingClass(privId)) {
                return grammarErrorOnNode(privId, ts.Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies);
            }
            if (!ts.isForInStatement(privId.parent)) {
                if (!ts.isExpressionNode(privId)) {
                    return grammarErrorOnNode(privId, ts.Diagnostics.Private_identifiers_are_only_allowed_in_class_bodies_and_may_only_be_used_as_part_of_a_class_member_declaration_property_access_or_on_the_left_hand_side_of_an_in_expression);
                }
                var isInOperation = ts.isBinaryExpression(privId.parent) && privId.parent.operatorToken.kind === 101 /* SyntaxKind.InKeyword */;
                if (!getSymbolForPrivateIdentifierExpression(privId) && !isInOperation) {
                    return grammarErrorOnNode(privId, ts.Diagnostics.Cannot_find_name_0, ts.idText(privId));
                }
            }
            return false;
        }
        function checkPrivateIdentifierExpression(privId) {
            checkGrammarPrivateIdentifierExpression(privId);
            var symbol = getSymbolForPrivateIdentifierExpression(privId);
            if (symbol) {
                markPropertyAsReferenced(symbol, /* nodeForCheckWriteOnly: */ undefined, /* isThisAccess: */ false);
            }
            return anyType;
        }
        function getSymbolForPrivateIdentifierExpression(privId) {
            if (!ts.isExpressionNode(privId)) {
                return undefined;
            }
            var links = getNodeLinks(privId);
            if (links.resolvedSymbol === undefined) {
                links.resolvedSymbol = lookupSymbolForPrivateIdentifierDeclaration(privId.escapedText, privId);
            }
            return links.resolvedSymbol;
        }
        function getPrivateIdentifierPropertyOfType(leftType, lexicallyScopedIdentifier) {
            return getPropertyOfType(leftType, lexicallyScopedIdentifier.escapedName);
        }
        function checkPrivateIdentifierPropertyAccess(leftType, right, lexicallyScopedIdentifier) {
            // Either the identifier could not be looked up in the lexical scope OR the lexically scoped identifier did not exist on the type.
            // Find a private identifier with the same description on the type.
            var propertyOnType;
            var properties = getPropertiesOfType(leftType);
            if (properties) {
                ts.forEach(properties, function (symbol) {
                    var decl = symbol.valueDeclaration;
                    if (decl && ts.isNamedDeclaration(decl) && ts.isPrivateIdentifier(decl.name) && decl.name.escapedText === right.escapedText) {
                        propertyOnType = symbol;
                        return true;
                    }
                });
            }
            var diagName = diagnosticName(right);
            if (propertyOnType) {
                var typeValueDecl = ts.Debug.checkDefined(propertyOnType.valueDeclaration);
                var typeClass_1 = ts.Debug.checkDefined(ts.getContainingClass(typeValueDecl));
                // We found a private identifier property with the same description.
                // Either:
                // - There is a lexically scoped private identifier AND it shadows the one we found on the type.
                // - It is an attempt to access the private identifier outside of the class.
                if (lexicallyScopedIdentifier === null || lexicallyScopedIdentifier === void 0 ? void 0 : lexicallyScopedIdentifier.valueDeclaration) {
                    var lexicalValueDecl = lexicallyScopedIdentifier.valueDeclaration;
                    var lexicalClass = ts.getContainingClass(lexicalValueDecl);
                    ts.Debug.assert(!!lexicalClass);
                    if (ts.findAncestor(lexicalClass, function (n) { return typeClass_1 === n; })) {
                        var diagnostic = error(right, ts.Diagnostics.The_property_0_cannot_be_accessed_on_type_1_within_this_class_because_it_is_shadowed_by_another_private_identifier_with_the_same_spelling, diagName, typeToString(leftType));
                        ts.addRelatedInfo(diagnostic, ts.createDiagnosticForNode(lexicalValueDecl, ts.Diagnostics.The_shadowing_declaration_of_0_is_defined_here, diagName), ts.createDiagnosticForNode(typeValueDecl, ts.Diagnostics.The_declaration_of_0_that_you_probably_intended_to_use_is_defined_here, diagName));
                        return true;
                    }
                }
                error(right, ts.Diagnostics.Property_0_is_not_accessible_outside_class_1_because_it_has_a_private_identifier, diagName, diagnosticName(typeClass_1.name || anon));
                return true;
            }
            return false;
        }
        function isThisPropertyAccessInConstructor(node, prop) {
            return (isConstructorDeclaredProperty(prop) || ts.isThisProperty(node) && isAutoTypedProperty(prop))
                && ts.getThisContainer(node, /*includeArrowFunctions*/ true) === getDeclaringConstructor(prop);
        }
        function checkPropertyAccessExpressionOrQualifiedName(node, left, leftType, right, checkMode) {
            var parentSymbol = getNodeLinks(left).resolvedSymbol;
            var assignmentKind = ts.getAssignmentTargetKind(node);
            var apparentType = getApparentType(assignmentKind !== 0 /* AssignmentKind.None */ || isMethodAccessForCall(node) ? getWidenedType(leftType) : leftType);
            var isAnyLike = isTypeAny(apparentType) || apparentType === silentNeverType;
            var prop;
            if (ts.isPrivateIdentifier(right)) {
                if (languageVersion < 99 /* ScriptTarget.ESNext */) {
                    if (assignmentKind !== 0 /* AssignmentKind.None */) {
                        checkExternalEmitHelpers(node, 1048576 /* ExternalEmitHelpers.ClassPrivateFieldSet */);
                    }
                    if (assignmentKind !== 1 /* AssignmentKind.Definite */) {
                        checkExternalEmitHelpers(node, 524288 /* ExternalEmitHelpers.ClassPrivateFieldGet */);
                    }
                }
                var lexicallyScopedSymbol = lookupSymbolForPrivateIdentifierDeclaration(right.escapedText, right);
                if (assignmentKind && lexicallyScopedSymbol && lexicallyScopedSymbol.valueDeclaration && ts.isMethodDeclaration(lexicallyScopedSymbol.valueDeclaration)) {
                    grammarErrorOnNode(right, ts.Diagnostics.Cannot_assign_to_private_method_0_Private_methods_are_not_writable, ts.idText(right));
                }
                if (isAnyLike) {
    