/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("@angular/core/schematics/migrations/entry-components/util", ["require", "exports", "typescript", "@angular/core/schematics/utils/typescript/decorators"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.migrateEntryComponentsUsages = void 0;
    const typescript_1 = __importDefault(require("typescript"));
    const decorators_1 = require("@angular/core/schematics/utils/typescript/decorators");
    /** Finds and migrates all Angular decorators that pass in `entryComponents`. */
    function migrateEntryComponentsUsages(typeChecker, printer, sourceFile) {
        const results = [];
        sourceFile.forEachChild(function walk(node) {
            if (typescript_1.default.isDecorator(node) && typescript_1.default.isCallExpression(node.expression) &&
                node.expression.arguments.length === 1 &&
                typescript_1.default.isObjectLiteralExpression(node.expression.arguments[0])) {
                const analysis = (0, decorators_1.getCallDecoratorImport)(typeChecker, node);
                if (analysis && analysis.importModule === '@angular/core' &&
                    (analysis.name === 'Component' || analysis.name === 'NgModule')) {
                    const literal = node.expression.arguments[0];
                    const entryComponentsProp = literal.properties.find(property => typescript_1.default.isPropertyAssignment(property) && typescript_1.default.isIdentifier(property.name) &&
                        property.name.text === 'entryComponents');
                    if (entryComponentsProp) {
                        const replacementNode = typescript_1.default.factory.updateObjectLiteralExpression(literal, literal.properties.filter(prop => prop !== entryComponentsProp));
                        results.push({
                            start: literal.getStart(),
                            length: literal.getWidth(),
                            end: literal.getEnd(),
                            replacement: printer.printNode(typescript_1.default.EmitHint.Unspecified, replacementNode, sourceFile)
                        });
                    }
                }
            }
            node.forEachChild(walk);
        });
        // Sort the operations in reverse ord