
                map.set(handle, callback);
                return handle;
            },
            cancelAnimationFrame: function (handle) {
                if (!map) {
                    throw new Error('animate() was not called within run()');
                }
                map.delete(handle);
            },
        };
        var animate = function (marbles) {
            var e_1, _a;
            if (map) {
                throw new Error('animate() must not be called more than once within run()');
            }
            if (/[|#]/.test(marbles)) {
                throw new Error('animate() must not complete or error');
            }
            map = new Map();
            var messages = TestScheduler.parseMarbles(marbles, undefined, undefined, undefined, true);
            try {
                for (var messages_1 = __values(messages), messages_1_1 = messages_1.next(); !messages_1_1.done; messages_1_1 = messages_1.next()) {
                    var message = messages_1_1.value;
                    _this.schedule(function () {
                        var e_2, _a;
                        var now = _this.now();
                        var callbacks = Array.from(map.values());
                        map.clear();
                        try {
                            for (var callbacks_1 = (e_2 = void 0, __values(callbacks)), callbacks_1_1 = callbacks_1.next(); !callbacks_1_1.done; callbacks_1_1 = callbacks_1.next()) {
                                var callback = callbacks_1_1.value;
                                callback(now);
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (callbacks_1_1 && !callbacks_1_1.done && (_a = callbacks_1.return)) _a.call(callbacks_1);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                    }, message.frame);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (messages_1_1 && !messages_1_1.done && (_a = messages_1.return)) _a.call(messages_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        return { animate: animate, delegate: delegate };
    };
    TestScheduler.prototype.createDelegates = function () {
        var _this = this;
        var lastHandle = 0;
        var scheduleLookup = new Map();
        var run = function () {
            var now = _this.now();
            var scheduledRecords = Array.from(scheduleLookup.values());
            var scheduledRecordsDue = scheduledRecords.filter(function (_a) {
                var due = _a.due;
                return due <= now;
            });
            var dueImmediates = scheduledRecordsDue.filter(function (_a) {
                var type = _a.type;
                return type === 'immediate';
            });
            if (dueImmediates.length > 0) {
                var _a = dueImmediates[0], handle = _a.handle, handler = _a.handler;
                scheduleLookup.delete(handle);
                handler();
                return;
            }
            var dueIntervals = scheduledRecordsDue.filter(function (_a) {
                var type = _a.type;
                return type === 'interval';
            });
            if (dueIntervals.length > 0) {
                var firstDueInterval = dueIntervals[0];
                var duration = firstDueInterval.duration, handler = firstDueInterval.handler;
                firstDueInterval.due = now + duration;
                firstDueInterval.subscription = _this.schedule(run, duration);
                handler();
                return;
            }
            var dueTimeouts = scheduledRecordsDue.filter(function (_a) {
                var type = _a.type;
                return type === 'timeout';
            });
            if (dueTimeouts.length > 0) {
                var _b = dueTimeouts[0], handle = _b.handle, handler = _b.handler;
                scheduleLookup.delete(handle);
                handler();
                return;
            }
            throw new Error('Expected a due immediate or interval');
        };
        var immediate = {
            setImmediate: function (handler) {
                var handle = ++lastHandle;
                scheduleLookup.set(handle, {
                    due: _this.now(),
                    duration: 0,
                    handle: handle,
                    handler: handler,
                    subscription: _this.schedule(run, 0)