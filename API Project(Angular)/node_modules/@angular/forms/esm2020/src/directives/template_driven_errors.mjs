GlobalScope !== 'undefined' &&\n         self instanceof WorkerGlobalScope && self))());\n\nexport {_global as global};\n\nexport function newArray<T = any>(size: number): T[];\nexport function newArray<T>(size: number, value: T): T[];\nexport function newArray<T>(size: number, value?: T): T[] {\n  const list: T[] = [];\n  for (let i = 0; i < size; i++) {\n    list.push(value!);\n  }\n  return list;\n}\n\n/**\n * Partitions a given array into 2 arrays, based on a boolean value returned by the condition\n * function.\n *\n * @param arr Input array that should be partitioned\n * @param conditionFn Condition function that is called for each item in a given array and returns a\n * boolean value.\n */\nexport function partitionArray<T, F = T>(\n    arr: (T|F)[], conditionFn: (value: T|F) => boolean): [T[], F[]] {\n  const truthy: T[] = [];\n  const falsy: F[] = [];\n  for (const item of arr) {\n    (conditionFn(item) ? truthy : falsy).push(item as any);\n  }\n  return [truthy, falsy];\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Represents a big integer using a buffer of its individual digits, with the least significant\n * digit stored at the beginning of the array (little endian).\n *\n * For performance reasons, each instance is mutable. The addition operation can be done in-place\n * to reduce memory pressure of allocation for the digits array.\n */\nexport class BigInteger {\n  static zero(): BigInteger {\n    return new BigInteger([0]);\n  }\n\n  static one(): BigInteger {\n    return new BigInteger([1]);\n  }\n\n  /**\n   * Creates a big integer using its individual digits in little endian storage.\n   */\n  private constructor(private readonly digits: number[]) {}\n\n  /**\n   * Creates a clone of this instance.\n   */\n  clone(): BigInteger {\n    return new BigInteger(this.digits.slice());\n  }\n\n  /**\n   * Returns a new big integer with the sum of `this` and `other` as its value. This does not mutate\n   * `this` but instead returns a new instance, unlike `addToSelf`.\n   */\n  add(other: BigInteger): BigInteger {\n    const result = this.clone();\n    result.addToSelf(other);\n    return result;\n  }\n\n  /**\n   * Adds `other` to the instance itself, thereby mutating its value.\n   */\n  addToSelf(other: BigInteger): void {\n    const maxNrOfDigits = Math.max(this.digits.length, other.digits.length);\n    let carry = 0;\n    for (let i = 0; i < maxNrOfDigits; i++) {\n      let digitSum = carry;\n      if (i < this.digits.length) {\n        digitSum += this.digits[i];\n      }\n      if (i < other.digits.length) {\n        digitSum += other.digits[i];\n      }\n\n      if (digitSum >= 10) {\n        this.digits[i] = digitSum - 10;\n        carry = 1;\n      } else {\n        this.digits[i] = digitSum;\n        carry = 0;\n      }\n    }\n\n    // Apply a remaining carry if needed.\n    if (carry > 0) {\n      this.digits[maxNrOfDigits] = 1;\n    }\n  }\n\n  /**\n   * Builds the decimal string representation of the big integer. As this is stored in\n   * little endian, the digits are concatenated in reverse order.\n   */\n  toString(): string {\n    let res = '';\n    for (let i = this.digits.length - 1; i >= 0; i--) {\n      res += this.digits[i];\n    }\n    return res;\n  }\n}\n\n/**\n * Represents a big integer which is optimized for multiplication operations, as its power-of-twos\n * are memoized. See `multiplyBy()` for details on the multiplication algorithm.\n */\nexport class BigIntForMultiplication {\n  /**\n   * Stores all memoized power-of-twos, where each index represents `this.number * 2^index`.\n   */\n  private readonly powerOfTwos: BigInteger[];\n\n  constructor(value: BigInteger) {\n    this.powerOfTwos = [value];\n  }\n\n  /**\n   * Returns the big integer itself.\n   */\n  getValue(): BigInteger {\n    return this.powerOfTwos[0];\n  }\n\n  /**\n   * Computes the value for `num * b`, where `num` is a JS number and `b` is a big integer. The\n   * value for `b` is represented by a storage model that is optimized for this computation.\n   *\n   * This operation is implemented in N(log2(num)) by continuous halving of the number, where the\n   * least-significant bit (LSB) is tested in each iteration. If the bit is set, the bit's index is\n   * used as exponent into the power-of-two multiplication of `b`.\n   *\n   * As an example, consider the multiplication num=42, b=1337. In binary 42 is 0b00101010 and the\n   * algorithm unrolls into the following iterations:\n   *\n   *  Iteration | num        | LSB  | b * 2^iter | Add? | product\n   * -----------|------------|------|------------|------|--------\n   *  0         | 0b00101010 | 0    | 1337       | No   | 0\n   *  1         | 0b00010101 | 1    | 2674       | Yes  | 2674\n   *  2         | 0b00001010 | 0    | 5348       | No   | 2674\n   *  3         | 0b00000101 | 1    | 10696      | Yes  | 13370\n   *  4         | 0b00000010 | 0    | 21392      | No   | 13370\n   *  5         | 0b00000001 | 1    | 42784      | Yes  | 56154\n   *  6         | 0b00000000 | 0    | 85568      | No   | 56154\n   *\n   * The computed product of 56154 is indeed the correct result.\n   *\n   * The `BigIntForMultiplication` representation for a big integer provides memoized access to the\n   * power-of-two values to reduce the workload in computing those values.\n   */\n  multiplyBy(num: number): BigInteger {\n    const product = BigInteger.zero();\n    this.multiplyByAndAddTo(num, product);\n    return product;\n  }\n\n  /**\n   * See `multiplyBy()` for details. This function allows for the computed product to be added\n   * directly to the provided result big integer.\n   */\n  multiplyByAndAddTo(num: number, result: BigInteger): void {\n    for (let exponent = 0; num !== 0; num = num >>> 1, exponent++) {\n      if (num & 1) {\n        const value = this.getMultipliedByPowerOfTwo(exponent);\n        result.addToSelf(value);\n      }\n    }\n  }\n\n  /**\n   * Computes and memoizes the big integer value for `this.number * 2^exponent`.\n   */\n  private getMultipliedByPowerOfTwo(exponent: number): BigInteger {\n    // Compute the powers up until the requested exponent, where each value is computed from its\n    // predecessor. This is simple as `this