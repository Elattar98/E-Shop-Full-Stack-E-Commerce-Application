param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n * @returns This function returns itself so that it may be chained\n * (e.g. `property('name', ctx.name)('title', ctx.title)`)\n *\n * @codeGenApi\n */\nexport function ɵɵproperty<T>(\n    propName: string, value: T, sanitizer?: SanitizerFn|null): typeof ɵɵproperty {\n  const lView = getLView();\n  const bindingIndex = nextBindingIndex();\n  if (bindingUpdated(lView, bindingIndex, value)) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, false);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);\n  }\n  return ɵɵproperty;\n}\n\n/**\n * Given `<div style=\"...\" my-dir>` and `MyDir` with `@Input('style')` we need to write to\n * directive input.\n */\nexport function setDirectiveInputsWhichShadowsStyling(\n    tView: TView, tNode: TNode, lView: LView, value: any, isClassBased: boolean) {\n  const inputs = tNode.inputs!;\n  const property = isClassBased ? 'class' : 'style';\n  // We support both 'class' and `className` hence the fallback.\n  setInputsForProperty(tView, lView, inputs[property], property, value);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDefined, assertEqual, assertIndexInRange} from '../../util/assert';\nimport {assertFirstCreatePass, assertHasParent} from '../assert';\nimport {attachPatchData} from '../context_discovery';\nimport {registerPostOrderHooks} from '../hooks';\nimport {hasClassInput, hasStyleInput, TAttributes, TElementNode, TNodeFlags, TNodeType} from '../interfaces/node';\nimport {RElement} from '../interfaces/renderer_dom';\nimport {isContentQueryHost, isDirectiveHost} from '../interfaces/type_checks';\nimport {HEADER_OFFSET, LView, RENDERER, TView} from '../interfaces/view';\nimport {assertTNodeType} from '../node_assert';\nimport {appendChild, createElementNode, writeDirectClass, writeDirectStyle} from '../node_manipulation';\nimport {decreaseElementDepthCount, getBindingIndex, getCurrentTNode, getElementDepthCount, getLView, getNamespace, getTView, increaseElementDepthCount, isCurrentTNodeParent, setCurrentTNode, setCurrentTNodeAsNotParent} from '../state';\nimport {computeStaticStyling} from '../styling/static_styling';\nimport {setUpAttributes} from '../util/attrs_utils';\nimport {getConstant} from '../util/view_utils';\n\nimport {validateElementIsKnown} from './element_validation';\nimport {setDirectiveInputsWhichShadowsStyling} from './property';\nimport {createDirectivesInstances, executeContentQueries, getOrCreateTNode, resolveDirectives, saveResolvedLocalsInData} from './shared';\n\n\nfunction elementStartFirstCreatePass(\n    index: number, tView: TView, lView: LView, native: RElement, name: string,\n    attrsIndex?: number|null, localRefsIndex?: number): TElementNode {\n  ngDevMode && assertFirstCreatePass(tView);\n  ngDevMode && ngDevMode.firstCreatePass++;\n\n  const tViewConsts = tView.consts;\n  const attrs = getConstant<TAttributes>(tViewConsts, attrsIndex);\n  const tNode = getOrCreateTNode(tView, index, TNodeType.Element, name, attrs);\n\n  const hasDirectives =\n      resolveDirectives(tView, lView, tNode, getConstant<string[]>(tViewConsts, localRefsIndex));\n  if (ngDevMode) {\n    validateElementIsKnown(native, lView, tNode.value, tView.schemas, hasDirectives);\n  }\n\n  if (tNode.attrs !== null) {\n    computeStaticStyling(tNode, tNode.attrs, false);\n  }\n\n  if (tNode.mergedAttrs !== null) {\n    computeStaticStyling(tNode, tNode.mergedAttrs, true);\n  }\n\n  if (tView.queries !== null) {\n    tView.queries.elementStart(tView, tNode);\n  }\n\n  return tNode;\n}\n\n/**\n * Create DOM element. The instruction must later be followed by `elementEnd()` call.\n *\n * @param index Index of the element in the LView array\n * @param name Name of the DOM Node\n * @param attrsIndex Index of the element's attributes in the `consts` array.\n * @param localRefsIndex Index of the element's local references in the `consts` array.\n * @returns This function returns itself so that it may be chained.\n *\n * Attributes and localRefs are passed as an array of strings where elements with an even index\n * hold an attribute name and elements with an odd index hold an attribute value, ex.:\n * ['id', 'warning5', 'class', 'alert']\n *\n * @codeGenApi\n */\nexport function ɵɵelementStart(\n    index: number, name: string, attrsIndex?: number|null,\n    localRefsIndex?: number): typeof ɵɵelementStart {\n  const lView = getLView();\n  const tView = getTView();\n  const adjustedIndex = HEADER_OFFSET + index;\n\n  ngDevMode &&\n      assertEqual(\n          getBindingIndex(), tView.bindingStartIndex,\n          'elements should be created before any bindings');\n  ngDevMode && assertIndexInRange(lView, adjustedIndex);\n\n  const renderer = lView[RENDERER];\n  const native = lView[adjustedIndex] = createElementNode(renderer, name, getNamespace());\n  const tNode = tView.firstCreatePass ?\n      elementStartFirstCreatePass(\n          adjustedIndex, tView, lView, native, name, attrsIndex, localRefsIndex) :\n      tView.data[adjustedIndex] as TElementNode;\n  setCurrentTNode(tNode, true);\n\n  const mergedAttrs = tNode.mergedAttrs;\n  if (mergedAttrs !== null) {\n    setUpAttributes(renderer, native, mergedAttrs);\n  }\n  const classes = tNode.classes;\n  if (classes !== null) {\n    writeDirectClass(renderer, native, classes);\n  }\n  const styles = tNode.styles;\n  if (styles !== null) {\n    writeDirectStyle(renderer, native, styles);\n  }\n\n  if ((tNode.flags & TNodeFlags.isDetached) !== TNodeFlags.isDetached) {\n    // In the i18n case, the translation may have removed this element, so only add it if it is not\n    // detached. See `TNodeType.Placeholder` and `LFrame.inI18n` for more context.\n    appendChild(tView, lView, native, tNode);\n  }\n\n  // any immediate children of a component or template container must be pre-emptively\n  // monkey-patched with the component view data so that the element can be inspected\n  // later on using any element discovery utility methods (see `element_discovery.ts`)\n  if (getElementDepthCount() === 0) {\n    attachPatchData(native, lView);\n  }\n  increaseElementDepthCount();\n\n\n  if (isDirectiveHost(tNode)) {\n    createDirectivesInstances(tView, lView, tNode);\n    executeContentQueries(tView, tNode, lView);\n  }\n  if (localRefsIndex !== null) {\n    saveResolvedLocalsInData(lView, tNode);\n  }\n  return ɵɵelementStart;\n}\n\n/**\n * Mar