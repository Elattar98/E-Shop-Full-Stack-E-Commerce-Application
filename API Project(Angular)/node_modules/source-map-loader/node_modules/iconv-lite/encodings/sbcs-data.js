ts = {}, ignorableDeepImportMatchers = [] }) {
    const absolutePathEntries = Object.entries(entryPoints).map(([relativePath, config]) => [fs.resolve(packagePath, relativePath), config]);
    this.packagePath = packagePath;
    this.entryPoints = new Map(absolutePathEntries);
    this.ignorableDeepImportMatchers = ignorableDeepImportMatchers;
  }
};
var NgccConfiguration = class {
  constructor(fs, baseDir) {
    this.fs = fs;
    this.cache = /* @__PURE__ */ new Map();
    this.defaultConfig = new PartiallyProcessedConfig(DEFAULT_NGCC_CONFIG);
    this.projectConfig = new PartiallyProcessedConfig(this.loadProjectConfig(baseDir));
    this.hashAlgorithm = this.projectConfig.hashAlgorithm;
    this.hash = this.computeHash();
  }
  getLockingConfig() {
    let { retryAttempts, retryDelay } = this.projectConfig.locking;
    if (retryAttempts === void 0) {
      retryAttempts = this.defaultConfig.locking.retryAttempts;
    }
    if (retryDelay === void 0) {
      retryDelay = this.defaultConfig.locking.retryDelay;
    }
    return { retryAttempts, retryDelay };
  }
  getPackageConfig(packageName, packagePath, version) {
    const rawPackageConfig = this.getRawPackageConfig(packageName, packagePath, version);
    return new ProcessedNgccPackageConfig(this.fs, packagePath, rawPackageConfig);
  }
  getRawPackageConfig(packageName, packagePath, version) {
    const cacheKey = packageName + (version !== null ? `@${version}` : "");
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey);
    }
    const projectLevelConfig = this.projectConfig.findPackageConfig(packageName, version);
    if (projectLevelConfig !== null) {
      this.cache.set(cacheKey, projectLevelConfig);
      return projectLevelConfig;
    }
    const packageLevelConfig = this.loadPackageConfig(packagePath, version);
    if (packageLevelConfig !== null) {
      this.cache.set(cacheKey, packageLevelConfig);
      return packageLevelConfig;
    }
    const defaultLevelConfig = this.defaultConfig.findPackageConfig(packageName, version);
    if (defaultLevelConfig !== null) {
      this.cache.set(cacheKey, defaultLevelConfig);
      return defaultLevelConfig;
    }
    return { versionRange: "*" };
  }
  loadProjectConfig(baseDir) {
    const configFilePath = this.fs.join(baseDir, NGCC_CONFIG_FILENAME);
    if (this.fs.exists(configFilePath)) {
      try {
        return this.evalSrcFile(configFilePath);
      } catch (e) {
        throw new Error(`Invalid project configuration file at "${configFilePath}": ` + e.message);
      }
    } else {
      return { packages: {} };
    }
  }
  loadPackageConfig(packagePath, version) {
    const configFilePath = this.fs.join(packagePath, NGCC_CONFIG_FILENAME);
    if (this.fs.exists(configFilePath)) {
      try {
        const packageConfig = this.evalSrcFile(configFilePath);
        return {
          ...packageConfig,
          versionRange: version || "*"
        };
      } catch (e) {
        throw new Error(`Invalid package configuration file at "${configFilePath}": ` + e.message);
      }
    } else {
      return null;
    }
  }
  evalSrcFile(srcPath) {
    const requireFn = isCommonJS ? __require : module5.createRequire(currentFileUrl);
    const src = this.fs.readFile(srcPath);
    const theExports = {};
    const sandbox = {
      module: { exports: theExports },
      exports: theExports,
      require: requireFn,
      __dirname: this.fs.dirname(srcPath),
      __filename: srcPath
    };
    vm.runInNewContext(src, sandbox, { filename: srcPath });
    return sandbox.module.exports;
  }
  computeHash() {
    return createHash(this.hashAlgorithm).update(this.projectConfig.toJson()).digest("hex");
  }
};

// bazel-out/k8-fastbuild/bin/packages/compiler-cli/ngcc/src/packages/entry_point_manifest.mjs
import { createHash as createHash2 } from "crypto";
var EntryPointManifest = class {
  constructor(fs, config, logger) {
    this.fs = fs;
    this.config = config;
    this.logger = logger;
  }
  readEntryPointsUsingManifest(basePath) {
    try {
      if (this.fs.basename(basePath) !== "node_modules") {
        return null;
      }
      const manifestPath = this.getEntryPointManifestPath(basePath);
      if (!this.fs.exists(manifestPath)) {
        return null;
      }
      const computedLockFileHash = this.computeLockFileHash(basePath);
      if (computedLockFileHash === null) {
        return null;
      }
      const { ngccVersion, configFileHash, lockFileHash, entryPointPaths } = JSON.parse(this.fs.readFile(manifestPath));
      if (ngccVersion !== NGCC_VERSION || configFileHash !== this.config.hash || lockFileHash !== computedLockFileHash) {
        return null;
      }
      this.logger.debug(`Entry-point manifest found for ${basePath} so loading entry-point information directly.`);
      const startTime = Date.now();
      const entryPoints = [];
      for (const [packagePath, entryPointPath, dependencyPaths = [], missingPaths = [], deepImportPaths = []] of entryPointPaths) {
        const result = getEntryPointInfo(this.fs, this.config, this.logger, this.fs.resolve(basePath, packagePath), thi