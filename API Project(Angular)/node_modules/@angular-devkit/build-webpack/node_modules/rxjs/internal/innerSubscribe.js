  const host = new EsmDependencyHost(this.fs, moduleResolver);
    const dependencies = createDependencyInfo();
    const rootFiles = this.tsConfig.rootNames.map((rootName) => this.fs.resolve(rootName));
    this.logger.debug(`Using the program from ${this.tsConfig.project} to seed the entry-point finding.`);
    this.logger.debug(`Collecting dependencies from the following files:` + rootFiles.map((file) => `
- ${file}`));
    host.collectDependenciesInFiles(rootFiles, dependencies);
    return Array.from(dependencies.dependencies);
  }
  getEntryPointWithDeps(entryPointPath) {
    const entryPoints = this.findOrLoadEntryPoints();
    if (!entryPoints.has(entryPointPath)) {
      return null;
    }
    const entryPointWithDeps = entryPoints.get(entryPointPath);
    if (!entryPointWithDeps.entryPoint.compiledByAngular) {
      return null;
    }
    return entryPointWithDeps;
  }
  findOrLoadEntryPoints() {
    if (this.entryPointsWithDependencies === null) {
      const entryPointsWithDependencies = this.entryPointsWithDependencies = /* @__PURE__ */ new Map();
      for (const basePath of this.getBasePaths()) {
        const entryPoints = this.entryPointManifest.readEntryPointsUsingManifest(basePath) || this.walkBasePathForPackages(basePath);
        for (const e of entryPoints) {
          entryPointsWithDependencies.set(e.entryPoint.path, e);
        }
      }
    }
    return this.entryPointsWithDependencies;
  }
  walkBasePathForPackages(basePath) {
    this.logger.debug(`No manifest found for ${basePath} so walking the directories for entry-points.`);
    const entryPoints = trackDuration(() => this.entryPointCollector.walkDirectoryForPackages(basePath), (duration) => this.logger.debug(`Walking ${basePath} for entry-points took ${duration}s.`));
    this.entryPointManifest.writeEntryPointManifest(basePath, entryPoints);
    return entryPoints;
  }
};

// bazel-out/k8-fastbuild/bin/packages/compiler-cli/ngcc/src/packages/build_marker.mjs
var NGCC_VERSION = "14.1.0";
function needsCleaning(packageJson) {
  return Object.values(packageJson.__processed_by_ivy_ngcc__ || {}).some((value) => value !== NGCC_VERSION);
}
function cleanPackageJson(packageJson) {
  if (packageJson.__processed_by_ivy_ngcc__ !== void 0) {
    delete packageJson.__processed_by_ivy_ngcc__;
    for (const prop of Object.keys(packageJson)) {
      if (prop.endsWith(NGCC_PROPERTY_EXTENSION)) {
        delete packageJson[prop];
      }
    }
    const scripts = packageJson.scripts;
    if (scripts !== void 0 && scripts.prepublishOnly) {
      delete scripts.prepublishOnly;
      if (scripts.prepublishOnly__ivy_ngcc_bak !== void 0) {
        scripts.prepublishOnly = scripts.prepublishOnly__ivy_ngcc_bak;
        delete scripts.prepublishOnly__ivy_ngcc_bak;
      }
    }
    return true;
  }
  return false;
}
function hasBeenProcessed(packageJson, format) {
  return packageJson.__processed_by_ivy_ngcc__ !== void 0 && packageJson.__processed_by_ivy_ngcc__[format] === NGCC_VERSION;
}
function markAsProcessed(pkgJsonUpdater, packageJson, packageJsonPath, formatProperties) {
  const update = pkgJsonUpdater.createUpdate();
  for (const prop of formatProperties) {
    update.addChange(["__processed_by_ivy_ngcc__", prop], NGCC_VERSION, "alphabetic");
  }
  const oldPrepublishOnly = packageJson.scripts && packageJson.scripts.prepublishOnly;
  const newPrepublishOnly = `node --eval "console.error('ERROR: Trying to publish a package that has been compiled by NGCC. This is not allowed.\\nPlease delete and rebuild the package, without compiling with NGCC, before attempting to publish.\\nNote that NGCC may have been run by importing this package into another project that is being built with Ivy enabled.\\n')" && exit 1`;
  if (oldPrepublishOnly && oldPrepublishOnly !== newPrepublishOnly) {
    update.addChange(["scripts", "prepublishOnly__ivy_ngcc_bak"], oldPrepublishOnly);
  }
  update.addChange(["scripts", "prepublishOnly"], newPrepublishOnly);
  update.writeChanges(packageJsonPath, packageJson);
}

// bazel-out/k8-fastbuild/bin/packages/compiler-cli/ngcc/src/entry_point_finder/targeted_entry_point_finder.mjs
var TargetedEntryPointFinder = class extends TracingEntryPointFinder {
  constructor(fs, config, logger, resolver, basePath, pathMappings, targetPath) {
    super(fs, config, logger, resolver, basePath, pathMappings);
    this.target