ined,
  assertT: Assert<Input, Output>,
  message = expectedToBe("option of given type"),
): asserts input is SubType<Input, Output | undefined> {
  if (input === undefined) {
    return;
  }
  assertT(input, message);
}

export function isOneOf<Input, Output>(
  input: Input,
  values: readonly Output[],
  message: string = expectedToBe(`one of ${values.join(", ")}`),
): asserts input is SubType<Input, Output> {
  assert(values.includes(input as SubType<Input, Output>), message);
}

export function isOneOfType<T>(
  input: unknown,
  assertT: Assert<unknown, T>[],
  message: string = expectedToBe(`one of type`),
  itemMessage?: string,
): asserts input is T {
  for (const assert of assertT) {
    try {
      (assert as WeakAssert)(input as T, itemMessage);
      return;
 