nstructions generated\n * for these attributes/properties/bindings must be done so in the correct order. The\n * order which these must be generated is as follows:\n *\n * if (createMode) {\n *   styling(...)\n * }\n * if (updateMode) {\n *   styleMap(...)\n *   classMap(...)\n *   styleProp(...)\n *   classProp(...)\n * }\n *\n * The creation/update methods within the builder class produce these instructions.\n */\nexport class StylingBuilder {\n  /** Whether or not there are any static styling values present */\n  private _hasInitialValues = false;\n  /**\n   *  Whether or not there are any styling bindings present\n   *  (i.e. `[style]`, `[class]`, `[style.prop]` or `[class.name]`)\n   */\n  public hasBindings = false;\n  public hasBindingsWithPipes = false;\n\n  /** the input for [class] (if it exists) */\n  private _classMapInput: BoundStylingEntry|null = null;\n  /** the input for [style] (if it exists) */\n  private _styleMapInput: BoundStylingEntry|null = null;\n  /** an array of each [style.prop] input */\n  private _singleStyleInputs: BoundStylingEntry[]|null = null;\n  /** an array of each [class.name] input */\n  private _singleClassInputs: BoundStylingEntry[]|null = null;\n  private _lastStylingInput: BoundStylingEntry|null = null;\n  private _firstStylingInput: BoundStylingEntry|null = null;\n\n  // maps are used instead of hash maps because a Map will\n  // retain the ordering of the keys\n\n  /**\n   * Represents the location of each style binding in the template\n   * (e.g. `<div [style.width]=\"w\" [style.height]=\"h\">` implies\n   * that `width=0` and `height=1`)\n   */\n  private _stylesIndex = new Map<string, number>();\n\n  /**\n   * Represents the location of each class binding in the template\n   * (e.g. `<div [class.big]=\"b\" [class.hidden]=\"h\">` implies\n   * that `big=0` and `hidden=1`)\n   */\n  private _classesIndex = new Map<string, number>();\n  private _initialStyleValues: string[] = [];\n  private _initialClassValues: string[] = [];\n\n  constructor(private _directiveExpr: o.Expression|null) {}\n\n  /**\n   * Registers a given input to the styling builder to be later used when producing AOT code.\n   *\n   * The code below will only accept the input if it is somehow tied to styling (whether it be\n   * style/class bindings or static style/class attributes).\n   */\n  registerBoundInput(input: t.BoundAttribute): boolean {\n    // [attr.style] or [attr.class] are skipped in the code below,\n    // they should not be treated as styling-based bindings since\n    // they are intended to be written directly to the attr and\n    // will therefore skip all style/class resolution that is present\n    // with style=\"\", [style]=\"\" and [style.prop]=\"\", class=\"\",\n    // [class.prop]=\"\". [class]=\"\" assignments\n    let binding: BoundStylingEntry|null = null;\n    let name = input.name;\n    switch (input.type) {\n      case BindingType.Property:\n        binding = this.registerInputBasedOnName(name, input.value, input.sourceSpan);\n        break;\n      case BindingType.Style:\n        binding = this.registerStyleInput(name, false, input.value, input.sourceSpan, input.unit);\n        break;\n      case BindingType.Class:\n        binding = this.registerClassInput(name, false, input.value, input.sourceSpan);\n        break;\n    }\n    return binding ? true : false;\n  }\n\n  registerInputBasedOnName(name: string, expression: AST, sourceSpan: ParseSourceSpan) {\n    let binding: BoundStylingEntry|null = null;\n    const prefix = name.substring(0, 6);\n    const isStyle = name === 'style' || prefix === 'style.' || prefix === 'style!';\n    const isClass = !isStyle && (name === 'class' || prefix === 'class.' || prefix === 'class!');\n    if (isStyle || isClass) {\n      const isMapBased = name.charAt(5) !== '.';        // style.prop or class.prop makes this a no\n      const property = name.slice(isMapBased ? 5 : 6);  // the dot explains why there's a +1\n      if (isStyle) {\n        binding = this.registerStyleInput(property, isMapBased, expression, sourceSpan);\n      } else {\n        binding = this.registerClassInput(property, isMapBased, expression, sourceSpan);\n      }\n    }\n    return binding;\n  }\n\n  registerStyleInput(\n      name: string, isMapBased: boolean, value: AST, sourceSpan: ParseSourceSpan,\n      suffix?: string|null): BoundStylingEntry|null {\n    if (isEmptyExpression(value)) {\n      return null;\n    }\n    // CSS custom properties are case-sensitive so we shouldn't normalize them.\n    // See: https://www.w3.org/TR/css-variables-1/#defining-variables\n    if (!isCssCustomProperty(name)) {\n      name = hyphenate(name);\n    }\n    const {property, hasOverrideFlag, suffix: bindingSuffix} = parseProperty(name);\n    suffix = typeof suffix === 'string' && suffix.length !== 0 ? suffix : bindingSuffix;\n    const entry:\n        BoundStylingEntry = {name: property, suffix: suff