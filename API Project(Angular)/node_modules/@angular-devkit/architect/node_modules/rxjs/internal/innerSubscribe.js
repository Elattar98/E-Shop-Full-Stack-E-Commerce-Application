et container = this.fs.dirname(path);
    while (path !== container) {
      segments.unshift(this.fs.basename(path));
      path = container;
      container = this.fs.dirname(container);
    }
    return segments;
  }
};

// bazel-out/k8-fastbuild/bin/packages/compiler-cli/ngcc/src/execution/tasks/queues/base_task_queue.mjs
var BaseTaskQueue = class {
  constructor(logger, tasks, dependencies) {
    this.logger = logger;
    this.tasks = tasks;
    this.dependencies = dependencies;
    this.inProgressTasks = /* @__PURE__ */ new Set();
    this.tasksToSkip = /* @__PURE__ */ new Map();
  }
  get allTasksCompleted() {
    return this.tasks.length === 0 && this.inProgressTasks.size === 0;
  }
  getNextTask() {
    let nextTask = this.computeNextTask();
    while (nextTask !== null) {
      if (!this.tasksToSkip.has(nextTask)) {
        break;
      }
      this.markAsCompleted(nextTask);
      const failedTask = this.tasksToSkip.get(nextTask);
      this.logger.warn(`Skipping processing of ${nextTask.entryPoint.name} because its dependency ${failedTask.entryPoint.name} failed to compile.`);
      nextTask = this.computeNextTask();
    }
    return nextTask;
  }
  markAsCompleted(task) {
    if (!this.inProgressTasks.has(task)) {
      throw new Error(`Trying to mark task that was not in progress as completed: ${stringifyTask(task)}`);
    }
    this.inProgressTasks.delete(task);
  }
  markAsFailed(task) {
    if (this.dependencies.has(task)) {
      for (const dependentTask of this.dependencies.get(task)) {
        this.skipDependentTasks(dependentTask, task);
      }
    }
  }
  markAsUnprocessed(task) {
    if (!this.inProgressTasks.has(task)) {
      throw new Error(`Trying to mark task that was not in progress as unprocessed: ${stringifyTask(task)}`);
    }
    this.inProgressTasks.delete(task);
    this.tasks.unshift(task);
  }
  toString() {
    const inProgTasks = Array.from(this.inProgressTasks);
    return `${this.constructor.name}
  All tasks completed: ${this.allTasksCompleted}
  Unprocessed tasks (${this.tasks.length}): ${this.stringifyTasks(this.tasks, "    ")}
  In-progress tasks (${inProgTasks.length}): ${this.stringifyTasks(inProgTasks, "    ")}`;
  }
  skipDependentTasks(task, failedTask) {
    this.tasksToSkip.set(task, failedTask);
    if (this.dependencies.has(task)) {
      for (const dependentTask of this.dependencies.get(task)) {
        this.skipDependentTasks(dependentTask, failedTask);
      }
    }
  }
  stringifyTasks(tasks, indentation) {
    return tasks.map((task) => `
${indentation}- ${stringifyTask(task)}`).join("");
  }
};

// bazel-out/k8-fastbuild/bin/packages/compiler-cli/ngcc/src/execution/tasks/queues/parallel_task_queue.mjs
var ParallelTaskQueue = class extends BaseTaskQueue {
  constructor(logger, tasks, dependencies) {
    super(logger, sortTasksByPriority(tasks, dependencies), dependencies);
    this.blockedTasks = getBlockedTasks(dependencies);
  }
  computeNextTask() {
    const nextTaskIdx = this.tasks.findIndex((task) => !this.blockedTasks.has(task));
    if (nextTaskIdx === -1)
      return null;
    const nextTask = this.tasks[nextTaskIdx];
    this.tasks.splice(nextTaskIdx, 1);
    this.inProgressTasks.add(nextTask);
    return nextTask;
  }
  markAsCompleted(task) {
    super.markAsCompleted(task);
    if (!this.dependencies.has(task)) {
      return;
    }
    for (const dependentTask of this.dependencies.get(task)) {
      if (this.blockedTasks.has(dependentTask)) {
        const blockingTasks = this.blockedTasks.get(dependentTask);
        blockingTasks.delete(task);
        if (blockingTasks.size === 0) {
          this.blockedTasks.delete(dependentTask);
        }
      }
    }
  }
  toString() {
    return `${super.toString()}
  Blocked tasks (${this.blockedTasks.size}): ${this.stringifyBlockedTasks("    ")}`;
  }
  stringifyBlockedTasks(indentation) {
    return Array.from(this.blockedTasks).map(([task, blockingTasks]) => `
${indentation}- ${stringifyTask(task)} (${blockingTasks.size}): ` + this.stringifyTasks(Array.from(blockingTasks), `${indentation}    `)).join("");
  }
};

// bazel-out/k8-fastbuild/bin/packages/compiler-cli/ngcc/src/execution/tasks/queues/serial_task_queue.mjs
var SerialTaskQueue = class extends BaseTaskQueue {
  computeNextTask() {
    const nextTask = this.tasks.shift() || null;
    if (nextTask) {
      if (this.in