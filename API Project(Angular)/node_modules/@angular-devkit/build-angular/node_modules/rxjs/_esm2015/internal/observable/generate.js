ollowing members:

1. `description`. The description of the job. Its name and schemas.
1. `scheduler`. A `Scheduler<>` instance that can be used to create additional jobs.
1. `dependencies`. A generic list of other job instances that were run as dependencies when
   scheduling this job. Their `id` is not guaranteed to match the `id` of the `Job<>` instance
   itself (those `Job<>`s might just be proxies). The state of those `Job<>` is guaranteed to be
   `JobState.Ended`, as `JobState.Errored` would have prevented this handler from running.
1. `inboundBus`. The raw input observable, complement of the `inboundBus` observer from the `Job<>`.

# Examples

An example of a job that adds all input together and return the output value. We use a
simple synchronous job registry and a simple job scheduler.

```typescript
import { jobs } from '@angular-devkit/core';

const add = jobs.createJobHandle<number[], number>((input) =>
  input.reduce((total, curr) => total + curr, 0),
);

// Register the job in a SimpleJobRegistry. Different registries have different API.
const registry = new jobs.SimpleJobRegistry();
const scheduler = new jobs.SimpleScheduler(registry);
registry.register(add, {
  name: 'add',
  input: { type: 'array', items: { type: 'number' } },
  output: { type: 'number' },
});

scheduler
  .schedule('add', [1, 2, 3, 4])
  .promise.then((output) => console.log('1 + 2 + 3 + 4 is ' + output));
```

# Creating Jobs

A job is at its core a function with a description object attached to it. The description object
stores the JSON schemas used to validate the types of the argument passed in, the input and
output values. By default, a job accepts and can output any JSON object.

```typescript
import { Observable } from 'rxjs';
import { jobs } from '@angular-devkit/core';

const argument = {
  type: 'array',
  items: { type: 'number' },
};
const output = {
  type: 'number',
};

export function add(argument: number[]): Observable<jobs.JobOutboundMessage<number>> {
  return new Observable((o) => {
    o.next({ kind: jobs.JobOutboundMessageKind.Start });
    o.next({
      kind: jobs.JobOutboundMessageKind.Output,
      output: argument.reduce((total, curr) => total + curr, 0),
    });
    o.next({ kind: jobs.JobOutboundMessageKind.End });
    o.complete();
  });
}

// Add a property to `add` to make it officially a JobHandler. The Job system does not recognize
// any function as a JobHandler.
add.jobDescription = {
  argument: argument,
  output: output,
};

// Call the job with an array as argument, and log its output.
declare const scheduler: jobs.Scheduler;
scheduler.schedule('add', [1, 2, 3, 4]).output.subscribe((x) => console.log(x)); // Will output 10.
```

This is a lot of boilerplate, so we made some helpers to improve readability and manage argument,
input and output automatically:

```typescript
// Add is a JobHandler function, like the above.
export const add = jobs.createJobHandler<number[], number>((argument) =>
  argument.reduce((total, curr) => total + curr, 0),
);

// Schedule like above.
```

You can also return a Promise or an Observable, as jobs are asynchronous. This helper will set
start and end messages appropriately. It will also manage channels automatically (see below).

A more complex job can be declared like this:

```typescript
import { Observable } from 'rxjs';
import { jobs } from '@angular-devkit/core';

// Show progress with each count in a separate output channel. Output "more" in a c