ingDirectory(fs, path) {
  return fs.exists(path) && fs.stat(path).isDirectory();
}
function extractPathPrefix(path) {
  const [prefix, rest] = path.split("*", 2);
  return { prefix, hasWildcard: rest !== void 0 };
}
function trackDuration(task, log) {
  const startTime = Date.now();
  const result = task();
  const duration = Math.round((Date.now() - startTime) / 100) / 10;
  log(duration);
  return result;
}
function dedupePaths(fs, paths) {
  const root = { children: /* @__PURE__ */ new Map() };
  for (const path of paths) {
    addPath(fs, root, path);
  }
  return flattenTree(root);
}
function addPath(fs, root, path) {
  let node = root;
  if (!fs.isRoot(path)) {
    const segments = path.split("/");
    for (let index = 0; index < segments.length; index++) {
      if (isLeaf(node)) {
        return;
      }
      const next = segments[index];
      if (!node.children.has(next)) {
        node.children.set(next, { children: /* @__PURE__ */ new Map() });
      }
      node = node.children.get(next);
    }
  }
  convertToLeaf(node, path);
}
function flattenTree(root) {
  const paths = [];
  const nodes = [root];
  for (let index = 0; index < nodes.length; index++) {
    const node = nodes[index];
    if (isLeaf(node)) {
      paths.push(node.path);
    } else {
      node.children.forEach((value) => nodes.push(value));
    }
  }
  return paths;
}
function isLeaf(node) {
  return node.path !== void 0;
}
function convertToLeaf(node, path) {
  node.path = path;
}

// bazel-out/k8-fastbuild/bin/packages/compiler-cli/ngcc/src/entry_point_finder/directory_walker_entry_point_finder.mjs
var DirectoryWalkerEntryPointFinder = class {
  constructor(logger, resolver, entryPointCollector, entryPointManifest, sourceDirectory, pathMappings) {
    this.logger = logger;
    this.resolver = resolver;
    this.entryPointCollector = entryPointCollector;
    this.entryPointManifest = entryPointManifest;
    this.sourceDirectory = sourceDirectory;
    this.pathMappings = pathMappings;
    this.basePaths = getBasePaths(this.logger, this.sourceDirectory, this.pathMappings);
  }
  findEntryPoints() {
    const unsortedEntryPoints = [];
    for (const basePath of this.basePaths) {
      const entryPoints = this.entryPointManifest.readEntryPointsUsingManifest(basePath) || this.walkBasePathForPackages(basePath);
      entryPoints.forEach((e) => unsortedEntryPoints.push(e));
    }
    return this.resolver.sortEntryPointsByDependency(unsortedEntryPoints);
  }
  walkBasePathForPackages(basePath) {
    this.logger.debug(`No manifest found for ${basePath} so walking the directories for entry-points.`);
    const entryPoints = trackDuration(() => this.entryPointCollector.walkDirectoryForPackages(basePath), (duration) => this.logger.debug(`Walking ${basePath} for entry-points took ${duration}s.`));
    this.entryPointManifest.writeEntryPointManifest(basePath, entryPoints);
    return entryPoints;
  }
};

// bazel-out/k8-fastbuild/bin/packages/compiler-cli/ngcc/src/entry_point_finder/entry_point_collector.mjs
var EntryPointCollector = class {
  constructor(fs, config, logger, resolver) {
    this.fs = fs;
    this.config = config;
    this.logger = logger;
    this.resolver = resolver;
  }
  walkDirectoryForPackages(sourceDirectory) {
    const primaryEntryPoint = getEntryPointInfo(this.fs, this.config, this.logger, sourceDirectory, sourceDirectory);
    if (primaryEntryPoint === INCOMPATIBLE_ENTRY_POINT) {
      return [];
    }
    const entryPoints = [];
    if (primaryEntryPoint !== NO_ENTRY_POINT) {
      if (primaryEntryPoint !== IGNORED_ENTRY_POINT) {
        entryPoints.push(this.resolver.getEntryPointWithDependencies(primaryEntryPoint));
      }
      this.collectSecondaryEntryPoints(entryPoints, sourceDirectory, sourceDirectory, this.fs.readdir(sourceDirectory));
      if (entryPoints.some((e) => e.entryPoint.compiledByAngular)) {
        const nestedNodeModulesPath = this.fs.join(sourceDirectory, "node_modules");
        if (this.fs.exists(nestedNodeModulesPath)) {
          entryPoints.push(...this.walkDirectoryForPackages(nestedNodeModulesPath));
        }
      }
      return entryPoints;
    }
    for (const path of this.fs.readdir(sourceDirectory)) {
      if (isIgnorablePath(path)) {
        continue;
      }
      const absolutePath = this.fs.resolve(sourceDirectory, path);
      const stat = this.fs.lstat(a