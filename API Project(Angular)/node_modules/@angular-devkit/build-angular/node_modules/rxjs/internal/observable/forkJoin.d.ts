n\n  peek(offset: number): Token {\n    const i = this.index + offset;\n    return i < this.tokens.length ? this.tokens[i] : EOF;\n  }\n\n  get next(): Token {\n    return this.peek(0);\n  }\n\n  /** Whether all the parser input has been processed. */\n  get atEOF(): boolean {\n    return this.index >= this.tokens.length;\n  }\n\n  /**\n   * Index of the next token to be processed, or the end of the last token if all have been\n   * processed.\n   */\n  get inputIndex(): number {\n    return this.atEOF ? this.currentEndIndex : this.next.index + this.offset;\n  }\n\n  /**\n   * End index of the last processed token, or the start of the first token if none have been\n   * processed.\n   */\n  get currentEndIndex(): number {\n    if (this.index > 0) {\n      const curToken = this.peek(-1);\n      return curToken.end + this.offset;\n    }\n    // No tokens have been processed yet; return the next token's start or the length of the input\n    // if there is no token.\n    if (this.tokens.length === 0) {\n      return this.input.length + this.offset;\n    }\n    return this.next.index + this.offset;\n  }\n\n  /**\n   * Returns the absolute offset of the start of the current token.\n   */\n  get currentAbsoluteOffset(): number {\n    return this.absoluteOffset + this.inputIndex;\n  }\n\n  /**\n   * Retrieve a `ParseSpan` from `start` to the current position (or to `artificialEndIndex` if\n   * provided).\n   *\n   * @param start Position from which the `ParseSpan` will start.\n   * @param artificialEndIndex Optional ending index to be used if provided (and if greater than the\n   *     natural ending index)\n   */\n  span(start: number, artificialEndIndex?: number): ParseSpan {\n    let endIndex = this.currentEndIndex;\n    if (artificialEndIndex !== undefined && artificialEndIndex > this.currentEndIndex) {\n      endIndex = artificialEndIndex;\n    }\n\n    // In some unusual parsing scenarios (like when certain tokens are missing and an `EmptyExpr` is\n    // being created), the current token may already be advanced beyond the `currentEndIndex`. This\n    // appears to be a deep-seated parser bug.\n    //\n    // As a workaround for now, swap the start and end indices to ensure a valid `ParseSpan`.\n    // TODO(alxhub): fix the bug upstream in the parser state, and remove this workaround.\n    if (start > endIndex) {\n      const tmp = endIndex;\n      endIndex = start;\n      start = tmp;\n    }\n\n    return new ParseSpan(start, endIndex);\n  }\n\n  sourceSpan(start: number, artificialEndIndex?: number): AbsoluteSourceSpan {\n    const serial = `${start}@${this.inputIndex}:${artificialEndIndex}`;\n    if (!this.sourceSpanCache.has(serial)) {\n      this.sourceSpanCache.set(\n          serial, this.span(start, artificialEndIndex).toAbsolute(this.absoluteOffset));\n    }\n    return this.sourceSpanCache.get(serial)!;\n  }\n\n  advance() {\n    this.index++;\n  }\n\n  /**\n   * Executes a callback in the provided context.\n   */\n  private withContext<T>(context: ParseContextFlags, cb: () => T): T {\n    this.context |= context;\n    const ret = cb();\n    this.context ^= context;\n    return ret;\n  }