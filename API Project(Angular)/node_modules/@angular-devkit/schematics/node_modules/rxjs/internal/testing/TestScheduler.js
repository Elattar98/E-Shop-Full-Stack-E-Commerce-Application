   setTimeout(doCount, 100);
    }),
  {
    argument: { type: 'number' },
    output: { type: 'number' },
  },
);

// Get a hold of a scheduler that refers to the job above.
declare const scheduler: jobs.Scheduler;

const job = scheduler.schedule('count', 0);
job.getChannel('side').subscribe((x) => console.log(x));
// You can type a channel too. Messages will be filtered out.
job
  .getChannel<number>('progress', { type: 'number' })
  .subscribe((x) => console.log(x));
```

## <a name="Communicating"></a>Communicating With Jobs

Jobs can be started and updated in a separate process or thread, and as such communication with a
job should avoid using global objects (which might not be shared). The jobs API and schedulers
provide 2 communication streams (one for input and the other for output), named `inboundBus` and
`outboundBus`.

### Raw Input Stream

The `schedule()` function returns a `Job<>` interface that contains a `inboundBus` member of type
`Observer<JobInboundMessage>`. All messages sent _to_ the job goes through this stream. The `kind`
member of the `JobInboundMessage` interface dictates what kind of message it is sending:

1. `JobInboundMessageKind.Ping`. A simple message that should be answered with
   `JobOutboundMessageKind.Pong` when the job is responsive. The `id` field of the message should
   be used when returning `Pong`.
1. `JobInboundMessageKind.Stop`. The job should be stopped. This is used when
   cancelling/unsubscribing from the `output` (or by calling `stop()`). Any inputs or outputs
   after this message will be ignored.
1. `JobInboundMessageKind.Input` is used when sending inputs to a job. These correspond to the
   `next` methods of an `Observer` and are reported to the job through its `context.input`
   Observable. There is no way to communicate an error to the job.

Using the `createJobHandler()` helper, all those messages are automatically handled by the
boilerplate code. If you need direct access to raw inputs, you should subscribe to the
`context.inboundBus` Observable.

### Raw Output Stream

The `Job<>` interface also contains a `outboundBus` member (of type
`Observable<JobOutboundMessage<O>>` where `O` is the typed output of the job) which is the output
complement of `inboundBus`. All messages sent _from_ the job goes through this stream. The `kind`
member of the `JobOutboundMessage<O>` interface dictates what kind of message it is sending:

1. `JobOutboundMessageKind.Create`. The `Job<>` was created, its dependencies are done, and the
   library is validating Argument and calling the internal job code.
1. `JobOutboundMessageKind.Start`. The job code itself should send that message when started.
   `createJobHandler()` will do it automatically.
1. `JobOutboundMessageKind.End`. The job has ended. This is done by the job itself and should always
   be sent when completed. The scheduler will listen to this message to set the state and unblock
   dependent jobs. `createJobHandler()` automatically send this message.
1. `JobOutboundMessageKind.Pong`. The job should answer a `JobInboundMessageKind.Ping` message with
   this. Automatically done by `createJobHandler()`.
1. `JobOutboundMessageKind.Output`. An `Output` has been generated by the job.
1. `JobOutboundMessageKind.ChannelMessage`, `JobOutboundMessageKind.ChannelError` and
   `JobOutboundMessageKind.ChannelComplete` are used for output channels. These correspond to the
   `next`, `error` and `complete` methods of an `Observer` and are available to the callee through
   the `job.channels` map of Observable.

Those messages can be accessed directly through the `job.outboundBus` member. The job itself should
return an `Observable<JobOutboundMessage<O>>`. The `createJobHandler()` helper handles most of use
cases of this and makes it easier for jobs to handle this.

## Job Dispatchers

Dispatchers are a helper that redirect to different jobs given conditions. To create a job
dispatcher, use the `createDispatcher()` function:

```typescript
import { jobs } from '@angular-devkit/core';

// A dispatcher that installs node modules given a user's preference.
const dispatcher = jobs.createDispatcher({
  name: 'node-install',
  argument: { properties: { moduleName: { type: 'string' } } },
  output: { type: 'boolean' },
});

const npmInstall = jobs.createJobHandler(/* ... */, { name: 'npm-install' });
const yarnInstall = jobs.createJobHandler(/* ... */, { name: 'yarn-install' });
const pnpmInstall = jobs.createJobHandler(/* ... */, { name: 'pnpm-install' });

declare const registry: jobs.SimpleJobRegistry;
registry.register(dispatcher);
registry.register(npmInstall);
registry.register(yarnInstall);
registry.register(pnpmInstall);

// Default to npm.
dispatcher.setDefaultDelegate(npmInstall.name);
// If the user is asking for yarn over npm, uses it.
dispatcher.addConditionalDelegate(() => userWantsYarn, yarnInstall.name);
```

## Execution Strategy

Jobs are always run in parallel and will always start, but many helper functions are provided
when creating a job to help you control the execution strategy;

1. `serialize()`. Multiple runs of this job will be queued with each others.
1. `memoize(replayMessages = false)` will create a job, or reuse the same job when inputs are
   matching. If the inputs don't match, a new job will be started and its outputs will be stored.

These strategies can be used when creating the job:

```typescript
// Same input and output as above.

export const add = jobs.strategy.memoize()(
  jobs.createJobHandler<number[], number>((argument) =>
    argument.reduce((total, curr) => total + curr, 0),
  ),
);
```

Strategies can be reused to synchronize between jobs. For example, given jobs `jobA` and `jobB`,
you can reuse the strategy to serialize both jobs together;

```typescript
const strategy = jobs.strategy.serialize();
const jobA = strategy(jobs.createJobHandler(...));
const jobB = strategy(jobs.createJobHandler(...));
```

Even further, we can have package A and package B run in serialization, and B and C also be
serialized. Running A and C will run in parallel, while running B will wait for both A and C
to finish.

```typescript
const strategy1 = jobs.strategy.serialize();
const strategy2 = jobs.strategy.serialize();
const jobA = strategy1(jobs.createJobHandler(...));
const jobB = strategy1(strategy2(jobs.createJobHandler(...)));
const jobC = strategy2(jobs.createJobHandler(...));
```

# Scheduling Jobs

Jobs can be scheduled using a `Scheduler` interface, which contains a `schedule()` method:

```typescript
interface Scheduler {
  /**
   * Schedule a job to be run, using its name.
   * @param name The name of job to be run.
   * @param argument The argument to send to the job when starting it.
   * @param options Scheduling options.
   * @returns The Job being run.
   */
  schedule<I extends MinimumInputValueT, O extends MinimumOutputValueT>(
    name: JobName,
    argument: I,
    options?: ScheduleJobOptions,
  ): Job<JsonValue, O>;
}
```

The scheduler also has a `getDescription()` method to get a `JobDescription` object for a certain
name; that description contains schemas for the argument, input, output, and other channels:

```typescript
interface Scheduler {
  /**
   * Get a job description for a named job.
   *
   * @param name The name of the job.
   * @returns A description, or null if the job cannot be scheduled.
   */
  getDescription(name: JobName): JobDescription | null;

  /**
   * Returns true if the job name has been registered.
   * @param name The name of the job.
   * @returns True if the job exists, false otherwise.
   */
  has(name: JobName): boolean;
}
```

Finally, the scheduler interface has a `pause()` method to stop scheduling. This will queue all
jobs and wait for the unpause function to be called before unblocking all the jobs scheduled.
This does not affect already running jobs.

```typescript
interface Scheduler {
  /**
   * Pause the scheduler, temporary queueing _new_ jobs. Returns a resume function that should be
   * used to resume execution. If multiple `pause()` were called, all their resume functions must
   * be called before the Scheduler actually starts new jobs. Additional calls to the same resume
   * function will have no effect.
   *
   * Jobs already running are NOT paused. This is pausing the scheduler only.
   *
   * @returns A function that can be run to resume the scheduler. If multiple `pause()` calls
   *          were made, all their return function must be called (in any order) before the
   *          scheduler can resume.
   */
  pause(): () => void;
}
```

## <a name="Dependencies"></a>Synchronizing and Dependencies

When scheduling jobs, it is often necessary to run jobs after certain other jobs are finished.
This is done through the `dependencies` options in the `schedule()` method.

These jobs will also be passed to the job being scheduled, through its context. This can be
useful if, for example, the output of those jobs are of a known type, or have known side channels.

An example of this would be a compiler that needs to know the output directory of other compilers
before it, in a tool chain.

### Dependencies

When scheduling jobs, the user can add a `dependencies` field to the scheduling options. The
scheduler will wait for those dependencies to finish before running the job, and pass those jobs
in the context of the job.

### Accessing Dependencies

Jobs are called with a `JobHandlerContext` as a second argument, which contains a
`dependencies: Job<JsonValue>[]` member which contains all dependencies that were used when
scheduling the job. Those aren't fully typed as they are determined by the user, and not the job
itself. They also can contain jobs that are not finished, and the job should use the `state`
member of the job itself before trying to access its content.

### Scheduler Sub Jobs

The `JobHandlerContext` also contains a `scheduler` member which can be used to schedule jobs
using the same scheduler that was used for the job. This allows jobs to call other jobs
and wait for them to end.

## Available Schedulers

The Core Angular DevKit library provides 2 implementations for the `Scheduler` interface:

## SimpleJobRegistry

Available in the jobs namespace. A registry that accept job registration, and can also schedule
jobs.

```typescript
import { jobs } from '@angular-devkit/core';

const add = jobs.createJobHandler<number[], number>((argument) =>
  argument.reduce((total, curr) => total + curr, 0),
);

// Register the job in a SimpleJobRegistry. Different registries have different API.
const registry = new jobs.SimpleJobRegistry();
const scheduler = new SimpleJobScheduler(registry);

registry.register(add, {
  name: 'add',
  argument: { type: 'array', items: { type: 'number' } },
  output: { type: 'number' },
});

scheduler.schedule('add', [1, 2, 3, 4]);
```

## NodeModuleJobRegistry

Available through `@angular-devkit/core/node`.

A scheduler that loads jobs using their node package names. These jobs need to use the
`createJobHandler()` helper and report their argument/input/output schemas that way.

```typescript
declare const registry: NodeModuleJobRegistry;
const scheduler = new SimpleJobScheduler(registry);

scheduler.schedule('some-node-package#someExport', 'input');
```

# Gotchas

1. Deadlocking Dependencies  
   It is impossible to add dependencies to an already running job, but it is entirely possible to
   get locked between jobs. Be aware of your own dependencies.

1. Using `job.promise`  
   `job.promise` waits for the job to ends. Don't rely on it unless you know the job is not
   watching and running for a long time. If you aren't sure, use
   `job.output.pipe(first()).toPromise()` instead which will return the first next output,
   regardless of whether the job watches and rerun or not.

# FAQ

1. Laziness  
   A job is lazy until executed, but its messages will be replayed when resubscribed.

1. Serialize Strategy vs Dependencies  
   Strategies are functions that transform the execution of a job, and can be used when
   declaring the job, or registering it. Dependencies, on the other hand, are listed when
   scheduling a job to order jobs during scheduling.

   A job has no control over the way it's scheduled, and its dependencies. It can, however,
   declare that it shouldn't run at the same time as itself. Alternatively, a user could
   schedule a job twice and imply that the second run should wait for the first to finish. In
   practice, this would be equivalent to having the job be serialized, but the important detail
   is in _whom_ is defining the rules; using the `serialize()` strategy, the job implementation
   is, while when using dependencies, the user is.

   The user does not need to know how to job needs to synchronize with itself, and the job does
   not need to know how it synchronizes with other jobs that it doesn't know about. That's part
   of the strength of this system as every job can be developed in a vacuum, only caring about
   its contracts (argument, input and output) and its own synchronization.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            