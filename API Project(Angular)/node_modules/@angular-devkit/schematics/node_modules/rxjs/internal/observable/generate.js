# Description

Jobs is the Angular DevKit subsystem for scheduling and running generic functions with clearly
typed inputs and outputs. A `Job` instance is a function associated with metadata. You can
schedule a job, synchronize it with other jobs, and use it to schedule other jobs.

The whole API is serializable, allowing you to use a Node Stream or message channel to
communicate between the job and the job scheduler.

Jobs are lazy, cold, and guaranteed to execute exactly once when scheduled. Subscribing to a job
returns messages from the point where the job is at.

## Argument, Input, Output and Channels

A job receives a single argument when scheduled and can also listen to an input channel. It can
emit multiple outputs, and can also provide multiple output channels that emit asynchronous JSON
messages, which can be typed.

The I/O model is like that of an executable, where the argument corresponds to arguments on the
command line, the input channel to STDIN, the output channel to STDOUT, and the channels
would be additional output streams.

## LifeCycle

A `Job` goes through multiple LifeCycle messages before its completion;

1. `JobState.Queued`. The job was queued and is waiting. This is the default state from the
   scheduler.
1. `JobState.Ready`. The job's dependencies (see
   ["Synchronizing and Dependencies"](#Dependencies)) are done running, the argument is
   validated, and the job is ready to execute.
1. `JobState.Started`. The argument has been validated, the job has been called and is running.
   This is handled by the job itself (or `createJobHandler()`).
1. `JobState.Ended`. The job has ended and is done running. This is handled by the job itself (or
   `createJobHandler()`).
1. `JobState.Errored`. A unrecoverable error happened.

Each state (except `Queued`) corresponds to a `JobOutboundMessage` on the `outboundBus` observable
that triggers the state change. The `Scheduler` emits the `Ready` and `Errored` messages; the job
implementation should not emit them, and if it does they are filtered out. You can listen for
these messages or use the corresponding state member.

The job implementation should emit the `Start` and `End` messages when it is starting the job logic
itself. Only the first `Start` and `End` messages will be forwarded. Any more will be filtered out.

The `Queued` state is set as the job is scheduled, so there is no need to listen for the message.

## `Job<OutputType>` Object

The `Job` object that is returned when you schedule a job provides access to the job's status and
utilities for tracking and modifying the job.

1. `id`. A unique symbol that can be used as a Map key.
1. `description`. The description of the job from the scheduler. See `JobDescription` object.
1. `argument`. The argument value that was used to start the job.
1. `input`. An `Observer` that can be used to send validated inputs to the job itself.
1. `output`. An `Observable<OutputType>` that filters out messages to get only the returned output
   of a job.
1. `promise`. A promise that waits for the last output of a job. Returns the last value outputted
   (or no value if there's no last value).
1. `state`. The current state of the job (see `LifeCycle`).
1. `channels`. A map of side channels the user can listen to as `Observable`.
1. `ping()`. A function that can be used to ping the job, receiving a `Promise` for when the ping
   is answered.
1. `stop()`. Sends a `stop` input to the job, which suggests to stop the job. The job itself can
   choose to ignore this message.
1. `inboundBus`. The raw input `Observer<JobInboundMessage>`. This can be used to send messages to
   the `context.inboundBus` observable in the job. These are `JobInboundMessage` messages. See
