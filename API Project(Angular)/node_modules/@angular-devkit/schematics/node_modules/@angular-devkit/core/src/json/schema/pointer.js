  // gets to the point of re-setting the integrity.
    const istream = ssri.integrityStream(this.opts)
    istream.on('integrity', i => this.integrity = i)
    stream.on('error', er => istream.emit('error', er))

    // if not caching this, just pipe through to the istream and return it
    if (!this.opts.cache || !this[_cacheFetches]) {
      return stream.pipe(istream)
    }

    // we have to return a stream that gets ALL the data, and proxies errors,
    // but then pipe from the original tarball stream into the cache as well.
    // To do this without losing any data, and since the cacache put stream
    // is not a passthrough, we have to pipe from the original stream into
    // the cache AFTER we pipe into the istream.  Since the cache stream
    // has an asynchronous flush to write its contents to disk, we need to
    // defer the istream end until the cache stream ends.
    stream.pipe(istream, { end: false })
    const cstream = cacache.put.stream(
      this.opts.cache,
      `pacote:tarball:${this.from}`,
      this.opts
    )
    stream.pipe(cstream)
    // defer istream end until after cstream
    // cache write errors should not crash the fetch, th