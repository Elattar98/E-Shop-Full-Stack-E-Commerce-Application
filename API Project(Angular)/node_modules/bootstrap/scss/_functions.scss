d, opts?: object | null): void;
export function isUnaryLike(node: object | null | undefined, opts?: object | null): node is UnaryLike;
export function assertUnaryLike(node: object | null | undefined, opts?: object | null): void;
export function isUnionTypeAnnotation(node: object | null | undefined, opts?: object | null): node is UnionTypeAnnotation;
export function assertUnionTypeAnnotation(node: object | null | undefined, opts?: object | null): void;
export function isUpdateExpression(node: object | null | undefined, opts?: object | null): node is UpdateExpression;
export function assertUpdateExpression(node: object | null | undefined, opts?: object | null): void;
export function isUserWhitespacable(node: object | null | undefined, opts?: object | null): node is UserWhitespacable;
export function assertUserWhitespacable(node: object | null | undefined, opts?: object | null): void;
export function isV8IntrinsicIdentifier(node: object | null | undefined, opts?: object | null): node is V8IntrinsicIdentifier;
export function assertV8IntrinsicIdentifier(node: object | null | undefined, opts?: object | null): void;
export function isVariableDeclaration(node: object | null | undefined, opts?: object | null): node is VariableDeclaration;
export function assertVariableDeclaration(node: object | null | undefined, opts?: object | null): void;
export function isVariableDeclarator(node: object | null | undefined, opts?: object | null): node is VariableDeclarator;
export function assertVariableDeclarator(node: object | null | undefined, opts?: object | null): void;
export function isVariance(node: object | null | undefined, opts?: object | null): node is Variance;
export function assertVariance(node: object | null | undefined, opts?: object | null): void;
export function isVoidTypeAnnotation(node: object | null | undefined, opts?: object | null): node is VoidTypeAnnotation;
export function assertVoidTypeAnnotation(node: object | null | undefined, opts?: object | null): void;
export function isWhile(node: object | null | undefined, opts?: object | null): node is While;
export function assertWhile(node: object | null | undefined, opts?: object | null): void;
export function isWhileStatement(node: object | null | undefined, opts?: object | null): node is WhileStatement;
export function assertWhileStatement(node: object | null | undefined, opts?: object | null): void;
export function isWithStatement(node: object | null | undefined, opts?: object | null): node is WithStatement;
export function assertWithStatement(node: object | null | undefined, opts?: object | null): void;
export function isYieldExpression(node: object | null | undefined, opts?: object | null): node is YieldExpression;
export function assertYieldExpression(node: object | null | undefined, opts?: object | null): void;
export function assertNode(obj: any): void
export function createTypeAnnotationBasedOnTypeof(type: 'string' | 'number' | 'undefined' | 'boolean' | 'function' | 'object' | 'symbol'): StringTypeAnnotation | VoidTypeAnnotation | NumberTypeAnnotation | BooleanTypeAnnotation | GenericTypeAnnotation
export function createUnionTypeAnnotation<T extends FlowType>(types: [T]): T
export function createFlowUnionType<T extends FlowType>(types: [T]): T
export function createUnionTypeAnnotation(types: ReadonlyArray<FlowType>): UnionTypeAnnotation
export function createFlowUnionType(types: ReadonlyArray<FlowType>): UnionTypeAnnotation
export function buildChildren(node: { children: ReadonlyArray<JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment | JSXEmptyExpression> }): JSXElement['children']
export function clone<T extends Node>(n: T): T;
export function cloneDeep<T extends Node>(n: T): T;
export function cloneDeepWithoutLoc<T extends Node>(n: T): T;
export function cloneNode<T extends Node>(n: T, deep?: boolean, withoutLoc?: boolean): T;
export function cloneWithoutLoc<T extends Node>(n: T): T;
export type CommentTypeShorthand = 'leading' | 'inner' | 'trailing'
export function addComment<T extends Node>(node: T, type: CommentTypeShorthand, content: string, line?: boolean): T
export function addComments<T extends Node>(node: T, type: CommentTypeShorthand, comments: ReadonlyArray<Comment>): T
export function inheritInnerComments(node: Node, parent: Node): void
export function inheritLeadingComments(node: Node, parent: Node): void
export function inheritsComments<T extends Node>(node: T, parent: Node): void
export function inheritTrailingComments(node: Node, parent: Node): void
export function removeComments<T extends Node>(node: T): T
export function ensureBlock(node: Extract<Node, { body: BlockStatement | Statement | Expression }>): BlockStatement
export function ensureBlock<K extends keyof Extract<Node, { body: BlockStatement | Statement | Expression }> = 'body'>(node: Extract<Node, Record<K, BlockStatement | Statement | Expression>>, key: K): BlockStatement
export function toBindingIdentifierName(name: { toString(): string } | null | undefined): string
export function toBlock(node: Statement | Expression, parent?: Function | null): BlockStatement
export function toComputedKey<T extends Extract<Node, { computed: boolean | null }>>(node: T, key?: Expression | Identifier): Expression
export function toExpression(node: Function): FunctionExpression
export function toExpression(node: Class): ClassExpression
export function toExpression(node: ExpressionStatement | Expression | Class | Function): Expression
export function toIdentifier(name: { toString(): string } | null | undefined): string
export function toKeyAlias(node: Method | Property, key?: Node): string
export function toSequenceExpression(nodes: ReadonlyArray<Node>, scope: { push(value: { id: LVal; kind: 'var'; init?: Expression}): void; buildUndefinedNode(): Node }): SequenceExpression | undefined
export function toStatement(node: AssignmentExpression, ignore?: boolean): ExpressionStatement
export function toStatement(node: Statement | AssignmentExpression, ignore?: boolean): Statement
export function toStatement(node: Class, ignore: true): ClassDeclaration | undefined
export function toStatement(node: Class, ignore?: boolean): ClassDeclaration
export function toStatement(node: Function, ignore: true): FunctionDeclaration | undefined
export function toStatement(node: Function, ignore?: boolean): FunctionDeclaration
export function toStatement(node: Statement | Class | Function | AssignmentExpression, ignore: true): Statement | undefined
export function toStatement(node: Statement | Class | Function | AssignmentExpression, ignore?: boolean): Statement
export function valueToNode(value: undefined): Identifier
export function valueToNode(value: boolean): BooleanLiteral
export function valueToNode(value: null): NullLiteral
export function valueToNode(value: string): StringLiteral
export function valueToNode(value: number): NumericLiteral | BinaryExpression | UnaryExpression
export function valueToNode(value: RegExp): RegExpLiteral
export function valueToNode(value: ReadonlyArray<undefined | boolean | null | string | number | RegExp | object>): ArrayExpression
export function valueToNode(value: object): ObjectExpression
export function valueToNode(value: undefined | boolean | null | string | number | RegExp | object): Expression
export function removeTypeDuplicates(types: ReadonlyArray<FlowType | false | null | undefined>): FlowType[]
export function appendToMemberExpression<T extends Pick<MemberExpression, 'object' | 'property'>>(member: T, append: MemberExpression['property'], computed?: boolean): T
export function inherits<T extends Node | null | undefined>(child: T, parent: Node | null | undefined): T
export function prependToMemberExpression<T extends Pick<MemberExpression, 'object' | 'property'>>(member: T, prepend: MemberExpression['object']): T
export function removeProperties(
  n: Node,
  opts?: { preserveComments: boolean } | null
): void;
export function removePropertiesDeep<T extends Node>(
  n: T,
  opts?: { preserveComments: boolean } | null
): T;
export function getBindingIdentifiers(node: Node, duplicates: true, outerOnly?: boolean): Record<string, Array<Identifier>>
export function getBindingIdentifiers(node: Node, duplicates?: false, outerOnly?: boolean): Record<string, Identifier>
export function getBindingIdentifiers(node: Node, duplicates: boolean, outerOnly?: boolean): Record<string, Identifier | Array<Identifier>>
export function getOuterBindingIdentifiers(node: Node, duplicates: true): Record<string, Array<Identifier>>
export function getOuterBindingIdentifiers(node: Node, duplicates?: false): Record<string, Identifier>
export function getOuterBindingIdentifiers(node: Node, duplicates: boolean): Record<string, Identifier | Array<Identifier>>
export type TraversalAncestors = ReadonlyArray<{
  node: Node,
  key: string,
  index?: number,
}>;
export type TraversalHandler<T> = (
  this: undefined, node: Node, parent: TraversalAncestors, type: T
) => void;
export type TraversalHandlers<T> = {
  enter?: TraversalHandler<T>,
  exit?: TraversalHandler<T>,
};
export function traverse<T>(n: Node, h: TraversalHandler<T> | TraversalHandlers<T>, state?: T): void;
export function traverseFast<T>(n: Node, h: TraversalHandler<T>, state?: T): void;
export function shallowEqual<T extends object>(actual: object, expected: T): actual is T
export function buildMatchMemberExpression(match: string, allowPartial?: boolean): (node: Node | null | undefined) => node is MemberExpression
export function is<T extends Node['type']>(type: T, n: Node | null | undefined, required?: undefined): n is Extract<Node, { type: T }>
export function is<T extends Node['type'], P extends Extract<Node, { type: T }>>(type: T, n: Node | null | undefined, required: Partial<P>): n is P
export function is<P extends Node>(type: string, n: Node | null | undefined, required: Partial<P>): n is P
export function is(type: string, n: Node | null | undefined, required?: Partial<Node>): n is Node
export function isBinding(node: Node, parent: Node, grandparent?: Node): boolean
export function isBlockScoped(node: Node): node is FunctionDeclaration | ClassDeclaration | VariableDeclaration
export function isImmutable(node: Node): node is Immutable
export function isLet(node: Node): node is VariableDeclaration
export function isNode(node: object | null | undefined): node is Node
export function isNodesEquivalent<T extends Partial<Node>>(a: T, b: any): b is T
export function isNodesEquivalent(a: any, b: any): boolean
export function isPlaceholderType(placeholderTyp