y<EnumNumberMember>): EnumNumberBody;
export function enumStringBody(members: Array<EnumStringMember | EnumDefaultedMember>): EnumStringBody;
export function enumSymbolBody(members: Array<EnumDefaultedMember>): EnumSymbolBody;
export function enumBooleanMember(id: Identifier): EnumBooleanMember;
export function enumNumberMember(id: Identifier, init: NumericLiteral): EnumNumberMember;
export function enumStringMember(id: Identifier, init: StringLiteral): EnumStringMember;
export function enumDefaultedMember(id: Identifier): EnumDefaultedMember;
export function indexedAccessType(objectType: FlowType, indexType: FlowType): IndexedAccessType;
export function optionalIndexedAccessType(objectType: FlowType, indexType: FlowType): OptionalIndexedAccessType;
export function jsxAttribute(name: JSXIdentifier | JSXNamespacedName, value?: JSXElement | JSXFragment | StringLiteral | JSXExpressionContainer | null): JSXAttribute;
export function jsxClosingElement(name: JSXIdentifier | JSXMemberExpression | JSXNamespacedName): JSXClosingElement;
export function jsxElement(openingElement: JSXOpeningElement, closingElement: JSXClosingElement | null | undefined, children: Array<JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment>, selfClosing?: boolean | null): JSXElement;
export function jsxEmptyExpression(): JSXEmptyExpression;
export function jsxExpressionContainer(expression: Expression | JSXEmptyExpression): JSXExpressionContainer;
export function jsxSpreadChild(expression: Expression): JSXSpreadChild;
export function jsxIdentifier(name: string): JSXIdentifier;
export function jsxMemberExpression(object: JSXMemberExpression | JSXIdentifier, property: JSXIdentifier): JSXMemberExpression;
export function jsxNamespacedName(namespace: JSXIdentifier, name: JSXIdentifier): JSXNamespacedName;
export function jsxOpeningElement(name: JSXIdentifier | JSXMemberExpression | JSXNamespacedName, attributes: Array<JSXAttribute | JSXSpreadAttribute>, selfClosing?: boolean): JSXOpeningElement;
export function jsxSpreadAttribute(argument: Expression): JSXSpreadAttribute;
export function jsxText(value: string): JSXText;
export function jsxFragment(openingFragment: JSXOpeningFragment, closingFragment: JSXClosingFragment, children: Array<JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment>): JSXFragment;
export function jsxOpeningFragment(): JSXOpeningFragment;
export function jsxClosingFragment(): JSXClosingFragment;
export function noop(): Noop;
export function placeholder(expectedNode: "Identifier" | "StringLiteral" | "Expression" | "Statement" | "Declaration" | "BlockStatement" | "ClassBody" | "Pattern", name: Identifier): Placeholder;
export function v8IntrinsicIdentifier(name: string): V8IntrinsicIdentifier;
export function argumentPlaceholder(): ArgumentPlaceholder;
export function bindExpression(object: Expression, callee: Expression): BindExpression;
export function importAttribute(key: Identifier | StringLiteral, value: StringLiteral): ImportAttribute;
export function decorator(expression: Expression): Decorator;
export function doExpression(body: BlockStatement, async?: boolean): DoExpression;
export function exportDefaultSpecifier(exported: Identifier): ExportDefaultSpecifier;
export function recordExpression(properties: Array<ObjectProperty | SpreadElement>): RecordExpression;
export function tupleExpression(elements?: Array<Expression | SpreadElement>): TupleExpression;
export function decimalLiteral(value: string): DecimalLiteral;
export function moduleExpression(body: Program): ModuleExpression;
export function topicReference(): TopicReference;
export function pipelineTopicExpression(expression: Expression): PipelineTopicExpression;
export function pipelineBareFunction(callee: Expression): PipelineBareFunction;
export function pipelinePrimaryTopicReference(): PipelinePrimaryTopicReference;
export function tsParameterProperty(parameter: Identifier | AssignmentPattern): TSParameterProperty;
export function tsDeclareFunction(id: Identifier | null | undefined, typeParameters: TSTypeParameterDeclaration | Noop | null | undefined, params: Array<Identifier | Pattern | RestElement>, returnType?: TSTypeAnnotation | Noop | null): TSDeclareFunction;
export function tsDeclareMethod(decorators: Array<Decorator> | null | undefined, key: Identifier | StringLiteral | NumericLiteral | BigIntLiteral | Expression, typeParameters: TSTypeParameterDeclaration | Noop | null | undefined, params: Array<Identifier | Pattern | RestElement | TSParameterProperty>, returnType?: TSTypeAnnotation | Noop | null): TSDeclareMethod;
export function tsQualifiedName(left: TSEntityName, right: Identifier): TSQualifiedName;
export function tsCallSignatureDeclaration(typeParameters: TSTypeParameterDeclaration | null | undefined, parameters: Array<Identifier | RestElement>, typeAnnotation?: TSTypeAnnotation | null): TSCallSignatureDeclaration;
export function tsConstructSignatureDeclaration(typeParameters: TSTypeParameterDeclaration | null | undefined, parameters: Array<Identifier | RestElement>, typeAnnotation?: TSTypeAnnotation | null): TSConstructSignatureDeclaration;
export function tsPropertySignature(key: Expression, typeAnnotation?: TSTypeAnnotation | null, initializer?: Expression | null): TSPropertySignature;
export function tsMethodSignature(key: Expression, typeParameters: TSTypeParameterDeclaration | null | undefined, parameters: Array<Identifier | RestElement>, typeAnnotation?: TSTypeAnnotation | null): TSMethodSignature;
export function tsIndexSignature(parameters: Array<Identifier>, typeAnnotation?: TSTypeAnnotation | null): TSIndexSignature;
export function tsAnyKeyword(): TSAnyKeyword;
export function tsBooleanKeyword(): TSBooleanKeyword;
export function tsBigIntKeyword(): TSBigIntKeyword;
export function tsIntrinsicKeyword(): TSIntrinsicKeyword;
export function tsNeverKeyword(): TSNeverKeyword;
export function tsNullKeyword(): TSNullKeyword;
export function tsNumberKeyword(): TSNumberKeyword;
export function tsObjectKeyword(): TSObjectKeyword;
export function tsStringKeyword(): TSStringKeyword;
export function tsSymbolKeyword(): TSSymbolKeyword;
export function tsUndefinedKeyword(): TSUndefinedKeyword;
export function tsUnknownKeyword(): TSUnknownKeyword;
export function tsVoidKeyword(): TSVoidKeyword;
export function tsThisType(): TSThisType;
export function tsFunctionType(typeParameters: TSTypeParameterDeclaration | null | undefined, parameters: Array<Identifier | RestElement>, typeAnnotation?: TSTypeAnnotation | null): TSFunctionType;
export function tsConstructorType(typeParameters: TSTypeParameterDeclaration | null | undefined, parameters: Array<Identifier | RestElement>, typeAnnotation?: TSTypeAnnotation | null): TSConstructorType;
export function tsTypeReference(typeName: TSEntityName, typeParameters?: TSTypeParameterInstantiation | null): TSTypeReference;
export function tsTypePredicate(parameterName: Identifier | TSThisType, typeAnnotation?: TSTypeAnnotation | null, asserts?: boolean | null): TSTypePredicate;
export function tsTypeQuery(exprName: TSEntityName | TSImportType, typeParameters?: TSTypeParameterInstantiation | null): TSTypeQuery;
export function tsTypeLiteral(members: Array<TSTypeElement>): TSTypeLiteral;
export function tsArrayType(elementType: TSType): TSArrayType;
export function tsTupleType(elementTypes: Array<TSType | TSNamedTupleMember>): TSTupleType;
export function tsOptionalType(typeAnnotation: TSType): TSOptionalType;
export function tsRestType(typeAnnotation: TSType): TSRestType;
export function tsNamedTupleMember(label: Identifier, elementType: TSType, optional?: boolean): TSNamedTupleMember;
export function tsUnionType(types: Array<TSType>): TSUnionType;
export function tsIntersectionType(types: Array<TSType>): TSIntersectionType;
export function tsConditionalType(checkType: TSType, extendsType: TSType, trueType: TSType, falseType: TSType): TSConditionalType;
export function tsInferType(typeParameter: TSTypeParameter): TSInferType;
export function tsParenthesizedType(typeAnnotation: TSType): TSParenthesizedType;
export function tsTypeOperator(typeAnnotation: TSType): TSTypeOperator;
export function tsIndexedAccessType(objectType: TSType, indexType: TSType): TSIndexedAccessType;
export function tsMappedType(typeParameter: TSTypeParameter, typeAnnotation?: TSType | null, nameType?: TSType | null): TSMappedType;
export function tsLiteralType(literal: NumericLiteral | StringLiteral | BooleanLiteral | BigIntLiteral | TemplateLiteral | UnaryExpression): TSLiteralType;
export function tsExpressionWithTypeArguments(expression: TSEntityName, typeParameters?: TSTypeParameterInstantiation | null): TSExpressionWithTypeArguments;
export function tsInterfaceDeclaration(id: Identifier, typeParameters: TSTypeParameterDeclaration | null | undefined, _extends: Array<TSExpressionWithTypeArguments> | null | undefined, body: TSInterfaceBody): TSInterfaceDeclaration;
export function tsInterfaceBody(body: Array<TSTypeElement>): TSInterfaceBody;
export function tsTypeAliasDeclaration(id: Identifier, typeParameters: TSTypeParameterDeclaration | null | undefined, typeAnnotation: TSType): TSTypeAliasDeclaration;
export function tsInstantiationExpression(expression: Expression, typeParameters?: TSTypeParameterInstantiation | null): TSInstantiationExpression;
export function tsAsExpression(expression: Expression, typeAnnotation: TSType): TSAsExpression;
export function tsTypeAssertion(typeAnnotation: TSType, expression: Expression): TSTypeAssertion;
export function tsEnumDeclaration(id: Identifier, members: Array<TSEnumMember>): TSEnumDeclaration;
export function tsEnumMember(id: Identifier | StringLiteral, initializer?: Expression | null): TSEnumMember;
export function tsModuleDeclaration(id: Identifier | StringLiteral, body: TSModuleBlock | TSModuleDeclaration): TSModuleDeclaration;
export function tsModuleBlock(body: Array<Statement>): TSModuleBlock;
export function tsImportType(argument: StringLiteral, qualifier?: TSEntityNa