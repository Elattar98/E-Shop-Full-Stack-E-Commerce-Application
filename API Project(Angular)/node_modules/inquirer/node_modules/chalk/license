observable.subscribe({
                next: function (x) {
                    var value = x instanceof Observable ? _this.materializeInnerObservable(x, _this.frame) : x;
                    actual.push({ frame: _this.frame, notification: nextNotification(value) });
                },
                error: function (error) {
                    actual.push({ frame: _this.frame, notification: errorNotification(error) });
                },
                complete: function () {
                    actual.push({ frame: _this.frame, notification: COMPLETE_NOTIFICATION });
                },
            });
        }, subscriptionFrame);
        if (unsubscriptionFrame !== Infinity) {
            this.schedule(function () { return subscription.unsubscribe(); }, unsubscriptionFrame);
        }
        this.flushTests.push(flushTest);
        var runMode = this.runMode;
        return {
            toBe: function (marbles, values, errorValue) {
                flushTest.ready = true;
                flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true, runMode);
    