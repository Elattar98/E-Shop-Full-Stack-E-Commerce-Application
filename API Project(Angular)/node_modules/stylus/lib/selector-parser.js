);\n *\n * // you can collapse static segments like this (this works only with the first passed-in value):\n * createUrlTreeFromSnapshot(snapshot, ['/team/33/user', userId]);\n *\n * // If the first segment can contain slashes, and you do not want the router to split it,\n * // you can do the following:\n * createUrlTreeFromSnapshot(snapshot, [{segmentPath: '/one/two'}]);\n *\n * // create /team/33/(user/11//right:chat)\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {outlets: {primary: 'user/11', right:\n * 'chat'}}], null, null);\n *\n * // remove the right secondary node\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n *\n * // For the examples below, assume the current URL is for the `/team/33/user/11` and the\n * `ActivatedRouteSnapshot` points to `user/11`:\n *\n * // navigate to /team/33/user/11/details\n * createUrlTreeFromSnapshot(snapshot, ['details']);\n *\n * // navigate to /team/33/user/22\n * createUrlTreeFromSnapshot(snapshot, ['../22']);\n *\n * // navigate to /team/44/user/22\n * createUrlTreeFromSnapshot(snapshot, ['../../team/44/user/22']);\n * ```\n */\nexport function createUrlTreeFromSnapshot(\n    relativeTo: ActivatedRouteSnapshot, commands: any[], queryParams: Params|null = null,\n    fragment: string|null = null): UrlTree {\n  const relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeTo);\n  return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, queryParams, fragment);\n}\n\nfunction createSegmentGroupFromRoute(route: ActivatedRouteSnapshot): UrlSegmentGroup {\n  let targetGroup: UrlSegmentGroup|undefined;\n\n  function createSegmentGroupFromRouteRecursive(currentRoute: ActivatedRouteSnapshot) {\n    const childOutlets: {[outlet: string]: UrlSegmentGroup} = {};\n    for (const childSnapshot of currentRoute.children) {\n      const root = createSegmentGroupFromRouteRecursive(childSnapshot);\n      childOutlets[childSnapshot.outlet] = root;\n    }\n    const segmentGroup = new UrlSegmentGroup(currentRoute.url, childOutlets);\n    if (currentRoute === route) {\n      targetGroup = segmentGroup;\n    }\n    return segmentGroup;\n  }\n  const rootCandidate = createSegmentGroupFromRouteRecursive(route.root);\n  const rootSegmentGroup = createRoot(rootCandidate);\n\n  return targetGroup ?? rootSegmentGroup;\n}\n\nexport function createUrlTreeFromSegmentGroup(\n    relativeTo: UrlSegmentGroup, commands: any[], queryParams: Params|null,\n    fragment: string|null): UrlTree {\n  let root = relativeTo;\n  while (root.parent) {\n    root = root.parent;\n  }\n  // There are no commands so the `UrlTree` goes to the same path as the one created from the\n  // `UrlSegmentGroup`. All we need to do is update the `queryParams` and `fragment` without\n  // applying any other logic.\n  if (commands.length === 0) {\n    return tree(root, root, root, queryParams, fragment);\n  }\n\n  const nav = computeNavigation(commands);\n\n  if (nav.toRoot()) {\n    return tree(root, root, new UrlSegmentGroup([], {}), queryParams, fragment);\n  }\n\n  const position = findStartingPositionForTargetGroup(nav, root, relativeTo);\n  const newSegmentGroup = position.processChildren ?\n      updateSegmentGroupChildren(position.segmentGroup, position.index, nav.commands) :\n      updateSegmentGroup(position.segmentGroup, position.index, nav.commands);\n  return tree(root, position.segmentGroup, newSegmentGroup, queryParams, fragment);\n}\n\nexport function createUrlTree(\n    route: ActivatedRoute, urlTree: UrlTree, commands: any[], queryParams: Params|null,\n    fragment: string|null): UrlTree {\n  if (commands.length === 0) {\n    return tree(urlTree.root, urlTree.root, urlTree.root, queryParams, fragment);\n  }\n\n  const nav = computeNavigation(commands);\n\n  if (nav.toRoot()) {\n    return tree(urlTree.root, urlTree.root, new UrlSegmentGroup([], {}), queryParams, fragment);\n  }\n\n  function createTreeUsingPathIndex(lastPathIndex: number) {\n    const startingPosition =\n        findStartingPosition(nav, urlTree, route.snapshot?._urlSegment, lastPathIndex);\n\n    const segmentGroup = startingPosition.processChildren ?\n        updateSegmentGroupChildren(\n            startingPosition.segmentGroup, startingPosition.index, nav.commands) :\n        updateSegmentGroup(startingPosition.segmentGroup, startingPosition.index, nav.commands);\n    return tree(urlTree.root, startingPosition.segmentGroup, segmentGroup, queryParams, fragment);\n  }\n  // Note: The types should disallow `snapshot` from being `undefined` but due to test mocks, this\n  // may be the case. Since we try to access it at an earlier point before the refactor to add the\n 