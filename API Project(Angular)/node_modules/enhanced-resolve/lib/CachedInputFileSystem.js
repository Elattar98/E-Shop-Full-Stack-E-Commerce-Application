 combined into a single symbol.
     * When the symbol is recognized as representing an accessor, its declarations are
     * analyzed such that both the setter and getter accessor are returned as separate
     * class members.
     *
     * One difference wrt the TypeScript host is that in ES2015, we cannot see which
     * accessor originally had any decorators applied to them, as decorators are applied
     * to the property descriptor in general, not a specific accessor. If an accessor
     * has both a setter and getter, any decorators are only attached to the setter member.
     *
     * @param symbol the symbol for the member to reflect over.
     * @param decorators an array of decorators associated with the member.
     * @param isStatic true if this member is static, false if it is an instance property.
     * @returns the reflected member information, or null if the symbol is not a member.
     */
    protected reflectMembers(symbol: ts.Symbol, decorators?: Decorator[], isStatic?: boolean): ClassMember[] | null;
    /**
     * Reflect over a symbol and extract the member information, combining it with the
     * provided decorator information, and whether it is a static member.
     * @param node the declaration node for the member to reflect over.
     * @param kind the assumed kind of the member, may become more accurate during reflection.
     * @param decorators an array of decorators associated with the member.
     * @param isStatic true if this member is static, false if it is an instance property.
     * @returns the reflected member information, or null if the symbol is not a member.
     */
    protected reflectMember(node: ts.Declaration, kind: ClassMemberKind | null, decorators?: Decorator[], isStatic?: boolean): ClassMember | null;
    /**
     * Find the declarations of the constructor parameters of a class identified by its symbol.
     * @param classSymbol the class whose parameters we want to find.
     * @returns an array of `ts.ParameterDeclaration` objects representing each of the parameters in
     * the class's constructor or null if there is no constructor.
     */
    protected getConstructorParameterDeclarations(classSymbol: NgccClassSymbol): ts.ParameterDeclaration[] | null;
    /**
     * Get the parameter decorators of a class constructor.
     *
     * @param classSymbol the class whose parameter info we want to get.
     * @param parameterNodes the array of TypeScript parameter nodes for this class's constructor.
     * @returns an array of constructor parameter info objects.
     */
    protected getConstructorParamInfo(classSymbol: NgccClassSymbol, parameterNodes: ts.ParameterDeclaration[]): CtorParameter[];
    /**
     * Compute the `TypeValueReference` for the given `typeExpression`.
     *
     * Although `typeExpression` is a valid `ts.Expression` that could be emitted directly into the
     * generated code, ngcc still needs to resolve the declaration and create an `IMPORTED` type
     * value reference as the compiler has specialized handling for some symbols, for example
     * `ChangeDetectorRef` from `@angular/core`. Such an `IMPORTED` type value reference will result
     * in a newly generated namespace import, instead of emitting the original `typeExpression` as is.
     */
    private typeToValue;
    /**
     * Determines where the `expression` is imported from.
     *
     * @param expression the expression to determine the import details for.
     * @returns the `Import` for the expression, or `null` if the expression is not imported or the
     * expression syntax is not supported.
     */
    private getImportOfExpression;
    /**
     * Get the parameter type and decorators for the constructor of a class,
     * where the information is stored on a static property of the class.
     *
     * Note that in ESM2015, the property is defined an array, or by an arrow function that returns
     * an array, of decorator and type information.
     *
     * For example,
     *
     * ```
     * SomeDirective.ctorParameters = () => [
     *   {type: ViewContainerRef},
     *   {type: TemplateRef},
     *   {type: undefined, decorators: [{ type: Inject, args: [INJECTED_TOKEN]}]},
     * ];
     * ```
     *
     * or
     *
     * ```
     * SomeDirective.ctorParameters = [
     *   {type: ViewContainerRef},
     *   {type: TemplateRef},
     *   {type: undefined, decorators: [{type: Inject, args: [INJECTED_TOKEN]}]},
     * ];
     * ```
     *
     * @param paramDecoratorsProperty the property that holds the parameter info we want to get.
     * @returns an array of objects containing the type and decorators for each parameter.
     */
    protected getParamInfoFromStaticProperty(paramDecoratorsProperty: ts.Symbol): ParamInfo[] | null;
    /**
     * Search statements related to the given class for calls to the specified helper.
     * @param classSymbol the class whose helper calls we are interested in.
     * @param helperNames the names of the helpers (e.g. `__decorate`) whose calls we are interested
     * in.
     * @returns an array of CallExpression nodes for each matching helper call.
     */
    protected getHelperCallsForClass(classSymbol: NgccClassSymbol, helperNames: string[]): ts.CallExpression[];
    /**
     * Find statements related to the given class that may contain calls to a helper.
     *
     * In ESM2015 code the helper calls are in the top level module, so we have to consider
     * all the statements in the module.
     *
     * @param classSymbol the class whose helper calls we are interested in.
     * @returns an array of statements that may contain helper calls.
     */
    protected getStatementsForClass(classSymbol: NgccClassSymbol): ts.Statement[];
    /**
     * Test whether a decorator was imported from `@angular/core`.
     *
     * Is the decorator:
     * * externally imported from `@angular/core`?
     * * the current hosted program is actually `@angular/core` and
     *   - relatively internally imported; or
     *   - not imported, from the current file.
     *
     * @param decorator the decorator to test.
     */
    protected isFromCore(decorator: Decorator): boolean;
    /**
     * Create a mapping between the public exports in a src program and the public exports of a dts
     * program.
     *
     * @param src the program bundle containing the source files.
     * @param dts the program bundle containing the typings files.
     * @returns a map of source declarations to typings declarations.
     */
    protected computePublicDtsDeclarationMap(src: BundleProgram, dts: BundleProgram): Map<DeclarationNode, ts.Declaration>;
    /**
     * Create a mapping between the "private" exports in a src program and the "private" exports of a
     * dts program. These exports may be exported from individual files in the src or dts programs,
     * but not exported from the root file (i.e publicly from the entry-point).
     *
     * This mapping is a "best guess" since we cannot guarantee that two declarations that happen to
     * be exported from a file with the same name are actually equivalent. But this is a reasonable
     * estimate for the purposes of ngcc.
     *
     * @param src the program bundle containing the source files.
     * @param dts the program bundle containing the typings files.
     * @returns a map of source declarations to typings declarations.
     */
    protected computePrivateDtsDeclarationMap(src: BundleProgram, dts: BundleProgram): Map<DeclarationNode, ts.Declaration>;
    /**
     * Collect mappings between names of exported declarations in a file and its actual declaration.
     *
     * Any new mappings are added to the `dtsDeclarationMap`.
     */
    protected collectDtsExportedDeclarations(dtsDeclarationMap: Map<string, ts.Declaration>, srcFile: ts.SourceFile, checker: ts.TypeChecker): void;
    protected collectSrcExportedDeclarations(declarationMap: Map<DeclarationNode, ts.Declaration>, dtsDeclarationMap: Map<string, ts.Declaration>, srcFile: ts.SourceFile): void;
    protected getDeclarationOfExpression(expression: ts.Expression): Declaration | null;
    /** Checks if the specified declaration resolves to the known JavaScript global `Object`. */
    protected isJavaScriptObjectDeclaration(decl: Declaration): boolean;
    /**
     * In JavaScript, enum declarations are emitted as a regular variable declaration followed by an
     * IIFE in which the enum members are assigned.
     *
     *   export var Enum;
     *   (function (Enum) {
     *     Enum["a"] = "A";
     *     Enum["b"] = "B";
     *   })(Enum || (Enum = {}));
     *
     * @param declaration A variable declaration that may represent an enum
     * @returns An array of enum members if the variable declaration is followed by an IIFE that
     * declares the enum members, or null otherwise.
     */
    protected resolveEnumMembers(declaration: ts.VariableDeclaration): EnumMember[] | null;
    /**
     * Attempts to extract all `EnumMember`s from a function that is according to the JavaScript emit
     * format for enums:
     *
     *   function (Enum) {
     *     Enum["MemberA"] = "a";
     *     Enum["MemberB"] = "b";
     *   }
     *
     * @param fn The function expression that is assumed to contain enum members.
     * @returns All enum members if the function is according to the correct syntax, null otherwise.
     */
    private reflectEnumMembers;
    /**
     * Attempts to extract a single `EnumMember` from a statement in the following syntax:
     *
     *   Enum["MemberA"] = "a";
     *
     * or, for enum member with numeric values:
     *
     *   Enum[Enum["MemberA"] = 0] = "MemberA";
     *
     * @param enumName The identifier of the enum that the members should be set on.
     * @param statement The statement to inspect.
     * @returns An `EnumMember` if the statement is according to the expected syntax, null otherwise.
     */
    protected reflectEnumMember(enumName: ts.Identifier, statement: ts.Statement): EnumMember | null;
    private getAdjacentNameOfClassSymbol;
}
/**
 * An enum member assignment that looks like `Enum[X] = Y;`.
 */
export declare type EnumMemberAssignment = ts.BinaryExpression & {
    left: ts.ElementAccessExpression;
};
export declare type ParamInfo = {
    decorators: Decorator[] | null;
    typeExpression: ts.Expression | null;
};
/**
 * Represents a call to `tslib.__metadata` as present in `tslib.__decorate` calls. This is a
 * synthetic decorator inserted by TypeScript that contains reflection information about the
 * target of the decorator, i.e. the class or property.
 */
export interface ParameterTypes {
    type: 'params';
    types: ts.Expression[];
}
/**
 * Represents a call to `tslib.__param` as present in `tslib.__decorate` calls. This contains
 * information on any decorators were applied to a certain parameter.
 */
export interface ParameterDecorators {
    type: 'param:decorators';
    index: number;
    decorator: Decorator;
}
/**
 * Represents a call to a decorator as it was present in the original source code, as present in
 * `tslib.__decorate` calls.
 */
export interface DecoratorCall {
    type: 'decorator';
    decorator: Decorator;
}
/**
 * Represents the different kinds of decorate helpers that may be present as first argument to
 * `tslib.__decorate`, as follows:
 *
 * ```
 * __decorate([
 *   Directive({ selector: '[someDirective]' }),
 *   tslib_1.__param(2, Inject(INJECTED_TOKEN)),
 *   tslib_1.__metadata("design:paramtypes", [ViewContainerRef, TemplateRef, String])
 * ], SomeDirective);
 * ```
 */
export declare type DecorateHelperEntry = ParameterTypes | ParameterDecorators | DecoratorCall;
/**
 * The recorded decorator information of a single class. This information is cached in the host.
 */
interface DecoratorInfo {
    /**
     * All decorators that were present on the class. If no decorators were present, this is `null`
     */
    classDecorators: Decorator[] | null;
    /**
     * All decorators per member of the class they were present on.
     */
    memberDecorators: Map<string, Decorator[]>;
    /**
     * Represents the constructor parameter information, such as the type of a parameter and all
     * decorators for a certain parameter. Indices in this array correspond with the parameter's
     * index in the constructor. Note that this array may be sparse, i.e. certain constructor
     * parameters may not have any info recorded.
     */
    constructorParamInfo: ParamInfo[];
}
/**
 * A statement node that represents an assignment.
 */
export declare type AssignmentStatement = ts.ExpressionStatement & {
    expression: {
        left: ts.Identifier;
        right: ts.Expression;
    };
};
/**
 * Test whether a statement node is an assignment statement.
 * @param statement the statement to test.
 */
export declare function isAssignmentStatement(stat