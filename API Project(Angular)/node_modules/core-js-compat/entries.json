nd perDirectoryResolvedTypeReferenceDirectives could be non empty if there was exception during program update
            // (between startCachingPerDirectoryResolution and finishCachingPerDirectoryResolution)
            clearPerDirectoryResolutions();
            hasChangedAutomaticTypeDirectiveNames = false;
        }
        function startRecordingFilesWithChangedResolutions() {
            filesWithChangedSetOfUnresolvedImports = [];
        }
        function finishRecordingFilesWithChangedResolutions() {
            var collected = filesWithChangedSetOfUnresolvedImports;
            filesWithChangedSetOfUnresolvedImports = undefined;
            return collected;
        }
        function isFileWithInvalidatedNonRelativeUnresolvedImports(path) {
            if (!filesWithInvalidatedNonRelativeUnresolvedImports) {
                return false;
            }
            // Invalidated if file has unresolved imports
            var value = filesWithInvalidatedNonRelativeUnresolvedImports.get(path);
            return !!value && !!value.length;
        }
        function createHasInvalidatedResolution(forceAllFilesAsInvalidated) {
            // Ensure pending resolutions are applied
            invalidateResolutionsOfFailedLookupLocations();
            if (forceAllFilesAsInvalidated) {
                // Any file asked would have invalidated resolution
                filesWithInvalidatedResolutions = undefined;
                return ts.returnTrue;
            }
            var collected = filesWithInvalidatedResolutions;
            filesWithInvalidatedResolutions = undefined;
            return function (path) { return (!!collected && collected.has(path)) ||
                isFileWithInvalidatedNonRelativeUnresolvedImports(path); };
        }
        function clearPerDirectoryResolutions() {
            moduleResolutionCache.clear();
            typeReferenceDirectiveResolutionCache.clear();
            nonRelativeExternalModuleResolutions.forEach(watchFailedLookupLocationOfNonRelativeModuleResolutions);
            nonRelativeExternalModuleResolutions.clear();
        }
        function finishCachingPerDirectoryResolution() {
            filesWithInvalidatedNonRelativeUnresolvedImports = undefined;
            clearPerDirectoryResolutions();
            directoryWatchesOfFailedLookups.forEach(function (watcher, path) {
                if (watcher.refCount === 0) {
                    directoryWatchesOfFailedLookups.delete(path);
                    watcher.watcher.close();
                }
            });
            hasChangedAutomaticTypeDirectiveNames = false;
        }
        function resolveModuleName(moduleName, containingFile, compilerOptions, host, redirectedReference, _containingSourceFile, mode) {
            var _a;
            var primaryResult = ts.resolveModuleName(moduleName, containingFile, compilerOptions, host, moduleResolutionCache, redirectedReference, mode);
            // return result immediately only if global cache support is not enabled or if it is .ts, .tsx or .d.ts
            if (!resolutionHost.getGlobalCache) {
                return primaryResult;
            }
            // otherwise try to load typings from @types
            var globalCache = resolutionHost.getGlobalCache();
            if (globalCache !== undefined && !ts.isExternalModuleNameRelative(moduleName) && !(primaryResult.resolvedModule && ts.extensionIsTS(primaryResult.resolvedModule.extension))) {
                // create different collection of failed lookup locations for second pass
                // if it will fail and we've already found something during the first pass - we don't want to pollute its results
                var _b = ts.loadModuleFromGlobalCache(ts.Debug.checkDefined(resolutionHost.globalCacheResolutionModuleName)(moduleName), resolutionHost.projectName, compilerOptions, host, globalCache, moduleResolutionCache), resolvedModule = _b.resolvedModule, failedLookupLocations = _b.failedLookupLocations;
                if (resolvedModule) {
                    // Modify existing resolution so its saved in the directory cache as well
                    primaryResult.resolvedModule = resolvedModule;
                    (_a = primaryResult.failedLookupLocations).push.apply(_a, failedLookupLocations);
                    return primaryResult;
                }
            }
            // Default return the result from the first pass
            return primaryResult;
        }
        function resolveTypeReferenceDirective(typeReferenceDirectiveName, containingFile, options, host, redirectedReference, _containingSourceFile, resolutionMode) {
            return ts.resolveTypeReferenceDirective(typeReferenceDirectiveName, containingFile, options, host, redirectedReference, typeReferenceDirectiveResolutionCache, resolutionMode);
        }
        function resolveNamesWithLocalCache(_a) {
            var _b, _c, _d;
            var names = _a.names, containingFile = _a.containingFile, redirectedReference = _a.redirectedReference, cache = _a.cache, perDirectoryCacheWithRedirects = _a.perDirectoryCacheWithRedirects, loader = _a.loader, getResolutionWithResolvedFileName = _a.getResolutionWithResolvedFileName, shouldRetryResolution = _a.shouldRetryResolution, reusedNames = _a.reusedNames, logChanges = _a.logChanges, containingSourceFile = _a.containingSourceFile, containingSourceFileMode = _a.containingSourceFileMode;
            var path = resolutionHost.toPath(containingFile);
            var resolutionsInFile = cache.get(path) || cache.set(path, ts.createModeAwareCache()).get(path);
            var dirPath = ts.getDirectoryPath(path);
            var perDirectoryCache = perDirectoryCacheWithRedirects.getOrCreateMapOfCacheRedirects(redirectedReference);
            var perDirectoryResolution = perDirectoryCache.get(dirPath);
            if (!perDirectoryResolution) {
                perDirectoryResolution = ts.createModeAwareCache();
                perDirectoryCache.set(dirPath, perDirectoryResolution);
            }
            var resolvedModules = [];
            var compilerOptions = resolutionHost.getCompilationSettings();
            var hasInvalidatedNonRelativeUnresolvedImport = logChanges && isFileWithInvalidatedNonRelativeUnresolvedImports(path);
            // All the resolutions in this file are invalidated if this file wasn't resolved using same redirect
            var program = resolutionHost.getCurrentProgram();
            var oldRedirect = program && program.getResolvedProjectReferenceToRedirect(containingFile);
            var unmatchedRedirects = oldRedirect ?
                !redirectedReference || redirectedReference.sourceFile.path !== oldRedirect.sourceFile.path :
                !!redirectedReference;
            var seenNamesInFile = ts.createModeAwareCache();
            var i = 0;
            for (var _i = 0, names_5 = names; _i < names_5.length; _i++) {
                var entry = names_5[_i];
                var name = ts.isString(entry) ? entry : entry.fileName.toLowerCase();
                // Imports supply a `containingSourceFile` but no `containingSourceFileMode` - it would be redundant
                // they require calculating the mode for a given import from it's position in the resolution table, since a given
                // import's syntax may override the file's default mode.
                // Type references instead supply a `containingSourceFileMode` and a non-string entry which contains
                // a default file mode override if applicable.
                var mode = !ts.isString(entry) ? ts.getModeForFileReference(entry, containingSourceFileMode) :
                    containingSourceFile ? ts.getModeForResolutionAtIndex(containingSourceFile, i) : undefined;
                i++;
                var resolution = resolutionsInFile.get(name, mode);
                // Resolution is valid if it is present and not invalidated
                if (!seenNamesInFile.has(name, mode) &&
                    unmatchedRedirects || !resolution || resolution.isInvalidated ||
                    // If the name is unresolved import that was invalidated, recalculate
                    (hasInvalidatedNonRelativeUnresolvedImport && !ts.isExternalModuleNameRelative(name) && shouldRetryResolution(resolution))) {
                    var existingResolution = resolution;
                    var resolutionInDirectory = perDirectoryResolution.get(name, mode);
                    if (resolutionInDirectory) {
                        resolution = resolutionInDirectory;
                        var host = ((_b = resolutionHost.getCompilerHost) === null || _b === void 0 ? void 0 : _b.call(resolutionHost)) || resolutionHost;
                        if (ts.isTraceEnabled(compilerOptions, host)) {
                            var resolved = getResolutionWithResolvedFileName(resolution);
                            ts.trace(host, loader === resolveModuleName ?
                                (resolved === null || resolved === void 0 ? void 0 : resolved.resolvedFileName) ?
                                    resolved.packagetId ?
                                        ts.Diagnostics.Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3_with_Package_ID_4 :
                                        ts.Diagnostics.Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3 :
                                    ts.Diagnostics.Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_not_resolved :
                                (resolved === null || resolved === void 0 ? void 0 : resolved.resolvedFileName) ?
                                    resolved.packagetId ?
                                        ts.Diagnostics.Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3_with_Package_ID_4 :
                                        ts.Diagnostics.Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3 :
                                    ts.Diagnostics.Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_not_resolved, name, containingFile, ts.getDirectoryPath(containingFile), resolved === null || resolved === void 0 ? void 0 : resolved.resolvedFileName, (resolved === null || resolved === void 0 ? void 0 : resolved.packagetId) && ts.packageIdToString(resolved.packagetId));
                        }
                    }
                    else {
                        resolution = loader(name, containingFile, compilerOptions, ((_c = resolutionHost.getCompilerHost) === null || _c === void 0 ? void 0 : _c.call(resolutionHost)) || resolutionHost, redirectedReference, containingSourceFile, mode);
                        perDirectoryResolution.set(name, mode, resolution);
                        if (resolutionHost.onDiscoveredSymlink && resolutionIsSymlink(resolution)) {
                            resolutionHost.onDiscoveredSymlink();
                        }
                    }
                    resolutionsInFile.set(name, mode, resolution);
                    watchFailedLookupLocationsOfExternalModuleResolutions(name, resolution, path, getResolutionWithResolvedFileName);
                    if (existingResolution) {
                        stopWatchFailedLookupLocationOfResolution(existingResolution, path, getResolutionWithResolvedFileName);
                    }
                    if (logChanges && filesWithChangedSetOfUnresolvedImports && !resolutionIsEqualTo(existingResolution, resolution)) {
                        filesWithChangedSetOfUnresolvedImports.push(path);
                        // reset log changes to avoid recording the same file multiple times
                        logChanges = false;
                    }
                }
                else {
                    var host = ((_d = resolutionHost.getCompilerHost) === null || _d === void 0 ? void 0 : _d.call(resolutionHost)) || resolutionHost;
                    if (ts.isTraceEnabled(compilerOptions, host) && !seenNamesInFile.has(name, mode)) {
                        var resolved = getResolutionWithResolvedFileName(resolution);
                        ts.trace(host, loader === resolveModuleName ?
                            (resolved === null || resolved === void 0 ? void 0 : resolved.resolvedFileName) ?
                                resolved.packagetId ?
                                    ts.Diagnostics.Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2_with_Package_ID_3 :
                                    ts.Diagnostics.Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2 :
                                ts.Diagnostics.Reusing_resolution_of_module_0_from_1_of_old_program_it_was_not_resolved :
                            (resolved === null || resolved === void 0 ? void 0 : resolved.resolvedFileName) ?
                                resolved.packagetId ?
                                    ts.Diagnostics.Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_successfully_resolved_to_2_with_Package_ID_3 :
                                    ts.Diagnostics.Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_successfully_resolved_to_2 :
                                ts.Diagnostics.Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_not_resolved, name, containingFile, resolved === null || resolved === void 0 ? void 0 : resolved.resolvedFileName, (resolved === null || resolved === void 0 ? void 0 : resolved.packagetId) && ts.packageIdToString(resolved.packagetId));
                    }
                }
                ts.Debug.assert(resolution !== undefined && !resolution.isInvalidated);
                seenNamesInFile.set(name, mode, true);
                resolvedModules.push(getResolutionWithResolvedFileName(resolution));
            }
            // Stop watching and remove the unused name
            resolutionsInFile.forEach(function (resolution, name, mode) {
                if (!seenNamesInFile.has(name, mode) && !ts.contains(reusedNames, name)) {
                    stopWatchFailedLookupLocationOfResolution(resolution, path, getResolutionWithResolvedFileName);
                    resolutionsInFile.delete(name, mode);
                }
            });
            return resolvedModules;
            function resolutionIsEqualTo(oldResolution, newResolution) {
                if (oldResolution === newResolution) {
                    return true;
                }
                if (!oldResolution || !newResolution) {
                    return false;
                }
                var oldResult = getResolutionWithResolvedFileName(oldResolution);
                var newResult = getResolutionWithResolvedFileName(newResolution);
                if (oldResult === newResult) {
                    return true;
                }
                if (!oldResult || !newResult) {
                    return false;
                }
                return oldResult.resolvedFileName === newResult.resolvedFileName;
            }
        }
        function resolveTypeReferenceDirectives(typeDirectiveNames, containingFile, redirectedReference, containingFileMode) {
            return resolveNamesWithLocalCache({
                names: typeDirectiveNames,
                containingFile: containingFile,
                redirectedReference: redirectedReference,
                cache: resolvedTypeReferenceDirectives,
                perDirectoryCacheWithRedirects: perDirectoryResolvedTypeReferenceDirectives,
                loader: resolveTypeReferenceDirective,
                getResolutionWithResolvedFileName: getResolvedTypeReferenceDirective,
                shouldRetryResolution: function (resolution) { return resolution.resolvedTypeReferenceDirective === undefined; },
                containingSourceFileMode: containingFileMode
            });
        }
        function resolveModuleNames(moduleNames, containingFile, reusedNames, redirectedReference, containingSourceFile) {
            return resolveNamesWithLocalCache({
                names: moduleNames,
                containingFile: containingFile,
                redirectedReference: redirectedReference,
                cache: resolvedModuleNames,
                perDirectoryCacheWithRedirects: perDirectoryResolvedModuleNames,
                loader: resolveModuleName,
                getResolutionWithResolvedFileName: getResolvedModule,
                shouldRetryResolution: function (resolution) { return !resolution.resolvedModule || !ts.resolutionExtensionIsTSOrJson(resolution.resolvedModule.extension); },
                reusedNames: reusedNames,
                logChanges: logChangesWhenResolvingModule,
                containingSourceFile: containingSourceFile,
            });
        }
        function getResolvedModuleWithFailedLookupLocationsFromCache(moduleName, containingFile, resolutionMode) {
            var cache = resolvedModuleNames.get(resolutionHost.toPath(containingFile));
            if (!cache)
                return undefined;
            return cache.get(moduleName, resolutionMode);
        }
        function isNodeModulesAtTypesDirectory(dirPath) {
            return ts.endsWith(dirPath, "/node_modules/@types");
        }
        function getDirectoryToWatchFailedLookupLocation(failedLookupLocation, failedLookupLocationPath) {
            if (isInDirectoryPath(rootPath, failedLookupLocationPath)) {
                // Ensure failed look up is normalized path
                failedLookupLocation = ts.isRootedDiskPath(failedLookupLocation) ? ts.normalizePath(failedLookupLocation) : ts.getNormalizedAbsolutePath(failedLookupLocation, getCurrentDirectory());
                var failedLookupPathSplit = failedLookupLocationPath.split(ts.directorySeparator);
                var failedLookupSplit = failedLookupLocation.split(ts.directorySeparator);
                ts.Debug.assert(failedLookupSplit.length === failedLookupPathSplit.length, "FailedLookup: ".concat(failedLookupLocation, " failedLookupLocationPath: ").concat(failedLookupLocationPath));
                if (failedLookupPathSplit.length > rootSplitLength + 1) {
                    // Instead of watching root, watch directory in root to avoid watching excluded directories not needed for module resolution
                    return {
                        dir: failedLookupSplit.slice(0, rootSplitLength + 1).join(ts.directorySeparator),
                        dirPath: failedLookupPathSplit.slice(0, rootSplitLength + 1).join(ts.directorySeparator)
                    };
                }
                else {
                    // Always watch root directory non recursively
                    return {
                        dir: rootDir,
                        dirPath: rootPath,
                        nonRecursive: false
                    };
                }
            }
            return getDirectoryToWatchFromFailedLookupLocationDirectory(ts.getDirectoryPath(ts.getNormalizedAbsolutePath(failedLookupLocation, getCurrentDirectory())), ts.getDirectoryPath(failedLookupLocationPath));
        }
        function getDirectoryToWatchFromFailedLookupLocationDirectory(dir, dirPath) {
            // If directory path contains node module, get the most parent node_modules directory for watching
            while (ts.pathContainsNodeModules(dirPath)) {
                dir = ts.getDirectoryPath(dir);
                dirPath = ts.getDirectoryPath(dirPath);
            }
            // If the directory is node_modules use it to watch, always watch it recursively
            if (ts.isNodeModulesDirectory(dirPath)) {
                return canWatchDirectory(ts.getDirectoryPath(dirPath)) ? { dir: dir, dirPath: dirPath } : undefined;
            }
            var nonRecursive = true;
            // Use some ancestor of the root directory
            var subDirectoryPath, subDirectory;
            if (rootPath !== undefined) {
                while (!isInDirectoryPath(dirPath, rootPath)) {
                    var parentPath = ts.getDirectoryPath(dirPath);
                    if (parentPath === dirPath) {
                        break;
                    }
                    nonRecursive = false;
                    subDirectoryPath = dirPath;
                    subDirectory = dir;
                    dirPath = parentPath;
                    dir = ts.getDirectoryPath(dir);
                }
            }
            return canWatchDirectory(dirPath) ? { dir: subDirectory || dir, dirPath: subDirectoryPath || dirPath, nonRecursive: nonRecursive } : undefined;
        }
        function isPathWithDefaultFailedLookupExtension(path) {
            return ts.fileExtensionIsOneOf(path, failedLookupDefaultExtensions);
        }
        function watchFailedLookupLocationsOfExternalModuleResolutions(name, resolution, filePath, getResolutionWithResolvedFileName) {
            if (resolution.refCount) {
                resolution.refCount++;
                ts.Debug.assertIsDefined(resolution.files);
            }
            else {
                resolution.refCount = 1;
                ts.Debug.assert(ts.length(resolution.files) === 0); // This resolution shouldnt be referenced by any file yet
                if (ts.isExternalModuleNameRelative(name)) {
                    watchFailedLookupLocationOfResolution(resolution);
                }
                else {
                    nonRelativeExternalModuleResolutions.add(name, resolution);
                }
                var resolved = getResolutionWithResolvedFileName(resolution);
                if (resolved && resolved.resolvedFileName) {
                    resolvedFileToResolution.add(resolutionHost.toPath(resolved.resolvedFileName), resolution);
                }
            }
            (resolution.files || (resolution.files = [])).push(filePath);
        }
        function watchFailedLookupLocationOfResolution(resolution) {
            ts.Debug.assert(!!resolution.refCount);
            var failedLookupLocations = resolution.failedLookupLocations;
            if (!failedLookupLocations.length)
                return;
            resolutionsWithFailedLookups.push(resolution);
            var setAtRoot = false;
            for (var _i = 0, failedLookupLocations_1 = failedLookupLocations; _i < failedLookupLocations_1.length; _i++) {
                var failedLookupLocation = failedLookupLocations_1[_i];
                var failedLookupLocationPath = resolutionHost.toPath(failedLookupLocation);
                var toWatch = getDirectoryToWatchFailedLookupLocation(failedLookupLocation, failedLookupLocationPath);
                if (toWatch) {
                    var dir = toWatch.dir, dirPath = toWatch.dirPath, nonRecursive = toWatch.nonRecursive;
                    // If the failed lookup location path is not one of the supported extensions,
                    // store it in the custom path
                    if (!isPathWithDefaultFailedLookupExtension(failedLookupLocationPath)) {
                        var refCount = customFailedLookupPaths.get(failedLookupLocationPath) || 0;
                        customFailedLookupPaths.set(failedLookupLocationPath, refCount + 1);
                    }
                    if (dirPath === rootPath) {
                        ts.Debug.assert(!nonRecursive);
                        setAtRoot = true;
                    }
                    else {
                        setDirectoryWatcher(dir, dirPath, nonRecursive);
                    }
                }
            }
            if (setAtRoot) {
                // This is always non recursive
                setDirectoryWatcher(rootDir, rootPath, /*nonRecursive*/ true); // TODO: GH#18217
            }
        }
        function watchFailedLookupLocationOfNonRelativeModuleResolutions(resolutions, name) {
            var program = resolutionHost.getCurrentProgram();
            if (!program || !program.getTypeChecker().tryFindAmbientModuleWithoutAugmentations(name)) {
                resolutions.forEach(watchFailedLookupLocationOfResolution);
            }
        }
        function setDirectoryWatcher(dir, dirPath, nonRecursive) {
            var dirWatcher = directoryWatchesOfFailedLookups.get(dirPath);
            if (dirWatcher) {
                ts.Debug.assert(!!nonRecursive === !!dirWatcher.nonRecursive);
                dirWatcher.refCount++;
            }
            else {
                directoryWatchesOfFailedLookups.set(dirPath, { watcher: createDirectoryWatcher(dir, dirPath, nonRecursive), refCount: 1, nonRecursive: nonRecursive });
            }
        }
        function stopWatchFailedLookupLocationOfResolution(resolution, filePath, getResolutionWithResolvedFileName) {
            ts.unorderedRemoveItem(ts.Debug.checkDefined(resolution.files), filePath);
            resolution.refCount--;
            if (resolution.refCount) {
                return;
            }
            var resolved = getResolutionWithResolvedFileName(resolution);
            if (resolved && resolved.resolvedFileName) {
                resolvedFileToResolution.remove(resolutionHost.toPath(resolved.resolvedFileName), resolution);
            }
            if (!ts.unorderedRemoveItem(resolutionsWithFailedLookups, resolution)) {
                // If not watching failed lookups, it wont be there in resolutionsWithFailedLookups
                return;
            }
            var failedLookupLocations = resolution.failedLookupLocations;
            var removeAtRoot = false;
            for (var _i = 0, failedLookupLocations_2 = failedLookupLocations; _i < failedLookupLocations_2.length; _i++) {
                var failedLookupLocation = failedLookupLocations_2[_i];
                var failedLookupLocationPath = resolutionHost.toPath(failedLookupLocation);
                var toWatch = getDirectoryToWatchFailedLookupLocation(failedLookupLocation, failedLookupLocationPath);
                if (toWatch) {
                    var dirPath = toWatch.dirPath;
                    var refCount = customFailedLookupPaths.get(failedLookupLocationPath);
                    if (refCount) {
                        if (refCount === 1) {
                            customFailedLookupPaths.delete(failedLookupLocationPath);
                        }
                        else {
                            ts.Debug.assert(refCount > 1);
                            customFailedLookupPaths.set(failedLookupLocationPath, refCount - 1);
                        }
                    }
                    if (dirPath === rootPath) {
                        removeAtRoot = true;
                    }
                    else {
                        removeDirectoryWatcher(dirPath);
                    }
                }
            }
            if (removeAtRoot) {
                removeDirectoryWatcher(rootPath);
            }
        }
        function removeDirectoryWatcher(dirPath) {
            var dirWatcher = directoryWatchesOfFailedLookups.get(dirPath);
            // Do not close the watcher yet since it might be needed by other failed lookup locations.
            dirWatcher.refCount--;
        }
        function createDirectoryWatcher(directory, dirPath, nonRecursive) {
            return resolutionHost.watchDirectoryOfFailedLookupLocation(directory, function (fileOrDirectory) {
                var fileOrDirectoryPath = resolutionHost.toPath(fileOrDirectory);
                if (cachedDirectoryStructureHost) {
                    // Since the file existence changed, update the sourceFiles cache
                    cachedDirectoryStructureHost.addOrDeleteFileOrDirectory(fileOrDirectory, fileOrDirectoryPath);
                }
                scheduleInvalidateResolutionOfFailedLookupLocation(fileOrDirectoryPath, dirPath === fileOrDirectoryPath);
            }, nonRecursive ? 0 /* WatchDirectoryFlags.None */ : 1 /* WatchDirectoryFlags.Recursive */);
        }
        function removeResolutionsOfFileFromCache(cache, filePath, getResolutionWithResolvedFileName) {
            // Deleted file, stop watching failed lookups for all the resolutions in the file
            var resolutions = cache.get(filePath);
            if (resolutions) {
                resolutions.forEach(function (resolution) { return stopWatchFailedLookupLocationOfResolution(resolution, filePath, getResolutionWithResolvedFileName); });
                cache.delete(filePath);
            }
        }
        function removeResolutionsFromProjectReferenceRedirects(filePath) {
            if (!ts.fileExtensionIs(filePath, ".json" /* Extension.Json */))
                return;
            var program = resolutionHost.getCurrentProgram();
            if (!program)
                return;
            // If this file is input file for the referenced project, get it
            var resolvedProjectReference = program.getResolvedProjectReferenceByPath(filePath);
            if (!resolvedProjectReference)
                return;
            // filePath is for the projectReference and the containing file is from this project reference, invalidate the resolution
            resolvedProjectReference.commandLine.fileNames.forEach(function (f) { return removeResolutionsOfFile(resolutionHost.toPath(f)); });
        }
        function removeResolutionsOfFile(filePath) {
            removeResolutionsOfFileFromCache(resolvedModuleNames, filePath, getResolvedModule);
            removeResolutionsOfFileFromCache(resolvedTypeReferenceDirectives, filePath, getResolvedTypeReferenceDirective);
        }
        function invalidateResolutions(resolutions, canInvalidate) {
            if (!resolutions)
                return false;
            var invalidated = false;
            for (var _i = 0, resolutions_1 = resolutions; _i < resolutions_1.length; _i++) {
                var resolution = resolutions_1[_i];
                if (resolution.isInvalidated || !canInvalidate(resolution))
                    continue;
                resolution.isInvalidated = invalidated = true;
                for (var _a = 0, _b = ts.Debug.checkDefined(resolution.files); _a < _b.length; _a++) {
                    var containingFilePath = _b[_a];
                    (filesWithInvalidatedResolutions || (filesWithInvalidatedResolutions = new ts.Set())).add(containingFilePath);
                    // When its a file with inferred types resolution, invalidate type reference directive resolution
                    hasChangedAutomaticTypeDirectiveNames = hasChangedAutomaticTypeDirectiveNames || ts.endsWith(containingFilePath, ts.inferredTypesContainingFile);
                }
            }
            return invalidated;
        }
        function invalidateResolutionOfFile(filePath) {
            removeResolutionsOfFile(filePath);
            // Resolution is invalidated if the resulting file name is same as the deleted file path
            var prevHasChangedAutomaticTypeDirectiveNames = hasChangedAutomaticTypeDirectiveNames;
            if (invalidateResolutions(resolvedFileToResolution.get(filePath), ts.returnTrue) &&
                hasChangedAutomaticTypeDirectiveNames &&
                !prevHasChangedAutomaticTypeDirectiveNames) {
                resolutionHost.onChangedAutomaticTypeDirectiveNames();
            }
        }
        function setFilesWithInvalidatedNonRelativeUnresolvedImports(filesMap) {
            ts.Debug.assert(filesWithInvalidatedNonRelativeUnresolvedImports === filesMap || filesWithInvalidatedNonRelativeUnresolvedImports === undefined);
            filesWithInvalidatedNonRelativeUnresolvedImports = filesMap;
        }
        function scheduleInvalidateResolutionOfFailedLookupLocation(fileOrDirectoryPath, isCreatingWatchedDirectory) {
            if (isCreatingWatchedDirectory) {
                // Watching directory is created
                // Invalidate any resolution has failed lookup in this directory
                (isInDirectoryChecks || (isInDirectoryChecks = [])).push(fileOrDirectoryPath);
            }
            else {
                // If something to do with folder/file starting with "." in node_modules folder, skip it
                var updatedPath = removeIgnoredPath(fileOrDirectoryPath);
                if (!updatedPath)
                    return false;
                fileOrDirectoryPath = updatedPath;
                // prevent saving an open file from over-eagerly triggering invalidation
                if (resolutionHost.fileIsOpen(fileOrDirectoryPath)) {
                    return false;
                }
                // Some file or directory in the watching directory is created
                // Return early if it does not have any of the watching extension or not the custom failed lookup path
                var dirOfFileOrDirectory = ts.getDirectoryPath(fileOrDirectoryPath);
                if (isNodeModulesAtTypesDirectory(fileOrDirectoryPath) || ts.isNodeModulesDirectory(fileOrDirectoryPath) ||
                    isNodeModulesAtTypesDirectory(dirOfFileOrDirectory) || ts.isNodeModulesDirectory(dirOfFileOrDirectory)) {
                    // Invalidate any resolution from this directory
                    (failedLookupChecks || (failedLookupChecks = [])).push(fileOrDirectoryPath);
                    (startsWithPathChecks || (startsWithPathChecks = new ts.Set())).add(fileOrDirectoryPath);
                }
                else {
                    if (!isPathWithDefaultFailedLookupExtension(fileOrDirectoryPath) && !customFailedLookupPaths.has(fileOrDirectoryPath)) {
                        return false;
                    }
                    // Ignore emits from the program
                    if (ts.isEmittedFileOfProgram(resolutionHost.getCurrentProgram(), fileOrDirectoryPath)) {
                        return false;
                    }
                    // Resolution need to be invalidated if failed lookup location is same as the file or directory getting created
                    (failedLookupChecks || (failedLookupChecks = [])).push(fileOrDirectoryPath);
                    // If the invalidated file is from a node_modules package, invalidate everything else
                    // in the package since we might not get notifications for other files in the package.
                    // This hardens our logic against unreliable file watchers.
                    var packagePath = ts.parseNodeModuleFromPath(fileOrDirectoryPath);
                    if (packagePath)
                        (startsWithPathChecks || (startsWithPathChecks = new ts.Set())).add(packagePath);
                }
            }
            resolutionHost.scheduleInvalidateResolutionsOfFailedLookupLocations();
        }
        function invalidateResolutionsOfFailedLookupLocations() {
            if (!failedLookupChecks && !startsWithPathChecks && !isInDirectoryChecks) {
                return false;
            }
            var invalidated = invalidateResolutions(resolutionsWithFailedLookups, canInvalidateFailedLookupResolution);
            failedLookupChecks = undefined;
            startsWithPathChecks = undefined;
            isInDirectoryChecks = undefined;
            return invalidated;
        }
        function canInvalidateFailedLookupResolution(resolution) {
            return resolution.failedLookupLocations.some(function (location) {
                var locationPath = resolutionHost.toPath(location);
                return ts.contains(failedLookupChecks, locationPath) ||
                    ts.firstDefinedIterator((startsWithPathChecks === null || startsWithPathChecks === void 0 ? void 0 : startsWithPathChecks.keys()) || ts.emptyIterator, function (fileOrDirectoryPath) { return ts.startsWith(locationPath, fileOrDirectoryPath) ? true : undefined; }) ||
                    (isInDirectoryChecks === null || isInDirectoryChecks === void 0 ? void 0 : isInDirectoryChecks.some(function (fileOrDirectoryPath) { return isInDirectoryPath(fileOrDirectoryPath, locationPath); }));
            });
        }
        function closeTypeRootsWatch() {
            ts.clearMap(typeRootsWatches, ts.closeFileWatcher);
        }
        function getDirectoryToWatchFailedLookupLocationFromTypeRoot(typeRoot, typeRootPath) {
            if (isInDirectoryPath(rootPath, typeRootPath)) {
                return rootPath;
            }
            var toWatch = getDirectoryToWatchFromFailedLookupLocationDirectory(typeRoot, typeRootPath);
            return toWatch && directoryWatchesOfFailedLookups.has(toWatch.dirPath) ? toWatch.dirPath : undefined;
        }
        function createTypeRootsWatch(typeRootPath, typeRoot) {
            // Create new watch and recursive info
            return resolutionHost.watchTypeRootsDirectory(typeRoot, function (fileOrDirectory) {
                var fileOrDirectoryPath = resolutionHost.toPath(fileOrDirectory);
                if (cachedDirectoryStructureHost) {
                    // Since the file existence changed, update the sourceFiles cache
                    cachedDirectoryStructureHost.addOrDeleteFileOrDirectory(fileOrDirectory, fileOrDirectoryPath);
                }
                // For now just recompile
                // We could potentially store more data here about whether it was/would be really be used or not
                // and with that determine to trigger compilation but for now this is enough
                hasChangedAutomaticTypeDirectiveNames = true;
                resolutionHost.onChangedAutomaticTypeDirectiveNames();
                // Since directory watchers invoked are flaky, the failed lookup location events might not be triggered
                // So handle to failed lookup locations here as well to ensure we are invalidating resolutions
                var dirPath = getDirectoryToWatchFailedLookupLocationFromTypeRoot(typeRoot, typeRootPath);
                if (dirPath) {
                    scheduleInvalidateResolutionOfFailedLookupLocation(fileOrDirectoryPath, dirPath === fileOrDirectoryPath);
                }
            }, 1 /* WatchDirectoryFlags.Recursive */);
        }
        /**
         * Watches the types that would get added as part of getAutomaticTypeDirectiveNames
         * To be called when compiler options change
         */
        function updateTypeRootsWatch() {
            var options = resolutionHost.getCompilationSettings();
            if (options.types) {
                // No need to do any watch since resolution cache is going to handle the failed lookups
                // for the types added by this
                closeTypeRootsWatch();
                return;
            }
            // we need to assume the directories exist to ensure that we can get all the type root directories that get included
            // But filter directories that are at root level to say directory doesnt exist, so that we arent watching them
            var typeRoots = ts.getEffectiveTypeRoots(options, { directoryExists: directoryExistsForTypeRootWatch, getCurrentDirectory: getCurrentDirectory });
            if (typeRoots) {
                ts.mutateMap(typeRootsWatches, ts.arrayToMap(typeRoots, function (tr) { return resolutionHost.toPath(tr); }), {
                    createNewValue: createTypeRootsWatch,
                    onDeleteValue: ts.closeFileWatcher
                });
            }
            else {
                closeTypeRootsWatch();
            }
        }
        /**
         * Use this function to return if directory exists to get type roots to watch
         * If we return directory exists then only the paths will be added to type roots
         * Hence return true for all directories except root directories which are filtered from watching
         */
        function directoryExistsForTypeRootWatch(nodeTypesDirectory) {
            var dir = ts.getDirectoryPath(ts.getDirectoryPath(nodeTypesDirectory));
            var dirPath = resolutionHost.toPath(dir);
            return dirPath === rootPath || canWatchDirectory(dirPath);
        }
    }
    ts.createResolutionCache = createResolutionCache;
    function resolutionIsSymlink(resolution) {
        var _a, _b;
        return !!(((_a = resolution.resolvedModule) === null || _a === void 0 ? void 0 : _a.originalPath) ||
            ((_b = resolution.resolvedTypeReferenceDirective) === null || _b === void 0 ? void 0 : _b.originalPath));
    }
})(ts || (ts = {}));
// Used by importFixes, getEditsForFileRename, and declaration emit to synthesize import module specifiers.
/* @internal */
var ts;
(function (ts) {
    var moduleSpecifiers;
    (function (moduleSpecifiers_1) {
        var RelativePreference;
        (function (RelativePreference) {
            RelativePreference[RelativePreference["Relative"] = 0] = "Relative";
            RelativePreference[RelativePreference["NonRelative"] = 1] = "NonRelative";
            RelativePreference[RelativePreference["Shortest"] = 2] = "Shortest";
            RelativePreference[RelativePreference["ExternalNonRelative"] = 3] = "ExternalNonRelative";
        })(RelativePreference || (RelativePreference = {}));
        // See UserPreferences#importPathEnding
        var Ending;
        (function (Ending) {
            Ending[Ending["Minimal"] = 0] = "Minimal";
            Ending[Ending["Index"] = 1] = "Index";
            Ending[Ending["JsExtension"] = 2] = "JsExtension";
        })(Ending || (Ending = {}));
        function getPreferences(host, _a, compilerOptions, importingSourceFile) {
            var importModuleSpecifierPreference = _a.importModuleSpecifierPreference, importModuleSpecifierEnding = _a.importModuleSpecifierEnding;
            return {
                relativePreference: importModuleSpecifierPreference === "relative" ? 0 /* RelativePreference.Relative */ :
                    importModuleSpecifierPreference === "non-relative" ? 1 /* RelativePreference.NonRelative */ :
                        importModuleSpecifierPreference === "project-relative" ? 3 /* RelativePreference.ExternalNonRelative */ :
                            2 /* RelativePreference.Shortest */,
                ending: getEnding(),
            };
            function getEnding() {
                switch (importModuleSpecifierEnding) {
                    case "minimal": return 0 /* Ending.Minimal */;
                    case "index": return 1 /* Ending.Index */;
                    case "js": return 2 /* Ending.JsExtension */;
                    default: return usesJsExtensionOnImports(importingSourceFile) || isFormatRequiringExtensions(compilerOptions, importingSourceFile.path, host) ? 2 /* Ending.JsExtension */
                        : ts.getEmitModuleResolutionKind(compilerOptions) !== ts.ModuleResolutionKind.NodeJs ? 1 /* Ending.Index */ : 0 /* Ending.Minimal */;
                }
            }
        }
        function getPreferencesForUpdate(compilerOptions, oldImportSpecifier, importingSourceFileName, host) {
            return {
                relativePreference: ts.isExternalModuleNameRelative(oldImportSpecifier) ? 0 /* RelativePreference.Relative */ : 1 /* RelativePreference.NonRelative */,
                ending: ts.hasJSFileExtension(oldImportSpecifier) || isFormatRequiringExtensions(compilerOptions, importingSourceFileName, host) ?
                    2 /* Ending.JsExtension */ :
                    ts.getEmitModuleResolutionKind(compilerOptions) !== ts.ModuleResolutionKind.NodeJs || ts.endsWith(oldImportSpecifier, "index") ? 1 /* Ending.Index */ : 0 /* Ending.Minimal */,
            };
        }
        function isFormatRequiringExtensions(compilerOptions, importingSourceFileName, host) {
            var _a;
            if (ts.getEmitModuleResolutionKind(compilerOptions) !== ts.ModuleResolutionKind.Node16
                && ts.getEmitModuleResolutionKind(compilerOptions) !== ts.ModuleResolutionKind.NodeNext) {
                return false;
            }
            return ts.getImpliedNodeFormatForFile(importingSourceFileName, (_a = host.getPackageJsonInfoCache) === null || _a === void 0 ? void 0 : _a.call(host), getModuleResolutionHost(host), compilerOptions) !== ts.ModuleKind.CommonJS;
        }
        function getModuleResolutionHost(host) {
            var _a;
            return {
                fileExists: host.fileExists,
                readFile: ts.Debug.checkDefined(host.readFile),
                directoryExists: host.directoryExists,
                getCurrentDirectory: host.getCurrentDirectory,
                realpath: host.realpath,
                useCaseSensitiveFileNames: (_a = host.useCaseSensitiveFileNames) === null || _a === void 0 ? void 0 : _a.call(host),
            };
        }
        // `importingSourceFile` and `importingSourceFileName`? Why not just use `importingSourceFile.path`?
        // Because when this is called by the file renamer, `importingSourceFile` is the file being renamed,
        // while `importingSourceFileName` its *new* name. We need a source file just to get its
        // `impliedNodeFormat` and to detect certain preferences from existing import module specifiers.
        function updateModuleSpecifier(compilerOptions, importingSourceFile, importingSourceFileName, toFileName, host, oldImportSpecifier, options) {
            if (options === void 0) { options = {}; }
            var res = getModuleSpecifierWorker(compilerOptions, importingSourceFile, importingSourceFileName, toFileName, host, getPreferencesForUpdate(compilerOptions, oldImportSpecifier, importingSourceFileName, host), {}, options);
            if (res === oldImportSpecifier)
                return undefined;
            return res;
        }
        moduleSpecifiers_1.updateModuleSpecifier = updateModuleSpecifier;
        // `importingSourceFile` and `importingSourceFileName`? Why not just use `importingSourceFile.path`?
        // Because when this is called by the declaration emitter, `importingSourceFile` is the implementation
        // file, but `importingSourceFileName` and `toFileName` refer to declaration files (the former to the
        // one currently being produced; the latter to the one being imported). We need an implementation file
        // just to get its `impliedNodeFormat` and to detect certain preferences from existing import module
        // specifiers.
        function getModuleSpecifier(compilerOptions, importingSourceFile, importingSourceFileName, toFileName, host, options) {
            if (options === void 0) { options = {}; }
            return getModuleSpecifierWorker(compilerOptions, importingSourceFile, importingSourceFileName, toFileName, host, getPreferences(host, {}, compilerOptions, importingSourceFile), {}, options);
        }
        moduleSpecifiers_1.getModuleSpecifier = getModuleSpecifier;
        function getNodeModulesPackageName(compilerOptions, importingSourceFile, nodeModulesFileName, host, preferences, options) {
            if (options === void 0) { options = {}; }
            var info = getInfo(importingSourceFile.path, host);
            var modulePaths = getAllModulePaths(importingSourceFile.path, nodeModulesFileName, host, preferences, options);
            return ts.firstDefined(modulePaths, function (modulePath) { return tryGetModuleNameAsNodeModule(modulePath, info, importingSourceFile, host, compilerOptions, preferences, /*packageNameOnly*/ true, options.overrideImportMode); });
        }
        moduleSpecifiers_1.getNodeModulesPackageName = getNodeModulesPackageName;
        function getModuleSpecifierWorker(compilerOptions, importingSourceFile, importingSourceFileName, toFileName, host, preferences, userPreferences, options) {
            if (options === void 0) { options = {}; }
            var info = getInfo(importingSourceFileName, host);
            var modulePaths = getAllModulePaths(importingSourceFileName, toFileName, host, userPreferences, options);
            return ts.firstDefined(modulePaths, function (modulePath) { return tryGetModuleNameAsNodeModule(modulePath, info, importingSourceFile, host, compilerOptions, userPreferences, /*packageNameOnly*/ undefined, options.overrideImportMode); }) ||
                getLocalModuleSpecifier(toFileName, info, compilerOptions, host, preferences);
        }
        function tryGetModuleSpecifiersFromCache(moduleSymbol, importingSourceFile, host, userPreferences, options) {
            if (options === void 0) { options = {}; }
            return tryGetModuleSpecifiersFromCacheWorker(moduleSymbol, importingSourceFile, host, userPreferences, options)[0];
        }
        moduleSpecifiers_1.tryGetModuleSpecifiersFromCache = tryGetModuleSpecifiersFromCache;
        function tryGetModuleSpecifiersFromCacheWorker(moduleSymbol, importingSourceFile, host, userPreferences, options) {
            var _a;
            if (options === void 0) { options = {}; }
            var moduleSourceFile = ts.getSourceFileOfModule(moduleSymbol);
            if (!moduleSourceFile) {
                return ts.emptyArray;
            }
            var cache = (_a = host.getModuleSpecifierCache) === null || _a === void 0 ? void 0 : _a.call(host);
            var cached = cache === null || cache === void 0 ? void 0 : cache.get(importingSourceFile.path, moduleSourceFile.path, userPreferences, options);
            return [cached === null || cached === void 0 ? void 0 : cached.moduleSpecifiers, moduleSourceFile, cached === null || cached === void 0 ? void 0 : cached.modulePaths, cache];
        }
        /** Returns an import for each symlink and for the realpath. */
        function getModuleSpecifiers(moduleSymbol, checker, compilerOptions, importingSourceFile, host, userPreferences, options) {
            if (options === void 0) { options = {}; }
            return getModuleSpecifiersWithCacheInfo(moduleSymbol, checker, compilerOptions, importingSourceFile, host, userPreferences, options).moduleSpecifiers;
        }
        moduleSpecifiers_1.getModuleSpecifiers = getModuleSpecifiers;
        function getModuleSpecifiersWithCacheInfo(moduleSymbol, checker, compilerOptions, importingSourceFile, host, userPreferences, options) {
            if (options === void 0) { options = {}; }
            var computedWithoutCache = false;
            var ambient = tryGetModuleNameFromAmbientModule(moduleSymbol, checker);
            if (ambient)
                return { moduleSpecifiers: [ambient], computedWithoutCache: computedWithoutCache };
            // eslint-disable-next-line prefer-const
            var _a = tryGetModuleSpecifiersFromCacheWorker(moduleSymbol, importingSourceFile, host, userPreferences, options), specifiers = _a[0], moduleSourceFile = _a[1], modulePaths = _a[2], cache = _a[3];
            if (specifiers)
                return { moduleSpecifiers: specifiers, computedWithoutCache: computedWithoutCache };
            if (!moduleSourceFile)
                return { moduleSpecifiers: ts.emptyArray, computedWithoutCache: computedWithoutCache };
            computedWithoutCache = true;
            modulePaths || (modulePaths = getAllModulePathsWorker(importingSourceFile.path, moduleSourceFile.originalFileName, host));
            var result = computeModuleSpecifiers(modulePaths, compilerOptions, importingSourceFile, host, userPreferences, options);
            cache === null || cache === void 0 ? void 0 : cache.set(importingSourceFile.path, moduleSourceFile.path, userPreferences, options, modulePaths, result);
            return { moduleSpecifiers: result, computedWithoutCache: computedWithoutCache };
        }
        moduleSpecifiers_1.getModuleSpecifiersWithCacheInfo = getModuleSpecifiersWithCacheInfo;
        function computeModuleSpecifiers(modulePaths, compilerOptions, importingSourceFile, host, userPreferences, options) {
            if (options === void 0) { options = {}; }
            var info = getInfo(importingSourceFile.path, host);
            var preferences = getPreferences(host, userPreferences, compilerOptions, importingSourceFile);
            var existingSpecifier = ts.forEach(modulePaths, function (modulePath) { return ts.forEach(host.getFileIncludeReasons().get(ts.toPath(modulePath.path, host.getCurrentDirectory(), info.getCanonicalFileName)), function (reason) {
                if (reason.kind !== ts.FileIncludeKind.Import || reason.file !== importingSourceFile.path)
                    return undefined;
                // If the candidate import mode doesn't match the mode we're generating for, don't consider it
                // TODO: maybe useful to keep around as an alternative option for certain contexts where the mode is overridable
                if (importingSourceFile.impliedNodeFormat && importingSourceFile.impliedNodeFormat !== ts.getModeForResolutionAtIndex(importingSourceFile, reason.index))
                    return undefined;
                var specifier = ts.getModuleNameStringLiteralAt(importingSourceFile, reason.index).text;
                // If the preference is for non relative and the module specifier is relative, ignore it
                return preferences.relativePreference !== 1 /* RelativePreference.NonRelative */ || !ts.pathIsRelative(specifier) ?
                    specifier :
                    undefined;
            }); });
            if (existingSpecifier) {
                var moduleSpecifiers_2 = [existingSpecifier];
                return moduleSpecifiers_2;
            }
            var importedFileIsInNodeModules = ts.some(modulePaths, function (p) { return p.isInNodeModules; });
            // Module specifier priority:
            //   1. "Bare package specifiers" (e.g. "@foo/bar") resulting from a path through node_modules to a package.json's "types" entry
            //   2. Specifiers generated using "paths" from tsconfig
            //   3. Non-relative specfiers resulting from a path through node_modules (e.g. "@foo/bar/path/to/file")
            //   4. Relative paths
            var nodeModulesSpecifiers;
            var pathsSpecifiers;
            var relativeSpecifiers;
            for (var _i = 0, modulePaths_1 = modulePaths; _i < modulePaths_1.length; _i++) {
                var modulePath = modulePaths_1[_i];
                var specifier = tryGetModuleNameAsNodeModule(modulePath, info, importingSourceFile, host, compilerOptions, userPreferences, /*packageNameOnly*/ undefined, options.overrideImportMode);
                nodeModulesSpecifiers = ts.append(nodeModulesSpecifiers, specifier);
                if (specifier && modulePath.isRedirect) {
                    // If we got a specifier for a redirect, it was a bare package specifier (e.g. "@foo/bar",
                    // not "@foo/bar/path/to/file"). No other specifier will be this good, so stop looking.
                    return nodeModulesSpecifiers;
                }
                if (!specifier && !modulePath.isRedirect) {
                    var local = getLocalModuleSpecifier(modulePath.path, info, compilerOptions, host, preferences);
                    if (ts.pathIsBareSpecifier(local)) {
                        pathsSpecifiers = ts.append(pathsSpecifiers, local);
                    }
                    else if (!importedFileIsInNodeModules || modulePath.isInNodeModules) {
                        // Why this extra conditional, not just an `else`? If some path to the file contained
                        // 'node_modules', but we can't create a non-relative specifier (e.g. "@foo/bar/path/to/file"),
                        // that means we had to go through a *sibling's* node_modules, not one we can access directly.
                        // If some path to the file was in node_modules but another was not, this likely indicates that
                        // we have a monorepo structure with symlinks. In this case, the non-node_modules path is
                        // probably the realpath, e.g. "../bar/path/to/file", but a relative path to another package
                        // in a monorepo is probably not portable. So, the module specifier we actually go with will be
                        // the relative path through node_modules, so that the declaration emitter can produce a
                        // portability error. (See declarationEmitReexportedSymlinkReference3)
                        relativeSpecifiers = ts.append(relativeSpecifiers, local);
                    }
                }
            }
            return (pathsSpecifiers === null || pathsSpecifiers === void 0 ? void 0 : pathsSpecifiers.length) ? pathsSpecifiers :
                (nodeModulesSpecifiers === null || nodeModulesSpecifiers === void 0 ? void 0 : nodeModulesSpecifiers.length) ? nodeModulesSpecifiers :
                    ts.Debug.checkDefined(relativeSpecifiers);
        }
        // importingSourceFileName is separate because getEditsForFileRename may need to specify an updated path
        function getInfo(importingSourceFileName, host) {
            var getCanonicalFileName = ts.createGetCanonicalFileName(host.useCaseSensitiveFileNames ? host.useCaseSensitiveFileNames() : true);
            var sourceDirectory = ts.getDirectoryPath(importingSourceFileName);
            return { getCanonicalFileName: getCanonicalFileName, importingSourceFileName: importingSourceFileName, sourceDirectory: sourceDirectory };
        }
        function getLocalModuleSpecifier(moduleFileName, info, compilerOptions, host, _a) {
            var ending = _a.ending, relativePreference = _a.relativePreference;
            var baseUrl = compilerOptions.baseUrl, paths = compilerOptions.paths, rootDirs = compilerOptions.rootDirs;
            var sourceDirectory = info.sourceDirectory, getCanonicalFileName = info.getCanonicalFileName;
            var relativePath = rootDirs && tryGetModuleNameFromRootDirs(rootDirs, moduleFileName, sourceDirectory, getCanonicalFileName, ending, compilerOptions) ||
                removeExtensionAndIndexPostFix(ts.ensurePathIsNonModuleName(ts.getRelativePathFromDirectory(sourceDirectory, moduleFileName, getCanonicalFileName)), ending, compilerOptions);
            if (!baseUrl && !paths || relativePreference === 0 /* RelativePreference.Relative */) {
                return relativePath;
            }
            var baseDirectory = ts.getNormalizedAbsolutePath(ts.getPathsBasePath(compilerOptions, host) || baseUrl, host.getCurrentDirectory());
            var relativeToBaseUrl = getRelativePathIfInDirectory(moduleFileName, baseDirectory, getCanonicalFileName);
            if (!relativeToBaseUrl) {
                return relativePath;
            }
            var importRelativeToBaseUrl = removeExtensionAndIndexPostFix(relativeToBaseUrl, ending, compilerOptions);
            var fromPaths = paths && tryGetModuleNameFromPaths(ts.removeFileExtension(relativeToBaseUrl), importRelativeToBaseUrl, paths);
            var nonRelative = fromPaths === undefined && baseUrl !== undefined ? importRelativeToBaseUrl : fromPaths;
            if (!nonRelative) {
                return relativePath;
            }
            if (relativePreference === 1 /* RelativePreference.NonRelative */) {
                return nonRelative;
            }
            if (relativePreference === 3 /* RelativePreference.ExternalNonRelative */) {
                var projectDirectory = compilerOptions.configFilePath ?
                    ts.toPath(ts.getDirectoryPath(compilerOptions.configFilePath), host.getCurrentDirectory(), info.getCanonicalFileName) :
                    info.getCanonicalFileName(host.getCurrentDirectory());
                var modulePath = ts.toPath(moduleFileName, projectDirectory, getCanonicalFileName);
                var sourceIsInternal = ts.startsWith(sourceDirectory, projectDirectory);
                var targetIsInternal = ts.startsWith(modulePath, projectDirectory);
                if (sourceIsInternal && !targetIsInternal || !sourceIsInternal && targetIsInternal) {
                    // 1. The import path crosses the boundary of the tsconfig.json-containing directory.
                    //
                    //      src/
                    //        tsconfig.json
                    //        index.ts -------
                    //      lib/              | (path crosses tsconfig.json)
                    //        imported.ts <---
                    //
                    return nonRelative;
                }
                var nearestTargetPackageJson = getNearestAncestorDirectoryWithPackageJson(host, ts.getDirectoryPath(modulePath));
                var nearestSourcePackageJson = getNearestAncestorDirectoryWithPackageJson(host, sourceDirectory);
                if (nearestSourcePackageJson !== nearestTargetPackageJson) {
                    // 2. The importing and imported files are part of different packages.
                    //
                    //      packages/a/
                    //        package.json
                    //        index.ts --------
                    //      packages/b/        | (path crosses package.json)
                    //        package.json     |
                    //        component.ts <---
                    //
                    return nonRelative;
                }
                return relativePath;
            }
            if (relativePreference !== 2 /* RelativePreference.Shortest */)
                ts.Debug.assertNever(relativePreference);
            // Prefer a relative import over a baseUrl import if it has fewer components.
            return isPathRelativeToParent(nonRelative) || countPathComponents(relativePath) < countPathComponents(nonRelative) ? relativePath : nonRelative;
        }
        function countPathComponents(path) {
            var count = 0;
            for (var i = ts.startsWith(path, "./") ? 2 : 0; i < path.length; i++) {
                if (path.charCodeAt(i) === 47 /* CharacterCodes.slash */)
                    count++;
            }
            return count;
        }
        moduleSpecifiers_1.countPathComponents = countPathComponents;
        function usesJsExtensionOnImports(_a) {
            var imports = _a.imports;
            return ts.firstDefined(imports, function (_a) {
                var text = _a.text;
                return ts.pathIsRelative(text) ? ts.hasJSFileExtension(text) : undefined;
            }) || false;
        }
        function comparePathsByRedirectAndNumberOfDirectorySeparators(a, b) {
            return ts.compareBooleans(b.isRedirect, a.isRedirect) || ts.compareNumberOfDirectorySeparators(a.path, b.path);
        }
        function getNearestAncestorDirectoryWithPackageJson(host, fileName) {
            if (host.getNearestAncestorDirectoryWithPackageJson) {
                return host.getNearestAncestorDirectoryWithPackageJson(fileName);
            }
            return !!ts.forEachAncestorDirectory(fileName, function (directory) {
                return host.fileExists(ts.combinePaths(directory, "package.json")) ? true : undefined;
            });
        }
        function forEachFileNameOfModule(importingFileName, importedFileName, host, preferSymlinks, cb) {
            var _a;
            var getCanonicalFileName = ts.hostGetCanonicalFileName(host);
            var cwd = host.getCurrentDirectory();
            var referenceRedirect = host.isSourceOfProjectReferenceRedirect(importedFileName) ? host.getProjectReferenceRedirect(importedFileName) : undefined;
            var importedPath = ts.toPath(importedFileName, cwd, getCanonicalFileName);
            var redirects = host.redirectTargetsMap.get(importedPath) || ts.emptyArray;
            var importedFileNames = __spreadArray(__spreadArray(__spreadArray([], (referenceRedirect ? [referenceRedirect] : ts.emptyArray), true), [importedFileName], false), redirects, true);
            var targets = importedFileNames.map(function (f) { return ts.getNormalizedAbsolutePath(f, cwd); });
            var shouldFilterIgnoredPaths = !ts.every(targets, ts.containsIgnoredPath);
            if (!preferSymlinks) {
                // Symlinks inside ignored paths are already filtered out of the symlink cache,
                // so we only need to remove them from the realpath filenames.
                var result_15 = ts.forEach(targets, function (p) { return !(shouldFilterIgnoredPaths && ts.containsIgnoredPath(p)) && cb(p, referenceRedirect === p); });
                if (result_15)
                    return result_15;
            }
            var symlinkedDirectories = (_a = host.getSymlinkCache) === null || _a === void 0 ? void 0 : _a.call(host).getSymlinkedDirectoriesByRealpath();
            var fullImportedFileName = ts.getNormalizedAbsolutePath(importedFileName, cwd);
            var result = symlinkedDirectories && ts.forEachAncestorDirectory(ts.getDirectoryPath(fullImportedFileName), function (realPathDirectory) {
                var symlinkDirectories = symlinkedDirectories.get(ts.ensureTrailingDirectorySeparator(ts.toPath(realPathDirectory, cwd, getCanonicalFileName)));
                if (!symlinkDirectories)
                    return undefined; // Continue to ancestor directory
                // Don't want to a package to globally import from itself (importNameCodeFix_symlink_own_package.ts)
                if (ts.startsWithDirectory(importingFileName, realPathDirectory, getCanonicalFileName)) {
                    return false; // Stop search, each ancestor directory will also hit this condition
                }
                return ts.forEach(targets, function (target) {
                    if (!ts.startsWithDirectory(target, realPathDirectory, getCanonicalFileName)) {
                        return;
                    }
                    var relative = ts.getRelativePathFromDirectory(realPathDirectory, target, getCanonicalFileName);
                    for (var _i = 0, symlinkDirectories_1 = symlinkDirectories; _i < symlinkDirectories_1.length; _i++) {
                        var symlinkDirectory = symlinkDirectories_1[_i];
                        var option = ts.resolvePath(symlinkDirectory, relative);
                        var result_16 = cb(option, target === referenceRedirect);
                        shouldFilterIgnoredPaths = true; // We found a non-ignored path in symlinks, so we can reject ignored-path realpaths
                        if (result_16)
                            return result_16;
                    }
                });
            });
            return result || (preferSymlinks
                ? ts.forEach(targets, function (p) { return shouldFilterIgnoredPaths && ts.containsIgnoredPath(p) ? undefined : cb(p, p === referenceRedirect); })
                : undefined);
        }
        moduleSpecifiers_1.forEachFileNameOfModule = forEachFileNameOfModule;
        /**
         * Looks for existing imports that use symlinks to this module.
         * Symlinks will be returned first so they are preferred over the real path.
         */
        function getAllModulePaths(importingFilePath, importedFileName, host, preferences, options) {
            var _a;
            if (options === void 0) { options = {}; }
            var importedFilePath = ts.toPath(importedFileName, host.getCurrentDirectory(), ts.hostGetCanonicalFileName(host));
            var cache = (_a = host.getModuleSpecifierCache) === null || _a === void 0 ? void 0 : _a.call(host);
            if (cache) {
                var cached = cache.get(importingFilePath, importedFilePath, preferences, options);
                if (cached === null || cached === void 0 ? void 0 : cached.modulePaths)
                    return cached.modulePaths;
            }
            var modulePaths = getAllModulePathsWorker(importingFilePath, importedFileName, host);
            if (cache) {
                cache.setModulePaths(importingFilePath, importedFilePath, preferences, options, modulePaths);
            }
            return modulePaths;
        }
        function getAllModulePathsWorker(importingFileName, importedFileName, host) {
            var getCanonicalFileName = ts.hostGetCanonicalFileName(host);
            var allFileNames = new ts.Map();
            var importedFileFromNodeModules = false;
            forEachFileNameOfModule(importingFileName, importedFileName, host, 
            /*preferSymlinks*/ true, function (path, isRedirect) {
                var isInNodeModules = ts.pathContainsNodeModules(path);
                allFileNames.set(path, { path: getCanonicalFileName(path), isRedirect: isRedirect, isInNodeModules: isInNodeModules });
                importedFileFromNodeModules = importedFileFromNodeModules || isInNodeModules;
                // don't return value, so we collect everything
            });
            // Sort by paths closest to importing file Name directory
            var sortedPaths = [];
            var _loop_32 = function (directory) {
                var directoryStart = ts.ensureTrailingDirectorySeparator(directory);
                var pathsInDirectory;
                allFileNames.forEach(function (_a, fileName) {
                    var path = _a.path, isRedirect = _a.isRedirect, isInNodeModules = _a.isInNodeModules;
                    if (ts.startsWith(path, directoryStart)) {
                        (pathsInDirectory || (pathsInDirectory = [])).push({ path: fileName, isRedirect: isRedirect, isInNodeModules: isInNodeModules });
                        allFileNames.delete(fileName);
                    }
                });
                if (pathsInDirectory) {
                    if (pathsInDirectory.length > 1) {
                        pathsInDirectory.sort(comparePathsByRedirectAndNumberOfDirectorySeparators);
                    }
                    sortedPaths.push.apply(sortedPaths, pathsInDirectory);
                }
                var newDirectory = ts.getDirectoryPath(directory);
                if (newDirectory === directory)
                    return out_directory_1 = directory, "break";
                directory = newDirectory;
                out_directory_1 = directory;
            };
            var out_directory_1;
            for (var directory = ts.getDirectoryPath(importingFileName); allFileNames.size !== 0;) {
                var state_10 = _loop_32(directory);
                directory = out_directory_1;
                if (state_10 === "break")
                    break;
            }
            if (allFileNames.size) {
                var remainingPaths = ts.arrayFrom(allFileNames.values());
                if (remainingPaths.length > 1)
                    remainingPaths.sort(comparePathsByRedirectAndNumberOfDirectorySeparators);
                sortedPaths.push.apply(sortedPaths, remainingPaths);
            }
            return sortedPaths;
        }
        function tryGetModuleNameFromAmbientModule(moduleSymbol, checker) {
            var _a;
            var decl = (_a = moduleSymbol.declarations) === null || _a === void 0 ? void 0 : _a.find(function (d) { return ts.isNonGlobalAmbientModule(d) && (!ts.isExternalModuleAugmentation(d) || !ts.isExternalModuleNameRelative(ts.getTextOfIdentifierOrLiteral(d.name))); });
            if (decl) {
                return decl.name.text;
            }
            // the module could be a namespace, which is export through "export=" from an ambient module.
            /**
             * declare module "m" {
             *     namespace ns {
             *         class c {}
             *     }
             *     export = ns;
             * }
             */
            // `import {c} from "m";` is valid, in which case, `moduleSymbol` is "ns", but the module name should be "m"
            var ambientModuleDeclareCandidates = ts.mapDefined(moduleSymbol.declarations, function (d) {
                var _a, _b, _c, _d;
                if (!ts.isModuleDeclaration(d))
                    return;
                var topNamespace = getTopNamespace(d);
                if (!(((_a = topNamespace === null || topNamespace === void 0 ? void 0 : topNamespace.parent) === null || _a === void 0 ? void 0 : _a.parent)
                    && ts.isModuleBlock(topNamespace.parent) && ts.isAmbientModule(topNamespace.parent.parent) && ts.isSourceFile(topNamespace.parent.parent.parent)))
                    return;
                var exportAssignment = (_d = (_c = (_b = topNamespace.parent.parent.symbol.exports) === null || _b === void 0 ? void 0 : _b.get("export=")) === null || _c === void 0 ? void 0 : _c.valueDeclaration) === null || _d === void 0 ? void 0 : _d.expression;
                if (!exportAssignment)
                    return;
                var exportSymbol = checker.getSymbolAtLocation(exportAssignment);
                if (!exportSymbol)
                    return;
                var originalExportSymbol = (exportSymbol === null || exportSymbol === void 0 ? void 0 : exportSymbol.flags) & 2097152 /* SymbolFlags.Alias */ ? checker.getAliasedSymbol(exportSymbol) : exportSymbol;
                if (originalExportSymbol === d.symbol)
                    return topNamespace.parent.parent;
                function getTopNamespace(namespaceDeclaration) {
                    while (namespaceDeclaration.flags & 4 /* NodeFlags.NestedNamespace */) {
                        namespaceDeclaration = namespaceDeclaration.parent;
                    }
                    return namespaceDeclaration;
                }
            });
            var ambientModuleDeclare = ambientModuleDeclareCandidates[0];
            if (ambientModuleDeclare) {
                return ambientModuleDeclare.name.text;
            }
        }
        function tryGetModuleNameFromPaths(relativeToBaseUrlWithIndex, relativeToBaseUrl, paths) {
            for (var key in paths) {
                for (var _i = 0, _a = paths[key]; _i < _a.length; _i++) {
                    var patternText_1 = _a[_i];
                    var pattern = ts.removeFileExtension(ts.normalizePath(patternText_1));
                    var indexOfStar = pattern.indexOf("*");
                    if (indexOfStar !== -1) {
                        var prefix = pattern.substr(0, indexOfStar);
                        var suffix = pattern.substr(indexOfStar + 1);
                        if (relativeToBaseUrl.length >= prefix.length + suffix.length &&
                            ts.startsWith(relativeToBaseUrl, prefix) &&
                            ts.endsWith(relativeToBaseUrl, suffix) ||
                            !suffix && relativeToBaseUrl === ts.removeTrailingDirectorySeparator(prefix)) {
                            var matchedStar = relativeToBaseUrl.substr(prefix.length, relativeToBaseUrl.length - suffix.length - prefix.length);
                            return key.replace("*", matchedStar);
                        }
                    }
                    else if (pattern === relativeToBaseUrl || pattern === relativeToBaseUrlWithIndex) {
                        return key;
                    }
                }
            }
        }
        var MatchingMode;
        (function (MatchingMode) {
            MatchingMode[MatchingMode["Exact"] = 0] = "Exact";
            MatchingMode[MatchingMode["Directory"] = 1] = "Directory";
            MatchingMode[MatchingMode["Pattern"] = 2] = "Pattern";
        })(MatchingMode || (MatchingMode = {}));
        function tryGetModuleNameFromExports(options, targetFilePath, packageDirectory, packageName, exports, conditions, mode) {
            if (mode === void 0) { mode = 0 /* MatchingMode.Exact */; }
            if (typeof exports === "string") {
                var pathOrPattern = ts.getNormalizedAbsolutePath(ts.combinePaths(packageDirectory, exports), /*currentDirectory*/ undefined);
                var extensionSwappedTarget = ts.hasTSFileExtension(targetFilePath) ? ts.removeFileExtension(targetFilePath) + tryGetJSExtensionForFile(targetFilePath, options) : undefined;
                switch (mode) {
                    case 0 /* MatchingMode.Exact */:
                        if (ts.comparePaths(targetFilePath, pathOrPattern) === 0 /* Comparison.EqualTo */ || (extensionSwappedTarget && ts.comparePaths(extensionSwappedTarget, pathOrPattern) === 0 /* Comparison.EqualTo */)) {
                            return { moduleFileToTry: packageName };
                        }
                        break;
                    case 1 /* MatchingMode.Directory */:
                        if (ts.containsPath(pathOrPattern, targetFilePath)) {
                            var fragment = ts.getRelativePathFromDirectory(pathOrPattern, targetFilePath, /*ignoreCase*/ false);
                            return { moduleFileToTry: ts.getNormalizedAbsolutePath(ts.combinePaths(ts.combinePaths(packageName, exports), fragment), /*currentDirectory*/ undefined) };
                        }
                        break;
                    case 2 /* MatchingMode.Pattern */:
                        var starPos = pathOrPattern.indexOf("*");
                        var leadingSlice = pathOrPattern.slice(0, starPos);
                        var trailingSlice = pathOrPattern.slice(starPos + 1);
                        if (ts.startsWith(targetFilePath, leadingSlice) && ts.endsWith(targetFilePath, trailingSlice)) {
                            var starReplacement = targetFilePath.slice(leadingSlice.length, targetFilePath.length - trailingSlice.length);
                            return { moduleFileToTry: packageName.replace("*", starReplacement) };
                        }
                        if (extensionSwappedTarget && ts.startsWith(extensionSwappedTarget, leadingSlice) && ts.endsWith(extensionSwappedTarget, trailingSlice)) {
                            var starReplacement = extensionSwappedTarget.slice(leadingSlice.length, extensionSwappedTarget.length - trailingSlice.length);
                            return { moduleFileToTry: packageName.replace("*", starReplacement) };
                        }
                        break;
                }
            }
            else if (Array.isArray(exports)) {
                return ts.forEach(exports, function (e) { return tryGetModuleNameFromExports(options, targetFilePath, packageDirectory, packageName, e, conditions); });
            }
            else if (typeof exports === "object" && exports !== null) { // eslint-disable-line no-null/no-null
                if (ts.allKeysStartWithDot(exports)) {
                    // sub-mappings
                    // 3 cases:
                    // * directory mappings (legacyish, key ends with / (technically allows index/extension resolution under cjs mode))
                    // * pattern mappings (contains a *)
                    // * exact mappings (no *, does not end with /)
                    return ts.forEach(ts.getOwnKeys(exports), function (k) {
                        var subPackageName = ts.getNormalizedAbsolutePath(ts.combinePaths(packageName, k), /*currentDirectory*/ undefined);
                        var mode = ts.endsWith(k, "/") ? 1 /* MatchingMode.Directory */
                            : ts.stringContains(k, "*") ? 2 /* MatchingMode.Pattern */
                                : 0 /* MatchingMode.Exact */;
                        return tryGetModuleNameFromExports(options, targetFilePath, packageDirectory, subPackageName, exports[k], conditions, mode);
                    });
                }
                else {
                    // conditional mapping
                    for (var _i = 0, _a = ts.getOwnKeys(exports); _i < _a.length; _i++) {
                        var key = _a[_i];
                        if (key === "default" || conditions.indexOf(key) >= 0 || ts.isApplicableVersionedTypesKey(conditions, key)) {
                            var subTarget = exports[key];
                            var result = tryGetModuleNameFromExports(options, targetFilePath, packageDirectory, packageName, subTarget, conditions);
                            if (result) {
                                return result;
                            }
                        }
                    }
                }
            }
            return undefined;
        }
        function tryGetModuleNameFromRootDirs(rootDirs, moduleFileName, sourceDirectory, getCanonicalFileName, ending, compilerOptions) {
            var normalizedTargetPath = getPathRelativeToRootDirs(moduleFileName, rootDirs, getCanonicalFileName);
            if (normalizedTargetPath === undefined) {
                return undefined;
            }
            var normalizedSourcePath = getPathRelativeToRootDirs(sourceDirectory, rootDirs, getCanonicalFileName);
            var relativePath = normalizedSourcePath !== undefined ? ts.ensurePathIsNonModuleName(ts.getRelativePathFromDirectory(normalizedSourcePath, normalizedTargetPath, getCanonicalFileName)) : normalizedTargetPath;
            return ts.getEmitModuleResolutionKind(compilerOptions) === ts.ModuleResolutionKind.NodeJs
                ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)
                : ts.removeFileExtension(relativePath);
        }
        function tryGetModuleNameAsNodeModule(_a, _b, importingSourceFile, host, options, userPreferences, packageNameOnly, overrideMode) {
            var path = _a.path, isRedirect = _a.isRedirect;
            var getCanonicalFileName = _b.getCanonicalFileName, sourceDirectory = _b.sourceDirectory;
            if (!host.fileExists || !host.readFile) {
                return undefined;
            }
            var parts = ts.getNodeModulePathParts(path);
            if (!parts) {
                return undefined;
            }
            // Simplify the full file path to something that can be resolved by Node.
            var moduleSpecifier = path;
            var isPackageRootPath = false;
            if (!packageNameOnly) {
                var preferences = getPreferences(host, userPreferences, options, importingSourceFile);
                var packageRootIndex = parts.packageRootIndex;
                var moduleFileName = void 0;
                while (true) {
                    // If the module could be imported by a directory name, use that directory's name
                    var _c = tryDirectoryWithPackageJson(packageRootIndex), moduleFileToTry = _c.moduleFileToTry, packageRootPath = _c.packageRootPath, blockedByExports = _c.blockedByExports, verbatimFromExports = _c.verbatimFromExports;
                    if (ts.getEmitModuleResolutionKind(options) !== ts.ModuleResolutionKind.Classic) {
                        if (blockedByExports) {
                            return undefined; // File is under this package.json, but is not publicly exported - there's no way to name it via `node_modules` resolution
                        }
                        if (verbatimFromExports) {
                            return moduleFileToTry;
                        }
                    }
                    if (packageRootPath) {
                        moduleSpecifier = packageRootPath;
                        isPackageRootPath = true;
                        break;
                    }
                    if (!moduleFileName)
                        moduleFileName = moduleFileToTry;
                    // try with next level of directory
                    packageRootIndex = path.indexOf(ts.directorySeparator, packageRootIndex + 1);
                    if (packageRootIndex === -1) {
                        moduleSpecifier = removeExtensionAndIndexPostFix(moduleFileName, preferences.ending, options, host);
                        break;
                    }
                }
            }
            if (isRedirect && !isPackageRootPath) {
                return undefined;
            }
            var globalTypingsCacheLocation = host.getGlobalTypingsCacheLocation && host.getGlobalTypingsCacheLocation();
            // Get a path that's relative to node_modules or the importing file's path
            // if node_modules folder is in this folder or any of its parent folders, no need to keep it.
            var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));
            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
                return undefined;
            }
            // If the module was found in @types, get the actual Node package name
            var nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
            var packageName = ts.getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
            // For classic resolution, only allow importing from node_modules/@types, not other node_modules
            return ts.getEmitModuleResolutionKind(options) === ts.ModuleResolutionKind.Classic && packageName === nodeModulesDirectoryName ? undefined : packageName;
            function tryDirectoryWithPackageJson(packageRootIndex) {
                var _a, _b;
                var packageRootPath = path.substring(0, packageRootIndex);
                var packageJsonPath = ts.combinePaths(packageRootPath, "package.json");
                var moduleFileToTry = path;
                var cachedPackageJson = (_b = (_a = host.getPackageJsonInfoCache) === null || _a === void 0 ? void 0 : _a.call(host)) === null || _b === void 0 ? void 0 : _b.getPackageJsonInfo(packageJsonPath);
                if (typeof cachedPackageJson === "object" || cachedPackageJson === undefined && host.fileExists(packageJsonPath)) {
                    var packageJsonContent = (cachedPackageJson === null || cachedPackageJson === void 0 ? void 0 : cachedPackageJson.packageJsonContent) || JSON.parse(host.readFile(packageJsonPath));
                    if (ts.getEmitModuleResolutionKind(options) === ts.ModuleResolutionKind.Node16 || ts.getEmitModuleResolutionKind(options) === ts.ModuleResolutionKind.NodeNext) {
                        // `conditions` *could* be made to go against `importingSourceFile.impliedNodeFormat` if something wanted to generate
                        // an ImportEqualsDeclaration in an ESM-implied file or an ImportCall in a CJS-implied file. But since this function is
                        // usually called to conjure an import out of thin air, we don't have an existing usage to call `getModeForUsageAtIndex`
                        // with, so for now we just stick with the mode of the file.
                        var conditions = ["node", overrideMode || importingSourceFile.impliedNodeFormat === ts.ModuleKind.ESNext ? "import" : "require", "types"];
                        var fromExports = packageJsonContent.exports && typeof packageJsonContent.name === "string"
                            ? tryGetModuleNameFromExports(options, path, packageRootPath, ts.getPackageNameFromTypesPackageName(packageJsonContent.name), packageJsonContent.exports, conditions)
                            : undefined;
                        if (fromExports) {
                            var withJsExtension = !ts.hasTSFileExtension(fromExports.moduleFileToTry)
                                ? fromExports
                                : { moduleFileToTry: ts.removeFileExtension(fromExports.moduleFileToTry) + tryGetJSExtensionForFile(fromExports.moduleFileToTry, options) };
                            return __assign(__assign({}, withJsExtension), { verbatimFromExports: true });
                        }
                        if (packageJsonContent.exports) {
                            return { moduleFileToTry: path, blockedByExports: true };
                        }
                    }
                    var versionPaths = packageJsonContent.typesVersions
                        ? ts.getPackageJsonTypesVersionsPaths(packageJsonContent.typesVersions)
                        : undefined;
                    if (versionPaths) {
                        var subModuleName = path.slice(packageRootPath.length + 1);
                        var fromPaths = tryGetModuleNameFromPaths(ts.removeFileExtension(subModuleName), removeExtensionAndIndexPostFix(subModuleName, 0 /* Ending.Minimal */, options), versionPaths.paths);
                        if (fromPaths !== undefined) {
                            moduleFileToTry = ts.combinePaths(packageRootPath, fromPaths);
                        }
                    }
                    // If the file is the main module, it can be imported by the package name
                    var mainFileRelative = packageJsonContent.typings || packageJsonContent.types || packageJsonContent.main || "index.js";
                    if (ts.isString(mainFileRelative)) {
                        var mainExportFile = ts.toPath(mainFileRelative, packageRootPath, getCanonicalFileName);
                        if (ts.removeFileExtension(mainExportFile) === ts.removeFileExtension(getCanonicalFileName(moduleFileToTry))) {
                            return { packageRootPath: packageRootPath, moduleFileToTry: moduleFileToTry };
                        }
                    }
                }
                else {
                    // No package.json exists; an index.js will still resolve as the package name
                    var fileName = getCanonicalFileName(moduleFileToTry.substring(parts.packageRootIndex + 1));
                    if (fileName === "index.d.ts" || fileName === "index.js" || fileName === "index.ts" || fileName === "index.tsx") {
                        return { moduleFileToTry: moduleFileToTry, packageRootPath: packageRootPath };
                    }
                }
                return { moduleFileToTry: moduleFileToTry };
            }
        }
        function tryGetAnyFileFromPath(host, path) {
            if (!host.fileExists)
                return;
            // We check all js, `node` and `json` extensions in addition to TS, since node module resolution would also choose those over the directory
            var extensions = ts.flatten(ts.getSupportedExtensions({ allowJs: true }, [{ extension: "node", isMixedContent: false }, { extension: "json", isMixedContent: false, scriptKind: 6 /* ScriptKind.JSON */ }]));
            for (var _i = 0, extensions_3 = extensions; _i < extensions_3.length; _i++) {
                var e = extensions_3[_i];
                var fullPath = path + e;
                if (host.fileExists(fullPath)) {
                    return fullPath;
                }
            }
        }
        function getPathRelativeToRootDirs(path, rootDirs, getCanonicalFileName) {
            return ts.firstDefined(rootDirs, function (rootDir) {
                var relativePath = getRelativePathIfInDirectory(path, rootDir, getCanonicalFileName);
                return relativePath !== undefined && isPathRelativeToParent(relativePath) ? undefined : relativePath;
            });
        }
        function removeExtensionAndIndexPostFix(fileName, ending, options, host) {
            if (ts.fileExtensionIsOneOf(fileName, [".json" /* Extension.Json */, ".mjs" /* Extension.Mjs */, ".cjs" /* Extension.Cjs */]))
                return fileName;
            var noExtension = ts.removeFileExtension(fileName);
            if (fileName === noExtension)
                return fileName;
            if (ts.fileExtensionIsOneOf(fileName, [".d.mts" /* Extension.Dmts */, ".mts" /* Extension.Mts */, ".d.cts" /* Extension.Dcts */, ".cts" /* Extension.Cts */]))
                return noExtension + getJSExtensionForFile(fileName, options);
            switch (ending) {
                case 0 /* Ending.Minimal */:
                    var withoutIndex = ts.removeSuffix(noExtension, "/index");
                    if (host && withoutIndex !== noExtension && tryGetAnyFileFromPath(host, withoutIndex)) {
                        // Can't remove index if there's a file by the same name as the directory.
                        // Probably more callers should pass `host` so we can determine this?
                        return noExtension;
                    }
                    return withoutIndex;
                case 1 /* Ending.Index */:
                    return noExtension;
                case 2 /* Ending.JsExtension */:
                    return noExtension + getJSExtensionForFile(fileName, options);
                default:
                    return ts.Debug.assertNever(ending);
            }
        }
        function getJSExtensionForFile(fileName, options) {
            var _a;
            return (_a = tryGetJSExtensionForFile(fileName, options)) !== null && _a !== void 0 ? _a : ts.Debug.fail("Extension ".concat(ts.extensionFromPath(fileName), " is unsupported:: FileName:: ").concat(fileName));
        }
        function tryGetJSExtensionForFile(fileName, options) {
            var ext = ts.tryGetExtensionFromPath(fileName);
            switch (ext) {
                case ".ts" /* Extension.Ts */:
                case ".d.ts" /* Extension.Dts */:
                    return ".js" /* Extension.Js */;
                case ".tsx" /* Extension.Tsx */:
                    return options.jsx === 1 /* JsxEmit.Preserve */ ? ".jsx" /* Extension.Jsx */ : ".js" /* Extension.Js */;
                case ".js" /* Extension.Js */:
                case ".jsx" /* Extension.Jsx */:
                case ".json" /* Extension.Json */:
                    return ext;
                case ".d.mts" /* Extension.Dmts */:
                case ".mts" /* Extension.Mts */:
                case ".mjs" /* Extension.Mjs */:
                    return ".mjs" /* Extension.Mjs */;
                case ".d.cts" /* Extension.Dcts */:
                case ".cts" /* Extension.Cts */:
                case ".cjs" /* Extension.Cjs */:
                    return ".cjs" /* Extension.Cjs */;
                default:
                    return undefined;
            }
        }
        moduleSpecifiers_1.tryGetJSExtensionForFile = tryGetJSExtensionForFile;
        function getRelativePathIfInDirectory(path, directoryPath, getCanonicalFileName) {
            var relativePath = ts.getRelativePathToDirectoryOrUrl(directoryPath, path, directoryPath, getCanonicalFileName, /*isAbsolutePathAnUrl*/ false);
            return ts.isRootedDiskPath(relativePath) ? undefined : relativePath;
        }
        function isPathRelativeToParent(path) {
            return ts.startsWith(path, "..");
        }
    })(moduleSpecifiers = ts.moduleSpecifiers || (ts.moduleSpecifiers = {}));
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    var sysFormatDiagnosticsHost = ts.sys ? {
        getCurrentDirectory: function () { return ts.sys.getCurrentDirectory(); },
        getNewLine: function () { return ts.sys.newLine; },
        getCanonicalFileName: ts.createGetCanonicalFileName(ts.sys.useCaseSensitiveFileNames)
    } : undefined;
    /**
     * Create a function that reports error by writing to the system and handles the formatting of the diagnostic
     */
    function createDiagnosticReporter(system, pretty) {
        var host = system === ts.sys && sysFormatDiagnosticsHost ? sysFormatDiagnosticsHost : {
            getCurrentDirectory: function () { return system.getCurrentDirectory(); },
            getNewLine: function () { return system.newLine; },
            getCanonicalFileName: ts.createGetCanonicalFileName(system.useCaseSensitiveFileNames),
        };
        if (!pretty) {
            return function (diagnostic) { return system.write(ts.formatDiagnostic(diagnostic, host)); };
        }
        var diagnostics = new Array(1);
        return function (diagnostic) {
            diagnostics[0] = diagnostic;
            system.write(ts.formatDiagnosticsWithColorAndContext(diagnostics, host) + host.getNewLine());
            diagnostics[0] = undefined; // TODO: GH#18217
        };
    }
    ts.createDiagnosticReporter = createDiagnosticReporter;
    /**
     * @returns Whether the screen was cleared.
     */
    function clearScreenIfNotWatchingForFileChanges(system, diagnostic, options) {
        if (system.clearScreen &&
            !options.preserveWatchOutput &&
            !options.extendedDiagnostics &&
            !options.diagnostics &&
            ts.contains(ts.screenStartingMessageCodes, diagnostic.code)) {
            system.clearScreen();
            return true;
        }
        return false;
    }
    ts.screenStartingMessageCodes = [
        ts.Diagnostics.Starting_compilation_in_watch_mode.code,
        ts.Diagnostics.File_change_detected_Starting_incremental_compilation.code,
    ];
    function getPlainDiagnosticFollowingNewLines(diagnostic, newLine) {
        return ts.contains(ts.screenStartingMessageCodes, diagnostic.code)
            ? newLine + newLine
            : newLine;
    }
    /**
     * Get locale specific time based on whether we are in test mode
     */
    function getLocaleTimeString(system) {
        return !system.now ?
            new Date().toLocaleTimeString() :
            system.now().toLocaleTimeString("en-US", { timeZone: "UTC" });
    }
    ts.getLocaleTimeString = getLocaleTimeString;
    /**
     * Create a function that reports watch status by writing to the system and handles the formatting of the diagnostic
     */
    function createWatchStatusReporter(system, pretty) {
        return pretty ?
            function (diagnostic, newLine, options) {
                clearScreenIfNotWatchingForFileChanges(system, diagnostic, options);
                var output = "[".concat(ts.formatColorAndReset(getLocaleTimeString(system), ts.ForegroundColorEscapeSequences.Grey), "] ");
                output += "".concat(ts.flattenDiagnosticMessageText(diagnostic.messageText, system.newLine)).concat(newLine + newLine);
                system.write(output);
            } :
            function (diagnostic, newLine, options) {
                var output = "";
                if (!clearScreenIfNotWatchingForFileChanges(system, diagnostic, options)) {
                    output += newLine;
                }
                output += "".concat(getLocaleTimeString(system), " - ");
                output += "".concat(ts.flattenDiagnosticMessageText(diagnostic.messageText, system.newLine)).concat(getPlainDiagnosticFollowingNewLines(diagnostic, newLine));
                system.write(output);
            };
    }
    ts.createWatchStatusReporter = createWatchStatusReporter;
    /** Parses config file using System interface */
    function parseConfigFileWithSystem(configFileName, optionsToExtend, extendedConfigCache, watchOptionsToExtend, system, reportDiagnostic) {
        var host = system;
        host.onUnRecoverableConfigFileDiagnostic = function (diagnostic) { return reportUnrecoverableDiagnostic(system, reportDiagnostic, diagnostic); };
        var result = ts.getParsedCommandLineOfConfigFile(configFileName, optionsToExtend, host, extendedConfigCache, watchOptionsToExtend);
        host.onUnRecoverableConfigFileDiagnostic = undefined; // TODO: GH#18217
        return result;
    }
    ts.parseConfigFileWithSystem = parseConfigFileWithSystem;
    function getErrorCountForSummary(diagnostics) {
        return ts.countWhere(diagnostics, function (diagnostic) { return diagnostic.category === ts.DiagnosticCategory.Error; });
    }
    ts.getErrorCountForSummary = getErrorCountForSummary;
    function getFilesInErrorForSummary(diagnostics) {
        var filesInError = ts.filter(diagnostics, function (diagnostic) { return diagnostic.category === ts.DiagnosticCategory.Error; })
            .map(function (errorDiagnostic) {
            if (errorDiagnostic.file === undefined)
                return;
            return "".concat(errorDiagnostic.file.fileName);
        });
        return filesInError.map(function (fileName) {
            var diagnosticForFileName = ts.find(diagnostics, function (diagnostic) {
                return diagnostic.file !== undefined && diagnostic.file.fileName === fileName;
            });
            if (diagnosticForFileName !== undefined) {
                var line = ts.getLineAndCharacterOfPosition(diagnosticForFileName.file, diagnosticForFileName.start).line;
                return {
                    fileName: fileName,
                    line: line + 1,
                };
            }
        });
    }
    ts.getFilesInErrorForSummary = getFilesInErrorForSummary;
    function getWatchErrorSummaryDiagnosticMessage(errorCount) {
        return errorCount === 1 ?
            ts.Diagnostics.Found_1_error_Watching_for_file_changes :
            ts.Diagnostics.Found_0_errors_Watching_for_file_changes;
    }
    ts.getWatchErrorSummaryDiagnosticMessage = getWatchErrorSummaryDiagnosticMessage;
    function prettyPathForFileError(error, cwd) {
        var line = ts.formatColorAndReset(":" + error.line, ts.ForegroundColorEscapeSequences.Grey);
        if (ts.pathIsAbsolute(error.fileName) && ts.pathIsAbsolute(cwd)) {
            return ts.getRelativePathFromDirectory(cwd, error.fileName, /* ignoreCase */ false) + line;
        }
        return error.fileName + line;
    }
    function getErrorSummaryText(errorCount, filesInError, newLine, host) {
        if (errorCount === 0)
            return "";
        var nonNilFiles = filesInError.filter(function (fileInError) { return fileInError !== undefined; });
        var distinctFileNamesWithLines = nonNilFiles.map(function (fileInError) { return "".concat(fileInError.fileName, ":").concat(fileInError.line); })
            .filter(function (value, index, self) { return self.indexOf(value) === index; });
        var firstFileReference = nonNilFiles[0] && prettyPathForFileError(nonNilFiles[0], host.getCurrentDirectory());
        var d = errorCount === 1 ?
            ts.createCompilerDiagnostic(filesInError[0] !== undefined ?
                ts.Diagnostics.Found_1_error_in_1 :
                ts.Diagnostics.Found_1_error, errorCount, firstFileReference) :
            ts.createCompilerDiagnostic(distinctFileNamesWithLines.length === 0 ?
                ts.Diagnostics.Found_0_errors :
                distinctFileNamesWithLines.length === 1 ?
                    ts.Diagnostics.Found_0_errors_in_the_same_file_starting_at_Colon_1 :
                    ts.Diagnostics.Found_0_errors_in_1_files, errorCount, distinctFileNamesWithLines.length === 1 ? firstFileReference : distinctFileNamesWithLines.length);
        var suffix = distinctFileNamesWithLines.length > 1 ? createTabularErrorsDisplay(nonNilFiles, host) : "";
        return "".concat(newLine).concat(ts.flattenDiagnosticMessageText(d.messageText, newLine)).concat(newLine).concat(newLine).concat(suffix);
    }
    ts.getErrorSummaryText = getErrorSummaryText;
    function createTabularErrorsDisplay(filesInError, host) {
        var distinctFiles = filesInError.filter(function (value, index, self) { return index === self.findIndex(function (file) { return (file === null || file === void 0 ? void 0 : file.fileName) === (value === null || value === void 0 ? void 0 : value.fileName); }); });
        if (distinctFiles.length === 0)
            return "";
        var numberLength = function (num) { return Math.log(num) * Math.LOG10E + 1; };
        var fileToErrorCount = distinctFiles.map(function (file) { return [file, ts.countWhere(filesInError, function (fileInError) { return fileInError.fileName === file.fileName; })]; });
        var maxErrors = fileToErrorCount.reduce(function (acc, value) { return Math.max(acc, value[1] || 0); }, 0);
        var headerRow = ts.Diagnostics.Errors_Files.message;
        var leftColumnHeadingLength = headerRow.split(" ")[0].length;
        var leftPaddingGoal = Math.max(leftColumnHeadingLength, numberLength(maxErrors));
        var headerPadding = Math.max(numberLength(maxErrors) - leftColumnHeadingLength, 0);
        var tabularData = "";
        tabularData += " ".repeat(headerPadding) + headerRow + "\n";
        fileToErrorCount.forEach(function (row) {
            var file = row[0], errorCount = row[1];
            var errorCountDigitsLength = Math.log(errorCount) * Math.LOG10E + 1 | 0;
            var leftPadding = errorCountDigitsLength < leftPaddingGoal ?
                " ".repeat(leftPaddingGoal - errorCountDigitsLength)
                : "";
            var fileRef = prettyPathForFileError(file, host.getCurrentDirectory());
            tabularData += "".concat(leftPadding).concat(errorCount, "  ").concat(fileRef, "\n");
        });
        return tabularData;
    }
    function isBuilderProgram(program) {
        return !!program.getState;
    }
    ts.isBuilderProgram = isBuilderProgram;
    function listFiles(program, write) {
        var options = program.getCompilerOptions();
        if (options.explainFiles) {
            explainFiles(isBuilderProgram(program) ? program.getProgram() : program, write);
        }
        else if (options.listFiles || options.listFilesOnly) {
            ts.forEach(program.getSourceFiles(), function (file) {
                write(file.fileName);
            });
        }
    }
    ts.listFiles = listFiles;
    function explainFiles(program, write) {
        var _a, _b;
        var reasons = program.getFileIncludeReasons();
        var getCanonicalFileName = ts.createGetCanonicalFileName(program.useCaseSensitiveFileNames());
        var relativeFileName = function (fileName) { return ts.convertToRelativePath(fileName, program.getCurrentDirectory(), getCanonicalFileName); };
        for (var _i = 0, _c = program.getSourceFiles(); _i < _c.length; _i++) {
            var file = _c[_i];
            write("".concat(toFileName(file, relativeFileName)));
            (_a = reasons.get(file.path)) === null || _a === void 0 ? void 0 : _a.forEach(function (reason) { return write("  ".concat(fileIncludeReasonToDiagnostics(program, reason, relativeFileName).messageText)); });
            (_b = explainIfFileIsRedirect(file, relativeFileName)) === null || _b === void 0 ? void 0 : _b.forEach(function (d) { return write("  ".concat(d.messageText)); });
        }
    }
    ts.explainFiles = explainFiles;
    function explainIfFileIsRedirect(file, fileNameConvertor) {
        var result;
        if (file.path !== file.resolvedPath) {
            (result || (result = [])).push(ts.chainDiagnosticMessages(
            /*details*/ undefined, ts.Diagnostics.File_is_output_of_project_reference_source_0, toFileName(file.originalFileName, fileNameConvertor)));
        }
        if (file.redirectInfo) {
            (result || (result = [])).push(ts.chainDiagnosticMessages(
            /*details*/ undefined, ts.Diagnostics.File_redirects_to_file_0, toFileName(file.redirectInfo.redirectTarget, fileNameConvertor)));
        }
        return result;
    }
    ts.explainIfFileIsRedirect = explainIfFileIsRedirect;
    function getMatchedFileSpec(program, fileName) {
        var _a;
        var configFile = program.getCompilerOptions().configFile;
        if (!((_a = configFile === null || configFile === void 0 ? void 0 : configFile.configFileSpecs) === null || _a === void 0 ? void 0 : _a.validatedFilesSpec))
            return undefined;
        var getCanonicalFileName = ts.createGetCanonicalFileName(program.useCaseSensitiveFileNames());
        var filePath = getCanonicalFileName(fileName);
        var basePath = ts.getDirectoryPath(ts.getNormalizedAbsolutePath(configFile.fileName, program.getCurrentDirectory()));
        return ts.find(configFile.configFileSpecs.validatedFilesSpec, function (fileSpec) { return getCanonicalFileName(ts.getNormalizedAbsolutePath(fileSpec, basePath)) === filePath; });
    }
    ts.getMatchedFileSpec = getMatchedFileSpec;
    function getMatchedIncludeSpec(program, fileName) {
        var _a, _b;
        var configFile = program.getCompilerOptions().configFile;
        if (!((_a = configFile === null || configFile === void 0 ? void 0 : configFile.configFileSpecs) === null || _a === void 0 ? void 0 : _a.validatedIncludeSpecs))
            return undefined;
        var isJsonFile = ts.fileExtensionIs(fileName, ".json" /* Extension.Json */);
        var basePath = ts.getDirectoryPath(ts.getNormalizedAbsolutePath(configFile.fileName, program.getCurrentDirectory()));
        var useCaseSensitiveFileNames = program.useCaseSensitiveFileNames();
        return ts.find((_b = configFile === null || configFile === void 0 ? void 0 : configFile.configFileSpecs) === null || _b === void 0 ? void 0 : _b.validatedIncludeSpecs, function (includeSpec) {
            if (isJsonFile && !ts.endsWith(includeSpec, ".json" /* Extension.Json */))
                return false;
            var pattern = ts.getPatternFromSpec(includeSpec, basePath, "files");
            return !!pattern && ts.getRegexFromPattern("(".concat(pattern, ")$"), useCaseSensitiveFileNames).test(fileName);
        });
    }
    ts.getMatchedIncludeSpec = getMatchedIncludeSpec;
    function fileIncludeReasonToDiagnostics(program, reason, fileNameConvertor) {
        var _a, _b;
        var options = program.getCompilerOptions();
        if (ts.isReferencedFile(reason)) {
            var referenceLocation = ts.getReferencedFileLocation(function (path) { return program.getSourceFileByPath(path); }, reason);
            var referenceText = ts.isReferenceFileLocation(referenceLocation) ? referenceLocation.file.text.substring(referenceLocation.pos, referenceLocation.end) : "\"".concat(referenceLocation.text, "\"");
            var message = void 0;
            ts.Debug.assert(ts.isReferenceFileLocation(referenceLocation) || reason.kind === ts.FileIncludeKind.Import, "Only synthetic references are imports");
            switch (reason.kind) {
                case ts.FileIncludeKind.Import:
                    if (ts.isReferenceFileLocation(referenceLocation)) {
                        message = referenceLocation.packageId ?
                            ts.Diagnostics.Imported_via_0_from_file_1_with_packageId_2 :
                            ts.Diagnostics.Imported_via_0_from_file_1;
                    }
                    else if (referenceLocation.text === ts.externalHelpersModuleNameText) {
                        message = referenceLocation.packageId ?
                            ts.Diagnostics.Imported_via_0_from_file_1_with_packageId_2_to_import_importHelpers_as_specified_in_compilerOptions :
                            ts.Diagnostics.Imported_via_0_from_file_1_to_import_importHelpers_as_specified_in_compilerOptions;
                    }
                    else {
                        message = referenceLocation.packageId ?
                            ts.Diagnostics.Imported_via_0_from_file_1_with_packageId_2_to_import_jsx_and_jsxs_factory_functions :
                            ts.Diagnostics.Imported_via_0_from_file_1_to_import_jsx_and_jsxs_factory_functions;
                    }
                    break;
                case ts.FileIncludeKind.ReferenceFile:
                    ts.Debug.assert(!referenceLocation.packageId);
                    message = ts.Diagnostics.Referenced_via_0_from_file_1;
                    break;
                case ts.FileIncludeKind.TypeReferenceDirective:
                    message = referenceLocation.packageId ?
                        ts.Diagnostics.Type_library_referenced_via_0_from_file_1_with_packageId_2 :
                        ts.Diagnostics.Type_library_referenced_via_0_from_file_1;
                    break;
                case ts.FileIncludeKind.LibReferenceDirective:
                    ts.Debug.assert(!referenceLocation.packageId);
                    message = ts.Diagnostics.Library_referenced_via_0_from_file_1;
                    break;
                default:
                    ts.Debug.assertNever(reason);
            }
            return ts.chainDiagnosticMessages(
            /*details*/ undefined, message, referenceText, toFileName(referenceLocation.file, fileNameConvertor), referenceLocation.packageId && ts.packageIdToString(referenceLocation.packageId));
        }
        switch (reason.kind) {
            case ts.FileIncludeKind.RootFile:
                if (!((_a = options.configFile) === null || _a === void 0 ? void 0 : _a.configFileSpecs))
                    return ts.chainDiagnosticMessages(/*details*/ undefined, ts.Diagnostics.Root_file_specified_for_compilation);
                var fileName = ts.getNormalizedAbsolutePath(program.getRootFileNames()[reason.index], program.getCurrentDirectory());
                var matchedByFiles = getMatchedFileSpec(program, fileName);
                if (matchedByFiles)
                    return ts.chainDiagnosticMessages(/*details*/ undefined, ts.Diagnostics.Part_of_files_list_in_tsconfig_json);
                var matchedByInclude = getMatchedIncludeSpec(program, fileName);
                return matchedByInclude ?
                    ts.chainDiagnosticMessages(
                    /*details*/ undefined, ts.Diagnostics.Matched_by_include_pattern_0_in_1, matchedByInclude, toFileName(options.configFile, fileNameConvertor)) :
                    // Could be additional files specified as roots
                    ts.chainDiagnosticMessages(/*details*/ undefined, ts.Diagnostics.Root_file_specified_for_compilation);
            case ts.FileIncludeKind.SourceFromProjectReference:
            case ts.FileIncludeKind.OutputFromProjectReference:
                var isOutput = reason.kind === ts.FileIncludeKind.OutputFromProjectReference;
                var referencedResolvedRef = ts.Debug.checkDefined((_b = program.getResolvedProjectReferences()) === null || _b === void 0 ? void 0 : _b[reason.index]);
                return ts.chainDiagnosticMessages(
                /*details*/ undefined, ts.outFile(options) ?
                    isOutput ?
                        ts.Diagnostics.Output_from_referenced_project_0_included_because_1_specified :
                        ts.Diagnostics.Source_from_referenced_project_0_included_because_1_specified :
                    isOutput ?
                        ts.Diagnostics.Output_from_referenced_project_0_included_because_module_is_specified_as_none :
                        ts.Diagnostics.Source_from_referenced_project_0_included_because_module_is_specified_as_none, toFileName(referencedResolvedRef.sourceFile.fileName, fileNameConvertor), options.outFile ? "--outFile" : "--out");
            case ts.FileIncludeKind.AutomaticTypeDirectiveFile:
                return ts.chainDiagnosticMessages(
                /*details*/ undefined, options.types ?
                    reason.packageId ?
                        ts.Diagnostics.Entry_point_of_type_library_0_specified_in_compilerOptions_with_packageId_1 :
                        ts.Diagnostics.Entry_point_of_type_library_0_specified_in_compilerOptions :
                    reason.packageId ?
                        ts.Diagnostics.Entry_point_for_implicit_type_library_0_with_packageId_1 :
                        ts.Diagnostics.Entry_point_for_implicit_type_library_0, reason.typeReference, reason.packageId && ts.packageIdToString(reason.packageId));
            case ts.FileIncludeKind.LibFile:
                if (reason.index !== undefined)
                    return ts.chainDiagnosticMessages(/*details*/ undefined, ts.Diagnostics.Library_0_specified_in_compilerOptions, options.lib[reason.index]);
                var target = ts.forEachEntry(ts.targetOptionDeclaration.type, function (value, key) { return value === ts.getEmitScriptTarget(options) ? key : undefined; });
                return ts.chainDiagnosticMessages(
                /*details*/ undefined, target ?
                    ts.Diagnostics.Default_library_for_target_0 :
                    ts.Diagnostics.Default_library, target);
            default:
                ts.Debug.assertNever(reason);
        }
    }
    ts.fileIncludeReasonToDiagnostics = fileIncludeReasonToDiagnostics;
    function toFileName(file, fileNameConvertor) {
        var fileName = ts.isString(file) ? file : file.fileName;
        return fileNameConvertor ? fileNameConvertor(fileName) : fileName;
    }
    /**
     * Helper that emit files, report diagnostics and lists emitted and/or source files depending on compiler options
     */
    function emitFilesAndReportErrors(program, reportDiagnostic, write, reportSummary, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers) {
        var isListFilesOnly = !!program.getCompilerOptions().listFilesOnly;
        // First get and report any syntactic errors.
        var allDiagnostics = program.getConfigFileParsingDiagnostics().slice();
        var configFileParsingDiagnosticsLength = allDiagnostics.length;
        ts.addRange(allDiagnostics, program.getSyntacticDiagnostics(/*sourceFile*/ undefined, cancellationToken));
        // If we didn't have any syntactic errors, then also try getting the global and
        // semantic errors.
        if (allDiagnostics.length === configFileParsingDiagnosticsLength) {
            ts.addRange(allDiagnostics, program.getOptionsDiagnostics(cancellationToken));
            if (!isListFilesOnly) {
                ts.addRange(allDiagnostics, program.getGlobalDiagnostics(cancellationToken));
                if (allDiagnostics.length === configFileParsingDiagnosticsLength) {
                    ts.addRange(allDiagnostics, program.getSemanticDiagnostics(/*sourceFile*/ undefined, cancellationToken));
                }
            }
        }
        // Emit and report any errors we ran into.
        var emitResult = isListFilesOnly
            ? { emitSkipped: true, diagnostics: ts.emptyArray }
            : program.emit(/*targetSourceFile*/ undefined, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers);
        var emittedFiles = emitResult.emittedFiles, emitDiagnostics = emitResult.diagnostics;
        ts.addRange(allDiagnostics, emitDiagnostics);
        var diagnostics = ts.sortAndDeduplicateDiagnostics(allDiagnostics);
        diagnostics.forEach(reportDiagnostic);
        if (write) {
            var currentDir_1 = program.getCurrentDirectory();
            ts.forEach(emittedFiles, function (file) {
                var filepath = ts.getNormalizedAbsolutePath(file, currentDir_1);
                write("TSFILE: ".concat(filepath));
            });
            listFiles(program, write);
        }
        if (reportSummary) {
            reportSummary(getErrorCountForSummary(diagnostics), getFilesInErrorForSummary(diagnostics));
        }
        return {
            emitResult: emitResult,
            diagnostics: diagnostics,
        };
    }
    ts.emitFilesAndReportErrors = emitFilesAndReportErrors;
    function emitFilesAndReportErrorsAndGetExitStatus(program, reportDiagnostic, write, reportSummary, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers) {
        var _a = emitFilesAndReportErrors(program, reportDiagnostic, write, reportSummary, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers), emitResult = _a.emitResult, diagnostics = _a.diagnostics;
        if (emitResult.emitSkipped && diagnostics.length > 0) {
            // If the emitter didn't emit anything, then pass that value along.
            return ts.ExitStatus.DiagnosticsPresent_OutputsSkipped;
        }
        else if (diagnostics.length > 0) {
            // The emitter emitted something, inform the caller if that happened in the presence
            // of diagnostics or not.
            return ts.ExitStatus.DiagnosticsPresent_OutputsGenerated;
        }
        return ts.ExitStatus.Success;
    }
    ts.emitFilesAndReportErrorsAndGetExitStatus = emitFilesAndReportErrorsAndGetExitStatus;
    ts.noopFileWatcher = { close: ts.noop };
    ts.returnNoopFileWatcher = function () { return ts.noopFileWatcher; };
    function createWatchHost(system, reportWatchStatus) {
        if (system === void 0) { system = ts.sys; }
        var onWatchStatusChange = reportWatchStatus || createWatchStatusReporter(system);
        return {
            onWatchStatusChange: onWatchStatusChange,
            watchFile: ts.maybeBind(system, system.watchFile) || ts.returnNoopFileWatcher,
            watchDirectory: ts.maybeBind(system, system.watchDirectory) || ts.returnNoopFileWatcher,
            setTimeout: ts.maybeBind(system, system.setTimeout) || ts.noop,
            clearTimeout: ts.maybeBind(system, system.clearTimeout) || ts.noop
        };
    }
    ts.createWatchHost = createWatchHost;
    ts.WatchType = {
        ConfigFile: "Config file",
        ExtendedConfigFile: "Extended config file",
        SourceFile: "Source file",
        MissingFile: "Missing file",
        WildcardDirectory: "Wild card directory",
        FailedLookupLocations: "Failed Lookup Locations",
        TypeRoots: "Type roots",
        ConfigFileOfReferencedProject: "Config file of referened project",
        ExtendedConfigOfReferencedProject: "Extended config file of referenced project",
        WildcardDirectoryOfReferencedProject: "Wild card directory of referenced project",
        PackageJson: "package.json file",
    };
    function createWatchFactory(host, options) {
        var watchLogLevel = host.trace ? options.extendedDiagnostics ? ts.WatchLogLevel.Verbose : options.diagnostics ? ts.WatchLogLevel.TriggerOnly : ts.WatchLogLevel.None : ts.WatchLogLevel.None;
        var writeLog = watchLogLevel !== ts.WatchLogLevel.None ? (function (s) { return host.trace(s); }) : ts.noop;
        var result = ts.getWatchFactory(host, watchLogLevel, writeLog);
        result.writeLog = writeLog;
        return result;
    }
    ts.createWatchFactory = createWatchFactory;
    function createCompilerHostFromProgramHost(host, getCompilerOptions, directoryStructureHost) {
        if (directoryStructureHost === void 0) { directoryStructureHost = host; }
        var useCaseSensitiveFileNames = host.useCaseSensitiveFileNames();
        var hostGetNewLine = ts.memoize(function () { return host.getNewLine(); });
        return {
            getSourceFile: function (fileName, languageVersionOrOptions, onError) {
                var text;
                try {
                    ts.performance.mark("beforeIORead");
                    text = host.readFile(fileName, getCompilerOptions().charset);
                    ts.performance.mark("afterIORead");
                    ts.performance.measure("I/O Read", "beforeIORead", "afterIORead");
                }
                catch (e) {
                    if (onError) {
                        onError(e.message);
                    }
                    text = "";
                }
                return text !== undefined ? ts.createSourceFile(fileName, text, languageVersionOrOptions) : undefined;
            },
            getDefaultLibLocation: ts.maybeBind(host, host.getDefaultLibLocation),
            getDefaultLibFileName: function (options) { return host.getDefaultLibFileName(options); },
            writeFile: writeFile,
            getCurrentDirectory: ts.memoize(function () { return host.getCurrentDirectory(); }),
            useCaseSensitiveFileNames: function () { return useCaseSensitiveFileNames; },
            getCanonicalFileName: ts.createGetCanonicalFileName(useCaseSensitiveFileNames),
            getNewLine: function () { return ts.getNewLineCharacter(getCompilerOptions(), hostGetNewLine); },
            fileExists: function (f) { return host.fileExists(f); },
            readFile: function (f) { return host.readFile(f); },
            trace: ts.maybeBind(host, host.trace),
            directoryExists: ts.maybeBind(directoryStructureHost, directoryStructureHost.directoryExists),
            getDirectories: ts.maybeBind(directoryStructureHost, directoryStructureHost.getDirectories),
            realpath: ts.maybeBind(host, host.realpath),
            getEnvironmentVariable: ts.maybeBind(host, host.getEnvironmentVariable) || (function () { return ""; }),
            createHash: ts.maybeBind(host, host.createHash),
            readDirectory: ts.maybeBind(host, host.readDirectory),
            disableUseFileVersionAsSignature: host.disableUseFileVersionAsSignature,
            storeFilesChangingSignatureDuringEmit: host.storeFilesChangingSignatureDuringEmit,
        };
        function writeFile(fileName, text, writeByteOrderMark, onError) {
            try {
                ts.performance.mark("beforeIOWrite");
                // NOTE: If patchWriteFileEnsuringDirectory has been called,
                // the host.writeFile will do its own directory creation and
                // the ensureDirectoriesExist call will always be redundant.
                ts.writeFileEnsuringDirectories(fileName, text, writeByteOrderMark, function (path, data, writeByteOrderMark) { return host.writeFile(path, data, writeByteOrderMark); }, function (path) { return host.createDirectory(path); }, function (path) { return host.directoryExists(path); });
                ts.performance.mark("afterIOWrite");
                ts.performance.measure("I/O Write", "beforeIOWrite", "afterIOWrite");
            }
            catch (e) {
                if (onError) {
                    onError(e.message);
                }
            }
        }
    }
    ts.createCompilerHostFromProgramHost = createCompilerHostFromProgramHost;
    function setGetSourceFileAsHashVersioned(compilerHost, host) {
        var originalGetSourceFile = compilerHost.getSourceFile;
        var computeHash = ts.maybeBind(host, host.createHash) || ts.generateDjb2Hash;
        compilerHost.getSourceFile = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var result = originalGetSourceFile.call.apply(originalGetSourceFile, __spreadArray([compilerHost], args, false));
            if (result) {
                result.version = computeHash(result.text);
            }
            return result;
        };
    }
    ts.setGetSourceFileAsHashVersioned = setGetSourceFileAsHashVersioned;
    /**
     * Creates the watch compiler host that can be extended with config file or root file names and options host
     */
    function createProgramHost(system, createProgram) {
        var getDefaultLibLocation = ts.memoize(function () { return ts.getDirectoryPath(ts.normalizePath(system.getExecutingFilePath())); });
        return {
            useCaseSensitiveFileNames: function () { return system.useCaseSensitiveFileNames; },
            getNewLine: function () { return system.newLine; },
            getCurrentDirectory: ts.memoize(function () { return system.getCurrentDirectory(); }),
            getDefaultLibLocation: getDefaultLibLocation,
            getDefaultLibFileName: function (options) { return ts.combinePaths(getDefaultLibLocation(), ts.getDefaultLibFileName(options)); },
            fileExists: function (path) { return system.fileExists(path); },
            readFile: function (path, encoding) { return system.readFile(path, encoding); },
            directoryExists: function (path) { return system.directoryExists(path); },
            getDirectories: function (path) { return system.getDirectories(path); },
            readDirectory: function (path, extensions, exclude, include, depth) { return system.readDirectory(path, extensions, exclude, include, depth); },
            realpath: ts.maybeBind(system, system.realpath),
            getEnvironmentVariable: ts.maybeBind(system, system.getEnvironmentVariable),
            trace: function (s) { return system.write(s + system.newLine); },
            createDirectory: function (path) { return system.createDirectory(path); },
            writeFile: function (path, data, writeByteOrderMark) { return system.writeFile(path, data, writeByteOrderMark); },
            createHash: ts.maybeBind(system, system.createHash),
            createProgram: createProgram || ts.createEmitAndSemanticDiagnosticsBuilderProgram,
            disableUseFileVersionAsSignature: system.disableUseFileVersionAsSignature,
            storeFilesChangingSignatureDuringEmit: system.storeFilesChangingSignatureDuringEmit,
        };
    }
    ts.createProgramHost = createProgramHost;
    /**
     * Creates the watch compiler host that can be extended with config file or root file names and options host
     */
    function createWatchCompilerHost(system, createProgram, reportDiagnostic, reportWatchStatus) {
        if (system === void 0) { system = ts.sys; }
        var write = function (s) { return system.write(s + system.newLine); };
        var result = createProgramHost(system, createProgram);
        ts.copyProperties(result, createWatchHost(system, reportWatchStatus));
        result.afterProgramCreate = function (builderProgram) {
            var compilerOptions = builderProgram.getCompilerOptions();
            var newLine = ts.getNewLineCharacter(compilerOptions, function () { return system.newLine; });
            emitFilesAndReportErrors(builderProgram, reportDiagnostic, write, function (errorCount) { return result.onWatchStatusChange(ts.createCompilerDiagnostic(getWatchErrorSummaryDiagnosticMessage(errorCount), errorCount), newLine, compilerOptions, errorCount); });
        };
        return result;
    }
    /**
     * Report error and exit
     */
    function reportUnrecoverableDiagnostic(system, reportDiagnostic, diagnostic) {
        reportDiagnostic(diagnostic);
        system.exit(ts.ExitStatus.DiagnosticsPresent_OutputsSkipped);
    }
    /**
     * Creates the watch compiler host from system for config file in watch mode
     */
    function createWatchCompilerHostOfConfigFile(_a) {
        var configFileName = _a.configFileName, optionsToExtend = _a.optionsToExtend, watchOptionsToExtend = _a.watchOptionsToExtend, extraFileExtensions = _a.extraFileExtensions, system = _a.system, createProgram = _a.createProgram, reportDiagnostic = _a.reportDiagnostic, reportWatchStatus = _a.reportWatchStatus;
        var diagnosticReporter = reportDiagnostic || createDiagnosticReporter(system);
        var host = createWatchCompilerHost(system, createProgram, diagnosticReporter, reportWatchStatus);
        host.onUnRecoverableConfigFileDiagnostic = function (diagnostic) { return reportUnrecoverableDiagnostic(system, diagnosticReporter, diagnostic); };
        host.configFileName = configFileName;
        host.optionsToExtend = optionsToExtend;
        host.watchOptionsToExtend = watchOptionsToExtend;
        host.extraFileExtensions = extraFileExtensions;
        return host;
    }
    ts.createWatchCompilerHostOfConfigFile = createWatchCompilerHostOfConfigFile;
    /**
     * Creates the watch compiler host from system for compiling root files and options in watch mode
     */
    function createWatchCompilerHostOfFilesAndCompilerOptions(_a) {
        var rootFiles = _a.rootFiles, options = _a.options, watchOptions = _a.watchOptions, projectReferences = _a.projectReferences, system = _a.system, createProgram = _a.createProgram, reportDiagnostic = _a.reportDiagnostic, reportWatchStatus = _a.reportWatchStatus;
        var host = createWatchCompilerHost(system, createProgram, reportDiagnostic || createDiagnosticReporter(system), reportWatchStatus);
        host.rootFiles = rootFiles;
        host.options = options;
        host.watchOptions = watchOptions;
        host.projectReferences = projectReferences;
        return host;
    }
    ts.createWatchCompilerHostOfFilesAndCompilerOptions = createWatchCompilerHostOfFilesAndCompilerOptions;
    function performIncrementalCompilation(input) {
        var system = input.system || ts.sys;
        var host = input.host || (input.host = ts.createIncrementalCompilerHost(input.options, system));
        var builderProgram = ts.createIncrementalProgram(input);
        var exitStatus = emitFilesAndReportErrorsAndGetExitStatus(builderProgram, input.reportDiagnostic || createDiagnosticReporter(system), function (s) { return host.trace && host.trace(s); }, input.reportErrorSummary || input.options.pretty ? function (errorCount, filesInError) { return system.write(getErrorSummaryText(errorCount, filesInError, system.newLine, host)); } : undefined);
        if (input.afterProgramEmitAndDiagnostics)
            input.afterProgramEmitAndDiagnostics(builderProgram);
        return exitStatus;
    }
    ts.performIncrementalCompilation = performIncrementalCompilation;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function readBuilderProgram(compilerOptions, host) {
        if (ts.outFile(compilerOptions))
            return undefined;
        var buildInfoPath = ts.getTsBuildInfoEmitOutputFilePath(compilerOptions);
        if (!buildInfoPath)
            return undefined;
        var content = host.readFile(buildInfoPath);
        if (!content)
            return undefined;
        var buildInfo = ts.getBuildInfo(content);
        if (buildInfo.version !== ts.version)
            return undefined;
        if (!buildInfo.program)
            return undefined;
        return ts.createBuildProgramUsingProgramBuildInfo(buildInfo.program, buildInfoPath, host);
    }
    ts.readBuilderProgram = readBuilderProgram;
    function createIncrementalCompilerHost(options, system) {
        if (system === void 0) { system = ts.sys; }
        var host = ts.createCompilerHostWorker(options, /*setParentNodes*/ undefined, system);
        host.createHash = ts.maybeBind(system, system.createHash);
        host.disableUseFileVersionAsSignature = system.disableUseFileVersionAsSignature;
        host.storeFilesChangingSignatureDuringEmit = system.storeFilesChangingSignatureDuringEmit;
        ts.setGetSourceFileAsHashVersioned(host, system);
        ts.changeCompilerHostLikeToUseCache(host, function (fileName) { return ts.toPath(fileName, host.getCurrentDirectory(), host.getCanonicalFileName); });
        return host;
    }
    ts.createIncrementalCompilerHost = createIncrementalCompilerHost;
    function createIncrementalProgram(_a) {
        var rootNames = _a.rootNames, options = _a.options, configFileParsingDiagnostics = _a.configFileParsingDiagnostics, projectReferences = _a.projectReferences, host = _a.host, createProgram = _a.createProgram;
        host = host || createIncrementalCompilerHost(options);
        createProgram = createProgram || ts.createEmitAndSemanticDiagnosticsBuilderProgram;
        var oldProgram = readBuilderProgram(options, host);
        return createProgram(rootNames, options, host, oldProgram, configFileParsingDiagnostics, projectReferences);
    }
    ts.createIncrementalProgram = createIncrementalProgram;
    function createWatchCompilerHost(rootFilesOrConfigFileName, options, system, createProgram, reportDiagnostic, reportWatchStatus, projectReferencesOrWatchOptionsToExtend, watchOptionsOrExtraFileExtensions) {
        if (ts.isArray(rootFilesOrConfigFileName)) {
            return ts.createWatchCompilerHostOfFilesAndCompilerOptions({
                rootFiles: rootFilesOrConfigFileName,
                options: options,
                watchOptions: watchOptionsOrExtraFileExtensions,
                projectReferences: projectReferencesOrWatchOptionsToExtend,
                system: system,
                createProgram: createProgram,
                reportDiagnostic: reportDiagnostic,
                reportWatchStatus: reportWatchStatus,
            });
        }
        else {
            return ts.createWatchCompilerHostOfConfigFile({
                configFileName: rootFilesOrConfigFileName,
                optionsToExtend: options,
                watchOptionsToExtend: projectReferencesOrWatchOptionsToExtend,
                extraFileExtensions: watchOptionsOrExtraFileExtensions,
                system: system,
                createProgram: createProgram,
                reportDiagnostic: reportDiagnostic,
                reportWatchStatus: reportWatchStatus,
            });
        }
    }
    ts.createWatchCompilerHost = createWatchCompilerHost;
    function createWatchProgram(host) {
        var builderProgram;
        var reloadLevel; // level to indicate if the program needs to be reloaded from config file/just filenames etc
        var missingFilesMap; // Map of file watchers for the missing files
        var packageJsonMap; // map of watchers for package json files used in module resolution
        var watchedWildcardDirectories; // map of watchers for the wild card directories in the config file
        var timerToUpdateProgram; // timer callback to recompile the program
        var timerToInvalidateFailedLookupResolutions; // timer callback to invalidate resolutions for changes in failed lookup locations
        var parsedConfigs; // Parsed commandline and watching cached for referenced projects
        var sharedExtendedConfigFileWatchers; // Map of file watchers for extended files, shared between different referenced projects
        var extendedConfigCache = host.extendedConfigCache; // Cache for extended config evaluation
        var changesAffectResolution = false; // Flag for indicating non-config changes affect module resolution
        var reportFileChangeDetectedOnCreateProgram = false; // True if synchronizeProgram should report "File change detected..." when a new program is created
        var sourceFilesCache = new ts.Map(); // Cache that stores the source file and version info
        var missingFilePathsRequestedForRelease; // These paths are held temporarily so that we can remove the entry from source file cache if the file is not tracked by missing files
        var hasChangedCompilerOptions = false; // True if the compiler options have changed between compilations
        var useCaseSensitiveFileNames = host.useCaseSensitiveFileNames();
        var currentDirectory = host.getCurrentDirectory();
        var configFileName = host.configFileName, _a = host.optionsToExtend, optionsToExtendForConfigFile = _a === void 0 ? {} : _a, watchOptionsToExtend = host.watchOptionsToExtend, extraFileExtensions = host.extraFileExtensions, createProgram = host.createProgram;
        var rootFileNames = host.rootFiles, compilerOptions = host.options, watchOptions = host.watchOptions, projectReferences = host.projectReferences;
        var wildcardDirectories;
        var configFileParsingDiagnostics;
        var canConfigFileJsonReportNoInputFiles = false;
        var hasChangedConfigFileParsingErrors = false;
        var cachedDirectoryStructureHost = configFileName === undefined ? undefined : ts.createCachedDirectoryStructureHost(host, currentDirectory, useCaseSensitiveFileNames);
        var directoryStructureHost = cachedDirectoryStructureHost || host;
        var parseConfigFileHost = ts.parseConfigHostFromCompilerHostLike(host, directoryStructureHost);
        // From tsc we want to get already parsed result and hence check for rootFileNames
        var newLine = updateNewLine();
        if (configFileName && host.configFileParsingResult) {
            setConfigFileParsingResult(host.configFileParsingResult);
            newLine = updateNewLine();
        }
        reportWatchDiagnostic(ts.Diagnostics.Starting_compilation_in_watch_mode);
        if (configFileName && !host.configFileParsingResult) {
            newLine = ts.getNewLineCharacter(optionsToExtendForConfigFile, function () { return host.getNewLine(); });
            ts.Debug.assert(!rootFileNames);
            parseConfigFile();
            newLine = updateNewLine();
        }
        var _b = ts.createWatchFactory(host, compilerOptions), watchFile = _b.watchFile, watchDirectory = _b.watchDirectory, writeLog = _b.writeLog;
        var getCanonicalFileName = ts.createGetCanonicalFileName(useCaseSensitiveFileNames);
        writeLog("Current directory: ".concat(currentDirectory, " CaseSensitiveFileNames: ").concat(useCaseSensitiveFileNames));
        var configFileWatcher;
        if (configFileName) {
            configFileWatcher = watchFile(configFileName, scheduleProgramReload, ts.PollingInterval.High, watchOptions, ts.WatchType.ConfigFile);
        }
        var compilerHost = ts.createCompilerHostFromProgramHost(host, function () { return compilerOptions; }, directoryStructureHost);
        ts.setGetSourceFileAsHashVersioned(compilerHost, host);
        // Members for CompilerHost
        var getNewSourceFile = compilerHost.getSourceFile;
        compilerHost.getSourceFile = function (fileName) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            return getVersionedSourceFileByPath.apply(void 0, __spreadArray([fileName, toPath(fileName)], args, false));
        };
        compilerHost.getSourceFileByPath = getVersionedSourceFileByPath;
        compilerHost.getNewLine = function () { return newLine; };
        compilerHost.fileExists = fileExists;
        compilerHost.onReleaseOldSourceFile = onReleaseOldSourceFile;
        compilerHost.onReleaseParsedCommandLine = onReleaseParsedCommandLine;
        // Members for ResolutionCacheHost
        compilerHost.toPath = toPath;
        compilerHost.getCompilationSettings = function () { return compilerOptions; };
        compilerHost.useSourceOfProjectReferenceRedirect = ts.maybeBind(host, host.useSourceOfProjectReferenceRedirect);
        compilerHost.watchDirectoryOfFailedLookupLocation = function (dir, cb, flags) { return watchDirectory(dir, cb, flags, watchOptions, ts.WatchType.FailedLookupLocations); };
        compilerHost.watchTypeRootsDirectory = function (dir, cb, flags) { return watchDirectory(dir, cb, flags, watchOptions, ts.WatchType.TypeRoots); };
        compilerHost.getCachedDirectoryStructureHost = function () { return cachedDirectoryStructureHost; };
        compilerHost.scheduleInvalidateResolutionsOfFailedLookupLocations = scheduleInvalidateResolutionsOfFailedLookupLocations;
        compilerHost.onInvalidatedResolution = scheduleProgramUpdate;
        compilerHost.onChangedAutomaticTypeDirectiveNames = scheduleProgramUpdate;
        compilerHost.fileIsOpen = ts.returnFalse;
        compilerHost.getCurrentProgram = getCurrentProgram;
        compilerHost.writeLog = writeLog;
        compilerHost.getParsedCommandLine = getParsedCommandLine;
        // Cache for the module resolution
        var resolutionCache = ts.createResolutionCache(compilerHost, configFileName ?
            ts.getDirectoryPath(ts.getNormalizedAbsolutePath(configFileName, currentDirectory)) :
            currentDirectory, 
        /*logChangesWhenResolvingModule*/ false);
        // Resolve module using host module resolution strategy if provided otherwise use resolution cache to resolve module names
        compilerHost.resolveModuleNames = host.resolveModuleNames ?
            (function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return host.resolveModuleNames.apply(host, args);
            }) :
            (function (moduleNames, containingFile, reusedNames, redirectedReference, _options, sourceFile) { return resolutionCache.resolveModuleNames(moduleNames, containingFile, reusedNames, redirectedReference, sourceFile); });
        compilerHost.resolveTypeReferenceDirectives = host.resolveTypeReferenceDirectives ?
            (function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return host.resolveTypeReferenceDirectives.apply(host, args);
            }) :
            (function (typeDirectiveNames, containingFile, redirectedReference, _options, containingFileMode) { return resolutionCache.resolveTypeReferenceDirectives(typeDirectiveNames, containingFile, redirectedReference, containingFileMode); });
        var userProvidedResolution = !!host.resolveModuleNames || !!host.resolveTypeReferenceDirectives;
        builderProgram = readBuilderProgram(compilerOptions, compilerHost);
        synchronizeProgram();
        // Update the wild card directory watch
        watchConfigFileWildCardDirectories();
        // Update extended config file watch
        if (configFileName)
            updateExtendedConfigFilesWatches(toPath(configFileName), compilerOptions, watchOptions, ts.WatchType.ExtendedConfigFile);
        return configFileName ?
            { getCurrentProgram: getCurrentBuilderProgram, getProgram: updateProgram, close: close } :
            { getCurrentProgram: getCurrentBuilderProgram, getProgram: updateProgram, updateRootFileNames: updateRootFileNames, close: close };
        function close() {
            clearInvalidateResolutionsOfFailedLookupLocations();
            resolutionCache.clear();
            ts.clearMap(sourceFilesCache, function (value) {
                if (value && value.fileWatcher) {
                    value.fileWatcher.close();
                    value.fileWatcher = undefined;
                }
            });
            if (configFileWatcher) {
                configFileWatcher.close();
                configFileWatcher = undefined;
            }
            extendedConfigCache === null || extendedConfigCache === void 0 ? void 0 : extendedConfigCache.clear();
            extendedConfigCache = undefined;
            if (sharedExtendedConfigFileWatchers) {
                ts.clearMap(sharedExtendedConfigFileWatchers, ts.closeFileWatcherOf);
                sharedExtendedConfigFileWatchers = undefined;
            }
            if (watchedWildcardDirectories) {
                ts.clearMap(watchedWildcardDirectories, ts.closeFileWatcherOf);
                watchedWildcardDirectories = undefined;
            }
            if (missingFilesMap) {
                ts.clearMap(missingFilesMap, ts.closeFileWatcher);
                missingFilesMap = undefined;
            }
            if (parsedConfigs) {
                ts.clearMap(parsedConfigs, function (config) {
                    var _a;
                    (_a = config.watcher) === null || _a === void 0 ? void 0 : _a.close();
                    config.watcher = undefined;
                    if (config.watchedDirectories)
                        ts.clearMap(config.watchedDirectories, ts.closeFileWatcherOf);
                    config.watchedDirectories = undefined;
                });
                parsedConfigs = undefined;
            }
            if (packageJsonMap) {
                ts.clearMap(packageJsonMap, ts.closeFileWatcher);
                packageJsonMap = undefined;
            }
        }
        function getCurrentBuilderProgram() {
            return builderProgram;
        }
        function getCurrentProgram() {
            return builderProgram && builderProgram.getProgramOrUndefined();
        }
        function synchronizeProgram() {
            writeLog("Synchronizing program");
            clearInvalidateResolutionsOfFailedLookupLocations();
            var program = getCurrentBuilderProgram();
            if (hasChangedCompilerOptions) {
                newLine = updateNewLine();
                if (program && (changesAffectResolution || ts.changesAffectModuleResolution(program.getCompilerOptions(), compilerOptions))) {
                    resolutionCache.clear();
                }
            }
            // All resolutions are invalid if user provided resolutions
            var hasInvalidatedResolution = resolutionCache.createHasInvalidatedResolution(userProvidedResolution || changesAffectResolution);
            if (ts.isProgramUptoDate(getCurrentProgram(), rootFileNames, compilerOptions, getSourceVersion, fileExists, hasInvalidatedResolution, hasChangedAutomaticTypeDirectiveNames, getParsedCommandLine, projectReferences)) {
                if (hasChangedConfigFileParsingErrors) {
                    if (reportFileChangeDetectedOnCreateProgram) {
                        reportWatchDiagnostic(ts.Diagnostics.File_change_detected_Starting_incremental_compilation);
                    }
                    builderProgram = createProgram(/*rootNames*/ undefined, /*options*/ undefined, compilerHost, builderProgram, configFileParsingDiagnostics, projectReferences);
                    hasChangedConfigFileParsingErrors = false;
                }
            }
            else {
                if (reportFileChangeDetectedOnCreateProgram) {
                    reportWatchDiagnostic(ts.Diagnostics.File_change_detected_Starting_incremental_compilation);
                }
                createNewProgram(hasInvalidatedResolution);
            }
            changesAffectResolution = false; // reset for next sync
            reportFileChangeDetectedOnCreateProgram = false;
            if (host.afterProgramCreate && program !== builderProgram) {
                host.afterProgramCreate(builderProgram);
            }
            return builderProgram;
        }
        function createNewProgram(hasInvalidatedResolution) {
            // Compile the program
            writeLog("CreatingProgramWith::");
            writeLog("  roots: ".concat(JSON.stringify(rootFileNames)));
            writeLog("  options: ".concat(JSON.stringify(compilerOptions)));
            if (projectReferences)
                writeLog("  projectReferences: ".concat(JSON.stringify(projectReferences)));
            var needsUpdateInTypeRootWatch = hasChangedCompilerOptions || !getCurrentProgram();
            hasChangedCompilerOptions = false;
            hasChangedConfigFileParsingErrors = false;
            resolutionCache.startCachingPerDirectoryResolution();
            compilerHost.hasInvalidatedResolution = hasInvalidatedResolution;
            compilerHost.hasChangedAutomaticTypeDirectiveNames = hasChangedAutomaticTypeDirectiveNames;
            builderProgram = createProgram(rootFileNames, compilerOptions, compilerHost, builderProgram, configFileParsingDiagnostics, projectReferences);
            // map package json cache entries to their realpaths so we don't try to watch across symlinks
            var packageCacheEntries = ts.map(resolutionCache.getModuleResolutionCache().getPackageJsonInfoCache().entries(), function (_a) {
                var path = _a[0], data = _a[1];
                return [compilerHost.realpath ? toPath(compilerHost.realpath(path)) : path, data];
            });
            resolutionCache.finishCachingPerDirectoryResolution();
            // Update watches
            ts.updateMissingFilePathsWatch(builderProgram.getProgram(), missingFilesMap || (missingFilesMap = new ts.Map()), watchMissingFilePath);
            ts.updatePackageJsonWatch(packageCacheEntries, packageJsonMap || (packageJsonMap = new ts.Map()), watchPackageJsonLookupPath);
            if (needsUpdateInTypeRootWatch) {
                resolutionCache.updateTypeRootsWatch();
            }
            if (missingFilePathsRequestedForRelease) {
                // These are the paths that program creater told us as not in use any more but were missing on the disk.
                // We didnt remove the entry for them from sourceFiles cache so that we dont have to do File IO,
                // if there is already watcher for it (for missing files)
                // At this point our watches were updated, hence now we know that these paths are not tracked and need to be removed
                // so that at later time we have correct result of their presence
                for (var _i = 0, missingFilePathsRequestedForRelease_1 = missingFilePathsRequestedForRelease; _i < missingFilePathsRequestedForRelease_1.length; _i++) {
                    var missingFilePath = missingFilePathsRequestedForRelease_1[_i];
                    if (!missingFilesMap.has(missingFilePath)) {
                        sourceFilesCache.delete(missingFilePath);
                    }
                }
                missingFilePathsRequestedForRelease = undefined;
            }
        }
        function updateRootFileNames(files) {
            ts.Debug.assert(!configFileName, "Cannot update root file names with config file watch mode");
            rootFileNames = files;
            scheduleProgramUpdate();
        }
        function updateNewLine() {
            return ts.getNewLineCharacter(compilerOptions || optionsToExtendForConfigFile, function () { return host.getNewLine(); });
        }
        function toPath(fileName) {
            return ts.toPath(fileName, currentDirectory, getCanonicalFileName);
        }
        function isFileMissingOnHost(hostSourceFile) {
            return typeof hostSourceFile === "boolean";
        }
        function isFilePresenceUnknownOnHost(hostSourceFile) {
            return typeof hostSourceFile.version === "boolean";
        }
        function fileExists(fileName) {
            var path = toPath(fileName);
            // If file is missing on host from cache, we can definitely say file doesnt exist
            // otherwise we need to ensure from the disk
            if (isFileMissingOnHost(sourceFilesCache.get(path))) {
                return false;
            }
            return directoryStructureHost.fileExists(fileName);
        }
        function getVersionedSourceFileByPath(fileName, path, languageVersionOrOptions, onError, shouldCreateNewSourceFile) {
            var hostSourceFile = sourceFilesCache.get(path);
            // No source file on the host
            if (isFileMissingOnHost(hostSourceFile)) {
                return undefined;
            }
            // Create new source file if requested or the versions dont match
            if (hostSourceFile === undefined || shouldCreateNewSourceFile || isFilePresenceUnknownOnHost(hostSourceFile)) {
                var sourceFile = getNewSourceFile(fileName, languageVersionOrOptions, onError);
                if (hostSourceFile) {
                    if (sourceFile) {
                        // Set the source file and create file watcher now that file was present on the disk
                        hostSourceFile.sourceFile = sourceFile;
                        hostSourceFile.version = sourceFile.version;
                        if (!hostSourceFile.fileWatcher) {
                            hostSourceFile.fileWatcher = watchFilePath(path, fileName, onSourceFileChange, ts.PollingInterval.Low, watchOptions, ts.WatchType.SourceFile);
                        }
                    }
                    else {
                        // There is no source file on host any more, close the watch, missing file paths will track it
                        if (hostSourceFile.fileWatcher) {
                            hostSourceFile.fileWatcher.close();
                        }
                        sourceFilesCache.set(path, false);
                    }
                }
                else {
                    if (sourceFile) {
                        var fileWatcher = watchFilePath(path, fileName, onSourceFileChange, ts.PollingInterval.Low, watchOptions, ts.WatchType.SourceFile);
                        sourceFilesCache.set(path, { sourceFile: sourceFile, version: sourceFile.version, fileWatcher: fileWatcher });
                    }
                    else {
                        sourceFilesCache.set(path, false);
                    }
                }
                if (sourceFile) {
                    sourceFile.impliedNodeFormat = ts.getImpliedNodeFormatForFile(path, resolutionCache.getModuleResolutionCache().getPackageJsonInfoCache(), compilerHost, compilerHost.getCompilationSettings());
                }
                return sourceFile;
            }
            return hostSourceFile.sourceFile;
        }
        function nextSourceFileVersion(path) {
            var hostSourceFile = sourceFilesCache.get(path);
            if (hostSourceFile !== undefined) {
                if (isFileMissingOnHost(hostSourceFile)) {
                    // The next version, lets set it as presence unknown file
                    sourceFilesCache.set(path, { version: false });
                }
                else {
                    hostSourceFile.version = false;
                }
            }
        }
        function getSourceVersion(path) {
            var hostSourceFile = sourceFilesCache.get(path);
            return !hostSourceFile || !hostSourceFile.version ? undefined : hostSourceFile.version;
        }
        function onReleaseOldSourceFile(oldSourceFile, _oldOptions, hasSourceFileByPath) {
            var hostSourceFileInfo = sourceFilesCache.get(oldSourceFile.resolvedPath);
            // If this is the source file thats in the cache and new program doesnt need it,
            // remove the cached entry.
            // Note we arent deleting entry if file became missing in new program or
            // there was version update and new source file was created.
            if (hostSourceFileInfo !== undefined) {
                // record the missing file paths so they can be removed later if watchers arent tracking them
                if (isFileMissingOnHost(hostSourceFileInfo)) {
                    (missingFilePathsRequestedForRelease || (missingFilePathsRequestedForRelease = [])).push(oldSourceFile.path);
                }
                else if (hostSourceFileInfo.sourceFile === oldSourceFile) {
                    if (hostSourceFileInfo.fileWatcher) {
                        hostSourceFileInfo.fileWatcher.close();
                    }
                    sourceFilesCache.delete(oldSourceFile.resolvedPath);
                    if (!hasSourceFileByPath) {
                        resolutionCache.removeResolutionsOfFile(oldSourceFile.path);
                    }
                }
            }
        }
        function reportWatchDiagnostic(message) {
            if (host.onWatchStatusChange) {
                host.onWatchStatusChange(ts.createCompilerDiagnostic(message), newLine, compilerOptions || optionsToExtendForConfigFile);
            }
        }
        function hasChangedAutomaticTypeDirectiveNames() {
            return resolutionCache.hasChangedAutomaticTypeDirectiveNames();
        }
        function clearInvalidateResolutionsOfFailedLookupLocations() {
            if (!timerToInvalidateFailedLookupResolutions)
                return false;
            host.clearTimeout(timerToInvalidateFailedLookupResolutions);
            timerToInvalidateFailedLookupResolutions = undefined;
            return true;
        }
        function scheduleInvalidateResolutionsOfFailedLookupLocations() {
            if (!host.setTimeout || !host.clearTimeout) {
                return resolutionCache.invalidateResolutionsOfFailedLookupLocations();
            }
            var pending = clearInvalidateResolutionsOfFailedLookupLocations();
            writeLog("Scheduling invalidateFailedLookup".concat(pending ? ", Cancelled earlier one" : ""));
            timerToInvalidateFailedLookupResolutions = host.setTimeout(invalidateResolutionsOfFailedLookup, 250);
        }
        function invalidateResolutionsOfFailedLookup() {
            timerToInvalidateFailedLookupResolutions = undefined;
            if (resolutionCache.invalidateResolutionsOfFailedLookupLocations()) {
                scheduleProgramUpdate();
            }
        }
        // Upon detecting a file change, wait for 250ms and then perform a recompilation. This gives batch
        // operations (such as saving all modified files in an editor) a chance to complete before we kick
        // off a new compilation.
        function scheduleProgramUpdate() {
            if (!host.setTimeout || !host.clearTimeout) {
                return;
            }
            if (timerToUpdateProgram) {
                host.clearTimeout(timerToUpdateProgram);
            }
            writeLog("Scheduling update");
            timerToUpdateProgram = host.setTimeout(updateProgramWithWatchStatus, 250);
        }
        function scheduleProgramReload() {
            ts.Debug.assert(!!configFileName);
            reloadLevel = ts.ConfigFileProgramReloadLevel.Full;
            scheduleProgramUpdate();
        }
        function updateProgramWithWatchStatus() {
            timerToUpdateProgram = undefined;
            reportFileChangeDetectedOnCreateProgram = true;
            updateProgram();
        }
        function updateProgram() {
            switch (reloadLevel) {
                case ts.ConfigFileProgramReloadLevel.Partial:
                    ts.perfLogger.logStartUpdateProgram("PartialConfigReload");
                    reloadFileNamesFromConfigFile();
                    break;
                case ts.ConfigFileProgramReloadLevel.Full:
                    ts.perfLogger.logStartUpdateProgram("FullConfigReload");
                    reloadConfigFile();
                    break;
                default:
                    ts.perfLogger.logStartUpdateProgram("SynchronizeProgram");
                    synchronizeProgram();
                    break;
            }
            ts.perfLogger.logStopUpdateProgram("Done");
            return getCurrentBuilderProgram();
        }
        function reloadFileNamesFromConfigFile() {
            writeLog("Reloading new file names and options");
            reloadLevel = ts.ConfigFileProgramReloadLevel.None;
            rootFileNames = ts.getFileNamesFromConfigSpecs(compilerOptions.configFile.configFileSpecs, ts.getNormalizedAbsolutePath(ts.getDirectoryPath(configFileName), currentDirectory), compilerOptions, parseConfigFileHost, extraFileExtensions);
            if (ts.updateErrorForNoInputFiles(rootFileNames, ts.getNormalizedAbsolutePath(configFileName, currentDirectory), compilerOptions.configFile.configFileSpecs, configFileParsingDiagnostics, canConfigFileJsonReportNoInputFiles)) {
                hasChangedConfigFileParsingErrors = true;
            }
            // Update the program
            synchronizeProgram();
        }
        function reloadConfigFile() {
            writeLog("Reloading config file: ".concat(configFileName));
            reloadLevel = ts.ConfigFileProgramReloadLevel.None;
            if (cachedDirectoryStructureHost) {
                cachedDirectoryStructureHost.clearCache();
            }
            parseConfigFile();
            hasChangedCompilerOptions = true;
            synchronizeProgram();
            // Update the wild card directory watch
            watchConfigFileWildCardDirectories();
            // Update extended config file watch
            updateExtendedConfigFilesWatches(toPath(configFileName), compilerOptions, watchOptions, ts.WatchType.ExtendedConfigFile);
        }
        function parseConfigFile() {
            setConfigFileParsingResult(ts.getParsedCommandLineOfConfigFile(configFileName, optionsToExtendForConfigFile, parseConfigFileHost, extendedConfigCache || (extendedConfigCache = new ts.Map()), watchOptionsToExtend, extraFileExtensions)); // TODO: GH#18217
        }
        function setConfigFileParsingResult(configFileParseResult) {
            rootFileNames = configFileParseResult.fileNames;
            compilerOptions = configFileParseResult.options;
            watchOptions = configFileParseResult.watchOptions;
            projectReferences = configFileParseResult.projectReferences;
            wildcardDirectories = configFileParseResult.wildcardDirectories;
            configFileParsingDiagnostics = ts.getConfigFileParsingDiagnostics(configFileParseResult).slice();
            canConfigFileJsonReportNoInputFiles = ts.canJsonReportNoInputFiles(configFileParseResult.raw);
            hasChangedConfigFileParsingErrors = true;
        }
        function getParsedCommandLine(configFileName) {
            var configPath = toPath(configFileName);
            var config = parsedConfigs === null || parsedConfigs === void 0 ? void 0 : parsedConfigs.get(configPath);
            if (config) {
                if (!config.reloadLevel)
                    return config.parsedCommandLine;
                // With host implementing getParsedCommandLine we cant just update file names
                if (config.parsedCommandLine && config.reloadLevel === ts.ConfigFileProgramReloadLevel.Partial && !host.getParsedCommandLine) {
                    writeLog("Reloading new file names and options");
                    var fileNames = ts.getFileNamesFromConfigSpecs(config.parsedCommandLine.options.configFile.configFileSpecs, ts.getNormalizedAbsolutePath(ts.getDirectoryPath(configFileName), currentDirectory), compilerOptions, parseConfigFileHost);
                    config.parsedCommandLine = __assign(__assign({}, config.parsedCommandLine), { fileNames: fileNames });
                    config.reloadLevel = undefined;
                    return config.parsedCommandLine;
                }
            }
            writeLog("Loading config file: ".concat(configFileName));
            var parsedCommandLine = host.getParsedCommandLine ?
                host.getParsedCommandLine(configFileName) :
                getParsedCommandLineFromConfigFileHost(configFileName);
            if (config) {
                config.parsedCommandLine = parsedCommandLine;
                config.reloadLevel = undefined;
            }
            else {
                (parsedConfigs || (parsedConfigs = new ts.Map())).set(configPath, config = { parsedCommandLine: parsedCommandLine });
            }
            watchReferencedProject(configFileName, configPath, config);
            return parsedCommandLine;
        }
        function getParsedCommandLineFromConfigFileHost(configFileName) {
            // Ignore the file absent errors
            var onUnRecoverableConfigFileDiagnostic = parseConfigFileHost.onUnRecoverableConfigFileDiagnostic;
            parseConfigFileHost.onUnRecoverableConfigFileDiagnostic = ts.noop;
            var parsedCommandLine = ts.getParsedCommandLineOfConfigFile(configFileName, 
            /*optionsToExtend*/ undefined, parseConfigFileHost, extendedConfigCache || (extendedConfigCache = new ts.Map()), watchOptionsToExtend);
            parseConfigFileHost.onUnRecoverableConfigFileDiagnostic = onUnRecoverableConfigFileDiagnostic;
            return parsedCommandLine;
        }
        function onReleaseParsedCommandLine(fileName) {
            var _a;
            var path = toPath(fileName);
            var config = parsedConfigs === null || parsedConfigs === void 0 ? void 0 : parsedConfigs.get(path);
            if (!config)
                return;
            parsedConfigs.delete(path);
            if (config.watchedDirectories)
                ts.clearMap(config.watchedDirectories, ts.closeFileWatcherOf);
            (_a = config.watcher) === null || _a === void 0 ? void 0 : _a.close();
            ts.clearSharedExtendedConfigFileWatcher(path, sharedExtendedConfigFileWatchers);
        }
        function watchFilePath(path, file, callback, pollingInterval, options, watchType) {
            return watchFile(file, function (fileName, eventKind) { return callback(fileName, eventKind, path); }, pollingInterval, options, watchType);
        }
        function onSourceFileChange(fileName, eventKind, path) {
            updateCachedSystemWithFile(fileName, path, eventKind);
            // Update the source file cache
            if (eventKind === ts.FileWatcherEventKind.Deleted && sourceFilesCache.has(path)) {
                resolutionCache.invalidateResolutionOfFile(path);
            }
            nextSourceFileVersion(path);
            // Update the program
            scheduleProgramUpdate();
        }
        function updateCachedSystemWithFile(fileName, path, eventKind) {
            if (cachedDirectoryStructureHost) {
                cachedDirectoryStructureHost.addOrDeleteFile(fileName, path, eventKind);
            }
        }
        function watchMissingFilePath(missingFilePath) {
            // If watching missing referenced config file, we are already watching it so no need for separate watcher
            return (parsedConfigs === null || parsedConfigs === void 0 ? void 0 : parsedConfigs.has(missingFilePath)) ?
                ts.noopFileWatcher :
                watchFilePath(missingFilePath, missingFilePath, onMissingFileChange, ts.PollingInterval.Medium, watchOptions, ts.WatchType.MissingFile);
        }
        function watchPackageJsonLookupPath(packageJsonPath) {
            // If the package.json is pulled into the compilation itself (eg, via json imports), don't add a second watcher here
            return sourceFilesCache.has(packageJsonPath) ?
                ts.noopFileWatcher :
                watchFilePath(packageJsonPath, packageJsonPath, onPackageJsonChange, ts.PollingInterval.High, watchOptions, ts.WatchType.PackageJson);
        }
        function onPackageJsonChange(fileName, eventKind, path) {
            updateCachedSystemWithFile(fileName, path, eventKind);
            // package.json changes invalidate module resolution and can change the set of loaded files
            // so if we witness a change to one, we have to do a full reload
            reloadLevel = ts.ConfigFileProgramReloadLevel.Full;
            changesAffectResolution = true;
            // Update the program
            scheduleProgramUpdate();
        }
        function onMissingFileChange(fileName, eventKind, missingFilePath) {
            updateCachedSystemWithFile(fileName, missingFilePath, eventKind);
            if (eventKind === ts.FileWatcherEventKind.Created && missingFilesMap.has(missingFilePath)) {
                missingFilesMap.get(missingFilePath).close();
                missingFilesMap.delete(missingFilePath);
                // Delete the entry in the source files cache so that new source file is created
                nextSourceFileVersion(missingFilePath);
                // When a missing file is created, we should update the graph.
                scheduleProgramUpdate();
            }
        }
        function watchConfigFileWildCardDirectories() {
            if (wildcardDirectories) {
                ts.updateWatchingWildcardDirectories(watchedWildcardDirectories || (watchedWildcardDirectories = new ts.Map()), new ts.Map(ts.getEntries(wildcardDirectories)), watchWildcardDirectory);
            }
            else if (watchedWildcardDirectories) {
                ts.clearMap(watchedWildcardDirectories, ts.closeFileWatcherOf);
            }
        }
        function watchWildcardDirectory(directory, flags) {
            return watchDirectory(directory, function (fileOrDirectory) {
                ts.Debug.assert(!!configFileName);
                var fileOrDirectoryPath = toPath(fileOrDirectory);
                // Since the file existence changed, update the sourceFiles cache
                if (cachedDirectoryStructureHost) {
                    cachedDirectoryStructureHost.addOrDeleteFileOrDirectory(fileOrDirectory, fileOrDirectoryPath);
                }
                nextSourceFileVersion(fileOrDirectoryPath);
                if (ts.isIgnoredFileFromWildCardWatching({
                    watchedDirPath: toPath(directory),
                    fileOrDirectory: fileOrDirectory,
                    fileOrDirectoryPath: fileOrDirectoryPath,
                    configFileName: configFileName,
                    extraFileExtensions: extraFileExtensions,
                    options: compilerOptions,
                    program: getCurrentBuilderProgram() || rootFileNames,
                    currentDirectory: currentDirectory,
                    useCaseSensitiveFileNames: useCaseSensitiveFileNames,
                    writeLog: writeLog,
                    toPath: toPath,
                }))
                    return;
                // Reload is pending, do the reload
                if (reloadLevel !== ts.ConfigFileProgramReloadLevel.Full) {
                    reloadLevel = ts.ConfigFileProgramReloadLevel.Partial;
                    // Schedule Update the program
                    scheduleProgramUpdate();
                }
            }, flags, watchOptions, ts.WatchType.WildcardDirectory);
        }
        function updateExtendedConfigFilesWatches(forProjectPath, options, watchOptions, watchType) {
            ts.updateSharedExtendedConfigFileWatcher(forProjectPath, options, sharedExtendedConfigFileWatchers || (sharedExtendedConfigFileWatchers = new ts.Map()), function (extendedConfigFileName, extendedConfigFilePath) { return watchFile(extendedConfigFileName, function (_fileName, eventKind) {
                var _a;
                updateCachedSystemWithFile(extendedConfigFileName, extendedConfigFilePath, eventKind);
                // Update extended config cache
                if (extendedConfigCache)
                    ts.cleanExtendedConfigCache(extendedConfigCache, extendedConfigFilePath, toPath);
                // Update projects
                var projects = (_a = sharedExtendedConfigFileWatchers.get(extendedConfigFilePath)) === null || _a === void 0 ? void 0 : _a.projects;
                // If there are no referenced projects this extended config file watcher depend on ignore
                if (!(projects === null || projects === void 0 ? void 0 : projects.size))
                    return;
                projects.forEach(function (projectPath) {
                    if (toPath(configFileName) === projectPath) {
                        // If this is the config file of the project, reload completely
                        reloadLevel = ts.ConfigFileProgramReloadLevel.Full;
                    }
                    else {
                        // Reload config for the referenced projects and remove the resolutions from referenced projects since the config file changed
                        var config = parsedConfigs === null || parsedConfigs === void 0 ? void 0 : parsedConfigs.get(projectPath);
                        if (config)
                            config.reloadLevel = ts.ConfigFileProgramReloadLevel.Full;
                        resolutionCache.removeResolutionsFromProjectReferenceRedirects(projectPath);
                    }
                    scheduleProgramUpdate();
                });
            }, ts.PollingInterval.High, watchOptions, watchType); }, toPath);
        }
        function watchReferencedProject(configFileName, configPath, commandLine) {
            var _a, _b, _c, _d, _e;
            // Watch file
            commandLine.watcher || (commandLine.watcher = watchFile(configFileName, function (_fileName, eventKind) {
                updateCachedSystemWithFile(configFileName, configPath, eventKind);
                var config = parsedConfigs === null || parsedConfigs === void 0 ? void 0 : parsedConfigs.get(configPath);
                if (config)
                    config.reloadLevel = ts.ConfigFileProgramReloadLevel.Full;
                resolutionCache.removeResolutionsFromProjectReferenceRedirects(configPath);
                scheduleProgramUpdate();
            }, ts.PollingInterval.High, ((_a = commandLine.parsedCommandLine) === null || _a === void 0 ? void 0 : _a.watchOptions) || watchOptions, ts.WatchType.ConfigFileOfReferencedProject));
            // Watch Wild card
            if ((_b = commandLine.parsedCommandLine) === null || _b === void 0 ? void 0 : _b.wildcardDirectories) {
                ts.updateWatchingWildcardDirectories(commandLine.watchedDirectories || (commandLine.watchedDirectories = new ts.Map()), new ts.Map(ts.getEntries((_c = commandLine.parsedCommandLine) === null || _c === void 0 ? void 0 : _c.wildcardDirectories)), function (directory, flags) {
                    var _a;
                    return watchDirectory(directory, function (fileOrDirectory) {
                        var fileOrDirectoryPath = toPath(fileOrDirectory);
                        // Since the file existence changed, update the sourceFiles cache
                        if (cachedDirectoryStructureHost) {
                            cachedDirectoryStructureHost.addOrDeleteFileOrDirectory(fileOrDirectory, fileOrDirectoryPath);
                        }
                        nextSourceFileVersion(fileOrDirectoryPath);
                        var config = parsedConfigs === null || parsedConfigs === void 0 ? void 0 : parsedConfigs.get(configPath);
                        if (!(config === null || config === void 0 ? void 0 : config.parsedCommandLine))
                            return;
                        if (ts.isIgnoredFileFromWildCardWatching({
                            watchedDirPath: toPath(directory),
                            fileOrDirectory: fileOrDirectory,
                            fileOrDirectoryPath: fileOrDirectoryPath,
                            configFileName: configFileName,
                            options: config.parsedCommandLine.options,
                            program: config.parsedCommandLine.fileNames,
                            currentDirectory: currentDirectory,
                            useCaseSensitiveFileNames: useCaseSensitiveFileNames,
                            writeLog: writeLog,
                            toPath: toPath,
                        }))
                            return;
                        // Reload is pending, do the reload
                        if (config.reloadLevel !== ts.ConfigFileProgramReloadLevel.Full) {
                            config.reloadLevel = ts.ConfigFileProgramReloadLevel.Partial;
                            // Schedule Update the program
                            scheduleProgramUpdate();
                        }
                    }, flags, ((_a = commandLine.parsedCommandLine) === null || _a === void 0 ? void 0 : _a.watchOptions) || watchOptions, ts.WatchType.WildcardDirectoryOfReferencedProject);
                });
            }
            else if (commandLine.watchedDirectories) {
                ts.clearMap(commandLine.watchedDirectories, ts.closeFileWatcherOf);
                commandLine.watchedDirectories = undefined;
            }
            // Watch extended config files
            updateExtendedConfigFilesWatches(configPath, (_d = commandLine.parsedCommandLine) === null || _d === void 0 ? void 0 : _d.options, ((_e = commandLine.parsedCommandLine) === null || _e === void 0 ? void 0 : _e.watchOptions) || watchOptions, ts.WatchType.ExtendedConfigOfReferencedProject);
        }
    }
    ts.createWatchProgram = createWatchProgram;
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    var UpToDateStatusType;
    (function (UpToDateStatusType) {
        UpToDateStatusType[UpToDateStatusType["Unbuildable"] = 0] = "Unbuildable";
        UpToDateStatusType[UpToDateStatusType["UpToDate"] = 1] = "UpToDate";
        /**
         * The project appears out of date because its upstream inputs are newer than its outputs,
         * but all of its outputs are actually newer than the previous identical outputs of its (.d.ts) inputs.
         * This means we can Pseudo-build (just touch timestamps), as if we had actually built this project.
         */
        UpToDateStatusType[UpToDateStatusType["UpToDateWithUpstreamTypes"] = 2] = "UpToDateWithUpstreamTypes";
        /**
         * The project appears out of date because its upstream inputs are newer than its outputs,
         * but all of its outputs are actually newer than the previous identical outputs of its (.d.ts) inputs.
         * This means we can Pseudo-build (just manipulate outputs), as if we had actually built this project.
         */
        UpToDateStatusType[UpToDateStatusType["OutOfDateWithPrepend"] = 3] = "OutOfDateWithPrepend";
        UpToDateStatusType[UpToDateStatusType["OutputMissing"] = 4] = "OutputMissing";
        UpToDateStatusType[UpToDateStatusType["OutOfDateWithSelf"] = 5] = "OutOfDateWithSelf";
        UpToDateStatusType[UpToDateStatusType["OutOfDateWithUpstream"] = 6] = "OutOfDateWithUpstream";
        UpToDateStatusType[UpToDateStatusType["UpstreamOutOfDate"] = 7] = "UpstreamOutOfDate";
        UpToDateStatusType[UpToDateStatusType["UpstreamBlocked"] = 8] = "UpstreamBlocked";
        UpToDateStatusType[UpToDateStatusType["ComputingUpstream"] = 9] = "ComputingUpstream";
        UpToDateStatusType[UpToDateStatusType["TsVersionOutputOfDate"] = 10] = "TsVersionOutputOfDate";
        /**
         * Projects with no outputs (i.e. "solution" files)
         */
        UpToDateStatusType[UpToDateStatusType["ContainerOnly"] = 11] = "ContainerOnly";
    })(UpToDateStatusType = ts.UpToDateStatusType || (ts.UpToDateStatusType = {}));
    function resolveConfigFileProjectName(project) {
        if (ts.fileExtensionIs(project, ".json" /* Extension.Json */)) {
            return project;
        }
        return ts.combinePaths(project, "tsconfig.json");
    }
    ts.resolveConfigFileProjectName = resolveConfigFileProjectName;
})(ts || (ts = {}));
var ts;
(function (ts) {
    var minimumDate = new Date(-8640000000000000);
    var maximumDate = new Date(8640000000000000);
    var BuildResultFlags;
    (function (BuildResultFlags) {
        BuildResultFlags[BuildResultFlags["None"] = 0] = "None";
        /**
         * No errors of any kind occurred during build
         */
        BuildResultFlags[BuildResultFlags["Success"] = 1] = "Success";
        /**
         * None of the .d.ts files emitted by this build were
         * different from the existing files on disk
         */
        BuildResultFlags[BuildResultFlags["DeclarationOutputUnchanged"] = 2] = "DeclarationOutputUnchanged";
        BuildResultFlags[BuildResultFlags["ConfigFileErrors"] = 4] = "ConfigFileErrors";
        BuildResultFlags[BuildResultFlags["SyntaxErrors"] = 8] = "SyntaxErrors";
        BuildResultFlags[BuildResultFlags["TypeErrors"] = 16] = "TypeErrors";
        BuildResultFlags[BuildResultFlags["DeclarationEmitErrors"] = 32] = "DeclarationEmitErrors";
        BuildResultFlags[BuildResultFlags["EmitErrors"] = 64] = "EmitErrors";
        BuildResultFlags[BuildResultFlags["AnyErrors"] = 124] = "AnyErrors";
    })(BuildResultFlags || (BuildResultFlags = {}));
    function getOrCreateValueFromConfigFileMap(configFileMap, resolved, createT) {
        var existingValue = configFileMap.get(resolved);
        var newValue;
        if (!existingValue) {
            newValue = createT();
            configFileMap.set(resolved, newValue);
        }
        return existingValue || newValue;
    }
    function getOrCreateValueMapFromConfigFileMap(configFileMap, resolved) {
        return getOrCreateValueFromConfigFileMap(configFileMap, resolved, function () { return new ts.Map(); });
    }
    function newer(date1, date2) {
        return date2 > date1 ? date2 : date1;
    }
    /*@internal*/
    function isCircularBuildOrder(buildOrder) {
        return !!buildOrder && !!buildOrder.buildOrder;
    }
    ts.isCircularBuildOrder = isCircularBuildOrder;
    /*@internal*/
    function getBuildOrderFromAnyBuildOrder(anyBuildOrder) {
        return isCircularBuildOrder(anyBuildOrder) ? anyBuildOrder.buildOrder : anyBuildOrder;
    }
    ts.getBuildOrderFromAnyBuildOrder = getBuildOrderFromAnyBuildOrder;
    /**
     * Create a function that reports watch status by writing to the system and handles the formating of the diagnostic
     */
    function createBuilderStatusReporter(system, pretty) {
        return function (diagnostic) {
            var output = pretty ? "[".concat(ts.formatColorAndReset(ts.getLocaleTimeString(system), ts.ForegroundColorEscapeSequences.Grey), "] ") : "".concat(ts.getLocaleTimeString(system), " - ");
            output += "".concat(ts.flattenDiagnosticMessageText(diagnostic.messageText, system.newLine)).concat(system.newLine + system.newLine);
            system.write(output);
        };
    }
    ts.createBuilderStatusReporter = createBuilderStatusReporter;
    function createSolutionBuilderHostBase(system, createProgram, reportDiagnostic, reportSolutionBuilderStatus) {
        var host = ts.createProgramHost(system, createProgram);
        host.getModifiedTime = system.getModifiedTime ? function (path) { return system.getModifiedTime(path); } : ts.returnUndefined;
        host.setModifiedTime = system.setModifiedTime ? function (path, date) { return system.setModifiedTime(path, date); } : ts.noop;
        host.deleteFile = system.deleteFile ? function (path) { return system.deleteFile(path); } : ts.noop;
        host.reportDiagnostic = reportDiagnostic || ts.createDiagnosticReporter(system);
        host.reportSolutionBuilderStatus = reportSolutionBuilderStatus || createBuilderStatusReporter(system);
        host.now = ts.maybeBind(system, system.now); // For testing
        return host;
    }
    function createSolutionBuilderHost(system, createProgram, reportDiagnostic, reportSolutionBuilderStatus, reportErrorSummary) {
        if (system === void 0) { system = ts.sys; }
        var host = createSolutionBuilderHostBase(system, createProgram, reportDiagnostic, reportSolutionBuilderStatus);
        host.reportErrorSummary = reportErrorSummary;
        return host;
    }
    ts.createSolutionBuilderHost = createSolutionBuilderHost;
    function createSolutionBuilderWithWatchHost(system, createProgram, reportDiagnostic, reportSolutionBuilderStatus, reportWatchStatus) {
        if (system === void 0) { system = ts.sys; }
        var host = createSolutionBuilderHostBase(system, createProgram, reportDiagnostic, reportSolutionBuilderStatus);
        var watchHost = ts.createWatchHost(system, reportWatchStatus);
        ts.copyProperties(host, watchHost);
        return host;
    }
    ts.createSolutionBuilderWithWatchHost = createSolutionBuilderWithWatchHost;
    function getCompilerOptionsOfBuildOptions(buildOptions) {
        var result = {};
        ts.commonOptionsWithBuild.forEach(function (option) {
            if (ts.hasProperty(buildOptions, option.name))
                result[option.name] = buildOptions[option.name];
        });
        return result;
    }
    function createSolutionBuilder(host, rootNames, defaultOptions) {
        return createSolutionBuilderWorker(/*watch*/ false, host, rootNames, defaultOptions);
    }
    ts.createSolutionBuilder = createSolutionBuilder;
    function createSolutionBuilderWithWatch(host, rootNames, defaultOptions, baseWatchOptions) {
        return createSolutionBuilderWorker(/*watch*/ true, host, rootNames, defaultOptions, baseWatchOptions);
    }
    ts.createSolutionBuilderWithWatch = createSolutionBuilderWithWatch;
    function createSolutionBuilderState(watch, hostOrHostWithWatch, rootNames, options, baseWatchOptions) {
        var host = hostOrHostWithWatch;
        var hostWithWatch = hostOrHostWithWatch;
        var currentDirectory = host.getCurrentDirectory();
        var getCanonicalFileName = ts.createGetCanonicalFileName(host.useCaseSensitiveFileNames());
        // State of the solution
        var baseCompilerOptions = getCompilerOptionsOfBuildOptions(options);
        var compilerHost = ts.createCompilerHostFromProgramHost(host, function () { return state.projectCompilerOptions; });
        ts.setGetSourceFileAsHashVersioned(compilerHost, host);
        compilerHost.getParsedCommandLine = function (fileName) { return parseConfigFile(state, fileName, toResolvedConfigFilePath(state, fileName)); };
        compilerHost.resolveModuleNames = ts.maybeBind(host, host.resolveModuleNames);
        compilerHost.resolveTypeReferenceDirectives = ts.maybeBind(host, host.resolveTypeReferenceDirectives);
        var moduleResolutionCache = !compilerHost.resolveModuleNames ? ts.createModuleResolutionCache(currentDirectory, getCanonicalFileName) : undefined;
        var typeReferenceDirectiveResolutionCache = !compilerHost.resolveTypeReferenceDirectives ? ts.createTypeReferenceDirectiveResolutionCache(currentDirectory, getCanonicalFileName, /*options*/ undefined, moduleResolutionCache === null || moduleResolutionCache === void 0 ? void 0 : moduleResolutionCache.getPackageJsonInfoCache()) : undefined;
        if (!compilerHost.resolveModuleNames) {
            var loader_3 = function (moduleName, resolverMode, containingFile, redirectedReference) { return ts.resolveModuleName(moduleName, containingFile, state.projectCompilerOptions, compilerHost, moduleResolutionCache, redirectedReference, resolverMode).resolvedModule; };
            compilerHost.resolveModuleNames = function (moduleNames, containingFile, _reusedNames, redirectedReference, _options, containingSourceFile) {
                return ts.loadWithModeAwareCache(ts.Debug.checkEachDefined(moduleNames), ts.Debug.checkDefined(containingSourceFile), containingFile, redirectedReference, loader_3);
            };
            compilerHost.getModuleResolutionCache = function () { return moduleResolutionCache; };
        }
        if (!compilerHost.resolveTypeReferenceDirectives) {
            var loader_4 = function (moduleName, containingFile, redirectedReference, containingFileMode) { return ts.resolveTypeReferenceDirective(moduleName, containingFile, state.projectCompilerOptions, compilerHost, redirectedReference, state.typeReferenceDirectiveResolutionCache, containingFileMode).resolvedTypeReferenceDirective; };
            compilerHost.resolveTypeReferenceDirectives = function (typeReferenceDirectiveNames, containingFile, redirectedReference, _options, containingFileMode) {
                return ts.loadWithTypeDirectiveCache(ts.Debug.checkEachDefined(typeReferenceDirectiveNames), containingFile, redirectedReference, containingFileMode, loader_4);
            };
        }
        var _a = ts.createWatchFactory(hostWithWatch, options), watchFile = _a.watchFile, watchDirectory = _a.watchDirectory, writeLog = _a.writeLog;
        var state = {
            host: host,
            hostWithWatch: hostWithWatch,
            currentDirectory: currentDirectory,
            getCanonicalFileName: getCanonicalFileName,
            parseConfigFileHost: ts.parseConfigHostFromCompilerHostLike(host),
            write: ts.maybeBind(host, host.trace),
            // State of solution
            options: options,
            baseCompilerOptions: baseCompilerOptions,
            rootNames: rootNames,
            baseWatchOptions: baseWatchOptions,
            resolvedConfigFilePaths: new ts.Map(),
            configFileCache: new ts.Map(),
            projectStatus: new ts.Map(),
            buildInfoChecked: new ts.Map(),
            extendedConfigCache: new ts.Map(),
            builderPrograms: new ts.Map(),
            diagnostics: new ts.Map(),
            projectPendingBuild: new ts.Map(),
            projectErrorsReported: new ts.Map(),
            compilerHost: compilerHost,
            moduleResolutionCache: moduleResolutionCache,
            typeReferenceDirectiveResolutionCache: typeReferenceDirectiveResolutionCache,
            // Mutable state
            buildOrder: undefined,
            readFileWithCache: function (f) { return host.readFile(f); },
            projectCompilerOptions: baseCompilerOptions,
            cache: undefined,
            allProjectBuildPending: true,
            needsSummary: true,
            watchAllProjectsPending: watch,
            currentInvalidatedProject: undefined,
            // Watch state
            watch: watch,
            allWatchedWildcardDirectories: new ts.Map(),
            allWatchedInputFiles: new ts.Map(),
            allWatchedConfigFiles: new ts.Map(),
            allWatchedExtendedConfigFiles: new ts.Map(),
            allWatchedPackageJsonFiles: new ts.Map(),
            lastCachedPackageJsonLookups: new ts.Map(),
            timerToBuildInvalidatedProject: undefined,
            reportFileChangeDetected: false,
            watchFile: watchFile,
            watchDirectory: watchDirectory,
            writeLog: writeLog,
        };
        return state;
    }
    function toPath(state, fileName) {
        return ts.toPath(fileName, state.currentDirectory, state.getCanonicalFileName);
    }
    function toResolvedConfigFilePath(state, fileName) {
        var resolvedConfigFilePaths = state.resolvedConfigFilePaths;
        var path = resolvedConfigFilePaths.get(fileName);
        if (path !== undefined)
            return path;
        var resolvedPath = toPath(state, fileName);
        resolvedConfigFilePaths.set(fileName, resolvedPath);
        return resolvedPath;
    }
    function isParsedCommandLine(entry) {
        return !!entry.options;
    }
    function getCachedParsedConfigFile(state, configFilePath) {
        var value = state.configFileCache.get(configFilePath);
        return value && isParsedCommandLine(value) ? value : undefined;
    }
    function parseConfigFile(state, configFileName, configFilePath) {
        var configFileCache = state.configFileCache;
        var value = configFileCache.get(configFilePath);
        if (value) {
            return isParsedCommandLine(value) ? value : undefined;
        }
        var diagnostic;
        var parseConfigFileHost = state.parseConfigFileHost, baseCompilerOptions = state.baseCompilerOptions, baseWatchOptions = state.baseWatchOptions, extendedConfigCache = state.extendedConfigCache, host = state.host;
        var parsed;
        if (host.getParsedCommandLine) {
            parsed = host.getParsedCommandLine(configFileName);
            if (!parsed)
                diagnostic = ts.createCompilerDiagnostic(ts.Diagnostics.File_0_not_found, configFileName);
        }
        else {
            parseConfigFileHost.onUnRecoverableConfigFileDiagnostic = function (d) { return diagnostic = d; };
            parsed = ts.getParsedCommandLineOfConfigFile(configFileName, baseCompilerOptions, parseConfigFileHost, extendedConfigCache, baseWatchOptions);
            parseConfigFileHost.onUnRecoverableConfigFileDiagnostic = ts.noop;
        }
        configFileCache.set(configFilePath, parsed || diagnostic);
        return parsed;
    }
    function resolveProjectName(state, name) {
        return ts.resolveConfigFileProjectName(ts.resolvePath(state.currentDirectory, name));
    }
    function createBuildOrder(state, roots) {
        var temporaryMarks = new ts.Map();
        var permanentMarks = new ts.Map();
        var circularityReportStack = [];
        var buildOrder;
        var circularDiagnostics;
        for (var _i = 0, roots_1 = roots; _i < roots_1.length; _i++) {
            var root = roots_1[_i];
            visit(root);
        }
        return circularDiagnostics ?
            { buildOrder: buildOrder || ts.emptyArray, circularDiagnostics: circularDiagnostics } :
            buildOrder || ts.emptyArray;
        function visit(configFileName, inCircularContext) {
            var projPath = toResolvedConfigFilePath(state, configFileName);
            // Already visited
            if (permanentMarks.has(projPath))
                return;
            // Circular
            if (temporaryMarks.has(projPath)) {
                if (!inCircularContext) {
                    (circularDiagnostics || (circularDiagnostics = [])).push(ts.createCompilerDiagnostic(ts.Diagnostics.Project_references_may_not_form_a_circular_graph_Cycle_detected_Colon_0, circularityReportStack.join("\r\n")));
                }
                return;
            }
            temporaryMarks.set(projPath, true);
            circularityReportStack.push(configFileName);
            var parsed = parseConfigFile(state, configFileName, projPath);
            if (parsed && parsed.projectReferences) {
                for (var _i = 0, _a = parsed.projectReferences; _i < _a.length; _i++) {
                    var ref = _a[_i];
                    var resolvedRefPath = resolveProjectName(state, ref.path);
                    visit(resolvedRefPath, inCircularContext || ref.circular);
                }
            }
            circularityReportStack.pop();
            permanentMarks.set(projPath, true);
            (buildOrder || (buildOrder = [])).push(configFileName);
        }
    }
    function getBuildOrder(state) {
        return state.buildOrder || createStateBuildOrder(state);
    }
    function createStateBuildOrder(state) {
        var buildOrder = createBuildOrder(state, state.rootNames.map(function (f) { return resolveProjectName(state, f); }));
        // Clear all to ResolvedConfigFilePaths cache to start fresh
        state.resolvedConfigFilePaths.clear();
        // TODO(rbuckton): Should be a `Set`, but that requires changing the code below that uses `mutateMapSkippingNewValues`
        var currentProjects = new ts.Map(getBuildOrderFromAnyBuildOrder(buildOrder).map(function (resolved) { return [toResolvedConfigFilePath(state, resolved), true]; }));
        var noopOnDelete = { onDeleteValue: ts.noop };
        // Config file cache
        ts.mutateMapSkippingNewValues(state.configFileCache, currentProjects, noopOnDelete);
        ts.mutateMapSkippingNewValues(state.projectStatus, currentProjects, noopOnDelete);
        ts.mutateMapSkippingNewValues(state.buildInfoChecked, currentProjects, noopOnDelete);
        ts.mutateMapSkippingNewValues(state.builderPrograms, currentProjects, noopOnDelete);
        ts.mutateMapSkippingNewValues(state.diagnostics, currentProjects, noopOnDelete);
        ts.mutateMapSkippingNewValues(state.projectPendingBuild, currentProjects, noopOnDelete);
        ts.mutateMapSkippingNewValues(state.projectErrorsReported, currentProjects, noopOnDelete);
        // Remove watches for the program no longer in the solution
        if (state.watch) {
            ts.mutateMapSkippingNewValues(state.allWatchedConfigFiles, currentProjects, { onDeleteValue: ts.closeFileWatcher });
            state.allWatchedExtendedConfigFiles.forEach(function (watcher) {
                watcher.projects.forEach(function (project) {
                    if (!currentProjects.has(project)) {
                        watcher.projects.delete(project);
                    }
                });
                watcher.close();
            });
            ts.mutateMapSkippingNewValues(state.allWatchedWildcardDirectories, currentProjects, { onDeleteValue: function (existingMap) { return existingMap.forEach(ts.closeFileWatcherOf); } });
            ts.mutateMapSkippingNewValues(state.allWatchedInputFiles, currentProjects, { onDeleteValue: function (existingMap) { return existingMap.forEach(ts.closeFileWatcher); } });
            ts.mutateMapSkippingNewValues(state.allWatchedPackageJsonFiles, currentProjects, { onDeleteValue: function (existingMap) { return existingMap.forEach(ts.closeFileWatcher); } });
        }
        return state.buildOrder = buildOrder;
    }
    function getBuildOrderFor(state, project, onlyReferences) {
        var resolvedProject = project && resolveProjectName(state, project);
        var buildOrderFromState = getBuildOrder(state);
        if (isCircularBuildOrder(buildOrderFromState))
            return buildOrderFromState;
        if (resolvedProject) {
            var projectPath_1 = toResolvedConfigFilePath(state, resolvedProject);
            var projectIndex = ts.findIndex(buildOrderFromState, function (configFileName) { return toResolvedConfigFilePath(state, configFileName) === projectPath_1; });
            if (projectIndex === -1)
                return undefined;
        }
        var buildOrder = resolvedProject ? createBuildOrder(state, [resolvedProject]) : buildOrderFromState;
        ts.Debug.assert(!isCircularBuildOrder(buildOrder));
        ts.Debug.assert(!onlyReferences || resolvedProject !== undefined);
        ts.Debug.assert(!onlyReferences || buildOrder[buildOrder.length - 1] === resolvedProject);
        return onlyReferences ? buildOrder.slice(0, buildOrder.length - 1) : buildOrder;
    }
    function enableCache(state) {
        if (state.cache) {
            disableCache(state);
        }
        var compilerHost = state.compilerHost, host = state.host;
        var originalReadFileWithCache = state.readFileWithCache;
        var originalGetSourceFile = compilerHost.getSourceFile;
        var _a = ts.changeCompilerHostLikeToUseCache(host, function (fileName) { return toPath(state, fileName); }, function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return originalGetSourceFile.call.apply(originalGetSourceFile, __spreadArray([compilerHost], args, false));
        }), originalReadFile = _a.originalReadFile, originalFileExists = _a.originalFileExists, originalDirectoryExists = _a.originalDirectoryExists, originalCreateDirectory = _a.originalCreateDirectory, originalWriteFile = _a.originalWriteFile, getSourceFileWithCache = _a.getSourceFileWithCache, readFileWithCache = _a.readFileWithCache;
        state.readFileWithCache = readFileWithCache;
        compilerHost.getSourceFile = getSourceFileWithCache;
        state.cache = {
            originalReadFile: originalReadFile,
            originalFileExists: originalFileExists,
            originalDirectoryExists: originalDirectoryExists,
            originalCreateDirectory: originalCreateDirectory,
            originalWriteFile: originalWriteFile,
            originalReadFileWithCache: originalReadFileWithCache,
            originalGetSourceFile: originalGetSourceFile,
        };
    }
    function disableCache(state) {
        if (!state.cache)
            return;
        var cache = state.cache, host = state.host, compilerHost = state.compilerHost, extendedConfigCache = state.extendedConfigCache, moduleResolutionCache = state.moduleResolutionCache, typeReferenceDirectiveResolutionCache = state.typeReferenceDirectiveResolutionCache;
        host.readFile = cache.originalReadFile;
        host.fileExists = cache.originalFileExists;
        host.directoryExists = cache.originalDirectoryExists;
        host.createDirectory = cache.originalCreateDirectory;
        host.writeFile = cache.originalWriteFile;
        compilerHost.getSourceFile = cache.originalGetSourceFile;
        state.readFileWithCache = cache.originalReadFileWithCache;
        extendedConfigCache.clear();
        moduleResolutionCache === null || moduleResolutionCache === void 0 ? void 0 : moduleResolutionCache.clear();
        typeReferenceDirectiveResolutionCache === null || typeReferenceDirectiveResolutionCache === void 0 ? void 0 : typeReferenceDirectiveResolutionCache.clear();
        state.cache = undefined;
    }
    function clearProjectStatus(state, resolved) {
        state.projectStatus.delete(resolved);
        state.diagnostics.delete(resolved);
    }
    function addProjToQueue(_a, proj, reloadLevel) {
        var projectPendingBuild = _a.projectPendingBuild;
        var value = projectPendingBuild.get(proj);
        if (value === undefined) {
            projectPendingBuild.set(proj, reloadLevel);
        }
        else if (value < reloadLevel) {
            projectPendingBuild.set(proj, reloadLevel);
        }
    }
    function setupInitialBuild(state, cancellationToken) {
        // Set initial build if not already built
        if (!state.allProjectBuildPending)
            return;
        state.allProjectBuildPending = false;
        if (state.options.watch)
            reportWatchStatus(state, ts.Diagnostics.Starting_compilation_in_watch_mode);
        enableCache(state);
        var buildOrder = getBuildOrderFromAnyBuildOrder(getBuildOrder(state));
        buildOrder.forEach(function (configFileName) {
            return state.projectPendingBuild.set(toResolvedConfigFilePath(state, configFileName), ts.ConfigFileProgramReloadLevel.None);
        });
        if (cancellationToken) {
            cancellationToken.throwIfCancellationRequested();
        }
    }
    var InvalidatedProjectKind;
    (function (InvalidatedProjectKind) {
        InvalidatedProjectKind[InvalidatedProjectKind["Build"] = 0] = "Build";
        InvalidatedProjectKind[InvalidatedProjectKind["UpdateBundle"] = 1] = "UpdateBundle";
        InvalidatedProjectKind[InvalidatedProjectKind["UpdateOutputFileStamps"] = 2] = "UpdateOutputFileStamps";
    })(InvalidatedProjectKind = ts.InvalidatedProjectKind || (ts.InvalidatedProjectKind = {}));
    function doneInvalidatedProject(state, projectPath) {
        state.projectPendingBuild.delete(projectPath);
        state.currentInvalidatedProject = undefined;
        return state.diagnostics.has(projectPath) ?
            ts.ExitStatus.DiagnosticsPresent_OutputsSkipped :
            ts.ExitStatus.Success;
    }
    function createUpdateOutputFileStampsProject(state, project, projectPath, config, buildOrder) {
        var updateOutputFileStampsPending = true;
        return {
            kind: InvalidatedProjectKind.UpdateOutputFileStamps,
            project: project,
            projectPath: projectPath,
            buildOrder: buildOrder,
            getCompilerOptions: function () { return config.options; },
            getCurrentDirectory: function () { return state.currentDirectory; },
            updateOutputFileStatmps: function () {
                updateOutputTimestamps(state, config, projectPath);
                updateOutputFileStampsPending = false;
            },
            done: function () {
                if (updateOutputFileStampsPending) {
                    updateOutputTimestamps(state, config, projectPath);
                }
                return doneInvalidatedProject(state, projectPath);
            }
        };
    }
    var BuildStep;
    (function (BuildStep) {
        BuildStep[BuildStep["CreateProgram"] = 0] = "CreateProgram";
        BuildStep[BuildStep["SyntaxDiagnostics"] = 1] = "SyntaxDiagnostics";
        BuildStep[BuildStep["SemanticDiagnostics"] = 2] = "SemanticDiagnostics";
        BuildStep[BuildStep["Emit"] = 3] = "Emit";
        BuildStep[BuildStep["EmitBundle"] = 4] = "EmitBundle";
        BuildStep[BuildStep["EmitBuildInfo"] = 5] = "EmitBuildInfo";
        BuildStep[BuildStep["BuildInvalidatedProjectOfBundle"] = 6] = "BuildInvalidatedProjectOfBundle";
        BuildStep[BuildStep["QueueReferencingProjects"] = 7] = "QueueReferencingProjects";
        BuildStep[BuildStep["Done"] = 8] = "Done";
    })(BuildStep || (BuildStep = {}));
    function createBuildOrUpdateInvalidedProject(kind, state, project, projectPath, projectIndex, config, buildOrder) {
        var step = kind === InvalidatedProjectKind.Build ? BuildStep.CreateProgram : BuildStep.EmitBundle;
        var program;
        var buildResult;
        var invalidatedProjectOfBundle;
        return kind === InvalidatedProjectKind.Build ?
            {
                kind: kind,
                project: project,
                projectPath: projectPath,
                buildOrder: buildOrder,
                getCompilerOptions: function () { return config.options; },
                getCurrentDirectory: function () { return state.currentDirectory; },
                getBuilderProgram: function () { return withProgramOrUndefined(ts.identity); },
                getProgram: function () {
                    return withProgramOrUndefined(function (program) { return program.getProgramOrUndefined(); });
                },
                getSourceFile: function (fileName) {
                    return withProgramOrUndefined(function (program) { return program.getSourceFile(fileName); });
                },
                getSourceFiles: function () {
                    return withProgramOrEmptyArray(function (program) { return program.getSourceFiles(); });
                },
                getOptionsDiagnostics: function (cancellationToken) {
                    return withProgramOrEmptyArray(function (program) { return program.getOptionsDiagnostics(cancellationToken); });
                },
                getGlobalDiagnostics: function (cancellationToken) {
                    return withProgramOrEmptyArray(function (program) { return program.getGlobalDiagnostics(cancellationToken); });
                },
                getConfigFileParsingDiagnostics: function () {
                    return withProgramOrEmptyArray(function (program) { return program.getConfigFileParsingDiagnostics(); });
                },
                getSyntacticDiagnostics: function (sourceFile, cancellationToken) {
                    return withProgramOrEmptyArray(function (program) { return program.getSyntacticDiagnostics(sourceFile, cancellationToken); });
                },
                getAllDependencies: function (sourceFile) {
                    return withProgramOrEmptyArray(function (program) { return program.getAllDependencies(sourceFile); });
                },
                getSemanticDiagnostics: function (sourceFile, cancellationToken) {
                    return withProgramOrEmptyArray(function (program) { return program.getSemanticDiagnostics(sourceFile, cancellationToken); });
                },
                getSemanticDiagnosticsOfNextAffectedFile: function (cancellationToken, ignoreSourceFile) {
                    return withProgramOrUndefined(function (program) {
                        return (program.getSemanticDiagnosticsOfNextAffectedFile) &&
                            program.getSemanticDiagnosticsOfNextAffectedFile(cancellationToken, ignoreSourceFile);
                    });
                },
                emit: function (targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers) {
                    if (targetSourceFile || emitOnlyDtsFiles) {
                        return withProgramOrUndefined(function (program) { var _a, _b; return program.emit(targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers || ((_b = (_a = state.host).getCustomTransformers) === null || _b === void 0 ? void 0 : _b.call(_a, project))); });
                    }
                    executeSteps(BuildStep.SemanticDiagnostics, cancellationToken);
                    if (step === BuildStep.EmitBuildInfo) {
                        return emitBuildInfo(writeFile, cancellationToken);
                    }
                    if (step !== BuildStep.Emit)
                        return undefined;
                    return emit(writeFile, cancellationToken, customTransformers);
                },
                done: done
            } :
            {
                kind: kind,
                project: project,
                projectPath: projectPath,
                buildOrder: buildOrder,
                getCompilerOptions: function () { return config.options; },
                getCurrentDirectory: function () { return state.currentDirectory; },
                emit: function (writeFile, customTransformers) {
                    if (step !== BuildStep.EmitBundle)
                        return invalidatedProjectOfBundle;
                    return emitBundle(writeFile, customTransformers);
                },
                done: done,
            };
        function done(cancellationToken, writeFile, customTransformers) {
            executeSteps(BuildStep.Done, cancellationToken, writeFile, customTransformers);
            return doneInvalidatedProject(state, projectPath);
        }
        function withProgramOrUndefined(action) {
            executeSteps(BuildStep.CreateProgram);
            return program && action(program);
        }
        function withProgramOrEmptyArray(action) {
            return withProgramOrUndefined(action) || ts.emptyArray;
        }
        function createProgram() {
            var _a, _b;
            ts.Debug.assert(program === undefined);
            if (state.options.dry) {
                reportStatus(state, ts.Diagnostics.A_non_dry_build_would_build_project_0, project);
                buildResult = BuildResultFlags.Success;
                step = BuildStep.QueueReferencingProjects;
                return;
            }
            if (state.options.verbose)
                reportStatus(state, ts.Diagnostics.Building_project_0, project);
            if (config.fileNames.length === 0) {
                reportAndStoreErrors(state, projectPath, ts.getConfigFileParsingDiagnostics(config));
                // Nothing to build - must be a solution file, basically
                buildResult = BuildResultFlags.None;
                step = BuildStep.QueueReferencingProjects;
                return;
            }
            var host = state.host, compilerHost = state.compilerHost;
            state.projectCompilerOptions = config.options;
            // Update module resolution cache if needed
            (_a = state.moduleResolutionCache) === null || _a === void 0 ? void 0 : _a.update(config.options);
            (_b = state.typeReferenceDirectiveResolutionCache) === null || _b === void 0 ? void 0 : _b.update(config.options);
            // Create program
            program = host.createProgram(config.fileNames, config.options, compilerHost, getOldProgram(state, projectPath, config), ts.getConfigFileParsingDiagnostics(config), config.projectReferences);
            if (state.watch) {
                state.lastCachedPackageJsonLookups.set(projectPath, state.moduleResolutionCache && ts.map(state.moduleResolutionCache.getPackageJsonInfoCache().entries(), function (_a) {
                    var path = _a[0], data = _a[1];
                    return [state.host.realpath && data ? toPath(state, state.host.realpath(path)) : path, data];
                }));
                state.builderPrograms.set(projectPath, program);
            }
            step++;
        }
        function handleDiagnostics(diagnostics, errorFlags, errorType) {
            var _a;
            if (diagnostics.length) {
                (_a = buildErrors(state, projectPath, program, config, diagnostics, errorFlags, errorType), buildResult = _a.buildResult, step = _a.step);
            }
            else {
                step++;
            }
        }
        function getSyntaxDiagnostics(cancellationToken) {
            ts.Debug.assertIsDefined(program);
            handleDiagnostics(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], program.getConfigFileParsingDiagnostics(), true), program.getOptionsDiagnostics(cancellationToken), true), program.getGlobalDiagnostics(cancellationToken), true), program.getSyntacticDiagnostics(/*sourceFile*/ undefined, cancellationToken), true), BuildResultFlags.SyntaxErrors, "Syntactic");
        }
        function getSemanticDiagnostics(cancellationToken) {
            handleDiagnostics(ts.Debug.checkDefined(program).getSemanticDiagnostics(/*sourceFile*/ undefined, cancellationToken), BuildResultFlags.TypeErrors, "Semantic");
        }
        function emit(writeFileCallback, cancellationToken, customTransformers) {
            var _a;
            var _b, _c;
            ts.Debug.assertIsDefined(program);
            ts.Debug.assert(step === BuildStep.Emit);
            // Before emitting lets backup state, so we can revert it back if there are declaration errors to handle emit and declaration errors correctly
            program.backupState();
            var declDiagnostics;
            var reportDeclarationDiagnostics = function (d) { return (declDiagnostics || (declDiagnostics = [])).push(d); };
            var outputFiles = [];
            var emitResult = ts.emitFilesAndReportErrors(program, reportDeclarationDiagnostics, 
            /*write*/ undefined, 
            /*reportSummary*/ undefined, function (name, text, writeByteOrderMark) { return outputFiles.push({ name: name, text: text, writeByteOrderMark: writeByteOrderMark }); }, cancellationToken, 
            /*emitOnlyDts*/ false, customTransformers || ((_c = (_b = state.host).getCustomTransformers) === null || _c === void 0 ? void 0 : _c.call(_b, project))).emitResult;
            // Don't emit .d.ts if there are decl file errors
            if (declDiagnostics) {
                program.restoreState();
                (_a = buildErrors(state, projectPath, program, config, declDiagnostics, BuildResultFlags.DeclarationEmitErrors, "Declaration file"), buildResult = _a.buildResult, step = _a.step);
                return {
                    emitSkipped: true,
                    diagnostics: emitResult.diagnostics
                };
            }
            // Actual Emit
            var host = state.host, compilerHost = state.compilerHost;
            var resultFlags = BuildResultFlags.DeclarationOutputUnchanged;
            var newestDeclarationFileContentChangedTime = minimumDate;
            var anyDtsChanged = false;
            var emitterDiagnostics = ts.createDiagnosticCollection();
            var emittedOutputs = new ts.Map();
            outputFiles.forEach(function (_a) {
                var name = _a.name, text = _a.text, writeByteOrderMark = _a.writeByteOrderMark;
                var priorChangeTime;
                if (!anyDtsChanged && ts.isDeclarationFileName(name)) {
                    // Check for unchanged .d.ts files
                    if (host.fileExists(name) && state.readFileWithCache(name) === text) {
                        priorChangeTime = host.getModifiedTime(name);
                    }
                    else {
                        resultFlags &= ~BuildResultFlags.DeclarationOutputUnchanged;
                        anyDtsChanged = true;
                    }
                }
                emittedOutputs.set(toPath(state, name), name);
                ts.writeFile(writeFileCallback ? { writeFile: writeFileCallback } : compilerHost, emitterDiagnostics, name, text, writeByteOrderMark);
                if (priorChangeTime !== undefined) {
                    newestDeclarationFileContentChangedTime = newer(priorChangeTime, newestDeclarationFileContentChangedTime);
                }
            });
            finishEmit(emitterDiagnostics, emittedOutputs, newestDeclarationFileContentChangedTime, 
            /*newestDeclarationFileContentChangedTimeIsMaximumDate*/ anyDtsChanged, outputFiles.length ? outputFiles[0].name : ts.getFirstProjectOutput(config, !host.useCaseSensitiveFileNames()), resultFlags);
            return emitResult;
        }
        function emitBuildInfo(writeFileCallback, cancellationToken) {
            ts.Debug.assertIsDefined(program);
            ts.Debug.assert(step === BuildStep.EmitBuildInfo);
            var emitResult = program.emitBuildInfo(writeFileCallback, cancellationToken);
            if (emitResult.diagnostics.length) {
                reportErrors(state, emitResult.diagnostics);
                state.diagnostics.set(projectPath, __spreadArray(__spreadArray([], state.diagnostics.get(projectPath), true), emitResult.diagnostics, true));
                buildResult = BuildResultFlags.EmitErrors & buildResult;
            }
            if (emitResult.emittedFiles && state.write) {
                emitResult.emittedFiles.forEach(function (name) { return listEmittedFile(state, config, name); });
            }
            afterProgramDone(state, program, config);
            step = BuildStep.QueueReferencingProjects;
            return emitResult;
        }
        function finishEmit(emitterDiagnostics, emittedOutputs, priorNewestUpdateTime, newestDeclarationFileContentChangedTimeIsMaximumDate, oldestOutputFileName, resultFlags) {
            var _a;
            var emitDiagnostics = emitterDiagnostics.getDiagnostics();
            if (emitDiagnostics.length) {
                (_a = buildErrors(state, projectPath, program, config, emitDiagnostics, BuildResultFlags.EmitErrors, "Emit"), buildResult = _a.buildResult, step = _a.step);
                return emitDiagnostics;
            }
            if (state.write) {
                emittedOutputs.forEach(function (name) { return listEmittedFile(state, config, name); });
            }
            // Update time stamps for rest of the outputs
            var newestDeclarationFileContentChangedTime = updateOutputTimestampsWorker(state, config, priorNewestUpdateTime, ts.Diagnostics.Updating_unchanged_output_timestamps_of_project_0, emittedOutputs);
            state.diagnostics.delete(projectPath);
            state.projectStatus.set(projectPath, {
                type: ts.UpToDateStatusType.UpToDate,
                newestDeclarationFileContentChangedTime: newestDeclarationFileContentChangedTimeIsMaximumDate ?
                    maximumDate :
                    newestDeclarationFileContentChangedTime,
                oldestOutputFileName: oldestOutputFileName
            });
            afterProgramDone(state, program, config);
            step = BuildStep.QueueReferencingProjects;
            buildResult = resultFlags;
            return emitDiagnostics;
        }
        function emitBundle(writeFileCallback, customTransformers) {
            var _a, _b;
            ts.Debug.assert(kind === InvalidatedProjectKind.UpdateBundle);
            if (state.options.dry) {
                reportStatus(state, ts.Diagnostics.A_non_dry_build_would_update_output_of_project_0, project);
                buildResult = BuildResultFlags.Success;
                step = BuildStep.QueueReferencingProjects;
                return undefined;
            }
            if (state.options.verbose)
                reportStatus(state, ts.Diagnostics.Updating_output_of_project_0, project);
            // Update js, and source map
            var compilerHost = state.compilerHost;
            state.projectCompilerOptions = config.options;
            var outputFiles = ts.emitUsingBuildInfo(config, compilerHost, function (ref) {
                var refName = resolveProjectName(state, ref.path);
                return parseConfigFile(state, refName, toResolvedConfigFilePath(state, refName));
            }, customTransformers || ((_b = (_a = state.host).getCustomTransformers) === null || _b === void 0 ? void 0 : _b.call(_a, project)));
            if (ts.isString(outputFiles)) {
                reportStatus(state, ts.Diagnostics.Cannot_update_output_of_project_0_because_there_was_error_reading_file_1, project, relName(state, outputFiles));
                step = BuildStep.BuildInvalidatedProjectOfBundle;
                return invalidatedProjectOfBundle = createBuildOrUpdateInvalidedProject(InvalidatedProjectKind.Build, state, project, projectPath, projectIndex, config, buildOrder);
            }
            // Actual Emit
            ts.Debug.assert(!!outputFiles.length);
            var emitterDiagnostics = ts.createDiagnosticCollection();
            var emittedOutputs = new ts.Map();
            outputFiles.forEach(function (_a) {
                var name = _a.name, text = _a.text, writeByteOrderMark = _a.writeByteOrderMark;
                emittedOutputs.set(toPath(state, name), name);
                ts.writeFile(writeFileCallback ? { writeFile: writeFileCallback } : compilerHost, emitterDiagnostics, name, text, writeByteOrderMark);
            });
            var emitDiagnostics = finishEmit(emitterDiagnostics, emittedOutputs, minimumDate, 
            /*newestDeclarationFileContentChangedTimeIsMaximumDate*/ false, outputFiles[0].name, BuildResultFlags.DeclarationOutputUnchanged);
            return { emitSkipped: false, diagnostics: emitDiagnostics };
        }
        function executeSteps(till, cancellationToken, writeFile, customTransformers) {
            while (step <= till && step < BuildStep.Done) {
                var currentStep = step;
                switch (step) {
                    case BuildStep.CreateProgram:
                        createProgram();
                        break;
                    case BuildStep.SyntaxDiagnostics:
                        getSyntaxDiagnostics(cancellationToken);
                        break;
                    case BuildStep.SemanticDiagnostics:
                        getSemanticDiagnostics(cancellationToken);
                        break;
                    case BuildStep.Emit:
                        emit(writeFile, cancellationToken, customTransformers);
                        break;
                    case BuildStep.EmitBuildInfo:
                        emitBuildInfo(writeFile, cancellationToken);
                        break;
                    case BuildStep.EmitBundle:
                        emitBundle(writeFile, customTransformers);
                        break;
                    case BuildStep.BuildInvalidatedProjectOfBundle:
                        ts.Debug.checkDefined(invalidatedProjectOfBundle).done(cancellationToken, writeFile, customTransformers);
                        step = BuildStep.Done;
                        break;
                    case BuildStep.QueueReferencingProjects:
                        queueReferencingProjects(state, project, projectPath, projectIndex, config, buildOrder, ts.Debug.checkDefined(buildResult));
                        step++;
                        break;
                    // Should never be done
                    case BuildStep.Done:
                    default:
                        ts.assertType(step);
                }
                ts.Debug.assert(step > currentStep);
            }
        }
    }
    function needsBuild(_a, status, config) {
        var options = _a.options;
        if (status.type !== ts.UpToDateStatusType.OutOfDateWithPrepend || options.force)
            return true;
        return config.fileNames.length === 0 ||
            !!ts.getConfigFileParsingDiagnostics(config).length ||
            !ts.isIncrementalCompilation(config.options);
    }
    function getNextInvalidatedProject(state, buildOrder, reportQueue) {
        if (!state.projectPendingBuild.size)
            return undefined;
        if (isCircularBuildOrder(buildOrder))
            return undefined;
        if (state.currentInvalidatedProject) {
            // Only if same buildOrder the currentInvalidated project can be sent again
            return ts.arrayIsEqualTo(state.currentInvalidatedProject.buildOrder, buildOrder) ?
                state.currentInvalidatedProject :
                undefined;
        }
        var options = state.options, projectPendingBuild = state.projectPendingBuild;
        for (var projectIndex = 0; projectIndex < buildOrder.length; projectIndex++) {
            var project = buildOrder[projectIndex];
            var projectPath = toResolvedConfigFilePath(state, project);
            var reloadLevel = state.projectPendingBuild.get(projectPath);
            if (reloadLevel === undefined)
                continue;
            if (reportQueue) {
                reportQueue = false;
                reportBuildQueue(state, buildOrder);
            }
            var config = parseConfigFile(state, project, projectPath);
            if (!config) {
                reportParseConfigFileDiagnostic(state, projectPath);
                projectPendingBuild.delete(projectPath);
                continue;
            }
            if (reloadLevel === ts.ConfigFileProgramReloadLevel.Full) {
                watchConfigFile(state, project, projectPath, config);
                watchExtendedConfigFiles(state, projectPath, config);
                watchWildCardDirectories(state, project, projectPath, config);
                watchInputFiles(state, project, projectPath, config);
                watchPackageJsonFiles(state, project, projectPath, config);
            }
            else if (reloadLevel === ts.ConfigFileProgramReloadLevel.Partial) {
                // Update file names
                config.fileNames = ts.getFileNamesFromConfigSpecs(config.options.configFile.configFileSpecs, ts.getDirectoryPath(project), config.options, state.parseConfigFileHost);
                ts.updateErrorForNoInputFiles(config.fileNames, project, config.options.configFile.configFileSpecs, config.errors, ts.canJsonReportNoInputFiles(config.raw));
                watchInputFiles(state, project, projectPath, config);
                watchPackageJsonFiles(state, project, projectPath, config);
            }
            var status = getUpToDateStatus(state, config, projectPath);
            verboseReportProjectStatus(state, project, status);
            if (!options.force) {
                if (status.type === ts.UpToDateStatusType.UpToDate) {
                    reportAndStoreErrors(state, projectPath, ts.getConfigFileParsingDiagnostics(config));
                    projectPendingBuild.delete(projectPath);
                    // Up to date, skip
                    if (options.dry) {
                        // In a dry build, inform the user of this fact
                        reportStatus(state, ts.Diagnostics.Project_0_is_up_to_date, project);
                    }
                    continue;
                }
                if (status.type === ts.UpToDateStatusType.UpToDateWithUpstreamTypes) {
                    reportAndStoreErrors(state, projectPath, ts.getConfigFileParsingDiagnostics(config));
                    return createUpdateOutputFileStampsProject(state, project, projectPath, config, buildOrder);
                }
            }
            if (status.type === ts.UpToDateStatusType.UpstreamBlocked) {
                reportAndStoreErrors(state, projectPath, ts.getConfigFileParsingDiagnostics(config));
                projectPendingBuild.delete(projectPath);
                if (options.verbose) {
                    reportStatus(state, status.upstreamProjectBlocked ?
                        ts.Diagnostics.Skipping_build_of_project_0_because_its_dependency_1_was_not_built :
                        ts.Diagnostics.Skipping_build_of_project_0_because_its_dependency_1_has_errors, project, status.upstreamProjectName);
                }
                continue;
            }
            if (status.type === ts.UpToDateStatusType.ContainerOnly) {
                reportAndStoreErrors(state, projectPath, ts.getConfigFileParsingDiagnostics(config));
                projectPendingBuild.delete(projectPath);
                // Do nothing
                continue;
            }
            return createBuildOrUpdateInvalidedProject(needsBuild(state, status, config) ?
                InvalidatedProjectKind.Build :
                InvalidatedProjectKind.UpdateBundle, state, project, projectPath, projectIndex, config, buildOrder);
        }
        return undefined;
    }
    function listEmittedFile(_a, proj, file) {
        var write = _a.write;
        if (write && proj.options.listEmittedFiles) {
            write("TSFILE: ".concat(file));
        }
    }
    function getOldProgram(_a, proj, parsed) {
        var options = _a.options, builderPrograms = _a.builderPrograms, compilerHost = _a.compilerHost;
        if (options.force)
            return undefined;
        var value = builderPrograms.get(proj);
        if (value)
            return value;
        return ts.readBuilderProgram(parsed.options, compilerHost);
    }
    function afterProgramDone(state, program, config) {
        if (program) {
            if (program && state.write)
                ts.listFiles(program, state.write);
            if (state.host.afterProgramEmitAndDiagnostics) {
                state.host.afterProgramEmitAndDiagnostics(program);
            }
            program.releaseProgram();
        }
        else if (state.host.afterEmitBundle) {
            state.host.afterEmitBundle(config);
        }
        state.projectCompilerOptions = state.baseCompilerOptions;
    }
    function buildErrors(state, resolvedPath, program, config, diagnostics, buildResult, errorType) {
        var canEmitBuildInfo = !(buildResult & BuildResultFlags.SyntaxErrors) && program && !ts.outFile(program.getCompilerOptions());
        reportAndStoreErrors(state, resolvedPath, diagnostics);
        state.projectStatus.set(resolvedPath, { type: ts.UpToDateStatusType.Unbuildable, reason: "".concat(errorType, " errors") });
        if (canEmitBuildInfo)
            return { buildResult: buildResult, step: BuildStep.EmitBuildInfo };
        afterProgramDone(state, program, config);
        return { buildResult: buildResult, step: BuildStep.QueueReferencingProjects };
    }
    function checkConfigFileUpToDateStatus(state, configFile, oldestOutputFileTime, oldestOutputFileName) {
        // Check tsconfig time
        var tsconfigTime = ts.getModifiedTime(state.host, configFile);
        if (oldestOutputFileTime < tsconfigTime) {
            return {
                type: ts.UpToDateStatusType.OutOfDateWithSelf,
                outOfDateOutputFileName: oldestOutputFileName,
                newerInputFileName: configFile
            };
        }
    }
    function getUpToDateStatusWorker(state, project, resolvedPath) {
        var force = !!state.options.force;
        var newestInputFileName = undefined;
        var newestInputFileTime = minimumDate;
        var host = state.host;
        // Get timestamps of input files
        for (var _i = 0, _a = project.fileNames; _i < _a.length; _i++) {
            var inputFile = _a[_i];
            if (!host.fileExists(inputFile)) {
                return {
                    type: ts.UpToDateStatusType.Unbuildable,
                    reason: "".concat(inputFile, " does not exist")
                };
            }
            if (!force) {
                var inputTime = ts.getModifiedTime(host, inputFile);
                if (inputTime > newestInputFileTime) {
                    newestInputFileName = inputFile;
                    newestInputFileTime = inputTime;
                }
            }
        }
        // Container if no files are specified in the project
        if (!project.fileNames.length && !ts.canJsonReportNoInputFiles(project.raw)) {
            return {
                type: ts.UpToDateStatusType.ContainerOnly
            };
        }
        // Collect the expected outputs of this project
        var outputs = ts.getAllProjectOutputs(project, !host.useCaseSensitiveFileNames());
        // Now see if all outputs are newer than the newest input
        var oldestOutputFileName = "(none)";
        var oldestOutputFileTime = maximumDate;
        var newestOutputFileName = "(none)";
        var newestOutputFileTime = minimumDate;
        var missingOutputFileName;
        var newestDeclarationFileContentChangedTime = minimumDate;
        var isOutOfDateWithInputs = false;
        if (!force) {
            for (var _b = 0, outputs_1 = outputs; _b < outputs_1.length; _b++) {
                var output = outputs_1[_b];
                // Output is missing; can stop checking
                // Don't immediately return because we can still be upstream-blocked, which is a higher-priority status
                if (!host.fileExists(output)) {
                    missingOutputFileName = output;
                    break;
                }
                var outputTime = ts.getModifiedTime(host, output);
                if (outputTime < oldestOutputFileTime) {
                    oldestOutputFileTime = outputTime;
                    oldestOutputFileName = output;
                }
                // If an output is older than the newest input, we can stop checking
                // Don't immediately return because we can still be upstream-blocked, which is a higher-priority status
                if (outputTime < newestInputFileTime) {
                    isOutOfDateWithInputs = true;
                    break;
                }
                if (outputTime > newestOutputFileTime) {
                    newestOutputFileTime = outputTime;
                    newestOutputFileName = output;
                }
                // Keep track of when the most recent time a .d.ts file was changed.
                // In addition to file timestamps, we also keep track of when a .d.ts file
                // had its file touched but not had its contents changed - this allows us
                // to skip a downstream typecheck
                if (ts.isDeclarationFileName(output)) {
                    var outputModifiedTime = ts.getModifiedTime(host, output);
                    newestDeclarationFileContentChangedTime = newer(newestDeclarationFileContentChangedTime, outputModifiedTime);
                }
            }
        }
        var pseudoUpToDate = false;
        var usesPrepend = false;
        var upstreamChangedProject;
        if (project.projectReferences) {
            state.projectStatus.set(resolvedPath, { type: ts.UpToDateStatusType.ComputingUpstream });
            for (var _c = 0, _d = project.projectReferences; _c < _d.length; _c++) {
                var ref = _d[_c];
                usesPrepend = usesPrepend || !!(ref.prepend);
                var resolvedRef = ts.resolveProjectReferencePath(ref);
                var resolvedRefPath = toResolvedConfigFilePath(state, resolvedRef);
                var refStatus = getUpToDateStatus(state, parseConfigFile(state, resolvedRef, resolvedRefPath), resolvedRefPath);
                // Its a circular reference ignore the status of this project
                if (refStatus.type === ts.UpToDateStatusType.ComputingUpstream ||
                    refStatus.type === ts.UpToDateStatusType.ContainerOnly) { // Container only ignore this project
                    continue;
                }
                // An upstream project is blocked
                if (refStatus.type === ts.UpToDateStatusType.Unbuildable ||
                    refStatus.type === ts.UpToDateStatusType.UpstreamBlocked) {
                    return {
                        type: ts.UpToDateStatusType.UpstreamBlocked,
                        upstreamProjectName: ref.path,
                        upstreamProjectBlocked: refStatus.type === ts.UpToDateStatusType.UpstreamBlocked
                    };
                }
                // If the upstream project is out of date, then so are we (someone shouldn't have asked, though?)
                if (refStatus.type !== ts.UpToDateStatusType.UpToDate) {
                    return {
                        type: ts.UpToDateStatusType.UpstreamOutOfDate,
                        upstreamProjectName: ref.path
                    };
                }
                // Check oldest output file name only if there is no missing output file name
                // (a check we will have skipped if this is a forced build)
                if (!force && !missingOutputFileName) {
                    // If the upstream project's newest file is older than our oldest output, we
                    // can't be out of date because of it
                    if (refStatus.newestInputFileTime && refStatus.newestInputFileTime <= oldestOutputFileTime) {
                        continue;
                    }
                    // If the upstream project has only change .d.ts files, and we've built
                    // *after* those files, then we're "psuedo up to date" and eligible for a fast rebuild
                    if (refStatus.newestDeclarationFileContentChangedTime && refStatus.newestDeclarationFileContentChangedTime <= oldestOutputFileTime) {
                        pseudoUpToDate = true;
                        upstreamChangedProject = ref.path;
                        continue;
                    }
                    // We have an output older than an upstream output - we are out of date
                    ts.Debug.assert(oldestOutputFileName !== undefined, "Should have an oldest output filename here");
                    return {
                        type: ts.UpToDateStatusType.OutOfDateWithUpstream,
                        outOfDateOutputFileName: oldestOutputFileName,
                        newerProjectName: ref.path
                    };
                }
            }
        }
        if (missingOutputFileName !== undefined) {
            return {
                type: ts.UpToDateStatusType.OutputMissing,
                missingOutputFileName: missingOutputFileName
            };
        }
        if (isOutOfDateWithInputs) {
            return {
                type: ts.UpToDateStatusType.OutOfDateWithSelf,
                outOfDateOutputFileName: oldestOutputFileName,
                newerInputFileName: newestInputFileName
            };
        }
        else {
            // Check tsconfig time
            var configStatus = checkConfigFileUpToDateStatus(state, project.options.configFilePath, oldestOutputFileTime, oldestOutputFileName);
            if (configStatus)
                return configStatus;
            // Check extended config time
            var extendedConfigStatus = ts.forEach(project.options.configFile.extendedSourceFiles || ts.emptyArray, function (configFile) { return checkConfigFileUpToDateStatus(state, configFile, oldestOutputFileTime, oldestOutputFileName); });
            if (extendedConfigStatus)
                return extendedConfigStatus;
            // Check package file time
            var dependentPackageFileStatus = ts.forEach(state.lastCachedPackageJsonLookups.get(resolvedPath) || ts.emptyArray, function (_a) {
                var path = _a[0];
                return checkConfigFileUpToDateStatus(state, path, oldestOutputFileTime, oldestOutputFileName);
            });
            if (dependentPackageFileStatus)
                return dependentPackageFileStatus;
        }
        if (!force && !state.buildInfoChecked.has(resolvedPath)) {
            state.buildInfoChecked.set(resolvedPath, true);
            var buildInfoPath = ts.getTsBuildInfoEmitOutputFilePath(project.options);
            if (buildInfoPath) {
                var value = state.readFileWithCache(buildInfoPath);
                var buildInfo = value && ts.getBuildInfo(value);
                if (buildInfo && (buildInfo.bundle || buildInfo.program) && buildInfo.version !== ts.version) {
                    return {
                        type: ts.UpToDateStatusType.TsVersionOutputOfDate,
                        version: buildInfo.version
                    };
                }
            }
        }
        if (usesPrepend && pseudoUpToDate) {
            return {
                type: ts.UpToDateStatusType.OutOfDateWithPrepend,
                outOfDateOutputFileName: oldestOutputFileName,
                newerProjectName: upstreamChangedProject
            };
        }
        // Up to date
        return {
            type: pseudoUpToDate ? ts.UpToDateStatusType.UpToDateWithUpstreamTypes : ts.UpToDateStatusType.UpToDate,
            newestDeclarationFileContentChangedTime: newestDeclarationFileContentChangedTime,
            newestInputFileTime: newestInputFileTime,
            newestOutputFileTime: newestOutputFileTime,
            newestInputFileName: newestInputFileName,
            newestOutputFileName: newestOutputFileName,
            oldestOutputFileName: oldestOutputFileName
        };
    }
    function getUpToDateStatus(state, project, resolvedPath) {
        if (project === undefined) {
            return { type: ts.UpToDateStatusType.Unbuildable, reason: "File deleted mid-build" };
        }
        var prior = state.projectStatus.get(resolvedPath);
        if (prior !== undefined) {
            return prior;
        }
        var actual = getUpToDateStatusWorker(state, project, resolvedPath);
        state.projectStatus.set(resolvedPath, actual);
        return actual;
    }
    function updateOutputTimestampsWorker(state, proj, priorNewestUpdateTime, verboseMessage, skipOutputs) {
        if (proj.options.noEmit)
            return priorNewestUpdateTime;
        var host = state.host;
        var outputs = ts.getAllProjectOutputs(proj, !host.useCaseSensitiveFileNames());
        if (!skipOutputs || outputs.length !== skipOutputs.size) {
            var reportVerbose = !!state.options.verbose;
            var now = host.now ? host.now() : new Date();
            for (var _i = 0, outputs_2 = outputs; _i < outputs_2.length; _i++) {
                var file = outputs_2[_i];
                if (skipOutputs && skipOutputs.has(toPath(state, file))) {
                    continue;
                }
                if (reportVerbose) {
                    reportVerbose = false;
                    reportStatus(state, verboseMessage, proj.options.configFilePath);
                }
                if (ts.isDeclarationFileName(file)) {
                    priorNewestUpdateTime = newer(priorNewestUpdateTime, ts.getModifiedTime(host, file));
                }
                host.setModifiedTime(file, now);
            }
        }
        return priorNewestUpdateTime;
    }
    function updateOutputTimestamps(state, proj, resolvedPath) {
        if (state.options.dry) {
            return reportStatus(state, ts.Diagnostics.A_non_dry_build_would_update_timestamps_for_output_of_project_0, proj.options.configFilePath);
        }
        var priorNewestUpdateTime = updateOutputTimestampsWorker(state, proj, minimumDate, ts.Diagnostics.Updating_output_timestamps_of_project_0);
        state.projectStatus.set(resolvedPath, {
            type: ts.UpToDateStatusType.UpToDate,
            newestDeclarationFileContentChangedTime: priorNewestUpdateTime,
            oldestOutputFileName: ts.getFirstProjectOutput(proj, !state.host.useCaseSensitiveFileNames())
        });
    }
    function queueReferencingProjects(state, project, projectPath, projectIndex, config, buildOrder, buildResult) {
        // Queue only if there are no errors
        if (buildResult & BuildResultFlags.AnyErrors)
            return;
        // Only composite projects can be referenced by other projects
        if (!config.options.composite)
            return;
        // Always use build order to queue projects
        for (var index = projectIndex + 1; index < buildOrder.length; index++) {
            var nextProject = buildOrder[index];
            var nextProjectPath = toResolvedConfigFilePath(state, nextProject);
            if (state.projectPendingBuild.has(nextProjectPath))
                continue;
            var nextProjectConfig = parseConfigFile(state, nextProject, nextProjectPath);
            if (!nextProjectConfig || !nextProjectConfig.projectReferences)
                continue;
            for (var _i = 0, _a = nextProjectConfig.projectReferences; _i < _a.length; _i++) {
                var ref = _a[_i];
                var resolvedRefPath = resolveProjectName(state, ref.path);
                if (toResolvedConfigFilePath(state, resolvedRefPath) !== projectPath)
                    continue;
                // If the project is referenced with prepend, always build downstream projects,
                // If declaration output is changed, build the project
                // otherwise mark the project UpToDateWithUpstreamTypes so it updates output time stamps
                var status = state.projectStatus.get(nextProjectPath);
                if (status) {
                    switch (status.type) {
                        case ts.UpToDateStatusType.UpToDate:
                            if (buildResult & BuildResultFlags.DeclarationOutputUnchanged) {
                                if (ref.prepend) {
                                    state.projectStatus.set(nextProjectPath, {
                                        type: ts.UpToDateStatusType.OutOfDateWithPrepend,
                                        outOfDateOutputFileName: status.oldestOutputFileName,
                                        newerProjectName: project
                                    });
                                }
                                else {
                                    status.type = ts.UpToDateStatusType.UpToDateWithUpstreamTypes;
                                }
                                break;
                            }
                        // falls through
                        case ts.UpToDateStatusType.UpToDateWithUpstreamTypes:
                        case ts.UpToDateStatusType.OutOfDateWithPrepend:
                            if (!(buildResult & BuildResultFlags.DeclarationOutputUnchanged)) {
                                state.projectStatus.set(nextProjectPath, {
                                    type: ts.UpToDateStatusType.OutOfDateWithUpstream,
                                    outOfDateOutputFileName: status.type === ts.UpToDateStatusType.OutOfDateWithPrepend ? status.outOfDateOutputFileName : status.oldestOutputFileName,
                                    newerProjectName: project
                                });
                            }
                            break;
                        case ts.UpToDateStatusType.UpstreamBlocked:
                            if (toResolvedConfigFilePath(state, resolveProjectName(state, status.upstreamProjectName)) === projectPath) {
                                clearProjectStatus(state, nextProjectPath);
                            }
                            break;
                    }
                }
                addProjToQueue(state, nextProjectPath, ts.ConfigFileProgramReloadLevel.None);
                break;
            }
        }
    }
    function build(state, project, cancellationToken, writeFile, getCustomTransformers, onlyReferences) {
        var buildOrder = getBuildOrderFor(state, project, onlyReferences);
        if (!buildOrder)
            return ts.ExitStatus.InvalidProject_OutputsSkipped;
        setupInitialBuild(state, cancellationToken);
        var reportQueue = true;
        var successfulProjects = 0;
        while (true) {
            var invalidatedProject = getNextInvalidatedProject(state, buildOrder, reportQueue);
            if (!invalidatedProject)
                break;
            reportQueue = false;
            invalidatedProject.done(cancellationToken, writeFile, getCustomTransformers === null || getCustomTransformers === void 0 ? void 0 : getCustomTransformers(invalidatedProject.project));
            if (!state.diagnostics.has(invalidatedProject.projectPath))
                successfulProjects++;
        }
        disableCache(state);
        reportErrorSummary(state, buildOrder);
        startWatching(state, buildOrder);
        return isCircularBuildOrder(buildOrder)
            ? ts.ExitStatus.ProjectReferenceCycle_OutputsSkipped
            : !buildOrder.some(function (p) { return state.diagnostics.has(toResolvedConfigFilePath(state, p)); })
                ? ts.ExitStatus.Success
                : successfulProjects
                    ? ts.ExitStatus.DiagnosticsPresent_OutputsGenerated
                    : ts.ExitStatus.DiagnosticsPresent_OutputsSkipped;
    }
    function clean(state, project, onlyReferences) {
        var buildOrder = getBuildOrderFor(state, project, onlyReferences);
        if (!buildOrder)
            return ts.ExitStatus.InvalidProject_OutputsSkipped;
        if (isCircularBuildOrder(buildOrder)) {
            reportErrors(state, buildOrder.circularDiagnostics);
            return ts.ExitStatus.ProjectReferenceCycle_OutputsSkipped;
        }
        var options = state.options, host = state.host;
        var filesToDelete = options.dry ? [] : undefined;
        for (var _i = 0, buildOrder_1 = buildOrder; _i < buildOrder_1.length; _i++) {
            var proj = buildOrder_1[_i];
            var resolvedPath = toResolvedConfigFilePath(state, proj);
            var parsed = parseConfigFile(state, proj, resolvedPath);
            if (parsed === undefined) {
                // File has gone missing; fine to ignore here
                reportParseConfigFileDiagnostic(state, resolvedPath);
                continue;
            }
            var outputs = ts.getAllProjectOutputs(parsed, !host.useCaseSensitiveFileNames());
            if (!outputs.length)
                continue;
            var inputFileNames = new ts.Set(parsed.fileNames.map(function (f) { return toPath(state, f); }));
            for (var _a = 0, outputs_3 = outputs; _a < outputs_3.length; _a++) {
                var output = outputs_3[_a];
                // If output name is same as input file name, do not delete and ignore the error
                if (inputFileNames.has(toPath(state, output)))
                    continue;
                if (host.fileExists(output)) {
                    if (filesToDelete) {
                        filesToDelete.push(output);
                    }
                    else {
                        host.deleteFile(output);
                        invalidateProject(state, resolvedPath, ts.ConfigFileProgramReloadLevel.None);
                    }
                }
            }
        }
        if (filesToDelete) {
            reportStatus(state, ts.Diagnostics.A_non_dry_build_would_delete_the_following_files_Colon_0, filesToDelete.map(function (f) { return "\r\n * ".concat(f); }).join(""));
        }
        return ts.ExitStatus.Success;
    }
    function invalidateProject(state, resolved, reloadLevel) {
        // If host implements getParsedCommandLine, we cant get list of files from parseConfigFileHost
        if (state.host.getParsedCommandLine && reloadLevel === ts.ConfigFileProgramReloadLevel.Partial) {
            reloadLevel = ts.ConfigFileProgramReloadLevel.Full;
        }
        if (reloadLevel === ts.ConfigFileProgramReloadLevel.Full) {
            state.configFileCache.delete(resolved);
            state.buildOrder = undefined;
        }
        state.needsSummary = true;
        clearProjectStatus(state, resolved);
        addProjToQueue(state, resolved, reloadLevel);
        enableCache(state);
    }
    function invalidateProjectAndScheduleBuilds(state, resolvedPath, reloadLevel) {
        state.reportFileChangeDetected = true;
        invalidateProject(state, resolvedPath, reloadLevel);
        scheduleBuildInvalidatedProject(state);
    }
    function scheduleBuildInvalidatedProject(state) {
        var hostWithWatch = state.hostWithWatch;
        if (!hostWithWatch.setTimeout || !hostWithWatch.clearTimeout) {
            return;
        }
        if (state.timerToBuildInvalidatedProject) {
            hostWithWatch.clearTimeout(state.timerToBuildInvalidatedProject);
        }
        state.timerToBuildInvalidatedProject = hostWithWatch.setTimeout(buildNextInvalidatedProject, 250, state);
    }
    function buildNextInvalidatedProject(state) {
        state.timerToBuildInvalidatedProject = undefined;
        if (state.reportFileChangeDetected) {
            state.reportFileChangeDetected = false;
            state.projectErrorsReported.clear();
            reportWatchStatus(state, ts.Diagnostics.File_change_detected_Starting_incremental_compilation);
        }
        var buildOrder = getBuildOrder(state);
        var invalidatedProject = getNextInvalidatedProject(state, buildOrder, /*reportQueue*/ false);
        if (invalidatedProject) {
            invalidatedProject.done();
            if (state.projectPendingBuild.size) {
                // Schedule next project for build
                if (state.watch && !state.timerToBuildInvalidatedProject) {
                    scheduleBuildInvalidatedProject(state);
                }
                return;
            }
        }
        disableCache(state);
        reportErrorSummary(state, buildOrder);
    }
    function watchConfigFile(state, resolved, resolvedPath, parsed) {
        if (!state.watch || state.allWatchedConfigFiles.has(resolvedPath))
            return;
        state.allWatchedConfigFiles.set(resolvedPath, state.watchFile(resolved, function () {
            invalidateProjectAndScheduleBuilds(state, resolvedPath, ts.ConfigFileProgramReloadLevel.Full);
        }, ts.PollingInterval.High, parsed === null || parsed === void 0 ? void 0 : parsed.watchOptions, ts.WatchType.ConfigFile, resolved));
    }
    function watchExtendedConfigFiles(state, resolvedPath, parsed) {
        ts.updateSharedExtendedConfigFileWatcher(resolvedPath, parsed === null || parsed === void 0 ? void 0 : parsed.options, state.allWatchedExtendedConfigFiles, function (extendedConfigFileName, extendedConfigFilePath) { return state.watchFile(extendedConfigFileName, function () {
            var _a;
            return (_a = state.allWatchedExtendedConfigFiles.get(extendedConfigFilePath)) === null || _a === void 0 ? void 0 : _a.projects.forEach(function (projectConfigFilePath) {
                return invalidateProjectAndScheduleBuilds(state, projectConfigFilePath, ts.ConfigFileProgramReloadLevel.Full);
            });
        }, ts.PollingInterval.High, parsed === null || parsed === void 0 ? void 0 : parsed.watchOptions, ts.WatchType.ExtendedConfigFile); }, function (fileName) { return toPath(state, fileName); });
    }
    function watchWildCardDirectories(state, resolved, resolvedPath, parsed) {
        if (!state.watch)
            return;
        ts.updateWatchingWildcardDirectories(getOrCreateValueMapFromConfigFileMap(state.allWatchedWildcardDirectories, resolvedPath), new ts.Map(ts.getEntries(parsed.wildcardDirectories)), function (dir, flags) { return state.watchDirectory(dir, function (fileOrDirectory) {
            var _a;
            if (ts.isIgnoredFileFromWildCardWatching({
                watchedDirPath: toPath(state, dir),
                fileOrDirectory: fileOrDirectory,
                fileOrDirectoryPath: toPath(state, fileOrDirectory),
                configFileName: resolved,
                currentDirectory: state.currentDirectory,
                options: parsed.options,
                program: state.builderPrograms.get(resolvedPath) || ((_a = getCachedParsedConfigFile(state, resolvedPath)) === null || _a === void 0 ? void 0 : _a.fileNames),
                useCaseSensitiveFileNames: state.parseConfigFileHost.useCaseSensitiveFileNames,
                writeLog: function (s) { return state.writeLog(s); },
                toPath: function (fileName) { return toPath(state, fileName); }
            }))
                return;
            invalidateProjectAndScheduleBuilds(state, resolvedPath, ts.ConfigFileProgramReloadLevel.Partial);
        }, flags, parsed === null || parsed === void 0 ? void 0 : parsed.watchOptions, ts.WatchType.WildcardDirectory, resolved); });
    }
    function watchInputFiles(state, resolved, resolvedPath, parsed) {
        if (!state.watch)
            return;
        ts.mutateMap(getOrCreateValueMapFromConfigFileMap(state.allWatchedInputFiles, resolvedPath), ts.arrayToMap(parsed.fileNames, function (fileName) { return toPath(state, fileName); }), {
            createNewValue: function (_path, input) { return state.watchFile(input, function () { return invalidateProjectAndScheduleBuilds(state, resolvedPath, ts.ConfigFileProgramReloadLevel.None); }, ts.PollingInterval.Low, parsed === null || parsed === void 0 ? void 0 : parsed.watchOptions, ts.WatchType.SourceFile, resolved); },
            onDeleteValue: ts.closeFileWatcher,
        });
    }
    function watchPackageJsonFiles(state, resolved, resolvedPath, parsed) {
        if (!state.watch || !state.lastCachedPackageJsonLookups)
            return;
        ts.mutateMap(getOrCreateValueMapFromConfigFileMap(state.allWatchedPackageJsonFiles, resolvedPath), new ts.Map(state.lastCachedPackageJsonLookups.get(resolvedPath)), {
            createNewValue: function (path, _input) { return state.watchFile(path, function () { return invalidateProjectAndScheduleBuilds(state, resolvedPath, ts.ConfigFileProgramReloadLevel.None); }, ts.PollingInterval.High, parsed === null || parsed === void 0 ? void 0 : parsed.watchOptions, ts.WatchType.PackageJson, resolved); },
            onDeleteValue: ts.closeFileWatcher,
        });
    }
    function startWatching(state, buildOrder) {
        if (!state.watchAllProjectsPending)
            return;
        state.watchAllProjectsPending = false;
        for (var _i = 0, _a = getBuildOrderFromAnyBuildOrder(buildOrder); _i < _a.length; _i++) {
            var resolved = _a[_i];
            var resolvedPath = toResolvedConfigFilePath(state, resolved);
            var cfg = parseConfigFile(state, resolved, resolvedPath);
            // Watch this file
            watchConfigFile(state, resolved, resolvedPath, cfg);
            watchExtendedConfigFiles(state, resolvedPath, cfg);
            if (cfg) {
                // Update watchers for wildcard directories
                watchWildCardDirectories(state, resolved, resolvedPath, cfg);
                // Watch input files
                watchInputFiles(state, resolved, resolvedPath, cfg);
                // Watch package json files
                watchPackageJsonFiles(state, resolved, resolvedPath, cfg);
            }
        }
    }
    function stopWatching(state) {
        ts.clearMap(state.allWatchedConfigFiles, ts.closeFileWatcher);
        ts.clearMap(state.allWatchedExtendedConfigFiles, ts.closeFileWatcherOf);
        ts.clearMap(state.allWatchedWildcardDirectories, function (watchedWildcardDirectories) { return ts.clearMap(watchedWildcardDirectories, ts.closeFileWatcherOf); });
        ts.clearMap(state.allWatchedInputFiles, function (watchedWildcardDirectories) { return ts.clearMap(watchedWildcardDirectories, ts.closeFileWatcher); });
        ts.clearMap(state.allWatchedPackageJsonFiles, function (watchedPacageJsonFiles) { return ts.clearMap(watchedPacageJsonFiles, ts.closeFileWatcher); });
    }
    function createSolutionBuilderWorker(watch, hostOrHostWithWatch, rootNames, options, baseWatchOptions) {
        var state = createSolutionBuilderState(watch, hostOrHostWithWatch, rootNames, options, baseWatchOptions);
        return {
            build: function (project, cancellationToken, writeFile, getCustomTransformers) { return build(state, project, cancellationToken, writeFile, getCustomTransformers); },
            clean: function (project) { return clean(state, project); },
            buildReferences: function (project, cancellationToken, writeFile, getCustomTransformers) { return build(state, project, cancellationToken, writeFile, getCustomTransformers, /*onlyReferences*/ true); },
            cleanReferences: function (project) { return clean(state, project, /*onlyReferences*/ true); },
            getNextInvalidatedProject: function (cancellationToken) {
                setupInitialBuild(state, cancellationToken);
                return getNextInvalidatedProject(state, getBuildOrder(state), /*reportQueue*/ false);
            },
            getBuildOrder: function () { return getBuildOrder(state); },
            getUpToDateStatusOfProject: function (project) {
                var configFileName = resolveProjectName(state, project);
                var configFilePath = toResolvedConfigFilePath(state, configFileName);
                return getUpToDateStatus(state, parseConfigFile(state, configFileName, configFilePath), configFilePath);
            },
            invalidateProject: function (configFilePath, reloadLevel) { return invalidateProject(state, configFilePath, reloadLevel || ts.ConfigFileProgramReloadLevel.None); },
            buildNextInvalidatedProject: function () { return buildNextInvalidatedProject(state); },
            getAllParsedConfigs: function () { return ts.arrayFrom(ts.mapDefinedIterator(state.configFileCache.values(), function (config) { return isParsedCommandLine(config) ? config : undefined; })); },
            close: function () { return stopWatching(state); },
        };
    }
    function relName(state, path) {
        return ts.convertToRelativePath(path, state.currentDirectory, function (f) { return state.getCanonicalFileName(f); });
    }
    function reportStatus(state, message) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        state.host.reportSolutionBuilderStatus(ts.createCompilerDiagnostic.apply(void 0, __spreadArray([message], args, false)));
    }
    function reportWatchStatus(state, message) {
        var _a, _b;
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        (_b = (_a = state.hostWithWatch).onWatchStatusChange) === null || _b === void 0 ? void 0 : _b.call(_a, ts.createCompilerDiagnostic.apply(void 0, __spreadArray([message], args, false)), state.host.getNewLine(), state.baseCompilerOptions);
    }
    function reportErrors(_a, errors) {
        var host = _a.host;
        errors.forEach(function (err) { return host.reportDiagnostic(err); });
    }
    function reportAndStoreErrors(state, proj, errors) {
        reportErrors(state, errors);
        state.projectErrorsReported.set(proj, true);
        if (errors.length) {
            state.diagnostics.set(proj, errors);
        }
    }
    function reportParseConfigFileDiagnostic(state, proj) {
        reportAndStoreErrors(state, proj, [state.configFileCache.get(proj)]);
    }
    function reportErrorSummary(state, buildOrder) {
        if (!state.needsSummary)
            return;
        state.needsSummary = false;
        var canReportSummary = state.watch || !!state.host.reportErrorSummary;
        var diagnostics = state.diagnostics;
        var totalErrors = 0;
        var filesInError = [];
        if (isCircularBuildOrder(buildOrder)) {
            reportBuildQueue(state, buildOrder.buildOrder);
            reportErrors(state, buildOrder.circularDiagnostics);
            if (canReportSummary)
                totalErrors += ts.getErrorCountForSummary(buildOrder.circularDiagnostics);
            if (canReportSummary)
                filesInError = __spreadArray(__spreadArray([], filesInError, true), ts.getFilesInErrorForSummary(buildOrder.circularDiagnostics), true);
        }
        else {
            // Report errors from the other projects
            buildOrder.forEach(function (project) {
                var projectPath = toResolvedConfigFilePath(state, project);
                if (!state.projectErrorsReported.has(projectPath)) {
                    reportErrors(state, diagnostics.get(projectPath) || ts.emptyArray);
                }
            });
            if (canReportSummary)
                diagnostics.forEach(function (singleProjectErrors) { return totalErrors += ts.getErrorCountForSummary(singleProjectErrors); });
            if (canReportSummary)
                diagnostics.forEach(function (singleProjectErrors) { return __spreadArray(__spreadArray([], filesInError, true), ts.getFilesInErrorForSummary(singleProjectErrors), true); });
        }
        if (state.watch) {
            reportWatchStatus(state, ts.getWatchErrorSummaryDiagnosticMessage(totalErrors), totalErrors);
        }
        else if (state.host.reportErrorSummary) {
            state.host.reportErrorSummary(totalErrors, filesInError);
        }
    }
    /**
     * Report the build ordering inferred from the current project graph if we're in verbose mode
     */
    function reportBuildQueue(state, buildQueue) {
        if (state.options.verbose) {
            reportStatus(state, ts.Diagnostics.Projects_in_this_build_Colon_0, buildQueue.map(function (s) { return "\r\n    * " + relName(state, s); }).join(""));
        }
    }
    function reportUpToDateStatus(state, configFileName, status) {
        if (state.options.force && (status.type === ts.UpToDateStatusType.UpToDate || status.type === ts.UpToDateStatusType.UpToDateWithUpstreamTypes)) {
            return reportStatus(state, ts.Diagnostics.Project_0_is_being_forcibly_rebuilt, relName(state, configFileName));
        }
        switch (status.type) {
            case ts.UpToDateStatusType.OutOfDateWithSelf:
                return reportStatus(state, ts.Diagnostics.Project_0_is_out_of_date_because_oldest_output_1_is_older_than_newest_input_2, relName(state, configFileName), relName(state, status.outOfDateOutputFileName), relName(state, status.newerInputFileName));
            case ts.UpToDateStatusType.OutOfDateWithUpstream:
                return reportStatus(state, ts.Diagnostics.Project_0_is_out_of_date_because_oldest_output_1_is_older_than_newest_input_2, relName(state, configFileName), relName(state, status.outOfDateOutputFileName), relName(state, status.newerProjectName));
            case ts.UpToDateStatusType.OutputMissing:
                return reportStatus(state, ts.Diagnostics.Project_0_is_out_of_date_because_output_file_1_does_not_exist, relName(state, configFileName), relName(state, status.missingOutputFileName));
            case ts.UpToDateStatusType.UpToDate:
                if (status.newestInputFileTime !== undefined) {
                    return reportStatus(state, ts.Diagnostics.Project_0_is_up_to_date_because_newest_input_1_is_older_than_oldest_output_2, relName(state, configFileName), relName(state, status.newestInputFileName || ""), relName(state, status.oldestOutputFileName || ""));
                }
                // Don't report anything for "up to date because it was already built" -- too verbose
                break;
            case ts.UpToDateStatusType.OutOfDateWithPrepend:
                return reportStatus(state, ts.Diagnostics.Project_0_is_out_of_date_because_output_of_its_dependency_1_has_changed, relName(state, configFileName), relName(state, status.newerProjectName));
            case ts.UpToDateStatusType.UpToDateWithUpstreamTypes:
                return reportStatus(state, ts.Diagnostics.Project_0_is_up_to_date_with_d_ts_files_from_its_dependencies, relName(state, configFileName));
            case ts.UpToDateStatusType.UpstreamOutOfDate:
                return reportStatus(state, ts.Diagnostics.Project_0_is_out_of_date_because_its_dependency_1_is_out_of_date, relName(state, configFileName), relName(state, status.upstreamProjectName));
            case ts.UpToDateStatusType.UpstreamBlocked:
                return reportStatus(state, status.upstreamProjectBlocked ?
                    ts.Diagnostics.Project_0_can_t_be_built_because_its_dependency_1_was_not_built :
                    ts.Diagnostics.Project_0_can_t_be_built_because_its_dependency_1_has_errors, relName(state, configFileName), relName(state, status.upstreamProjectName));
            case ts.UpToDateStatusType.Unbuildable:
                return reportStatus(state, ts.Diagnostics.Failed_to_parse_file_0_Colon_1, relName(state, configFileName), status.reason);
            case ts.UpToDateStatusType.TsVersionOutputOfDate:
                return reportStatus(state, ts.Diagnostics.Project_0_is_out_of_date_because_output_for_it_was_generated_with_version_1_that_differs_with_current_version_2, relName(state, configFileName), status.version, ts.version);
            case ts.UpToDateStatusType.ContainerOnly:
            // Don't report status on "solution" projects
            // falls through
            case ts.UpToDateStatusType.ComputingUpstream:
                // Should never leak from getUptoDateStatusWorker
                break;
            default:
                ts.assertType(status);
        }
    }
    /**
     * Report the up-to-date status of a project if we're in verbose mode
     */
    function verboseReportProjectStatus(state, configFileName, status) {
        if (state.options.verbose) {
            reportUpToDateStatus(state, configFileName, status);
        }
    }
})(ts || (ts = {}));
var ts;
(function (ts) {
    var server;
    (function (server) {
        /* @internal */
        server.ActionSet = "action::set";
        /* @internal */
        server.ActionInvalidate = "action::invalidate";
        /* @internal */
        server.ActionPackageInstalled = "action::packageInstalled";
        /* @internal */
        server.EventTypesRegistry = "event::typesRegistry";
        /* @internal */
        server.EventBeginInstallTypes = "event::beginInstallTypes";
        /* @internal */
        server.EventEndInstallTypes = "event::endInstallTypes";
        /* @internal */
        server.EventInitializationFailed = "event::initializationFailed";
        /* @internal */
        var Arguments;
        (function (Arguments) {
            Arguments.GlobalCacheLocation = "--globalTypingsCacheLocation";
            Arguments.LogFile = "--logFile";
            Arguments.EnableTelemetry = "--enableTelemetry";
            Arguments.TypingSafeListLocation = "--typingSafeListLocation";
            Arguments.TypesMapLocation = "--typesMapLocation";
            /**
             * This argument specifies the location of the NPM executable.
             * typingsInstaller will run the command with `${npmLocation} install ...`.
             */
            Arguments.NpmLocation = "--npmLocation";
            /**
             * Flag indicating that the typings installer should try to validate the default npm location.
             * If the default npm is not found when this flag is enabled, fallback to `npm install`
             */
            Arguments.ValidateDefaultNpmLocation = "--validateDefaultNpmLocation";
        })(Arguments = server.Arguments || (server.Arguments = {}));
        /* @internal */
        function hasArgument(argumentName) {
            return ts.sys.args.indexOf(argumentName) >= 0;
        }
        server.hasArgument = hasArgument;
        /* @internal */
        function findArgument(argumentName) {
            var index = ts.sys.args.indexOf(argumentName);
            return index >= 0 && index < ts.sys.args.length - 1
                ? ts.sys.args[index + 1]
                : undefined;
        }
        server.findArgument = findArgument;
        /* @internal */
        function nowString() {
            // E.g. "12:34:56.789"
            var d = new Date();
            return "".concat(ts.padLeft(d.getHours().toString(), 2, "0"), ":").concat(ts.padLeft(d.getMinutes().toString(), 2, "0"), ":").concat(ts.padLeft(d.getSeconds().toString(), 2, "0"), ".").concat(ts.padLeft(d.getMilliseconds().toString(), 3, "0"));
        }
        server.nowString = nowString;
    })(server = ts.server || (ts.server = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var JsTyping;
    (function (JsTyping) {
        function isTypingUpToDate(cachedTyping, availableTypingVersions) {
            var availableVersion = new ts.Version(ts.getProperty(availableTypingVersions, "ts".concat(ts.versionMajorMinor)) || ts.getProperty(availableTypingVersions, "latest"));
            return availableVersion.compareTo(cachedTyping.version) <= 0;
        }
        JsTyping.isTypingUpToDate = isTypingUpToDate;
        var unprefixedNodeCoreModuleList = [
            "assert",
            "assert/strict",
            "async_hooks",
            "buffer",
            "child_process",
            "cluster",
            "console",
            "constants",
            "crypto",
            "dgram",
            "diagnostics_channel",
            "dns",
            "dns/promises",
            "domain",
            "events",
            "fs",
            "fs/promises",
            "http",
            "https",
            "http2",
            "inspector",
            "module",
            "net",
            "os",
            "path",
            "perf_hooks",
            "process",
            "punycode",
            "querystring",
            "readline",
            "repl",
            "stream",
            "stream/promises",
            "string_decoder",
            "timers",
            "timers/promises",
            "tls",
            "trace_events",
            "tty",
            "url",
            "util",
            "util/types",
            "v8",
            "vm",
            "wasi",
            "worker_threads",
            "zlib"
        ];
        JsTyping.prefixedNodeCoreModuleList = unprefixedNodeCoreModuleList.map(function (name) { return "node:".concat(name); });
        JsTyping.nodeCoreModuleList = __spreadArray(__spreadArray([], unprefixedNodeCoreModuleList, true), JsTyping.prefixedNodeCoreModuleList, true);
        JsTyping.nodeCoreModules = new ts.Set(JsTyping.nodeCoreModuleList);
        function nonRelativeModuleNameForTypingCache(moduleName) {
            return JsTyping.nodeCoreModules.has(moduleName) ? "node" : moduleName;
        }
        JsTyping.nonRelativeModuleNameForTypingCache = nonRelativeModuleNameForTypingCache;
        function loadSafeList(host, safeListPath) {
            var result = ts.readConfigFile(safeListPath, function (path) { return host.readFile(path); });
            return new ts.Map(ts.getEntries(result.config));
        }
        JsTyping.loadSafeList = loadSafeList;
        function loadTypesMap(host, typesMapPath) {
            var result = ts.readConfigFile(typesMapPath, function (path) { return host.readFile(path); });
            if (result.config) {
                return new ts.Map(ts.getEntries(result.config.simpleMap));
            }
            return undefined;
        }
        JsTyping.loadTypesMap = loadTypesMap;
        /**
         * @param host is the object providing I/O related operations.
         * @param fileNames are the file names that belong to the same project
         * @param projectRootPath is the path to the project root directory
         * @param safeListPath is the path used to retrieve the safe list
         * @param packageNameToTypingLocation is the map of package names to their cached typing locations and installed versions
         * @param typeAcquisition is used to customize the typing acquisition process
         * @param compilerOptions are used as a source for typing inference
         */
        function discoverTypings(host, log, fileNames, projectRootPath, safeList, packageNameToTypingLocation, typeAcquisition, unresolvedImports, typesRegistry) {
            if (!typeAcquisition || !typeAcquisition.enable) {
                return { cachedTypingPaths: [], newTypingNames: [], filesToWatch: [] };
            }
            // A typing name to typing file path mapping
            var inferredTypings = new ts.Map();
            // Only infer typings for .js and .jsx files
            fileNames = ts.mapDefined(fileNames, function (fileName) {
                var path = ts.normalizePath(fileName);
                if (ts.hasJSFileExtension(path)) {
                    return path;
                }
            });
            var filesToWatch = [];
            if (typeAcquisition.include)
                addInferredTypings(typeAcquisition.include, "Explicitly included types");
            var exclude = typeAcquisition.exclude || [];
            // Directories to search for package.json, bower.json and other typing information
            var possibleSearchDirs = new ts.Set(fileNames.map(ts.getDirectoryPath));
            possibleSearchDirs.add(projectRootPath);
            possibleSearchDirs.forEach(function (searchDir) {
                getTypingNames(searchDir, "bower.json", "bower_components", filesToWatch);
                getTypingNames(searchDir, "package.json", "node_modules", filesToWatch);
            });
            if (!typeAcquisition.disableFilenameBasedTypeAcquisition) {
                getTypingNamesFromSourceFileNames(fileNames);
            }
            // add typings for unresolved imports
            if (unresolvedImports) {
                var module_1 = ts.deduplicate(unresolvedImports.map(nonRelativeModuleNameForTypingCache), ts.equateStringsCaseSensitive, ts.compareStringsCaseSensitive);
                addInferredTypings(module_1, "Inferred typings from unresolved imports");
            }
            // Add the cached typing locations for inferred typings that are already installed
            packageNameToTypingLocation.forEach(function (typing, name) {
                var registryEntry = typesRegistry.get(name);
                if (inferredTypings.has(name) && inferredTypings.get(name) === undefined && registryEntry !== undefined && isTypingUpToDate(typing, registryEntry)) {
                    inferredTypings.set(name, typing.typingLocation);
                }
            });
            // Remove typings that the user has added to the exclude list
            for (var _i = 0, exclude_1 = exclude; _i < exclude_1.length; _i++) {
                var excludeTypingName = exclude_1[_i];
                var didDelete = inferredTypings.delete(excludeTypingName);
                if (didDelete && log)
                    log("Typing for ".concat(excludeTypingName, " is in exclude list, will be ignored."));
            }
            var newTypingNames = [];
            var cachedTypingPaths = [];
            inferredTypings.forEach(function (inferred, typing) {
                if (inferred !== undefined) {
                    cachedTypingPaths.push(inferred);
                }
                else {
                    newTypingNames.push(typing);
                }
            });
            var result = { cachedTypingPaths: cachedTypingPaths, newTypingNames: newTypingNames, filesToWatch: filesToWatch };
            if (log)
                log("Result: ".concat(JSON.stringify(result)));
            return result;
            function addInferredTyping(typingName) {
                if (!inferredTypings.has(typingName)) {
                    inferredTypings.set(typingName, undefined); // TODO: GH#18217
                }
            }
            function addInferredTypings(typingNames, message) {
                if (log)
                    log("".concat(message, ": ").concat(JSON.stringify(typingNames)));
                ts.forEach(typingNames, addInferredTyping);
            }
            /**
             * Adds inferred typings from manifest/module pairs (think package.json + node_modules)
             *
             * @param projectRootPath is the path to the directory where to look for package.json, bower.json and other typing information
             * @param manifestName is the name of the manifest (package.json or bower.json)
             * @param modulesDirName is the directory name for modules (node_modules or bower_components). Should be lowercase!
             * @param filesToWatch are the files to watch for changes. We will push things into this array.
             */
            function getTypingNames(projectRootPath, manifestName, modulesDirName, filesToWatch) {
                // First, we check the manifests themselves. They're not
                // _required_, but they allow us to do some filtering when dealing
                // with big flat dep directories.
                var manifestPath = ts.combinePaths(projectRootPath, manifestName);
                var manifest;
                var manifestTypingNames;
                if (host.fileExists(manifestPath)) {
                    filesToWatch.push(manifestPath);
                    manifest = ts.readConfigFile(manifestPath, function (path) { return host.readFile(path); }).config;
                    manifestTypingNames = ts.flatMap([manifest.dependencies, manifest.devDependencies, manifest.optionalDependencies, manifest.peerDependencies], ts.getOwnKeys);
                    addInferredTypings(manifestTypingNames, "Typing names in '".concat(manifestPath, "' dependencies"));
                }
                // Now we scan the directories for typing information in
                // already-installed dependencies (if present). Note that this
                // step happens regardless of whether a manifest was present,
                // which is certainly a valid configuration, if an unusual one.
                var packagesFolderPath = ts.combinePaths(projectRootPath, modulesDirName);
                filesToWatch.push(packagesFolderPath);
                if (!host.directoryExists(packagesFolderPath)) {
                    return;
                }
                // There's two cases we have to take into account here:
                // 1. If manifest is undefined, then we're not using a manifest.
                //    That means that we should scan _all_ dependencies at the top
                //    level of the modulesDir.
                // 2. If manifest is defined, then we can do some special
                //    filtering to reduce the amount of scanning we need to do.
                //
                // Previous versions of this algorithm checked for a `_requiredBy`
                // field in the package.json, but that field is only present in
                // `npm@>=3 <7`.
                // Package names that do **not** provide their own typings, so
                // we'll look them up.
                var packageNames = [];
                var dependencyManifestNames = manifestTypingNames
                    // This is #1 described above.
                    ? manifestTypingNames.map(function (typingName) { return ts.combinePaths(packagesFolderPath, typingName, manifestName); })
                    // And #2. Depth = 3 because scoped packages look like `node_modules/@foo/bar/package.json`
                    : host.readDirectory(packagesFolderPath, [".json" /* Extension.Json */], /*excludes*/ undefined, /*includes*/ undefined, /*depth*/ 3)
                        .filter(function (manifestPath) {
                        if (ts.getBaseFileName(manifestPath) !== manifestName) {
                            return false;
                        }
                        // It's ok to treat
                        // `node_modules/@foo/bar/package.json` as a manifest,
                        // but not `node_modules/jquery/nested/package.json`.
                        // We only assume depth 3 is ok for formally scoped
                        // packages. So that needs this dance here.
                        var pathComponents = ts.getPathComponents(ts.normalizePath(manifestPath));
                        var isScoped = pathComponents[pathComponents.length - 3][0] === "@";
                        return isScoped && pathComponents[pathComponents.length - 4].toLowerCase() === modulesDirName || // `node_modules/@foo/bar`
                            !isScoped && pathComponents[pathComponents.length - 3].toLowerCase() === modulesDirName; // `node_modules/foo`
                    });
                if (log)
                    log("Searching for typing names in ".concat(packagesFolderPath, "; all files: ").concat(JSON.stringify(dependencyManifestNames)));
                // Once we have the names of things to look up, we iterate over
                // and either collect their included typings, or add them to the
                // list of typings we need to look up separately.
                for (var _i = 0, dependencyManifestNames_1 = dependencyManifestNames; _i < dependencyManifestNames_1.length; _i++) {
                    var manifestPath_1 = dependencyManifestNames_1[_i];
                    var normalizedFileName = ts.normalizePath(manifestPath_1);
                    var result_1 = ts.readConfigFile(normalizedFileName, function (path) { return host.readFile(path); });
                    var manifest_1 = result_1.config;
                    // If the package has its own d.ts typings, those will take precedence. Otherwise the package name will be used
                    // to download d.ts files from DefinitelyTyped
                    if (!manifest_1.name) {
                        continue;
                    }
                    var ownTypes = manifest_1.types || manifest_1.typings;
                    if (ownTypes) {
                        var absolutePath = ts.getNormalizedAbsolutePath(ownTypes, ts.getDirectoryPath(normalizedFileName));
                        if (host.fileExists(absolutePath)) {
                            if (log)
                                log("    Package '".concat(manifest_1.name, "' provides its own types."));
                            inferredTypings.set(manifest_1.name, absolutePath);
                        }
                        else {
                            if (log)
                                log("    Package '".concat(manifest_1.name, "' provides its own types but they are missing."));
                        }
                    }
                    else {
                        packageNames.push(manifest_1.name);
                    }
                }
                addInferredTypings(packageNames, "    Found package names");
            }
            /**
             * Infer typing names from given file names. For example, the file name "jquery-min.2.3.4.js"
             * should be inferred to the 'jquery' typing name; and "angular-route.1.2.3.js" should be inferred
             * to the 'angular-route' typing name.
             * @param fileNames are the names for source files in the project
             */
            function getTypingNamesFromSourceFileNames(fileNames) {
                var fromFileNames = ts.mapDefined(fileNames, function (j) {
                    if (!ts.hasJSFileExtension(j))
                        return undefined;
                    var inferredTypingName = ts.removeFileExtension(ts.getBaseFileName(j.toLowerCase()));
                    var cleanedTypingName = ts.removeMinAndVersionNumbers(inferredTypingName);
                    return safeList.get(cleanedTypingName);
                });
                if (fromFileNames.length) {
                    addInferredTypings(fromFileNames, "Inferred typings from file names");
                }
                var hasJsxFile = ts.some(fileNames, function (f) { return ts.fileExtensionIs(f, ".jsx" /* Extension.Jsx */); });
                if (hasJsxFile) {
                    if (log)
                        log("Inferred 'react' typings due to presence of '.jsx' extension");
                    addInferredTyping("react");
                }
            }
        }
        JsTyping.discoverTypings = discoverTypings;
        var NameValidationResult;
        (function (NameValidationResult) {
            NameValidationResult[NameValidationResult["Ok"] = 0] = "Ok";
            NameValidationResult[NameValidationResult["EmptyName"] = 1] = "EmptyName";
            NameValidationResult[NameValidationResult["NameTooLong"] = 2] = "NameTooLong";
            NameValidationResult[NameValidationResult["NameStartsWithDot"] = 3] = "NameStartsWithDot";
            NameValidationResult[NameValidationResult["NameStartsWithUnderscore"] = 4] = "NameStartsWithUnderscore";
            NameValidationResult[NameValidationResult["NameContainsNonURISafeCharacters"] = 5] = "NameContainsNonURISafeCharacters";
        })(NameValidationResult = JsTyping.NameValidationResult || (JsTyping.NameValidationResult = {}));
        var maxPackageNameLength = 214;
        /**
         * Validates package name using rules defined at https://docs.npmjs.com/files/package.json
         */
        function validatePackageName(packageName) {
            return validatePackageNameWorker(packageName, /*supportScopedPackage*/ true);
        }
        JsTyping.validatePackageName = validatePackageName;
        function validatePackageNameWorker(packageName, supportScopedPackage) {
            if (!packageName) {
                return 1 /* NameValidationResult.EmptyName */;
            }
            if (packageName.length > maxPackageNameLength) {
                return 2 /* NameValidationResult.NameTooLong */;
            }
            if (packageName.charCodeAt(0) === 46 /* CharacterCodes.dot */) {
                return 3 /* NameValidationResult.NameStartsWithDot */;
            }
            if (packageName.charCodeAt(0) === 95 /* CharacterCodes._ */) {
                return 4 /* NameValidationResult.NameStartsWithUnderscore */;
            }
            // check if name is scope package like: starts with @ and has one '/' in the middle
            // scoped packages are not currently supported
            if (supportScopedPackage) {
                var matches = /^@([^/]+)\/([^/]+)$/.exec(packageName);
                if (matches) {
                    var scopeResult = validatePackageNameWorker(matches[1], /*supportScopedPackage*/ false);
                    if (scopeResult !== 0 /* NameValidationResult.Ok */) {
                        return { name: matches[1], isScopeName: true, result: scopeResult };
                    }
                    var packageResult = validatePackageNameWorker(matches[2], /*supportScopedPackage*/ false);
                    if (packageResult !== 0 /* NameValidationResult.Ok */) {
                        return { name: matches[2], isScopeName: false, result: packageResult };
                    }
                    return 0 /* NameValidationResult.Ok */;
                }
            }
            if (encodeURIComponent(packageName) !== packageName) {
                return 5 /* NameValidationResult.NameContainsNonURISafeCharacters */;
            }
            return 0 /* NameValidationResult.Ok */;
        }
        function renderPackageNameValidationFailure(result, typing) {
            return typeof result === "object" ?
                renderPackageNameValidationFailureWorker(typing, result.result, result.name, result.isScopeName) :
                renderPackageNameValidationFailureWorker(typing, result, typing, /*isScopeName*/ false);
        }
        JsTyping.renderPackageNameValidationFailure = renderPackageNameValidationFailure;
        function renderPackageNameValidationFailureWorker(typing, result, name, isScopeName) {
            var kind = isScopeName ? "Scope" : "Package";
            switch (result) {
                case 1 /* NameValidationResult.EmptyName */:
                    return "'".concat(typing, "':: ").concat(kind, " name '").concat(name, "' cannot be empty");
                case 2 /* NameValidationResult.NameTooLong */:
                    return "'".concat(typing, "':: ").concat(kind, " name '").concat(name, "' should be less than ").concat(maxPackageNameLength, " characters");
                case 3 /* NameValidationResult.NameStartsWithDot */:
                    return "'".concat(typing, "':: ").concat(kind, " name '").concat(name, "' cannot start with '.'");
                case 4 /* NameValidationResult.NameStartsWithUnderscore */:
                    return "'".concat(typing, "':: ").concat(kind, " name '").concat(name, "' cannot start with '_'");
                case 5 /* NameValidationResult.NameContainsNonURISafeCharacters */:
                    return "'".concat(typing, "':: ").concat(kind, " name '").concat(name, "' contains non URI safe characters");
                case 0 /* NameValidationResult.Ok */:
                    return ts.Debug.fail(); // Shouldn't have called this.
                default:
                    throw ts.Debug.assertNever(result);
            }
        }
    })(JsTyping = ts.JsTyping || (ts.JsTyping = {}));
})(ts || (ts = {}));
var ts;
(function (ts) {
    var ScriptSnapshot;
    (function (ScriptSnapshot) {
        var StringScriptSnapshot = /** @class */ (function () {
            function StringScriptSnapshot(text) {
                this.text = text;
            }
            StringScriptSnapshot.prototype.getText = function (start, end) {
                return start === 0 && end === this.text.length
                    ? this.text
                    : this.text.substring(start, end);
            };
            StringScriptSnapshot.prototype.getLength = function () {
                return this.text.length;
            };
            StringScriptSnapshot.prototype.getChangeRange = function () {
                // Text-based snapshots do not support incremental parsing. Return undefined
                // to signal that to the caller.
                return undefined;
            };
            return StringScriptSnapshot;
        }());
        function fromString(text) {
            return new StringScriptSnapshot(text);
        }
        ScriptSnapshot.fromString = fromString;
    })(ScriptSnapshot = ts.ScriptSnapshot || (ts.ScriptSnapshot = {}));
    /* @internal */
    var PackageJsonDependencyGroup;
    (function (PackageJsonDependencyGroup) {
        PackageJsonDependencyGroup[PackageJsonDependencyGroup["Dependencies"] = 1] = "Dependencies";
        PackageJsonDependencyGroup[PackageJsonDependencyGroup["DevDependencies"] = 2] = "DevDependencies";
        PackageJsonDependencyGroup[PackageJsonDependencyGroup["PeerDependencies"] = 4] = "PeerDependencies";
        PackageJsonDependencyGroup[PackageJsonDependencyGroup["OptionalDependencies"] = 8] = "OptionalDependencies";
        PackageJsonDependencyGroup[PackageJsonDependencyGroup["All"] = 15] = "All";
    })(PackageJsonDependencyGroup = ts.PackageJsonDependencyGroup || (ts.PackageJsonDependencyGroup = {}));
    /* @internal */
    var PackageJsonAutoImportPreference;
    (function (PackageJsonAutoImportPreference) {
        PackageJsonAutoImportPreference[PackageJsonAutoImportPreference["Off"] = 0] = "Off";
        PackageJsonAutoImportPreference[PackageJsonAutoImportPreference["On"] = 1] = "On";
        PackageJsonAutoImportPreference[PackageJsonAutoImportPreference["Auto"] = 2] = "Auto";
    })(PackageJsonAutoImportPreference = ts.PackageJsonAutoImportPreference || (ts.PackageJsonAutoImportPreference = {}));
    var LanguageServiceMode;
    (function (LanguageServiceMode) {
        LanguageServiceMode[LanguageServiceMode["Semantic"] = 0] = "Semantic";
        LanguageServiceMode[LanguageServiceMode["PartialSemantic"] = 1] = "PartialSemantic";
        LanguageServiceMode[LanguageServiceMode["Syntactic"] = 2] = "Syntactic";
    })(LanguageServiceMode = ts.LanguageServiceMode || (ts.LanguageServiceMode = {}));
    /* @internal */
    ts.emptyOptions = {};
    var SemanticClassificationFormat;
    (function (SemanticClassificationFormat) {
        SemanticClassificationFormat["Original"] = "original";
        SemanticClassificationFormat["TwentyTwenty"] = "2020";
    })(SemanticClassificationFormat = ts.SemanticClassificationFormat || (ts.SemanticClassificationFormat = {}));
    var CompletionTriggerKind;
    (function (CompletionTriggerKind) {
        /** Completion was triggered by typing an identifier, manual invocation (e.g Ctrl+Space) or via API. */
        CompletionTriggerKind[CompletionTriggerKind["Invoked"] = 1] = "Invoked";
        /** Completion was triggered by a trigger character. */
        CompletionTriggerKind[CompletionTriggerKind["TriggerCharacter"] = 2] = "TriggerCharacter";
        /** Completion was re-triggered as the current completion list is incomplete. */
        CompletionTriggerKind[CompletionTriggerKind["TriggerForIncompleteCompletions"] = 3] = "TriggerForIncompleteCompletions";
    })(CompletionTriggerKind = ts.CompletionTriggerKind || (ts.CompletionTriggerKind = {}));
    var InlayHintKind;
    (function (InlayHintKind) {
        InlayHintKind["Type"] = "Type";
        InlayHintKind["Parameter"] = "Parameter";
        InlayHintKind["Enum"] = "Enum";
    })(InlayHintKind = ts.InlayHintKind || (ts.InlayHintKind = {}));
    var HighlightSpanKind;
    (function (HighlightSpanKind) {
        HighlightSpanKind["none"] = "none";
        HighlightSpanKind["definition"] = "definition";
        HighlightSpanKind["reference"] = "reference";
        HighlightSpanKind["writtenReference"] = "writtenReference";
    })(HighlightSpanKind = ts.HighlightSpanKind || (ts.HighlightSpanKind = {}));
    var IndentStyle;
    (function (IndentStyle) {
        IndentStyle[IndentStyle["None"] = 0] = "None";
        IndentStyle[IndentStyle["Block"] = 1] = "Block";
        IndentStyle[IndentStyle["Smart"] = 2] = "Smart";
    })(IndentStyle = ts.IndentStyle || (ts.IndentStyle = {}));
    var SemicolonPreference;
    (function (SemicolonPreference) {
        SemicolonPreference["Ignore"] = "ignore";
        SemicolonPreference["Insert"] = "insert";
        SemicolonPreference["Remove"] = "remove";
    })(SemicolonPreference = ts.SemicolonPreference || (ts.SemicolonPreference = {}));
    function getDefaultFormatCodeSettings(newLineCharacter) {
        return {
            indentSize: 4,
            tabSize: 4,
            newLineCharacter: newLineCharacter || "\n",
            convertTabsToSpaces: true,
            indentStyle: IndentStyle.Smart,
            insertSpaceAfterConstructor: false,
            insertSpaceAfterCommaDelimiter: true,
            insertSpaceAfterSemicolonInForStatements: true,
            insertSpaceBeforeAndAfterBinaryOperators: true,
            insertSpaceAfterKeywordsInControlFlowStatements: true,
            insertSpaceAfterFunctionKeywordForAnonymousFunctions: false,
            insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis: false,
            insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets: false,
            insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces: true,
            insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces: false,
            insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces: false,
            insertSpaceBeforeFunctionParenthesis: false,
            placeOpenBraceOnNewLineForFunctions: false,
            placeOpenBraceOnNewLineForControlBlocks: false,
            semicolons: SemicolonPreference.Ignore,
            trimTrailingWhitespace: true
        };
    }
    ts.getDefaultFormatCodeSettings = getDefaultFormatCodeSettings;
    /* @internal */
    ts.testFormatSettings = getDefaultFormatCodeSettings("\n");
    var SymbolDisplayPartKind;
    (function (SymbolDisplayPartKind) {
        SymbolDisplayPartKind[SymbolDisplayPartKind["aliasName"] = 0] = "aliasName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["className"] = 1] = "className";
        SymbolDisplayPartKind[SymbolDisplayPartKind["enumName"] = 2] = "enumName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["fieldName"] = 3] = "fieldName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["interfaceName"] = 4] = "interfaceName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["keyword"] = 5] = "keyword";
        SymbolDisplayPartKind[SymbolDisplayPartKind["lineBreak"] = 6] = "lineBreak";
        SymbolDisplayPartKind[SymbolDisplayPartKind["numericLiteral"] = 7] = "numericLiteral";
        SymbolDisplayPartKind[SymbolDisplayPartKind["stringLiteral"] = 8] = "stringLiteral";
        SymbolDisplayPartKind[SymbolDisplayPartKind["localName"] = 9] = "localName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["methodName"] = 10] = "methodName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["moduleName"] = 11] = "moduleName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["operator"] = 12] = "operator";
        SymbolDisplayPartKind[SymbolDisplayPartKind["parameterName"] = 13] = "parameterName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["propertyName"] = 14] = "propertyName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["punctuation"] = 15] = "punctuation";
        SymbolDisplayPartKind[SymbolDisplayPartKind["space"] = 16] = "space";
        SymbolDisplayPartKind[SymbolDisplayPartKind["text"] = 17] = "text";
        SymbolDisplayPartKind[SymbolDisplayPartKind["typeParameterName"] = 18] = "typeParameterName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["enumMemberName"] = 19] = "enumMemberName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["functionName"] = 20] = "functionName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["regularExpressionLiteral"] = 21] = "regularExpressionLiteral";
        SymbolDisplayPartKind[SymbolDisplayPartKind["link"] = 22] = "link";
        SymbolDisplayPartKind[SymbolDisplayPartKind["linkName"] = 23] = "linkName";
        SymbolDisplayPartKind[SymbolDisplayPartKind["linkText"] = 24] = "linkText";
    })(SymbolDisplayPartKind = ts.SymbolDisplayPartKind || (ts.SymbolDisplayPartKind = {}));
    // Do not change existing values, as they exist in telemetry.
    var CompletionInfoFlags;
    (function (CompletionInfoFlags) {
        CompletionInfoFlags[CompletionInfoFlags["None"] = 0] = "None";
        CompletionInfoFlags[CompletionInfoFlags["MayIncludeAutoImports"] = 1] = "MayIncludeAutoImports";
        CompletionInfoFlags[CompletionInfoFlags["IsImportStatementCompletion"] = 2] = "IsImportStatementCompletion";
        CompletionInfoFlags[CompletionInfoFlags["IsContinuation"] = 4] = "IsContinuation";
        CompletionInfoFlags[CompletionInfoFlags["ResolvedModuleSpecifiers"] = 8] = "ResolvedModuleSpecifiers";
        CompletionInfoFlags[CompletionInfoFlags["ResolvedModuleSpecifiersBeyondLimit"] = 16] = "ResolvedModuleSpecifiersBeyondLimit";
        CompletionInfoFlags[CompletionInfoFlags["MayIncludeMethodSnippets"] = 32] = "MayIncludeMethodSnippets";
    })(CompletionInfoFlags = ts.CompletionInfoFlags || (ts.CompletionInfoFlags = {}));
    var OutliningSpanKind;
    (function (OutliningSpanKind) {
        /** Single or multi-line comments */
        OutliningSpanKind["Comment"] = "comment";
        /** Sections marked by '// #region' and '// #endregion' comments */
        OutliningSpanKind["Region"] = "region";
        /** Declarations and expressions */
        OutliningSpanKind["Code"] = "code";
        /** Contiguous blocks of import declarations */
        OutliningSpanKind["Imports"] = "imports";
    })(OutliningSpanKind = ts.OutliningSpanKind || (ts.OutliningSpanKind = {}));
    var OutputFileType;
    (function (OutputFileType) {
        OutputFileType[OutputFileType["JavaScript"] = 0] = "JavaScript";
        OutputFileType[OutputFileType["SourceMap"] = 1] = "SourceMap";
        OutputFileType[OutputFileType["Declaration"] = 2] = "Declaration";
    })(OutputFileType = ts.OutputFileType || (ts.OutputFileType = {}));
    var EndOfLineState;
    (function (EndOfLineState) {
        EndOfLineState[EndOfLineState["None"] = 0] = "None";
        EndOfLineState[EndOfLineState["InMultiLineCommentTrivia"] = 1] = "InMultiLineCommentTrivia";
        EndOfLineState[EndOfLineState["InSingleQuoteStringLiteral"] = 2] = "InSingleQuoteStringLiteral";
        EndOfLineState[EndOfLineState["InDoubleQuoteStringLiteral"] = 3] = "InDoubleQuoteStringLiteral";
        EndOfLineState[EndOfLineState["InTemplateHeadOrNoSubstitutionTemplate"] = 4] = "InTemplateHeadOrNoSubstitutionTemplate";
        EndOfLineState[EndOfLineState["InTemplateMiddleOrTail"] = 5] = "InTemplateMiddleOrTail";
        EndOfLineState[EndOfLineState["InTemplateSubstitutionPosition"] = 6] = "InTemplateSubstitutionPosition";
    })(EndOfLineState = ts.EndOfLineState || (ts.EndOfLineState = {}));
    var TokenClass;
    (function (TokenClass) {
        TokenClass[TokenClass["Punctuation"] = 0] = "Punctuation";
        TokenClass[TokenClass["Keyword"] = 1] = "Keyword";
        TokenClass[TokenClass["Operator"] = 2] = "Operator";
        TokenClass[TokenClass["Comment"] = 3] = "Comment";
        TokenClass[TokenClass["Whitespace"] = 4] = "Whitespace";
        TokenClass[TokenClass["Identifier"] = 5] = "Identifier";
        TokenClass[TokenClass["NumberLiteral"] = 6] = "NumberLiteral";
        TokenClass[TokenClass["BigIntLiteral"] = 7] = "BigIntLiteral";
        TokenClass[TokenClass["StringLiteral"] = 8] = "StringLiteral";
        TokenClass[TokenClass["RegExpLiteral"] = 9] = "RegExpLiteral";
    })(TokenClass = ts.TokenClass || (ts.TokenClass = {}));
    var ScriptElementKind;
    (function (ScriptElementKind) {
        ScriptElementKind["unknown"] = "";
        ScriptElementKind["warning"] = "warning";
        /** predefined type (void) or keyword (class) */
        ScriptElementKind["keyword"] = "keyword";
        /** top level script node */
        ScriptElementKind["scriptElement"] = "script";
        /** module foo {} */
        ScriptElementKind["moduleElement"] = "module";
        /** class X {} */
        ScriptElementKind["classElement"] = "class";
        /** var x = class X {} */
        ScriptElementKind["localClassElement"] = "local class";
        /** interface Y {} */
        ScriptElementKind["interfaceElement"] = "interface";
        /** type T = ... */
        ScriptElementKind["typeElement"] = "type";
        /** enum E */
        ScriptElementKind["enumElement"] = "enum";
        ScriptElementKind["enumMemberElement"] = "enum member";
        /**
         * Inside module and script only
         * const v = ..
         */
        ScriptElementKind["variableElement"] = "var";
        /** Inside function */
        ScriptElementKind["localVariableElement"] = "local var";
        /**
         * Inside module and script only
         * function f() { }
         */
        ScriptElementKind["functionElement"] = "function";
        /** Inside function */
        ScriptElementKind["localFunctionElement"] = "local function";
        /** class X { [public|private]* foo() {} } */
        ScriptElementKind["memberFunctionElement"] = "method";
        /** class X { [public|private]* [get|set] foo:number; } */
        ScriptElementKind["memberGetAccessorElement"] = "getter";
        ScriptElementKind["memberSetAccessorElement"] = "setter";
        /**
         * class X { [public|private]* foo:number; }
         * interface Y { foo:number; }
         */
        ScriptElementKind["memberVariableElement"] = "property";
        /**
         * class X { constructor() { } }
         * class X { static { } }
         */
        ScriptElementKind["constructorImplementationElement"] = "constructor";
        /** interface Y { ():number; } */
        ScriptElementKind["callSignatureElement"] = "call";
        /** interface Y { []:number; } */
        ScriptElementKind["indexSignatureElement"] = "index";
        /** interface Y { new():Y; } */
        ScriptElementKind["constructSignatureElement"] = "construct";
        /** function foo(*Y*: string) */
        ScriptElementKind["parameterElement"] = "parameter";
        ScriptElementKind["typeParameterElement"] = "type parameter";
        ScriptElementKind["primitiveType"] = "primitive type";
        ScriptElementKind["label"] = "label";
        ScriptElementKind["alias"] = "alias";
        ScriptElementKind["constElement"] = "const";
        ScriptElementKind["letElement"] = "let";
        ScriptElementKind["directory"] = "directory";
        ScriptElementKind["externalModuleName"] = "external module name";
        /**
         * <JsxTagName attribute1 attribute2={0} />
         * @deprecated
         */
        ScriptElementKind["jsxAttribute"] = "JSX attribute";
        /** String literal */
        ScriptElementKind["string"] = "string";
        /** Jsdoc @link: in `{@link C link text}`, the before and after text "{@link " and "}" */
        ScriptElementKind["link"] = "link";
        /** Jsdoc @link: in `{@link C link text}`, the entity name "C" */
        ScriptElementKind["linkName"] = "link name";
        /** Jsdoc @link: in `{@link C link text}`, the link text "link text" */
        ScriptElementKind["linkText"] = "link text";
    })(ScriptElementKind = ts.ScriptElementKind || (ts.ScriptElementKind = {}));
    var ScriptElementKindModifier;
    (function (ScriptElementKindModifier) {
        ScriptElementKindModifier["none"] = "";
        ScriptElementKindModifier["publicMemberModifier"] = "public";
        ScriptElementKindModifier["privateMemberModifier"] = "private";
        ScriptElementKindModifier["protectedMemberModifier"] = "protected";
        ScriptElementKindModifier["exportedModifier"] = "export";
        ScriptElementKindModifier["ambientModifier"] = "declare";
        ScriptElementKindModifier["staticModifier"] = "static";
        ScriptElementKindModifier["abstractModifier"] = "abstract";
        ScriptElementKindModifier["optionalModifier"] = "optional";
        ScriptElementKindModifier["deprecatedModifier"] = "deprecated";
        ScriptElementKindModifier["dtsModifier"] = ".d.ts";
        ScriptElementKindModifier["tsModifier"] = ".ts";
        ScriptElementKindModifier["tsxModifier"] = ".tsx";
        ScriptElementKindModifier["jsModifier"] = ".js";
        ScriptElementKindModifier["jsxModifier"] = ".jsx";
        ScriptElementKindModifier["jsonModifier"] = ".json";
        ScriptElementKindModifier["dmtsModifier"] = ".d.mts";
        ScriptElementKindModifier["mtsModifier"] = ".mts";
        ScriptElementKindModifier["mjsModifier"] = ".mjs";
        ScriptElementKindModifier["dctsModifier"] = ".d.cts";
        ScriptElementKindModifier["ctsModifier"] = ".cts";
        ScriptElementKindModifier["cjsModifier"] = ".cjs";
    })(ScriptElementKindModifier = ts.ScriptElementKindModifier || (ts.ScriptElementKindModifier = {}));
    var ClassificationTypeNames;
    (function (ClassificationTypeNames) {
        ClassificationTypeNames["comment"] = "comment";
        ClassificationTypeNames["identifier"] = "identifier";
        ClassificationTypeNames["keyword"] = "keyword";
        ClassificationTypeNames["numericLiteral"] = "number";
        ClassificationTypeNames["bigintLiteral"] = "bigint";
        ClassificationTypeNames["operator"] = "operator";
        ClassificationTypeNames["stringLiteral"] = "string";
        ClassificationTypeNames["whiteSpace"] = "whitespace";
        ClassificationTypeNames["text"] = "text";
        ClassificationTypeNames["punctuation"] = "punctuation";
        ClassificationTypeNames["className"] = "class name";
        ClassificationTypeNames["enumName"] = "enum name";
        ClassificationTypeNames["interfaceName"] = "interface name";
        ClassificationTypeNames["moduleName"] = "module name";
        ClassificationTypeNames["typeParameterName"] = "type parameter name";
        ClassificationTypeNames["typeAliasName"] = "type alias name";
        ClassificationTypeNames["parameterName"] = "parameter name";
        ClassificationTypeNames["docCommentTagName"] = "doc comment tag name";
        ClassificationTypeNames["jsxOpenTagName"] = "jsx open tag name";
        ClassificationTypeNames["jsxCloseTagName"] = "jsx close tag name";
        ClassificationTypeNames["jsxSelfClosingTagName"] = "jsx self closing tag name";
        ClassificationTypeNames["jsxAttribute"] = "jsx attribute";
        ClassificationTypeNames["jsxText"] = "jsx text";
        ClassificationTypeNames["jsxAttributeStringLiteralValue"] = "jsx attribute string literal value";
    })(ClassificationTypeNames = ts.ClassificationTypeNames || (ts.ClassificationTypeNames = {}));
    var ClassificationType;
    (function (ClassificationType) {
        ClassificationType[ClassificationType["comment"] = 1] = "comment";
        ClassificationType[ClassificationType["identifier"] = 2] = "identifier";
        ClassificationType[ClassificationType["keyword"] = 3] = "keyword";
        ClassificationType[ClassificationType["numericLiteral"] = 4] = "numericLiteral";
        ClassificationType[ClassificationType["operator"] = 5] = "operator";
        ClassificationType[ClassificationType["stringLiteral"] = 6] = "stringLiteral";
        ClassificationType[ClassificationType["regularExpressionLiteral"] = 7] = "regularExpressionLiteral";
        ClassificationType[ClassificationType["whiteSpace"] = 8] = "whiteSpace";
        ClassificationType[ClassificationType["text"] = 9] = "text";
        ClassificationType[ClassificationType["punctuation"] = 10] = "punctuation";
        ClassificationType[ClassificationType["className"] = 11] = "className";
        ClassificationType[ClassificationType["enumName"] = 12] = "enumName";
        ClassificationType[ClassificationType["interfaceName"] = 13] = "interfaceName";
        ClassificationType[ClassificationType["moduleName"] = 14] = "moduleName";
        ClassificationType[ClassificationType["typeParameterName"] = 15] = "typeParameterName";
        ClassificationType[ClassificationType["typeAliasName"] = 16] = "typeAliasName";
        ClassificationType[ClassificationType["parameterName"] = 17] = "parameterName";
        ClassificationType[ClassificationType["docCommentTagName"] = 18] = "docCommentTagName";
        ClassificationType[ClassificationType["jsxOpenTagName"] = 19] = "jsxOpenTagName";
        ClassificationType[ClassificationType["jsxCloseTagName"] = 20] = "jsxCloseTagName";
        ClassificationType[ClassificationType["jsxSelfClosingTagName"] = 21] = "jsxSelfClosingTagName";
        ClassificationType[ClassificationType["jsxAttribute"] = 22] = "jsxAttribute";
        ClassificationType[ClassificationType["jsxText"] = 23] = "jsxText";
        ClassificationType[ClassificationType["jsxAttributeStringLiteralValue"] = 24] = "jsxAttributeStringLiteralValue";
        ClassificationType[ClassificationType["bigintLiteral"] = 25] = "bigintLiteral";
    })(ClassificationType = ts.ClassificationType || (ts.ClassificationType = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    // These utilities are common to multiple language service features.
    //#region
    ts.scanner = ts.createScanner(99 /* ScriptTarget.Latest */, /*skipTrivia*/ true);
    var SemanticMeaning;
    (function (SemanticMeaning) {
        SemanticMeaning[SemanticMeaning["None"] = 0] = "None";
        SemanticMeaning[SemanticMeaning["Value"] = 1] = "Value";
        SemanticMeaning[SemanticMeaning["Type"] = 2] = "Type";
        SemanticMeaning[SemanticMeaning["Namespace"] = 4] = "Namespace";
        SemanticMeaning[SemanticMeaning["All"] = 7] = "All";
    })(SemanticMeaning = ts.SemanticMeaning || (ts.SemanticMeaning = {}));
    function getMeaningFromDeclaration(node) {
        switch (node.kind) {
            case 254 /* SyntaxKind.VariableDeclaration */:
                return ts.isInJSFile(node) && ts.getJSDocEnumTag(node) ? 7 /* SemanticMeaning.All */ : 1 /* SemanticMeaning.Value */;
            case 164 /* SyntaxKind.Parameter */:
            case 203 /* SyntaxKind.BindingElement */:
            case 167 /* SyntaxKind.PropertyDeclaration */:
            case 166 /* SyntaxKind.PropertySignature */:
            case 296 /* SyntaxKind.PropertyAssignment */:
            case 297 /* SyntaxKind.ShorthandPropertyAssignment */:
            case 169 /* SyntaxKind.MethodDeclaration */:
            case 168 /* SyntaxKind.MethodSignature */:
            case 171 /* SyntaxKind.Constructor */:
            case 172 /* SyntaxKind.GetAccessor */:
            case 173 /* SyntaxKind.SetAccessor */:
            case 256 /* SyntaxKind.FunctionDeclaration */:
            case 213 /* SyntaxKind.FunctionExpression */:
            case 214 /* SyntaxKind.ArrowFunction */:
            case 292 /* SyntaxKind.CatchClause */:
            case 285 /* SyntaxKind.JsxAttribute */:
                return 1 /* SemanticMeaning.Value */;
            case 163 /* SyntaxKind.TypeParameter */:
            case 258 /* SyntaxKind.InterfaceDeclaration */:
            case 259 /* SyntaxKind.TypeAliasDeclaration */:
            case 182 /* SyntaxKind.TypeLiteral */:
                return 2 /* SemanticMeaning.Type */;
            case 345 /* SyntaxKind.JSDocTypedefTag */:
                // If it has no name node, it shares the name with the value declaration below it.
                return node.name === undefined ? 1 /* SemanticMeaning.Value */ | 2 /* SemanticMeaning.Type */ : 2 /* SemanticMeaning.Type */;
            case 299 /* SyntaxKind.EnumMember */:
            case 257 /* SyntaxKind.ClassDeclaration */:
                return 1 /* SemanticMeaning.Value */ | 2 /* SemanticMeaning.Type */;
            case 261 /* SyntaxKind.ModuleDeclaration */:
                if (ts.isAmbientModule(node)) {
                    return 4 /* SemanticMeaning.Namespace */ | 1 /* SemanticMeaning.Value */;
                }
                else if (ts.getModuleInstanceState(node) === 1 /* ModuleInstanceState.Instantiated */) {
                    return 4 /* SemanticMeaning.Namespace */ | 1 /* SemanticMeaning.Value */;
                }
                else {
                    return 4 /* SemanticMeaning.Namespace */;
                }
            case 260 /* SyntaxKind.EnumDeclaration */:
            case 269 /* SyntaxKind.NamedImports */:
            case 270 /* SyntaxKind.ImportSpecifier */:
            case 265 /* SyntaxKind.ImportEqualsDeclaration */:
            case 266 /* SyntaxKind.ImportDeclaration */:
            case 271 /* SyntaxKind.ExportAssignment */:
            case 272 /* SyntaxKind.ExportDeclaration */:
                return 7 /* SemanticMeaning.All */;
            // An external module can be a Value
            case 305 /* SyntaxKind.SourceFile */:
                return 4 /* SemanticMeaning.Namespace */ | 1 /* SemanticMeaning.Value */;
        }
        return 7 /* SemanticMeaning.All */;
    }
    ts.getMeaningFromDeclaration = getMeaningFromDeclaration;
    function getMeaningFromLocation(node) {
        node = getAdjustedReferenceLocation(node);
        var parent = node.parent;
        if (node.kind === 305 /* SyntaxKind.SourceFile */) {
            return 1 /* SemanticMeaning.Value */;
        }
        else if (ts.isExportAssignment(parent)
            || ts.isExportSpecifier(parent)
            || ts.isExternalModuleReference(parent)
            || ts.isImportSpecifier(parent)
            || ts.isImportClause(parent)
            || ts.isImportEqualsDeclaration(parent) && node === parent.name) {
            return 7 /* SemanticMeaning.All */;
        }
        else if (isInRightSideOfInternalImportEqualsDeclaration(node)) {
            return getMeaningFromRightHandSideOfImportEquals(node);
        }
        else if (ts.isDeclarationName(node)) {
            return getMeaningFromDeclaration(parent);
        }
        else if (ts.isEntityName(node) && ts.findAncestor(node, ts.or(ts.isJSDocNameReference, ts.isJSDocLinkLike, ts.isJSDocMemberName))) {
            return 7 /* SemanticMeaning.All */;
        }
        else if (isTypeReference(node)) {
            return 2 /* SemanticMeaning.Type */;
        }
        else if (isNamespaceReference(node)) {
            return 4 /* SemanticMeaning.Namespace */;
        }
        else if (ts.isTypeParameterDeclaration(parent)) {
            ts.Debug.assert(ts.isJSDocTemplateTag(parent.parent)); // Else would be handled by isDeclarationName
            return 2 /* SemanticMeaning.Type */;
        }
        else if (ts.isLiteralTypeNode(parent)) {
            // This might be T["name"], which is actually referencing a property and not a type. So allow both meanings.
            return 2 /* SemanticMeaning.Type */ | 1 /* SemanticMeaning.Value */;
        }
        else {
            return 1 /* SemanticMeaning.Value */;
        }
    }
    ts.getMeaningFromLocation = getMeaningFromLocation;
    function getMeaningFromRightHandSideOfImportEquals(node) {
        //     import a = |b|; // Namespace
        //     import a = |b.c|; // Value, type, namespace
        //     import a = |b.c|.d; // Namespace
        var name = node.kind === 161 /* SyntaxKind.QualifiedName */ ? node : ts.isQualifiedName(node.parent) && node.parent.right === node ? node.parent : undefined;
        return name && name.parent.kind === 265 /* SyntaxKind.ImportEqualsDeclaration */ ? 7 /* SemanticMeaning.All */ : 4 /* SemanticMeaning.Namespace */;
    }
    function isInRightSideOfInternalImportEqualsDeclaration(node) {
        while (node.parent.kind === 161 /* SyntaxKind.QualifiedName */) {
            node = node.parent;
        }
        return ts.isInternalModuleImportEqualsDeclaration(node.parent) && node.parent.moduleReference === node;
    }
    ts.isInRightSideOfInternalImportEqualsDeclaration = isInRightSideOfInternalImportEqualsDeclaration;
    function isNamespaceReference(node) {
        return isQualifiedNameNamespaceReference(node) || isPropertyAccessNamespaceReference(node);
    }
    function isQualifiedNameNamespaceReference(node) {
        var root = node;
        var isLastClause = true;
        if (root.parent.kind === 161 /* SyntaxKind.QualifiedName */) {
            while (root.parent && root.parent.kind === 161 /* SyntaxKind.QualifiedName */) {
                root = root.parent;
            }
            isLastClause = root.right === node;
        }
        return root.parent.kind === 178 /* SyntaxKind.TypeReference */ && !isLastClause;
    }
    function isPropertyAccessNamespaceReference(node) {
        var root = node;
        var isLastClause = true;
        if (root.parent.kind === 206 /* SyntaxKind.PropertyAccessExpression */) {
            while (root.parent && root.parent.kind === 206 /* SyntaxKind.PropertyAccessExpression */) {
                root = root.parent;
            }
            isLastClause = root.name === node;
        }
        if (!isLastClause && root.parent.kind === 228 /* SyntaxKind.ExpressionWithTypeArguments */ && root.parent.parent.kind === 291 /* SyntaxKind.HeritageClause */) {
            var decl = root.parent.parent.parent;
            return (decl.kind === 257 /* SyntaxKind.ClassDeclaration */ && root.parent.parent.token === 117 /* SyntaxKind.ImplementsKeyword */) ||
                (decl.kind === 258 /* SyntaxKind.InterfaceDeclaration */ && root.parent.parent.token === 94 /* SyntaxKind.ExtendsKeyword */);
        }
        return false;
    }
    function isTypeReference(node) {
        if (ts.isRightSideOfQualifiedNameOrPropertyAccess(node)) {
            node = node.parent;
        }
        switch (node.kind) {
            case 108 /* SyntaxKind.ThisKeyword */:
                return !ts.isExpressionNode(node);
            case 192 /* SyntaxKind.ThisType */:
                return true;
        }
        switch (node.parent.kind) {
            case 178 /* SyntaxKind.TypeReference */:
                return true;
            case 200 /* SyntaxKind.ImportType */:
                return !node.parent.isTypeOf;
            case 228 /* SyntaxKind.ExpressionWithTypeArguments */:
                return ts.isPartOfTypeNode(node.parent);
        }
        return false;
    }
    function isCallExpressionTarget(node, includeElementAccess, skipPastOuterExpressions) {
        if (includeElementAccess === void 0) { includeElementAccess = false; }
        if (skipPastOuterExpressions === void 0) { skipPastOuterExpressions = false; }
        return isCalleeWorker(node, ts.isCallExpression, selectExpressionOfCallOrNewExpressionOrDecorator, includeElementAccess, skipPastOuterExpressions);
    }
    ts.isCallExpressionTarget = isCallExpressionTarget;
    function isNewExpressionTarget(node, includeElementAccess, skipPastOuterExpressions) {
        if (includeElementAccess === void 0) { includeElementAccess = false; }
        if (skipPastOuterExpressions === void 0) { skipPastOuterExpressions = false; }
        return isCalleeWorker(node, ts.isNewExpression, selectExpressionOfCallOrNewExpressionOrDecorator, includeElementAccess, skipPastOuterExpressions);
    }
    ts.isNewExpressionTarget = isNewExpressionTarget;
    function isCallOrNewExpressionTarget(node, includeElementAccess, skipPastOuterExpressions) {
        if (includeElementAccess === void 0) { includeElementAccess = false; }
        if (skipPastOuterExpressions === void 0) { skipPastOuterExpressions = false; }
        return isCalleeWorker(node, ts.isCallOrNewExpression, selectExpressionOfCallOrNewExpressionOrDecorator, includeElementAccess, skipPastOuterExpressions);
    }
    ts.isCallOrNewExpressionTarget = isCallOrNewExpressionTarget;
    function isTaggedTemplateTag(node, includeElementAccess, skipPastOuterExpressions) {
        if (includeElementAccess === void 0) { includeElementAccess = false; }
        if (skipPastOuterExpressions === void 0) { skipPastOuterExpressions = false; }
        return isCalleeWorker(node, ts.isTaggedTemplateExpression, selectTagOfTaggedTemplateExpression, includeElementAccess, skipPastOuterExpressions);
    }
    ts.isTaggedTemplateTag = isTaggedTemplateTag;
    function isDecoratorTarget(node, includeElementAccess, skipPastOuterExpressions) {
        if (includeElementAccess === void 0) { includeElementAccess = false; }
        if (skipPastOuterExpressions === void 0) { skipPastOuterExpressions = false; }
        return isCalleeWorker(node, ts.isDecorator, selectExpressionOfCallOrNewExpressionOrDecorator, includeElementAccess, skipPastOuterExpressions);
    }
    ts.isDecoratorTarget = isDecoratorTarget;
    function isJsxOpeningLikeElementTagName(node, includeElementAccess, skipPastOuterExpressions) {
        if (includeElementAccess === void 0) { includeElementAccess = false; }
        if (skipPastOuterExpressions === void 0) { skipPastOuterExpressions = false; }
        return isCalleeWorker(node, ts.isJsxOpeningLikeElement, selectTagNameOfJsxOpeningLikeElement, includeElementAccess, skipPastOuterExpressions);
    }
    ts.isJsxOpeningLikeElementTagName = isJsxOpeningLikeElementTagName;
    function selectExpressionOfCallOrNewExpressionOrDecorator(node) {
        return node.expression;
    }
    function selectTagOfTaggedTemplateExpression(node) {
        return node.tag;
    }
    function selectTagNameOfJsxOpeningLikeElement(node) {
        return node.tagName;
    }
    function isCalleeWorker(node, pred, calleeSelector, includeElementAccess, skipPastOuterExpressions) {
        var target = includeElementAccess ? climbPastPropertyOrElementAccess(node) : climbPastPropertyAccess(node);
        if (skipPastOuterExpressions) {
            target = ts.skipOuterExpressions(target);
        }
        return !!target && !!target.parent && pred(target.parent) && calleeSelector(target.parent) === target;
    }
    function climbPastPropertyAccess(node) {
        return isRightSideOfPropertyAccess(node) ? node.parent : node;
    }
    ts.climbPastPropertyAccess = climbPastPropertyAccess;
    function climbPastPropertyOrElementAccess(node) {
        return isRightSideOfPropertyAccess(node) || isArgumentExpressionOfElementAccess(node) ? node.parent : node;
    }
    ts.climbPastPropertyOrElementAccess = climbPastPropertyOrElementAccess;
    function getTargetLabel(referenceNode, labelName) {
        while (referenceNode) {
            if (referenceNode.kind === 250 /* SyntaxKind.LabeledStatement */ && referenceNode.label.escapedText === labelName) {
                return referenceNode.label;
            }
            referenceNode = referenceNode.parent;
        }
        return undefined;
    }
    ts.getTargetLabel = getTargetLabel;
    function hasPropertyAccessExpressionWithName(node, funcName) {
        if (!ts.isPropertyAccessExpression(node.expression)) {
            return false;
        }
        return node.expression.name.text === funcName;
    }
    ts.hasPropertyAccessExpressionWithName = hasPropertyAccessExpressionWithName;
    function isJumpStatementTarget(node) {
        var _a;
        return ts.isIdentifier(node) && ((_a = ts.tryCast(node.parent, ts.isBreakOrContinueStatement)) === null || _a === void 0 ? void 0 : _a.label) === node;
    }
    ts.isJumpStatementTarget = isJumpStatementTarget;
    function isLabelOfLabeledStatement(node) {
        var _a;
        return ts.isIdentifier(node) && ((_a = ts.tryCast(node.parent, ts.isLabeledStatement)) === null || _a === void 0 ? void 0 : _a.label) === node;
    }
    ts.isLabelOfLabeledStatement = isLabelOfLabeledStatement;
    function isLabelName(node) {
        return isLabelOfLabeledStatement(node) || isJumpStatementTarget(node);
    }
    ts.isLabelName = isLabelName;
    function isTagName(node) {
        var _a;
        return ((_a = ts.tryCast(node.parent, ts.isJSDocTag)) === null || _a === void 0 ? void 0 : _a.tagName) === node;
    }
    ts.isTagName = isTagName;
    function isRightSideOfQualifiedName(node) {
        var _a;
        return ((_a = ts.tryCast(node.parent, ts.isQualifiedName)) === null || _a === void 0 ? void 0 : _a.right) === node;
    }
    ts.isRightSideOfQualifiedName = isRightSideOfQualifiedName;
    function isRightSideOfPropertyAccess(node) {
        var _a;
        return ((_a = ts.tryCast(node.parent, ts.isPropertyAccessExpression)) === null || _a === void 0 ? void 0 : _a.name) === node;
    }
    ts.isRightSideOfPropertyAccess = isRightSideOfPropertyAccess;
    function isArgumentExpressionOfElementAccess(node) {
        var _a;
        return ((_a = ts.tryCast(node.parent, ts.isElementAccessExpression)) === null || _a === void 0 ? void 0 : _a.argumentExpression) === node;
    }
    ts.isArgumentExpressionOfElementAccess = isArgumentExpressionOfElementAccess;
    function isNameOfModuleDeclaration(node) {
        var _a;
        return ((_a = ts.tryCast(node.parent, ts.isModuleDeclaration)) === null || _a === void 0 ? void 0 : _a.name) === node;
    }
    ts.isNameOfModuleDeclaration = isNameOfModuleDeclaration;
    function isNameOfFunctionDeclaration(node) {
        var _a;
        return ts.isIdentifier(node) && ((_a = ts.tryCast(node.parent, ts.isFunctionLike)) === null || _a === void 0 ? void 0 : _a.name) === node;
    }
    ts.isNameOfFunctionDeclaration = isNameOfFunctionDeclaration;
    function isLiteralNameOfPropertyDeclarationOrIndexAccess(node) {
        switch (node.parent.kind) {
            case 167 /* SyntaxKind.PropertyDeclaration */:
            case 166 /* SyntaxKind.PropertySignature */:
            case 296 /* SyntaxKind.PropertyAssignment */:
            case 299 /* SyntaxKind.EnumMember */:
            case 169 /* SyntaxKind.MethodDeclaration */:
            case 168 /* SyntaxKind.MethodSignature */:
            case 172 /* SyntaxKind.GetAccessor */:
            case 173 /* SyntaxKind.SetAccessor */:
            case 261 /* SyntaxKind.ModuleDeclaration */:
                return ts.getNameOfDeclaration(node.parent) === node;
            case 207 /* SyntaxKind.ElementAccessExpression */:
                return node.parent.argumentExpression === node;
            case 162 /* SyntaxKind.ComputedPropertyName */:
                return true;
            case 196 /* SyntaxKind.LiteralType */:
                return node.parent.parent.kind === 194 /* SyntaxKind.IndexedAccessType */;
            default:
                return false;
        }
    }
    ts.isLiteralNameOfPropertyDeclarationOrIndexAccess = isLiteralNameOfPropertyDeclarationOrIndexAccess;
    function isExpressionOfExternalModuleImportEqualsDeclaration(node) {
        return ts.isExternalModuleImportEqualsDeclaration(node.parent.parent) &&
            ts.getExternalModuleImportEqualsDeclarationExpression(node.parent.parent) === node;
    }
    ts.isExpressionOfExternalModuleImportEqualsDeclaration = isExpressionOfExternalModuleImportEqualsDeclaration;
    function getContainerNode(node) {
        if (ts.isJSDocTypeAlias(node)) {
            // This doesn't just apply to the node immediately under the comment, but to everything in its parent's scope.
            // node.parent = the JSDoc comment, node.parent.parent = the node having the comment.
            // Then we get parent again in the loop.
            node = node.parent.parent;
        }
        while (true) {
            node = node.parent;
            if (!node) {
                return undefined;
            }
            switch (node.kind) {
                case 305 /* SyntaxKind.SourceFile */:
                case 169 /* SyntaxKind.MethodDeclaration */:
                case 168 /* SyntaxKind.MethodSignature */:
                case 256 /* SyntaxKind.FunctionDeclaration */:
                case 213 /* SyntaxKind.FunctionExpression */:
                case 172 /* SyntaxKind.GetAccessor */:
                case 173 /* SyntaxKind.SetAccessor */:
                case 257 /* SyntaxKind.ClassDeclaration */:
                case 258 /* SyntaxKind.InterfaceDeclaration */:
                case 260 /* SyntaxKind.EnumDeclaration */:
                case 261 /* SyntaxKind.ModuleDeclaration */:
                    return node;
            }
        }
    }
    ts.getContainerNode = getContainerNode;
    function getNodeKind(node) {
        switch (node.kind) {
            case 305 /* SyntaxKind.SourceFile */:
                return ts.isExternalModule(node) ? "module" /* ScriptElementKind.moduleElement */ : "script" /* ScriptElementKind.scriptElement */;
            case 261 /* SyntaxKind.ModuleDeclaration */:
                return "module" /* ScriptElementKind.moduleElement */;
            case 257 /* SyntaxKind.ClassDeclaration */:
            case 226 /* SyntaxKind.ClassExpression */:
                return "class" /* ScriptElementKind.classElement */;
            case 258 /* SyntaxKind.InterfaceDeclaration */: return "interface" /* ScriptElementKind.interfaceElement */;
            case 259 /* SyntaxKind.TypeAliasDeclaration */:
            case 338 /* SyntaxKind.JSDocCallbackTag */:
            case 345 /* SyntaxKind.JSDocTypedefTag */:
                return "type" /* ScriptElementKind.typeElement */;
            case 260 /* SyntaxKind.EnumDeclaration */: return "enum" /* ScriptElementKind.enumElement */;
            case 254 /* SyntaxKind.VariableDeclaration */:
                return getKindOfVariableDeclaration(node);
            case 203 /* SyntaxKind.BindingElement */:
                return getKindOfVariableDeclaration(ts.getRootDeclaration(node));
            case 214 /* SyntaxKind.ArrowFunction */:
            case 256 /* SyntaxKind.FunctionDeclaration */:
            case 213 /* SyntaxKind.FunctionExpression */:
                return "function" /* ScriptElementKind.functionElement */;
            case 172 /* SyntaxKind.GetAccessor */: return "getter" /* ScriptElementKind.memberGetAccessorElement */;
            case 173 /* SyntaxKind.SetAccessor */: return "setter" /* ScriptElementKind.memberSetAccessorElement */;
            case 169 /* SyntaxKind.MethodDeclaration */:
            case 168 /* SyntaxKind.MethodSignature */:
                return "method" /* ScriptElementKind.memberFunctionElement */;
            case 296 /* SyntaxKind.PropertyAssignment */:
                var initializer = node.initializer;
                return ts.isFunctionLike(initializer) ? "method" /* ScriptElementKind.memberFunctionElement */ : "property" /* ScriptElementKind.memberVariableElement */;
            case 167 /* SyntaxKind.PropertyDeclaration */:
            case 166 /* SyntaxKind.PropertySignature */:
            case 297 /* SyntaxKind.ShorthandPropertyAssignment */:
            case 298 /* SyntaxKind.SpreadAssignment */:
                return "property" /* ScriptElementKind.memberVariableElement */;
            case 176 /* SyntaxKind.IndexSignature */: return "index" /* ScriptElementKind.indexSignatureElement */;
            case 175 /* SyntaxKind.ConstructSignature */: return "construct" /* ScriptElementKind.constructSignatureElement */;
            case 174 /* SyntaxKind.CallSignature */: return "call" /* ScriptElementKind.callSignatureElement */;
            case 171 /* SyntaxKind.Constructor */:
            case 170 /* SyntaxKind.ClassStaticBlockDeclaration */:
                return "constructor" /* ScriptElementKind.constructorImplementationElement */;
            case 163 /* SyntaxKind.TypeParameter */: return "type parameter" /* ScriptElementKind.typeParameterElement */;
            case 299 /* SyntaxKind.EnumMember */: return "enum member" /* ScriptElementKind.enumMemberElement */;
            case 164 /* SyntaxKind.Parameter */: return ts.hasSyntacticModifier(node, 16476 /* ModifierFlags.ParameterPropertyModifier */) ? "property" /* ScriptElementKind.memberVariableElement */ : "parameter" /* ScriptElementKind.parameterElement */;
            case 265 /* SyntaxKind.ImportEqualsDeclaration */:
            case 270 /* SyntaxKind.ImportSpecifier */:
            case 275 /* SyntaxKind.ExportSpecifier */:
            case 268 /* SyntaxKind.NamespaceImport */:
            case 274 /* SyntaxKind.NamespaceExport */:
                return "alias" /* ScriptElementKind.alias */;
            case 221 /* SyntaxKind.BinaryExpression */:
                var kind = ts.getAssignmentDeclarationKind(node);
                var right = node.right;
                switch (kind) {
                    case 7 /* AssignmentDeclarationKind.ObjectDefinePropertyValue */:
                    case 8 /* AssignmentDeclarationKind.ObjectDefinePropertyExports */:
                    case 9 /* AssignmentDeclarationKind.ObjectDefinePrototypeProperty */:
                    case 0 /* AssignmentDeclarationKind.None */:
                        return "" /* ScriptElementKind.unknown */;
                    case 1 /* AssignmentDeclarationKind.ExportsProperty */:
                    case 2 /* AssignmentDeclarationKind.ModuleExports */:
                        var rightKind = getNodeKind(right);
                        return rightKind === "" /* ScriptElementKind.unknown */ ? "const" /* ScriptElementKind.constElement */ : rightKind;
                    case 3 /* AssignmentDeclarationKind.PrototypeProperty */:
                        return ts.isFunctionExpression(right) ? "method" /* ScriptElementKind.memberFunctionElement */ : "property" /* ScriptElementKind.memberVariableElement */;
                    case 4 /* AssignmentDeclarationKind.ThisProperty */:
                        return "property" /* ScriptElementKind.memberVariableElement */; // property
                    case 5 /* AssignmentDeclarationKind.Property */:
                        // static method / property
                        return ts.isFunctionExpression(right) ? "method" /* ScriptElementKind.memberFunctionElement */ : "property" /* ScriptElementKind.memberVariableElement */;
                    case 6 /* AssignmentDeclarationKind.Prototype */:
                        return "local class" /* ScriptElementKind.localClassElement */;
                    default: {
                        ts.assertType(kind);
                        return "" /* ScriptElementKind.unknown */;
                    }
                }
            case 79 /* SyntaxKind.Identifier */:
                return ts.isImportClause(node.parent) ? "alias" /* ScriptElementKind.alias */ : "" /* ScriptElementKind.unknown */;
            case 271 /* SyntaxKind.ExportAssignment */:
                var scriptKind = getNodeKind(node.expression);
                // If the expression didn't come back with something (like it does for an identifiers)
                return scriptKind === "" /* ScriptElementKind.unknown */ ? "const" /* ScriptElementKind.constElement */ : scriptKind;
            default:
                return "" /* ScriptElementKind.unknown */;
        }
        function getKindOfVariableDeclaration(v) {
            return ts.isVarConst(v)
                ? "const" /* ScriptElementKind.constElement */
                : ts.isLet(v)
                    ? "let" /* ScriptElementKind.letElement */
                    : "var" /* ScriptElementKind.variableElement */;
        }
    }
    ts.getNodeKind = getNodeKind;
    function isThis(node) {
        switch (node.kind) {
            case 108 /* SyntaxKind.ThisKeyword */:
                // case SyntaxKind.ThisType: TODO: GH#9267
                return true;
            case 79 /* SyntaxKind.Identifier */:
                // 'this' as a parameter
                return ts.identifierIsThisKeyword(node) && node.parent.kind === 164 /* SyntaxKind.Parameter */;
            default:
                return false;
        }
    }
    ts.isThis = isThis;
    // Matches the beginning of a triple slash directive
    var tripleSlashDirectivePrefixRegex = /^\/\/\/\s*</;
    function getLineStartPositionForPosition(position, sourceFile) {
        var lineStarts = ts.getLineStarts(sourceFile);
        var line = sourceFile.getLineAndCharacterOfPosition(position).line;
        return lineStarts[line];
    }
    ts.getLineStartPositionForPosition = getLineStartPositionForPosition;
    function rangeContainsRange(r1, r2) {
        return startEndContainsRange(r1.pos, r1.end, r2);
    }
    ts.rangeContainsRange = rangeContainsRange;
    function rangeContainsRangeExclusive(r1, r2) {
        return rangeContainsPositionExclusive(r1, r2.pos) && rangeContainsPositionExclusive(r1, r2.end);
    }
    ts.rangeContainsRangeExclusive = rangeContainsRangeExclusive;
    function rangeContainsPosition(r, pos) {
        return r.pos <= pos && pos <= r.end;
    }
    ts.rangeContainsPosition = rangeContainsPosition;
    function rangeContainsPositionExclusive(r, pos) {
        return r.pos < pos && pos < r.end;
    }
    ts.rangeContainsPositionExclusive = rangeContainsPositionExclusive;
    function startEndContainsRange(start, end, range) {
        return start <= range.pos && end >= range.end;
    }
    ts.startEndContainsRange = startEndContainsRange;
    function rangeContainsStartEnd(range, start, end) {
        return range.pos <= start && range.end >= end;
    }
    ts.rangeContainsStartEnd = rangeContainsStartEnd;
    function rangeOverlapsWithStartEnd(r1, start, end) {
        return startEndOverlapsWithStartEnd(r1.pos, r1.end, start, end);
    }
    ts.rangeOverlapsWithStartEnd = rangeOverlapsWithStartEnd;
    function nodeOverlapsWithStartEnd(node, sourceFile, start, end) {
        return startEndOverlapsWithStartEnd(node.getStart(sourceFile), node.end, start, end);
    }
    ts.nodeOverlapsWithStartEnd = nodeOverlapsWithStartEnd;
    function startEndOverlapsWithStartEnd(start1, end1, start2, end2) {
        var start = Math.max(start1, start2);
        var end = Math.min(end1, end2);
        return start < end;
    }
    ts.startEndOverlapsWithStartEnd = startEndOverlapsWithStartEnd;
    /**
     * Assumes `candidate.start <= position` holds.
     */
    function positionBelongsToNode(candidate, position, sourceFile) {
        ts.Debug.assert(candidate.pos <= position);
        return position < candidate.end || !isCompletedNode(candidate, sourceFile);
    }
    ts.positionBelongsToNode = positionBelongsToNode;
    function isCompletedNode(n, sourceFile) {
        if (n === undefined || ts.nodeIsMissing(n)) {
            return false;
        }
        switch (n.kind) {
            case 257 /* SyntaxKind.ClassDeclaration */:
            case 258 /* SyntaxKind.InterfaceDeclaration */:
            case 260 /* SyntaxKind.EnumDeclaration */:
            case 205 /* SyntaxKind.ObjectLiteralExpression */:
            case 201 /* SyntaxKind.ObjectBindingPattern */:
            case 182 /* SyntaxKind.TypeLiteral */:
            case 235 /* SyntaxKind.Block */:
            case 262 /* SyntaxKind.ModuleBlock */:
            case 263 /* SyntaxKind.CaseBlock */:
            case 269 /* SyntaxKind.NamedImports */:
            case 273 /* SyntaxKind.NamedExports */:
                return nodeEndsWith(n, 19 /* SyntaxKind.CloseBraceToken */, sourceFile);
            case 292 /* SyntaxKind.CatchClause */:
                return isCompletedNode(n.block, sourceFile);
            case 209 /* SyntaxKind.NewExpression */:
                if (!n.arguments) {
                    return true;
                }
            // falls through
            case 208 /* SyntaxKind.CallExpression */:
            case 212 /* SyntaxKind.ParenthesizedExpression */:
            case 191 /* SyntaxKind.ParenthesizedType */:
                return nodeEndsWith(n, 21 /* SyntaxKind.CloseParenToken */, sourceFile);
            case 179 /* SyntaxKind.FunctionType */:
            case 180 /* SyntaxKind.ConstructorType */:
                return isCompletedNode(n.type, sourceFile);
            case 171 /* SyntaxKind.Constructor */:
            case 172 /* SyntaxKind.GetAccessor */:
            case 173 /* SyntaxKind.SetAccessor */:
            case 256 /* SyntaxKind.FunctionDeclaration */:
            case 213 /* SyntaxKind.FunctionExpression */:
            case 169 /* SyntaxKind.MethodDeclaration */:
            case 168 /* SyntaxKind.MethodSignature */:
            case 175 /* SyntaxKind.ConstructSignature */:
            case 174 /* SyntaxKind.CallSignature */:
            case 214 /* SyntaxKind.ArrowFunction */:
                if (n.body) {
                    return isCompletedNode(n.body, sourceFile);
                }
                if (n.type) {
                    return isCompletedNode(n.type, sourceFile);
                }
                // Even though type parameters can be unclosed, we can get away with
                // having at least a closing paren.
                return hasChildOfKind(n, 21 /* SyntaxKind.CloseParenToken */, sourceFile);
            case 261 /* SyntaxKind.ModuleDeclaration */:
                return !!n.body && isCompletedNode(n.body, sourceFile);
            case 239 /* SyntaxKind.IfStatement */:
                if (n.elseStatement) {
                    return isCompletedNode(n.elseStatement, sourceFile);
                }
                return isCompletedNode(n.thenStatement, sourceFile);
            case 238 /* SyntaxKind.ExpressionStatement */:
                return isCompletedNode(n.expression, sourceFile) ||
                    hasChildOfKind(n, 26 /* SyntaxKind.SemicolonToken */, sourceFile);
            case 204 /* SyntaxKind.ArrayLiteralExpression */:
            case 202 /* SyntaxKind.ArrayBindingPattern */:
            case 207 /* SyntaxKind.ElementAccessExpression */:
            case 162 /* SyntaxKind.ComputedPropertyName */:
            case 184 /* SyntaxKind.TupleType */:
                return nodeEndsWith(n, 23 /* SyntaxKind.CloseBracketToken */, sourceFile);
            case 176 /* SyntaxKind.IndexSignature */:
                if (n.type) {
                    return isCompletedNode(n.type, sourceFile);
                }
                return hasChildOfKind(n, 23 /* SyntaxKind.CloseBracketToken */, sourceFile);
            case 289 /* SyntaxKind.CaseClause */:
            case 290 /* SyntaxKind.DefaultClause */:
                // there is no such thing as terminator token for CaseClause/DefaultClause so for simplicity always consider them non-completed
                return false;
            case 242 /* SyntaxKind.ForStatement */:
            case 243 /* SyntaxKind.ForInStatement */:
            case 244 /* SyntaxKind.ForOfStatement */:
            case 241 /* SyntaxKind.WhileStatement */:
                return isCompletedNode(n.statement, sourceFile);
            case 240 /* SyntaxKind.DoStatement */:
                // rough approximation: if DoStatement has While keyword - then if node is completed is checking the presence of ')';
                return hasChildOfKind(n, 115 /* SyntaxKind.WhileKeyword */, sourceFile)
                    ? nodeEndsWith(n, 21 /* SyntaxKind.CloseParenToken */, sourceFile)
                    : isCompletedNode(n.statement, sourceFile);
            case 181 /* SyntaxKind.TypeQuery */:
                return isCompletedNode(n.exprName, sourceFile);
            case 216 /* SyntaxKind.TypeOfExpression */:
            case 215 /* SyntaxKind.DeleteExpression */:
            case 217 /* SyntaxKind.VoidExpression */:
            case 224 /* SyntaxKind.YieldExpression */:
            case 225 /* SyntaxKind.SpreadElement */:
                var unaryWordExpression = n;
                return isCompletedNode(unaryWordExpression.expression, sourceFile);
            case 210 /* SyntaxKind.TaggedTemplateExpression */:
                return isCompletedNode(n.template, sourceFile);
            case 223 /* SyntaxKind.TemplateExpression */:
                var lastSpan = ts.lastOrUndefined(n.templateSpans);
                return isCompletedNode(lastSpan, sourceFile);
            case 233 /* SyntaxKind.TemplateSpan */:
                return ts.nodeIsPresent(n.literal);
            case 272 /* SyntaxKind.ExportDeclaration */:
            case 266 /* SyntaxKind.ImportDeclaration */:
                return ts.nodeIsPresent(n.moduleSpecifier);
            case 219 /* SyntaxKind.PrefixUnaryExpression */:
                return isCompletedNode(n.operand, sourceFile);
            case 221 /* SyntaxKind.BinaryExpression */:
                return isCompletedNode(n.right, sourceFile);
            case 222 /* SyntaxKind.ConditionalExpression */:
                return isCompletedNode(n.whenFalse, sourceFile);
            default:
                return true;
        }
    }
    /*
     * Checks if node ends with 'expectedLastToken'.
     * If child at position 'length - 1' is 'SemicolonToken' it is skipped and 'expectedLastToken' is compared with child at position 'length - 2'.
     */
    function nodeEndsWith(n, expectedLastToken, sourceFile) {
        var children = n.getChildren(sourceFile);
        if (children.length) {
            var lastChild = ts.last(children);
            if (lastChild.kind === expectedLastToken) {
                return true;
            }
            else if (lastChild.kind === 26 /* SyntaxKind.SemicolonToken */ && children.length !== 1) {
                return children[children.length - 2].kind === expectedLastToken;
            }
        }
        return false;
    }
    function findListItemInfo(node) {
        var list = findContainingList(node);
        // It is possible at this point for syntaxList to be undefined, either if
        // node.parent had no list child, or if none of its list children contained
        // the span of node. If this happens, return undefined. The caller should
        // handle this case.
        if (!list) {
            return undefined;
        }
        var children = list.getChildren();
        var listItemIndex = ts.indexOfNode(children, node);
        return {
            listItemIndex: listItemIndex,
            list: list
        };
    }
    ts.findListItemInfo = findListItemInfo;
    function hasChildOfKind(n, kind, sourceFile) {
        return !!findChildOfKind(n, kind, sourceFile);
    }
    ts.hasChildOfKind = hasChildOfKind;
    function findChildOfKind(n, kind, sourceFile) {
        return ts.find(n.getChildren(sourceFile), function (c) { return c.kind === kind; });
    }
    ts.findChildOfKind = findChildOfKind;
    function findContainingList(node) {
        // The node might be a list element (nonsynthetic) or a comma (synthetic). Either way, it will
        // be parented by the container of the SyntaxList, not the SyntaxList itself.
        // In order to find the list item index, we first need to locate SyntaxList itself and then search
        // for the position of the relevant node (or comma).
        var syntaxList = ts.find(node.parent.getChildren(), function (c) { return ts.isSyntaxList(c) && rangeContainsRange(c, node); });
        // Either we didn't find an appropriate list, or the list must contain us.
        ts.Debug.assert(!syntaxList || ts.contains(syntaxList.getChildren(), node));
        return syntaxList;
    }
    ts.findContainingList = findContainingList;
    function isDefaultModifier(node) {
        return node.kind === 88 /* SyntaxKind.DefaultKeyword */;
    }
    function isClassKeyword(node) {
        return node.kind === 84 /* SyntaxKind.ClassKeyword */;
    }
    function isFunctionKeyword(node) {
        return node.kind === 98 /* SyntaxKind.FunctionKeyword */;
    }
    function getAdjustedLocationForClass(node) {
        if (ts.isNamedDeclaration(node)) {
            return node.name;
        }
        if (ts.isClassDeclaration(node)) {
            // for class and function declarations, use the `default` modifier
            // when the declaration is unnamed.
            var defaultModifier = node.modifiers && ts.find(node.modifiers, isDefaultModifier);
            if (defaultModifier)
                return defaultModifier;
        }
        if (ts.isClassExpression(node)) {
            // for class expressions, use the `class` keyword when the class is unnamed
            var classKeyword = ts.find(node.getChildren(), isClassKeyword);
            if (classKeyword)
                return classKeyword;
        }
    }
    function getAdjustedLocationForFunction(node) {
        if (ts.isNamedDeclaration(node)) {
            return node.name;
        }
        if (ts.isFunctionDeclaration(node)) {
            // for class and function declarations, use the `default` modifier
            // when the declaration is unnamed.
            var defaultModifier = ts.find(node.modifiers, isDefaultModifier);
            if (defaultModifier)
                return defaultModifier;
        }
        if (ts.isFunctionExpression(node)) {
            // for function expressions, use the `function` keyword when the function is unnamed
            var functionKeyword = ts.find(node.getChildren(), isFunctionKeyword);
            if (functionKeyword)
                return functionKeyword;
        }
    }
    function getAncestorTypeNode(node) {
        var lastTypeNode;
        ts.findAncestor(node, function (a) {
            if (ts.isTypeNode(a)) {
                lastTypeNode = a;
            }
            return !ts.isQualifiedName(a.parent) && !ts.isTypeNode(a.parent) && !ts.isTypeElement(a.parent);
        });
        return lastTypeNode;
    }
    function getContextualTypeFromParentOrAncestorTypeNode(node, checker) {
        var contextualType = getContextualTypeFromParent(node, checker);
        if (contextualType)
            return contextualType;
        var ancestorTypeNode = getAncestorTypeNode(node);
        return ancestorTypeNode && checker.getTypeAtLocation(ancestorTypeNode);
    }
    ts.getContextualTypeFromParentOrAncestorTypeNode = getContextualTypeFromParentOrAncestorTypeNode;
    function getAdjustedLocationForDeclaration(node, forRename) {
        if (!forRename) {
            switch (node.kind) {
                case 257 /* SyntaxKind.ClassDeclaration */:
                case 226 /* SyntaxKind.ClassExpression */:
                    return getAdjustedLocationForClass(node);
                case 256 /* SyntaxKind.FunctionDeclaration */:
                case 213 /* SyntaxKind.FunctionExpression */:
                    return getAdjustedLocationForFunction(node);
            }
        }
        if (ts.isNamedDeclaration(node)) {
            return node.name;
        }
    }
    function getAdjustedLocationForImportDeclaration(node, forRename) {
        if (node.importClause) {
            if (node.importClause.name && node.importClause.namedBindings) {
                // do not adjust if we have both a name and named bindings
                return;
            }
            // /**/import [|name|] from ...;
            // import /**/type [|name|] from ...;
            if (node.importClause.name) {
                return node.importClause.name;
            }
            // /**/import { [|name|] } from ...;
            // /**/import { propertyName as [|name|] } from ...;
            // /**/import * as [|name|] from ...;
            // import /**/type { [|name|] } from ...;
            // import /**/type { propertyName as [|name|] } from ...;
            // import /**/type * as [|name|] from ...;
            if (node.importClause.namedBindings) {
                if (ts.isNamedImports(node.importClause.namedBindings)) {
                    // do nothing if there is more than one binding
                    var onlyBinding = ts.singleOrUndefined(node.importClause.namedBindings.elements);
                    if (!onlyBinding) {
                        return;
                    }
                    return onlyBinding.name;
                }
                else if (ts.isNamespaceImport(node.importClause.namedBindings)) {
                    return node.importClause.namedBindings.name;
                }
            }
        }
        if (!forRename) {
            // /**/import "[|module|]";
            // /**/import ... from "[|module|]";
            // import /**/type ... from "[|module|]";
            return node.moduleSpecifier;
        }
    }
    function getAdjustedLocationForExportDeclaration(node, forRename) {
        if (node.exportClause) {
            // /**/export { [|name|] } ...
            // /**/export { propertyName as [|name|] } ...
            // /**/export * as [|name|] ...
            // export /**/type { [|name|] } from ...
            // export /**/type { propertyName as [|name|] } from ...
            // export /**/type * as [|name|] ...
            if (ts.isNamedExports(node.exportClause)) {
                // do nothing if there is more than one binding
                var onlyBinding = ts.singleOrUndefined(node.exportClause.elements);
                if (!onlyBinding) {
                    return;
                }
                return node.exportClause.elements[0].name;
            }
            else if (ts.isNamespaceExport(node.exportClause)) {
                return node.exportClause.name;
            }
        }
        if (!forRename) {
            // /**/export * from "[|module|]";
            // export /**/type * from "[|module|]";
            return node.moduleSpecifier;
        }
    }
    function getAdjustedLocationForHeritageClause(node) {
        // /**/extends [|name|]
        // /**/implements [|name|]
        if (node.types.length === 1) {
            return node.types[0].expression;
        }
        // /**/extends name1, name2 ...
        // /**/implements name1, name2 ...
    }
    function getAdjustedLocation(node, forRename) {
        var parent = node.parent;
        // /**/<modifier> [|name|] ...
        // /**/<modifier> <class|interface|type|enum|module|namespace|function|get|set> [|name|] ...
        // /**/<class|interface|type|enum|module|namespace|function|get|set> [|name|] ...
        // /**/import [|name|] = ...
        //
        // NOTE: If the node is a modifier, we don't adjust its location if it is the `default` modifier as that is handled
        // specially by `getSymbolAtLocation`.
        if (ts.isModifier(node) && (forRename || node.kind !== 88 /* SyntaxKind.DefaultKeyword */) ? ts.contains(parent.modifiers, node) :
            node.kind === 84 /* SyntaxKind.ClassKeyword */ ? ts.isClassDeclaration(parent) || ts.isClassExpression(node) :
                node.kind === 98 /* SyntaxKind.FunctionKeyword */ ? ts.isFunctionDeclaration(parent) || ts.isFunctionExpression(node) :
                    node.kind === 118 /* SyntaxKind.InterfaceKeyword */ ? ts.isInterfaceDeclaration(parent) :
                        node.kind === 92 /* SyntaxKind.EnumKeyword */ ? ts.isEnumDeclaration(parent) :
                            node.kind === 152 /* SyntaxKind.TypeKeyword */ ? ts.isTypeAliasDeclaration(parent) :
                                node.kind === 142 /* SyntaxKind.NamespaceKeyword */ || node.kind === 141 /* SyntaxKind.ModuleKeyword */ ? ts.isModuleDeclaration(parent) :
                                    node.kind === 100 /* SyntaxKind.ImportKeyword */ ? ts.isImportEqualsDeclaration(parent) :
                                        node.kind === 136 /* SyntaxKind.GetKeyword */ ? ts.isGetAccessorDeclaration(parent) :
                                            node.kind === 149 /* SyntaxKind.SetKeyword */ && ts.isSetAccessorDeclaration(parent)) {
            var location = getAdjustedLocationForDeclaration(parent, forRename);
            if (location) {
                return location;
            }
        }
        // /**/<var|let|const> [|name|] ...
        if ((node.kind === 113 /* SyntaxKind.VarKeyword */ || node.kind === 85 /* SyntaxKind.ConstKeyword */ || node.kind === 119 /* SyntaxKind.LetKeyword */) &&
            ts.isVariableDeclarationList(parent) && parent.declarations.length === 1) {
            var decl = parent.declarations[0];
            if (ts.isIdentifier(decl.name)) {
                return decl.name;
            }
        }
        if (node.kind === 152 /* SyntaxKind.TypeKeyword */) {
            // import /**/type [|name|] from ...;
            // import /**/type { [|name|] } from ...;
            // import /**/type { propertyName as [|name|] } from ...;
            // import /**/type ... from "[|module|]";
            if (ts.isImportClause(parent) && parent.isTypeOnly) {
                var location = getAdjustedLocationForImportDeclaration(parent.parent, forRename);
                if (location) {
                    return location;
                }
            }
            // export /**/type { [|name|] } from ...;
            // export /**/type { propertyName as [|name|] } from ...;
            // export /**/type * from "[|module|]";
            // export /**/type * as ... from "[|module|]";
            if (ts.isExportDeclaration(parent) && parent.isTypeOnly) {
                var location = getAdjustedLocationForExportDeclaration(parent, forRename);
                if (location) {
                    return location;
                }
            }
        }
        // import { propertyName /**/as [|name|] } ...
        // import * /**/as [|name|] ...
        // export { propertyName /**/as [|name|] } ...
        // export * /**/as [|name|] ...
        if (node.kind === 127 /* SyntaxKind.AsKeyword */) {
            if (ts.isImportSpecifier(parent) && parent.propertyName ||
                ts.isExportSpecifier(parent) && parent.propertyName ||
                ts.isNamespaceImport(parent) ||
                ts.isNamespaceExport(parent)) {
                return parent.name;
            }
            if (ts.isExportDeclaration(parent) && parent.exportClause && ts.isNamespaceExport(parent.exportClause)) {
                return parent.exportClause.name;
            }
        }
        // /**/import [|name|] from ...;
        // /**/import { [|name|] } from ...;
        // /**/import { propertyName as [|name|] } from ...;
        // /**/import ... from "[|module|]";
        // /**/import "[|module|]";
        if (node.kind === 100 /* SyntaxKind.ImportKeyword */ && ts.isImportDeclaration(parent)) {
            var location = getAdjustedLocationForImportDeclaration(parent, forRename);
            if (location) {
                return location;
            }
        }
        if (node.kind === 93 /* SyntaxKind.ExportKeyword */) {
            // /**/export { [|name|] } ...;
            // /**/export { propertyName as [|name|] } ...;
            // /**/export * from "[|module|]";
            // /**/export * as ... from "[|module|]";
            if (ts.isExportDeclaration(parent)) {
                var location = getAdjustedLocationForExportDeclaration(parent, forRename);
                if (location) {
                    return location;
                }
            }
            // NOTE: We don't adjust the location of the `default` keyword as that is handled specially by `getSymbolAtLocation`.
            // /**/export default [|name|];
            // /**/export = [|name|];
            if (ts.isExportAssignment(parent)) {
                return ts.skipOuterExpressions(parent.expression);
            }
        }
        // import name = /**/require("[|module|]");
        if (node.kind === 146 /* SyntaxKind.RequireKeyword */ && ts.isExternalModuleReference(parent)) {
            return parent.expression;
        }
        // import ... /**/from "[|module|]";
        // export ... /**/from "[|module|]";
        if (node.kind === 156 /* SyntaxKind.FromKeyword */ && (ts.isImportDeclaration(parent) || ts.isExportDeclaration(parent)) && parent.moduleSpecifier) {
            return parent.moduleSpecifier;
        }
        // class ... /**/extends [|name|] ...
        // class ... /**/implements [|name|] ...
        // class ... /**/implements name1, name2 ...
        // interface ... /**/extends [|name|] ...
        // interface ... /**/extends name1, name2 ...
        if ((node.kind === 94 /* SyntaxKind.ExtendsKeyword */ || node.kind === 117 /* SyntaxKind.ImplementsKeyword */) && ts.isHeritageClause(parent) && parent.token === node.kind) {
            var location = getAdjustedLocationForHeritageClause(parent);
            if (location) {
                return location;
            }
        }
        if (node.kind === 94 /* SyntaxKind.ExtendsKeyword */) {
            // ... <T /**/extends [|U|]> ...
            if (ts.isTypeParameterDeclaration(parent) && parent.constraint && ts.isTypeReferenceNode(parent.constraint)) {
                return parent.constraint.typeName;
            }
            // ... T /**/extends [|U|] ? ...
            if (ts.isConditionalTypeNode(parent) && ts.isTypeReferenceNode(parent.extendsType)) {
                return parent.extendsType.typeName;
            }
        }
        // ... T extends /**/infer [|U|] ? ...
        if (node.kind === 137 /* SyntaxKind.InferKeyword */ && ts.isInferTypeNode(parent)) {
            return parent.typeParameter.name;
        }
        // { [ [|K|] /**/in keyof T]: ... }
        if (node.kind === 101 /* SyntaxKind.InKeyword */ && ts.isTypeParameterDeclaration(parent) && ts.isMappedTypeNode(parent.parent)) {
            return parent.name;
        }
        // /**/keyof [|T|]
        if (node.kind === 140 /* SyntaxKind.KeyOfKeyword */ && ts.isTypeOperatorNode(parent) && parent.operator === 140 /* SyntaxKind.KeyOfKeyword */ &&
            ts.isTypeReferenceNode(parent.type)) {
            return parent.type.typeName;
        }
        // /**/readonly [|name|][]
        if (node.kind === 145 /* SyntaxKind.ReadonlyKeyword */ && ts.isTypeOperatorNode(parent) && parent.operator === 145 /* SyntaxKind.ReadonlyKeyword */ &&
            ts.isArrayTypeNode(parent.type) && ts.isTypeReferenceNode(parent.type.elementType)) {
            return parent.type.elementType.typeName;
        }
        if (!forRename) {
            // /**/new [|name|]
            // /**/void [|name|]
            // /**/void obj.[|name|]
            // /**/typeof [|name|]
            // /**/typeof obj.[|name|]
            // /**/await [|name|]
            // /**/await obj.[|name|]
            // /**/yield [|name|]
            // /**/yield obj.[|name|]
            // /**/delete obj.[|name|]
            if (node.kind === 103 /* SyntaxKind.NewKeyword */ && ts.isNewExpression(parent) ||
                node.kind === 114 /* SyntaxKind.VoidKeyword */ && ts.isVoidExpression(parent) ||
                node.kind === 112 /* SyntaxKind.TypeOfKeyword */ && ts.isTypeOfExpression(parent) ||
                node.kind === 132 /* SyntaxKind.AwaitKeyword */ && ts.isAwaitExpression(parent) ||
                node.kind === 125 /* SyntaxKind.YieldKeyword */ && ts.isYieldExpression(parent) ||
                node.kind === 89 /* SyntaxKind.DeleteKeyword */ && ts.isDeleteExpression(parent)) {
                if (parent.expression) {
                    return ts.skipOuterExpressions(parent.expression);
                }
            }
            // left /**/in [|name|]
            // left /**/instanceof [|name|]
            if ((node.kind === 101 /* SyntaxKind.InKeyword */ || node.kind === 102 /* SyntaxKind.InstanceOfKeyword */) && ts.isBinaryExpression(parent) && parent.operatorToken === node) {
                return ts.skipOuterExpressions(parent.right);
            }
            // left /**/as [|name|]
            if (node.kind === 127 /* SyntaxKind.AsKeyword */ && ts.isAsExpression(parent) && ts.isTypeReferenceNode(parent.type)) {
                return parent.type.typeName;
            }
            // for (... /**/in [|name|])
            // for (... /**/of [|name|])
            if (node.kind === 101 /* SyntaxKind.InKeyword */ && ts.isForInStatement(parent) ||
                node.kind === 160 /* SyntaxKind.OfKeyword */ && ts.isForOfStatement(parent)) {
                return ts.skipOuterExpressions(parent.expression);
            }
        }
        return node;
    }
    /**
     * Adjusts the location used for "find references" and "go to definition" when the cursor was not
     * on a property name.
     */
    function getAdjustedReferenceLocation(node) {
        return getAdjustedLocation(node, /*forRename*/ false);
    }
    ts.getAdjustedReferenceLocation = getAdjustedReferenceLocation;
    /**
     * Adjusts the location used for "rename" when the cursor was not on a property name.
     */
    function getAdjustedRenameLocation(node) {
        return getAdjustedLocation(node, /*forRename*/ true);
    }
    ts.getAdjustedRenameLocation = getAdjustedRenameLocation;
    /**
     * Gets the token whose text has range [start, end) and
     * position >= start and (position < end or (position === end && token is literal or keyword or identifier))
     */
    function getTouchingPropertyName(sourceFile, position) {
        return getTouchingToken(sourceFile, position, function (n) { return ts.isPropertyNameLiteral(n) || ts.isKeyword(n.kind) || ts.isPrivateIdentifier(n); });
    }
    ts.getTouchingPropertyName = getTouchingPropertyName;
    /**
     * Returns the token if position is in [start, end).
     * If position === end, returns the preceding token if includeItemAtEndPosition(previousToken) === true
     */
    function getTouchingToken(sourceFile, position, includePrecedingTokenAtEndPosition) {
        return getTokenAtPositionWorker(sourceFile, position, /*allowPositionInLeadingTrivia*/ false, includePrecedingTokenAtEndPosition, /*includeEndPosition*/ false);
    }
    ts.getTouchingToken = getTouchingToken;
    /** Returns a token if position is in [start-of-leading-trivia, end) */
    function getTokenAtPosition(sourceFile, position) {
        return getTokenAtPositionWorker(sourceFile, position, /*allowPositionInLeadingTrivia*/ true, /*includePrecedingTokenAtEndPosition*/ undefined, /*includeEndPosition*/ false);
    }
    ts.getTokenAtPosition = getTokenAtPosition;
    /** Get the token whose text contains the position */
    function getTokenAtPositionWorker(sourceFile, position, allowPositionInLeadingTrivia, includePrecedingTokenAtEndPosition, includeEndPosition) {
        var current = sourceFile;
        var foundToken;
        var _loop_1 = function () {
            // find the child that contains 'position'
            var children = current.getChildren(sourceFile);
            var i = ts.binarySearchKey(children, position, function (_, i) { return i; }, function (middle, _) {
                // This last callback is more of a selector than a comparator -
                // `EqualTo` causes the `middle` result to be returned
                // `GreaterThan` causes recursion on the left of the middle
                // `LessThan` causes recursion on the right of the middle
                // Let's say you have 3 nodes, spanning positons
                // pos: 1, end: 3
                // pos: 3, end: 3
                // pos: 3, end: 5
                // and you're looking for the token at positon 3 - all 3 of these nodes are overlapping with position 3.
                // In fact, there's a _good argument_ that node 2 shouldn't even be allowed to exist - depending on if
                // the start or end of the ranges are considered inclusive, it's either wholly subsumed by the first or the last node.
                // Unfortunately, such nodes do exist. :( - See fourslash/completionsImport_tsx.tsx - empty jsx attributes create
                // a zero-length node.
                // What also you may not expect is that which node we return depends on the includePrecedingTokenAtEndPosition flag.
                // Specifically, if includePrecedingTokenAtEndPosition is set, we return the 1-3 node, while if it's unset, we
                // return the 3-5 node. (The zero length node is never correct.) This is because the includePrecedingTokenAtEndPosition
                // flag causes us to return the first node whose end position matches the position and which produces and acceptable token
                // kind. Meanwhile, if includePrecedingTokenAtEndPosition is unset, we look for the first node whose start is <= the
                // position and whose end is greater than the position.
                var start = allowPositionInLeadingTrivia ? children[middle].getFullStart() : children[middle].getStart(sourceFile, /*includeJsDoc*/ true);
                if (start > position) {
                    return 1 /* Comparison.GreaterThan */;
                }
                // first element whose start position is before the input and whose end position is after or equal to the input
                if (nodeContainsPosition(children[middle])) {
                    if (children[middle - 1]) {
                        // we want the _first_ element that contains the position, so left-recur if the prior node also contains the position
                        if (nodeContainsPosition(children[middle - 1])) {
                            return 1 /* Comparison.GreaterThan */;
                        }
                    }
                    return 0 /* Comparison.EqualTo */;
                }
                // this complex condition makes us left-recur around a zero-length node when includePrecedingTokenAtEndPosition is set, rather than right-recur on it
                if (includePrecedingTokenAtEndPosition && start === position && children[middle - 1] && children[middle - 1].getEnd() === position && nodeContainsPosition(children[middle - 1])) {
                    return 1 /* Comparison.GreaterThan */;
                }
                return -1 /* Comparison.LessThan */;
            });
            if (foundToken) {
                return { value: foundToken };
            }
            if (i >= 0 && children[i]) {
                current = children[i];
                return "continue-outer";
            }
            return { value: current };
        };
        outer: while (true) {
            var state_1 = _loop_1();
            if (typeof state_1 === "object")
                return state_1.value;
            switch (state_1) {
                case "continue-outer": continue outer;
            }
        }
        function nodeContainsPosition(node) {
            var start = allowPositionInLeadingTrivia ? node.getFullStart() : node.getStart(sourceFile, /*includeJsDoc*/ true);
            if (start > position) {
                // If this child begins after position, then all subsequent children will as well.
                return false;
            }
            var end = node.getEnd();
            if (position < end || (position === end && (node.kind === 1 /* SyntaxKind.EndOfFileToken */ || includeEndPosition))) {
                return true;
            }
            else if (includePrecedingTokenAtEndPosition && end === position) {
                var previousToken = findPrecedingToken(position, sourceFile, node);
                if (previousToken && includePrecedingTokenAtEndPosition(previousToken)) {
                    foundToken = previousToken;
                    return true;
                }
            }
            return false;
        }
    }
    /**
     * Returns the first token where position is in [start, end),
     * excluding `JsxText` tokens containing only whitespace.
     */
    function findFirstNonJsxWhitespaceToken(sourceFile, position) {
        var tokenAtPosition = getTokenAtPosition(sourceFile, position);
        while (isWhiteSpaceOnlyJsxText(tokenAtPosition)) {
            var nextToken = findNextToken(tokenAtPosition, tokenAtPosition.parent, sourceFile);
            if (!nextToken)
                return;
            tokenAtPosition = nextToken;
        }
        return tokenAtPosition;
    }
    ts.findFirstNonJsxWhitespaceToken = findFirstNonJsxWhitespaceToken;
    /**
     * The token on the left of the position is the token that strictly includes the position
     * or sits to the left of the cursor if it is on a boundary. For example
     *
     *   fo|o               -> will return foo
     *   foo <comment> |bar -> will return foo
     *
     */
    function findTokenOnLeftOfPosition(file, position) {
        // Ideally, getTokenAtPosition should return a token. However, it is currently
        // broken, so we do a check to make sure the result was indeed a token.
        var tokenAtPosition = getTokenAtPosition(file, position);
        if (ts.isToken(tokenAtPosition) && position > tokenAtPosition.getStart(file) && position < tokenAtPosition.getEnd()) {
            return tokenAtPosition;
        }
        return findPrecedingToken(position, file);
    }
    ts.findTokenOnLeftOfPosition = findTokenOnLeftOfPosition;
    function findNextToken(previousToken, parent, sourceFile) {
        return find(parent);
        function find(n) {
            if (ts.isToken(n) && n.pos === previousToken.end) {
                // this is token that starts at the end of previous token - return it
                return n;
            }
            return ts.firstDefined(n.getChildren(sourceFile), function (child) {
                var shouldDiveInChildNode = 
                // previous token is enclosed somewhere in the child
                (child.pos <= previousToken.pos && child.end > previousToken.end) ||
                    // previous token ends exactly at the beginning of child
                    (child.pos === previousToken.end);
                return shouldDiveInChildNode && nodeHasTokens(child, sourceFile) ? find(child) : undefined;
            });
        }
    }
    ts.findNextToken = findNextToken;
    function findPrecedingToken(position, sourceFile, startNode, excludeJsdoc) {
        var result = find((startNode || sourceFile));
        ts.Debug.assert(!(result && isWhiteSpaceOnlyJsxText(result)));
        return result;
        function find(n) {
            if (isNonWhitespaceToken(n) && n.kind !== 1 /* SyntaxKind.EndOfFileToken */) {
                return n;
            }
            var children = n.getChildren(sourceFile);
            var i = ts.binarySearchKey(children, position, function (_, i) { return i; }, function (middle, _) {
                // This last callback is more of a selector than a comparator -
                // `EqualTo` causes the `middle` result to be returned
                // `GreaterThan` causes recursion on the left of the middle
                // `LessThan` causes recursion on the right of the middle
                if (position < children[middle].end) {
                    // first element whose end position is greater than the input position
                    if (!children[middle - 1] || position >= children[middle - 1].end) {
                        return 0 /* Comparison.EqualTo */;
                    }
                    return 1 /* Comparison.GreaterThan */;
                }
                return -1 /* Comparison.LessThan */;
            });
            if (i >= 0 && children[i]) {
                var child = children[i];
                // Note that the span of a node's tokens is [node.getStart(...), node.end).
                // Given that `position < child.end` and child has constituent tokens, we distinguish these cases:
                // 1) `position` precedes `child`'s tokens or `child` has no tokens (ie: in a comment or whitespace preceding `child`):
                // we need to find the last token in a previous child.
                // 2) `position` is within the same span: we recurse on `child`.
                if (position < child.end) {
                    var start = child.getStart(sourceFile, /*includeJsDoc*/ !excludeJsdoc);
                    var lookInPreviousChild = (start >= position) || // cursor in the leading trivia
                        !nodeHasTokens(child, sourceFile) ||
                        isWhiteSpaceOnlyJsxText(child);
                    if (lookInPreviousChild) {
                        // actual start of the node is past the position - previous token should be at the end of previous child
                        var candidate_1 = findRightmostChildNodeWithTokens(children, /*exclusiveStartPosition*/ i, sourceFile, n.kind);
                        return candidate_1 && findRightmostToken(candidate_1, sourceFile);
                    }
                    else {
                        // candidate should be in this node
                        return find(child);
                    }
                }
            }
            ts.Debug.assert(startNode !== undefined || n.kind === 305 /* SyntaxKind.SourceFile */ || n.kind === 1 /* SyntaxKind.EndOfFileToken */ || ts.isJSDocCommentContainingNode(n));
            // Here we know that none of child token nodes embrace the position,
            // the only known case is when position is at the end of the file.
            // Try to find the rightmost token in the file without filtering.
            // Namely we are skipping the check: 'position < node.end'
            var candidate = findRightmostChildNodeWithTokens(children, /*exclusiveStartPosition*/ children.length, sourceFile, n.kind);
            return candidate && findRightmostToken(candidate, sourceFile);
        }
    }
    ts.findPrecedingToken = findPrecedingToken;
    function isNonWhitespaceToken(n) {
        return ts.isToken(n) && !isWhiteSpaceOnlyJsxText(n);
    }
    function findRightmostToken(n, sourceFile) {
        if (isNonWhitespaceToken(n)) {
            return n;
        }
        var children = n.getChildren(sourceFile);
        if (children.length === 0) {
            return n;
        }
        var candidate = findRightmostChildNodeWithTokens(children, /*exclusiveStartPosition*/ children.length, sourceFile, n.kind);
        return candidate && findRightmostToken(candidate, sourceFile);
    }
    /**
     * Finds the rightmost child to the left of `children[exclusiveStartPosition]` which is a non-all-whitespace token or has constituent tokens.
     */
    function findRightmostChildNodeWithTokens(children, exclusiveStartPosition, sourceFile, parentKind) {
        for (var i = exclusiveStartPosition - 1; i >= 0; i--) {
            var child = children[i];
            if (isWhiteSpaceOnlyJsxText(child)) {
                if (i === 0 && (parentKind === 11 /* SyntaxKind.JsxText */ || parentKind === 279 /* SyntaxKind.JsxSelfClosingElement */)) {
                    ts.Debug.fail("`JsxText` tokens should not be the first child of `JsxElement | JsxSelfClosingElement`");
                }
            }
            else if (nodeHasTokens(children[i], sourceFile)) {
                return children[i];
            }
        }
    }
    function isInString(sourceFile, position, previousToken) {
        if (previousToken === void 0) { previousToken = findPrecedingToken(position, sourceFile); }
        if (previousToken && ts.isStringTextContainingNode(previousToken)) {
            var start = previousToken.getStart(sourceFile);
            var end = previousToken.getEnd();
            // To be "in" one of these literals, the position has to be:
            //   1. entirely within the token text.
            //   2. at the end position of an unterminated token.
            //   3. at the end of a regular expression (due to trailing flags like '/foo/g').
            if (start < position && position < end) {
                return true;
            }
            if (position === end) {
                return !!previousToken.isUnterminated;
            }
        }
        return false;
    }
    ts.isInString = isInString;
    /**
     * returns true if the position is in between the open and close elements of an JSX expression.
     */
    function isInsideJsxElementOrAttribute(sourceFile, position) {
        var token = getTokenAtPosition(sourceFile, position);
        if (!token) {
            return false;
        }
        if (token.kind === 11 /* SyntaxKind.JsxText */) {
            return true;
        }
        // <div>Hello |</div>
        if (token.kind === 29 /* SyntaxKind.LessThanToken */ && token.parent.kind === 11 /* SyntaxKind.JsxText */) {
            return true;
        }
        // <div> { | </div> or <div a={| </div>
        if (token.kind === 29 /* SyntaxKind.LessThanToken */ && token.parent.kind === 288 /* SyntaxKind.JsxExpression */) {
            return true;
        }
        // <div> {
        // |
        // } < /div>
        if (token && token.kind === 19 /* SyntaxKind.CloseBraceToken */ && token.parent.kind === 288 /* SyntaxKind.JsxExpression */) {
            return true;
        }
        // <div>|</div>
        if (token.kind === 29 /* SyntaxKind.LessThanToken */ && token.parent.kind === 281 /* SyntaxKind.JsxClosingElement */) {
            return true;
        }
        return false;
    }
    ts.isInsideJsxElementOrAttribute = isInsideJsxElementOrAttribute;
    function isWhiteSpaceOnlyJsxText(node) {
        return ts.isJsxText(node) && node.containsOnlyTriviaWhiteSpaces;
    }
    function isInTemplateString(sourceFile, position) {
        var token = getTokenAtPosition(sourceFile, position);
        return ts.isTemplateLiteralKind(token.kind) && position > token.getStart(sourceFile);
    }
    ts.isInTemplateString = isInTemplateString;
    function isInJSXText(sourceFile, position) {
        var token = getTokenAtPosition(sourceFile, position);
        if (ts.isJsxText(token)) {
            return true;
        }
        if (token.kind === 18 /* SyntaxKind.OpenBraceToken */ && ts.isJsxExpression(token.parent) && ts.isJsxElement(token.parent.parent)) {
            return true;
        }
        if (token.kind === 29 /* SyntaxKind.LessThanToken */ && ts.isJsxOpeningLikeElement(token.parent) && ts.isJsxElement(token.parent.parent)) {
            return true;
        }
        return false;
    }
    ts.isInJSXText = isInJSXText;
    function isInsideJsxElement(sourceFile, position) {
        function isInsideJsxElementTraversal(node) {
            while (node) {
                if (node.kind >= 279 /* SyntaxKind.JsxSelfClosingElement */ && node.kind <= 288 /* SyntaxKind.JsxExpression */
                    || node.kind === 11 /* SyntaxKind.JsxText */
                    || node.kind === 29 /* SyntaxKind.LessThanToken */
                    || node.kind === 31 /* SyntaxKind.GreaterThanToken */
                    || node.kind === 79 /* SyntaxKind.Identifier */
                    || node.kind === 19 /* SyntaxKind.CloseBraceToken */
                    || node.kind === 18 /* SyntaxKind.OpenBraceToken */
                    || node.kind === 43 /* SyntaxKind.SlashToken */) {
                    node = node.parent;
                }
                else if (node.kind === 278 /* SyntaxKind.JsxElement */) {
                    if (position > node.getStart(sourceFile))
                        return true;
                    node = node.parent;
                }
                else {
                    return false;
                }
            }
            return false;
        }
        return isInsideJsxElementTraversal(getTokenAtPosition(sourceFile, position));
    }
    ts.isInsideJsxElement = isInsideJsxElement;
    function findPrecedingMatchingToken(token, matchingTokenKind, sourceFile) {
        var closeTokenText = ts.tokenToString(token.kind);
        var matchingTokenText = ts.tokenToString(matchingTokenKind);
        var tokenFullStart = token.getFullStart();
        // Text-scan based fast path - can be bamboozled by comments and other trivia, but often provides
        // a good, fast approximation without too much extra work in the cases where it fails.
        var bestGuessIndex = sourceFile.text.lastIndexOf(matchingTokenText, tokenFullStart);
        if (bestGuessIndex === -1) {
            return undefined; // if the token text doesn't appear in the file, there can't be a match - super fast bail
        }
        // we can only use the textual result directly if we didn't have to count any close tokens within the range
        if (sourceFile.text.lastIndexOf(closeTokenText, tokenFullStart - 1) < bestGuessIndex) {
            var nodeAtGuess = findPrecedingToken(bestGuessIndex + 1, sourceFile);
            if (nodeAtGuess && nodeAtGuess.kind === matchingTokenKind) {
                return nodeAtGuess;
            }
        }
        var tokenKind = token.kind;
        var remainingMatchingTokens = 0;
        while (true) {
            var preceding = findPrecedingToken(token.getFullStart(), sourceFile);
            if (!preceding) {
                return undefined;
            }
            token = preceding;
            if (token.kind === matchingTokenKind) {
                if (remainingMatchingTokens === 0) {
                    return token;
                }
                remainingMatchingTokens--;
            }
            else if (token.kind === tokenKind) {
                remainingMatchingTokens++;
            }
        }
    }
    ts.findPrecedingMatchingToken = findPrecedingMatchingToken;
    function removeOptionality(type, isOptionalExpression, isOptionalChain) {
        return isOptionalExpression ? type.getNonNullableType() :
            isOptionalChain ? type.getNonOptionalType() :
                type;
    }
    ts.removeOptionality = removeOptionality;
    function isPossiblyTypeArgumentPosition(token, sourceFile, checker) {
        var info = getPossibleTypeArgumentsInfo(token, sourceFile);
        return info !== undefined && (ts.isPartOfTypeNode(info.called) ||
            getPossibleGenericSignatures(info.called, info.nTypeArguments, checker).length !== 0 ||
            isPossiblyTypeArgumentPosition(info.called, sourceFile, checker));
    }
    ts.isPossiblyTypeArgumentPosition = isPossiblyTypeArgumentPosition;
    function getPossibleGenericSignatures(called, typeArgumentCount, checker) {
        var type = checker.getTypeAtLocation(called);
        if (ts.isOptionalChain(called.parent)) {
            type = removeOptionality(type, ts.isOptionalChainRoot(called.parent), /*isOptionalChain*/ true);
        }
        var signatures = ts.isNewExpression(called.parent) ? type.getConstructSignatures() : type.getCallSignatures();
        return signatures.filter(function (candidate) { return !!candidate.typeParameters && candidate.typeParameters.length >= typeArgumentCount; });
    }
    ts.getPossibleGenericSignatures = getPossibleGenericSignatures;
    // Get info for an expression like `f <` that may be the start of type arguments.
    function getPossibleTypeArgumentsInfo(tokenIn, sourceFile) {
        // This is a rare case, but one that saves on a _lot_ of work if true - if the source file has _no_ `<` character,
        // then there obviously can't be any type arguments - no expensive brace-matching backwards scanning required
        if (sourceFile.text.lastIndexOf("<", tokenIn ? tokenIn.pos : sourceFile.text.length) === -1) {
            return undefined;
        }
        var token = tokenIn;
        // This function determines if the node could be type argument position
        // Since during editing, when type argument list is not complete,
        // the tree could be of any shape depending on the tokens parsed before current node,
        // scanning of the previous identifier followed by "<" before current node would give us better result
        // Note that we also balance out the already provided type arguments, arrays, object literals while doing so
        var remainingLessThanTokens = 0;
        var nTypeArguments = 0;
        while (token) {
            switch (token.kind) {
                case 29 /* SyntaxKind.LessThanToken */:
                    // Found the beginning of the generic argument expression
                    token = findPrecedingToken(token.getFullStart(), sourceFile);
                    if (token && token.kind === 28 /* SyntaxKind.QuestionDotToken */) {
                        token = findPrecedingToken(token.getFullStart(), sourceFile);
                    }
                    if (!token || !ts.isIdentifier(token))
                        return undefined;
                    if (!remainingLessThanTokens) {
                        return ts.isDeclarationName(token) ? undefined : { called: token, nTypeArguments: nTypeArguments };
                    }
                    remainingLessThanTokens--;
                    break;
                case 49 /* SyntaxKind.GreaterThanGreaterThanGreaterThanToken */:
                    remainingLessThanTokens = +3;
                    break;
                case 48 /* SyntaxKind.GreaterThanGreaterThanToken */:
                    remainingLessThanTokens = +2;
                    break;
                case 31 /* SyntaxKind.GreaterThanToken */:
                    remainingLessThanTokens++;
                    break;
                case 19 /* SyntaxKind.CloseBraceToken */:
                    // This can be object type, skip until we find the matching open brace token
                    // Skip until the matching open brace token
                    token = findPrecedingMatchingToken(token, 18 /* SyntaxKind.OpenBraceToken */, sourceFile);
                    if (!token)
                        return undefined;
                    break;
                case 21 /* SyntaxKind.CloseParenToken */:
                    // This can be object type, skip until we find the matching open brace token
                    // Skip until the matching open brace token
                    token = findPrecedingMatchingToken(token, 20 /* SyntaxKind.OpenParenToken */, sourceFile);
                    if (!token)
                        return undefined;
                    break;
                case 23 /* SyntaxKind.CloseBracketToken */:
                    // This can be object type, skip until we find the matching open brace token
                    // Skip until the matching open brace token
                    token = findPrecedingMatchingToken(token, 22 /* SyntaxKind.OpenBracketToken */, sourceFile);
                    if (!token)
                        return undefined;
                    break;
                // Valid tokens in a type name. Skip.
                case 27 /* SyntaxKind.CommaToken */:
                    nTypeArguments++;
                    break;
                case 38 /* SyntaxKind.EqualsGreaterThanToken */:
                // falls through
                case 79 /* SyntaxKind.Identifier */:
                case 10 /* SyntaxKind.StringLiteral */:
                case 8 /* SyntaxKind.NumericLiteral */:
                case 9 /* SyntaxKind.BigIntLiteral */:
                case 110 /* SyntaxKind.TrueKeyword */:
                case 95 /* SyntaxKind.FalseKeyword */:
                // falls through
                case 112 /* SyntaxKind.TypeOfKeyword */:
                case 94 /* SyntaxKind.ExtendsKeyword */:
                case 140 /* SyntaxKind.KeyOfKeyword */:
                case 24 /* SyntaxKind.DotToken */:
                case 51 /* SyntaxKind.BarToken */:
                case 57 /* SyntaxKind.QuestionToken */:
                case 58 /* SyntaxKind.ColonToken */:
                    break;
                default:
                    if (ts.isTypeNode(token)) {
                        break;
                    }
                    // Invalid token in type
                    return undefined;
            }
            token = findPrecedingToken(token.getFullStart(), sourceFile);
        }
        return undefined;
    }
    ts.getPossibleTypeArgumentsInfo = getPossibleTypeArgumentsInfo;
    /**
     * Returns true if the cursor at position in sourceFile is within a comment.
     *
     * @param tokenAtPosition Must equal `getTokenAtPosition(sourceFile, position)
     * @param predicate Additional predicate to test on the comment range.
     */
    function isInComment(sourceFile, position, tokenAtPosition) {
        return ts.formatting.getRangeOfEnclosingComment(sourceFile, position, /*precedingToken*/ undefined, tokenAtPosition);
    }
    ts.isInComment = isInComment;
    function hasDocComment(sourceFile, position) {
        var token = getTokenAtPosition(sourceFile, position);
        return !!ts.findAncestor(token, ts.isJSDoc);
    }
    ts.hasDocComment = hasDocComment;
    function nodeHasTokens(n, sourceFile) {
        // If we have a token or node that has a non-zero width, it must have tokens.
        // Note: getWidth() does not take trivia into account.
        return n.kind === 1 /* SyntaxKind.EndOfFileToken */ ? !!n.jsDoc : n.getWidth(sourceFile) !== 0;
    }
    function getNodeModifiers(node, excludeFlags) {
        if (excludeFlags === void 0) { excludeFlags = 0 /* ModifierFlags.None */; }
        var result = [];
        var flags = ts.isDeclaration(node)
            ? ts.getCombinedNodeFlagsAlwaysIncludeJSDoc(node) & ~excludeFlags
            : 0 /* ModifierFlags.None */;
        if (flags & 8 /* ModifierFlags.Private */)
            result.push("private" /* ScriptElementKindModifier.privateMemberModifier */);
        if (flags & 16 /* ModifierFlags.Protected */)
            result.push("protected" /* ScriptElementKindModifier.protectedMemberModifier */);
        if (flags & 4 /* ModifierFlags.Public */)
            result.push("public" /* ScriptElementKindModifier.publicMemberModifier */);
        if (flags & 32 /* ModifierFlags.Static */ || ts.isClassStaticBlockDeclaration(node))
            result.push("static" /* ScriptElementKindModifier.staticModifier */);
        if (flags & 128 /* ModifierFlags.Abstract */)
            result.push("abstract" /* ScriptElementKindModifier.abstractModifier */);
        if (flags & 1 /* ModifierFlags.Export */)
            result.push("export" /* ScriptElementKindModifier.exportedModifier */);
        if (flags & 8192 /* ModifierFlags.Deprecated */)
            result.push("deprecated" /* ScriptElementKindModifier.deprecatedModifier */);
        if (node.flags & 16777216 /* NodeFlags.Ambient */)
            result.push("declare" /* ScriptElementKindModifier.ambientModifier */);
        if (node.kind === 271 /* SyntaxKind.ExportAssignment */)
            result.push("export" /* ScriptElementKindModifier.exportedModifier */);
        return result.length > 0 ? result.join(",") : "" /* ScriptElementKindModifier.none */;
    }
    ts.getNodeModifiers = getNodeModifiers;
    function getTypeArgumentOrTypeParameterList(node) {
        if (node.kind === 178 /* SyntaxKind.TypeReference */ || node.kind === 208 /* SyntaxKind.CallExpression */) {
            return node.typeArguments;
        }
        if (ts.isFunctionLike(node) || node.kind === 257 /* SyntaxKind.ClassDeclaration */ || node.kind === 258 /* SyntaxKind.InterfaceDeclaration */) {
            return node.typeParameters;
        }
        return undefined;
    }
    ts.getTypeArgumentOrTypeParameterList = getTypeArgumentOrTypeParameterList;
    function isComment(kind) {
        return kind === 2 /* SyntaxKind.SingleLineCommentTrivia */ || kind === 3 /* SyntaxKind.MultiLineCommentTrivia */;
    }
    ts.isComment = isComment;
    function isStringOrRegularExpressionOrTemplateLiteral(kind) {
        if (kind === 10 /* SyntaxKind.StringLiteral */
            || kind === 13 /* SyntaxKind.RegularExpressionLiteral */
            || ts.isTemplateLiteralKind(kind)) {
            return true;
        }
        return false;
    }
    ts.isStringOrRegularExpressionOrTemplateLiteral = isStringOrRegularExpressionOrTemplateLiteral;
    function isPunctuation(kind) {
        return 18 /* SyntaxKind.FirstPunctuation */ <= kind && kind <= 78 /* SyntaxKind.LastPunctuation */;
    }
    ts.isPunctuation = isPunctuation;
    function isInsideTemplateLiteral(node, position, sourceFile) {
        return ts.isTemplateLiteralKind(node.kind)
            && (node.getStart(sourceFile) < position && position < node.end) || (!!node.isUnterminated && position === node.end);
    }
    ts.isInsideTemplateLiteral = isInsideTemplateLiteral;
    function isAccessibilityModifier(kind) {
        switch (kind) {
            case 123 /* SyntaxKind.PublicKeyword */:
            case 121 /* SyntaxKind.PrivateKeyword */:
            case 122 /* SyntaxKind.ProtectedKeyword */:
                return true;
        }
        return false;
    }
    ts.isAccessibilityModifier = isAccessibilityModifier;
    function cloneCompilerOptions(options) {
        var result = ts.clone(options);
        ts.setConfigFileInOptions(result, options && options.configFile);
        return result;
    }
    ts.cloneCompilerOptions = cloneCompilerOptions;
    function isArrayLiteralOrObjectLiteralDestructuringPattern(node) {
        if (node.kind === 204 /* SyntaxKind.ArrayLiteralExpression */ ||
            node.kind === 205 /* SyntaxKind.ObjectLiteralExpression */) {
            // [a,b,c] from:
            // [a, b, c] = someExpression;
            if (node.parent.kind === 221 /* SyntaxKind.BinaryExpression */ &&
                node.parent.left === node &&
                node.parent.operatorToken.kind === 63 /* SyntaxKind.EqualsToken */) {
                return true;
            }
            // [a, b, c] from:
            // for([a, b, c] of expression)
            if (node.parent.kind === 244 /* SyntaxKind.ForOfStatement */ &&
                node.parent.initializer === node) {
                return true;
            }
            // [a, b, c] of
            // [x, [a, b, c] ] = someExpression
            // or
            // {x, a: {a, b, c} } = someExpression
            if (isArrayLiteralOrObjectLiteralDestructuringPattern(node.parent.kind === 296 /* SyntaxKind.PropertyAssignment */ ? node.parent.parent : node.parent)) {
                return true;
            }
        }
        return false;
    }
    ts.isArrayLiteralOrObjectLiteralDestructuringPattern = isArrayLiteralOrObjectLiteralDestructuringPattern;
    function isInReferenceComment(sourceFile, position) {
        return isInReferenceCommentWorker(sourceFile, position, /*shouldBeReference*/ true);
    }
    ts.isInReferenceComment = isInReferenceComment;
    function isInNonReferenceComment(sourceFile, position) {
        return isInReferenceCommentWorker(sourceFile, position, /*shouldBeReference*/ false);
    }
    ts.isInNonReferenceComment = isInNonReferenceComment;
    function isInReferenceCommentWorker(sourceFile, position, shouldBeReference) {
        var range = isInComment(sourceFile, position, /*tokenAtPosition*/ undefined);
        return !!range && shouldBeReference === tripleSlashDirectivePrefixRegex.test(sourceFile.text.substring(range.pos, range.end));
    }
    function getReplacementSpanForContextToken(contextToken) {
        if (!contextToken)
            return undefined;
        switch (contextToken.kind) {
            case 10 /* SyntaxKind.StringLiteral */:
            case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
                return createTextSpanFromStringLiteralLikeContent(contextToken);
            default:
                return createTextSpanFromNode(contextToken);
        }
    }
    ts.getReplacementSpanForContextToken = getReplacementSpanForContextToken;
    function createTextSpanFromNode(node, sourceFile, endNode) {
        return ts.createTextSpanFromBounds(node.getStart(sourceFile), (endNode || node).getEnd());
    }
    ts.createTextSpanFromNode = createTextSpanFromNode;
    function createTextSpanFromStringLiteralLikeContent(node) {
        if (node.isUnterminated)
            return undefined;
        return ts.createTextSpanFromBounds(node.getStart() + 1, node.getEnd() - 1);
    }
    ts.createTextSpanFromStringLiteralLikeContent = createTextSpanFromStringLiteralLikeContent;
    function createTextRangeFromNode(node, sourceFile) {
        return ts.createRange(node.getStart(sourceFile), node.end);
    }
    ts.createTextRangeFromNode = createTextRangeFromNode;
    function createTextSpanFromRange(range) {
        return ts.createTextSpanFromBounds(range.pos, range.end);
    }
    ts.createTextSpanFromRange = createTextSpanFromRange;
    function createTextRangeFromSpan(span) {
        return ts.createRange(span.start, span.start + span.length);
    }
    ts.createTextRangeFromSpan = createTextRangeFromSpan;
    function createTextChangeFromStartLength(start, length, newText) {
        return createTextChange(ts.createTextSpan(start, length), newText);
    }
    ts.createTextChangeFromStartLength = createTextChangeFromStartLength;
    function createTextChange(span, newText) {
        return { span: span, newText: newText };
    }
    ts.createTextChange = createTextChange;
    ts.typeKeywords = [
        130 /* SyntaxKind.AnyKeyword */,
        128 /* SyntaxKind.AssertsKeyword */,
        158 /* SyntaxKind.BigIntKeyword */,
        133 /* SyntaxKind.BooleanKeyword */,
        95 /* SyntaxKind.FalseKeyword */,
        137 /* SyntaxKind.InferKeyword */,
        140 /* SyntaxKind.KeyOfKeyword */,
        143 /* SyntaxKind.NeverKeyword */,
        104 /* SyntaxKind.NullKeyword */,
        147 /* SyntaxKind.NumberKeyword */,
        148 /* SyntaxKind.ObjectKeyword */,
        145 /* SyntaxKind.ReadonlyKeyword */,
        150 /* SyntaxKind.StringKeyword */,
        151 /* SyntaxKind.SymbolKeyword */,
        110 /* SyntaxKind.TrueKeyword */,
        114 /* SyntaxKind.VoidKeyword */,
        153 /* SyntaxKind.UndefinedKeyword */,
        154 /* SyntaxKind.UniqueKeyword */,
        155 /* SyntaxKind.UnknownKeyword */,
    ];
    function isTypeKeyword(kind) {
        return ts.contains(ts.typeKeywords, kind);
    }
    ts.isTypeKeyword = isTypeKeyword;
    function isTypeKeywordToken(node) {
        return node.kind === 152 /* SyntaxKind.TypeKeyword */;
    }
    ts.isTypeKeywordToken = isTypeKeywordToken;
    function isTypeKeywordTokenOrIdentifier(node) {
        return isTypeKeywordToken(node) || ts.isIdentifier(node) && node.text === "type";
    }
    ts.isTypeKeywordTokenOrIdentifier = isTypeKeywordTokenOrIdentifier;
    /** True if the symbol is for an external module, as opposed to a namespace. */
    function isExternalModuleSymbol(moduleSymbol) {
        return !!(moduleSymbol.flags & 1536 /* SymbolFlags.Module */) && moduleSymbol.name.charCodeAt(0) === 34 /* CharacterCodes.doubleQuote */;
    }
    ts.isExternalModuleSymbol = isExternalModuleSymbol;
    function nodeSeenTracker() {
        var seen = [];
        return function (node) {
            var id = ts.getNodeId(node);
            return !seen[id] && (seen[id] = true);
        };
    }
    ts.nodeSeenTracker = nodeSeenTracker;
    function getSnapshotText(snap) {
        return snap.getText(0, snap.getLength());
    }
    ts.getSnapshotText = getSnapshotText;
    function repeatString(str, count) {
        var result = "";
        for (var i = 0; i < count; i++) {
            result += str;
        }
        return result;
    }
    ts.repeatString = repeatString;
    function skipConstraint(type) {
        return type.isTypeParameter() ? type.getConstraint() || type : type;
    }
    ts.skipConstraint = skipConstraint;
    function getNameFromPropertyName(name) {
        return name.kind === 162 /* SyntaxKind.ComputedPropertyName */
            // treat computed property names where expression is string/numeric literal as just string/numeric literal
            ? ts.isStringOrNumericLiteralLike(name.expression) ? name.expression.text : undefined
            : ts.isPrivateIdentifier(name) ? ts.idText(name) : ts.getTextOfIdentifierOrLiteral(name);
    }
    ts.getNameFromPropertyName = getNameFromPropertyName;
    function programContainsModules(program) {
        return program.getSourceFiles().some(function (s) { return !s.isDeclarationFile && !program.isSourceFileFromExternalLibrary(s) && !!(s.externalModuleIndicator || s.commonJsModuleIndicator); });
    }
    ts.programContainsModules = programContainsModules;
    function programContainsEsModules(program) {
        return program.getSourceFiles().some(function (s) { return !s.isDeclarationFile && !program.isSourceFileFromExternalLibrary(s) && !!s.externalModuleIndicator; });
    }
    ts.programContainsEsModules = programContainsEsModules;
    function compilerOptionsIndicateEsModules(compilerOptions) {
        return !!compilerOptions.module || ts.getEmitScriptTarget(compilerOptions) >= 2 /* ScriptTarget.ES2015 */ || !!compilerOptions.noEmit;
    }
    ts.compilerOptionsIndicateEsModules = compilerOptionsIndicateEsModules;
    function createModuleSpecifierResolutionHost(program, host) {
        // Mix in `getSymlinkCache` from Program when host doesn't have it
        // in order for non-Project hosts to have a symlinks cache.
        return {
            fileExists: function (fileName) { return program.fileExists(fileName); },
            getCurrentDirectory: function () { return host.getCurrentDirectory(); },
            readFile: ts.maybeBind(host, host.readFile),
            useCaseSensitiveFileNames: ts.maybeBind(host, host.useCaseSensitiveFileNames),
            getSymlinkCache: ts.maybeBind(host, host.getSymlinkCache) || program.getSymlinkCache,
            getModuleSpecifierCache: ts.maybeBind(host, host.getModuleSpecifierCache),
            getPackageJsonInfoCache: function () { var _a; return (_a = program.getModuleResolutionCache()) === null || _a === void 0 ? void 0 : _a.getPackageJsonInfoCache(); },
            getGlobalTypingsCacheLocation: ts.maybeBind(host, host.getGlobalTypingsCacheLocation),
            redirectTargetsMap: program.redirectTargetsMap,
            getProjectReferenceRedirect: function (fileName) { return program.getProjectReferenceRedirect(fileName); },
            isSourceOfProjectReferenceRedirect: function (fileName) { return program.isSourceOfProjectReferenceRedirect(fileName); },
            getNearestAncestorDirectoryWithPackageJson: ts.maybeBind(host, host.getNearestAncestorDirectoryWithPackageJson),
            getFileIncludeReasons: function () { return program.getFileIncludeReasons(); },
        };
    }
    ts.createModuleSpecifierResolutionHost = createModuleSpecifierResolutionHost;
    function getModuleSpecifierResolverHost(program, host) {
        return __assign(__assign({}, createModuleSpecifierResolutionHost(program, host)), { getCommonSourceDirectory: function () { return program.getCommonSourceDirectory(); } });
    }
    ts.getModuleSpecifierResolverHost = getModuleSpecifierResolverHost;
    function moduleResolutionRespectsExports(moduleResolution) {
        return moduleResolution >= ts.ModuleResolutionKind.Node16 && moduleResolution <= ts.ModuleResolutionKind.NodeNext;
    }
    ts.moduleResolutionRespectsExports = moduleResolutionRespectsExports;
    function moduleResolutionUsesNodeModules(moduleResolution) {
        return moduleResolution === ts.ModuleResolutionKind.NodeJs || moduleResolution >= ts.ModuleResolutionKind.Node16 && moduleResolution <= ts.ModuleResolutionKind.NodeNext;
    }
    ts.moduleResolutionUsesNodeModules = moduleResolutionUsesNodeModules;
    function makeImportIfNecessary(defaultImport, namedImports, moduleSpecifier, quotePreference) {
        return defaultImport || namedImports && namedImports.length ? makeImport(defaultImport, namedImports, moduleSpecifier, quotePreference) : undefined;
    }
    ts.makeImportIfNecessary = makeImportIfNecessary;
    function makeImport(defaultImport, namedImports, moduleSpecifier, quotePreference, isTypeOnly) {
        return ts.factory.createImportDeclaration(
        /*decorators*/ undefined, 
        /*modifiers*/ undefined, defaultImport || namedImports
            ? ts.factory.createImportClause(!!isTypeOnly, defaultImport, namedImports && namedImports.length ? ts.factory.createNamedImports(namedImports) : undefined)
            : undefined, typeof moduleSpecifier === "string" ? makeStringLiteral(moduleSpecifier, quotePreference) : moduleSpecifier, 
        /*assertClause*/ undefined);
    }
    ts.makeImport = makeImport;
    function makeStringLiteral(text, quotePreference) {
        return ts.factory.createStringLiteral(text, quotePreference === 0 /* QuotePreference.Single */);
    }
    ts.makeStringLiteral = makeStringLiteral;
    var QuotePreference;
    (function (QuotePreference) {
        QuotePreference[QuotePreference["Single"] = 0] = "Single";
        QuotePreference[QuotePreference["Double"] = 1] = "Double";
    })(QuotePreference = ts.QuotePreference || (ts.QuotePreference = {}));
    function quotePreferenceFromString(str, sourceFile) {
        return ts.isStringDoubleQuoted(str, sourceFile) ? 1 /* QuotePreference.Double */ : 0 /* QuotePreference.Single */;
    }
    ts.quotePreferenceFromString = quotePreferenceFromString;
    function getQuotePreference(sourceFile, preferences) {
        if (preferences.quotePreference && preferences.quotePreference !== "auto") {
            return preferences.quotePreference === "single" ? 0 /* QuotePreference.Single */ : 1 /* QuotePreference.Double */;
        }
        else {
            // ignore synthetic import added when importHelpers: true
            var firstModuleSpecifier = sourceFile.imports &&
                ts.find(sourceFile.imports, function (n) { return ts.isStringLiteral(n) && !ts.nodeIsSynthesized(n.parent); });
            return firstModuleSpecifier ? quotePreferenceFromString(firstModuleSpecifier, sourceFile) : 1 /* QuotePreference.Double */;
        }
    }
    ts.getQuotePreference = getQuotePreference;
    function getQuoteFromPreference(qp) {
        switch (qp) {
            case 0 /* QuotePreference.Single */: return "'";
            case 1 /* QuotePreference.Double */: return '"';
            default: return ts.Debug.assertNever(qp);
        }
    }
    ts.getQuoteFromPreference = getQuoteFromPreference;
    function symbolNameNoDefault(symbol) {
        var escaped = symbolEscapedNameNoDefault(symbol);
        return escaped === undefined ? undefined : ts.unescapeLeadingUnderscores(escaped);
    }
    ts.symbolNameNoDefault = symbolNameNoDefault;
    function symbolEscapedNameNoDefault(symbol) {
        if (symbol.escapedName !== "default" /* InternalSymbolName.Default */) {
            return symbol.escapedName;
        }
        return ts.firstDefined(symbol.declarations, function (decl) {
            var name = ts.getNameOfDeclaration(decl);
            return name && name.kind === 79 /* SyntaxKind.Identifier */ ? name.escapedText : undefined;
        });
    }
    ts.symbolEscapedNameNoDefault = symbolEscapedNameNoDefault;
    function isModuleSpecifierLike(node) {
        return ts.isStringLiteralLike(node) && (ts.isExternalModuleReference(node.parent) ||
            ts.isImportDeclaration(node.parent) ||
            ts.isRequireCall(node.parent, /*requireStringLiteralLikeArgument*/ false) && node.parent.arguments[0] === node ||
            ts.isImportCall(node.parent) && node.parent.arguments[0] === node);
    }
    ts.isModuleSpecifierLike = isModuleSpecifierLike;
    function isObjectBindingElementWithoutPropertyName(bindingElement) {
        return ts.isBindingElement(bindingElement) &&
            ts.isObjectBindingPattern(bindingElement.parent) &&
            ts.isIdentifier(bindingElement.name) &&
            !bindingElement.propertyName;
    }
    ts.isObjectBindingElementWithoutPropertyName = isObjectBindingElementWithoutPropertyName;
    function getPropertySymbolFromBindingElement(checker, bindingElement) {
        var typeOfPattern = checker.getTypeAtLocation(bindingElement.parent);
        return typeOfPattern && checker.getPropertyOfType(typeOfPattern, bindingElement.name.text);
    }
    ts.getPropertySymbolFromBindingElement = getPropertySymbolFromBindingElement;
    function getParentNodeInSpan(node, file, span) {
        if (!node)
            return undefined;
        while (node.parent) {
            if (ts.isSourceFile(node.parent) || !spanContainsNode(span, node.parent, file)) {
                return node;
            }
            node = node.parent;
        }
    }
    ts.getParentNodeInSpan = getParentNodeInSpan;
    function spanContainsNode(span, node, file) {
        return ts.textSpanContainsPosition(span, node.getStart(file)) &&
            node.getEnd() <= ts.textSpanEnd(span);
    }
    function findModifier(node, kind) {
        return node.modifiers && ts.find(node.modifiers, function (m) { return m.kind === kind; });
    }
    ts.findModifier = findModifier;
    function insertImports(changes, sourceFile, imports, blankLineBetween) {
        var decl = ts.isArray(imports) ? imports[0] : imports;
        var importKindPredicate = decl.kind === 237 /* SyntaxKind.VariableStatement */ ? ts.isRequireVariableStatement : ts.isAnyImportSyntax;
        var existingImportStatements = ts.filter(sourceFile.statements, importKindPredicate);
        var sortedNewImports = ts.isArray(imports) ? ts.stableSort(imports, ts.OrganizeImports.compareImportsOrRequireStatements) : [imports];
        if (!existingImportStatements.length) {
            changes.insertNodesAtTopOfFile(sourceFile, sortedNewImports, blankLineBetween);
        }
        else if (existingImportStatements && ts.OrganizeImports.importsAreSorted(existingImportStatements)) {
            for (var _i = 0, sortedNewImports_1 = sortedNewImports; _i < sortedNewImports_1.length; _i++) {
                var newImport = sortedNewImports_1[_i];
                var insertionIndex = ts.OrganizeImports.getImportDeclarationInsertionIndex(existingImportStatements, newImport);
                if (insertionIndex === 0) {
                    // If the first import is top-of-file, insert after the leading comment which is likely the header.
                    var options = existingImportStatements[0] === sourceFile.statements[0] ?
                        { leadingTriviaOption: ts.textChanges.LeadingTriviaOption.Exclude } : {};
                    changes.insertNodeBefore(sourceFile, existingImportStatements[0], newImport, /*blankLineBetween*/ false, options);
                }
                else {
                    var prevImport = existingImportStatements[insertionIndex - 1];
                    changes.insertNodeAfter(sourceFile, prevImport, newImport);
                }
            }
        }
        else {
            var lastExistingImport = ts.lastOrUndefined(existingImportStatements);
            if (lastExistingImport) {
                changes.insertNodesAfter(sourceFile, lastExistingImport, sortedNewImports);
            }
            else {
                changes.insertNodesAtTopOfFile(sourceFile, sortedNewImports, blankLineBetween);
            }
        }
    }
    ts.insertImports = insertImports;
    function getTypeKeywordOfTypeOnlyImport(importClause, sourceFile) {
        ts.Debug.assert(importClause.isTypeOnly);
        return ts.cast(importClause.getChildAt(0, sourceFile), isTypeKeywordToken);
    }
    ts.getTypeKeywordOfTypeOnlyImport = getTypeKeywordOfTypeOnlyImport;
    function textSpansEqual(a, b) {
        return !!a && !!b && a.start === b.start && a.length === b.length;
    }
    ts.textSpansEqual = textSpansEqual;
    function documentSpansEqual(a, b) {
        return a.fileName === b.fileName && textSpansEqual(a.textSpan, b.textSpan);
    }
    ts.documentSpansEqual = documentSpansEqual;
    /**
     * Iterates through 'array' by index and performs the callback on each element of array until the callback
     * returns a truthy value, then returns that value.
     * If no such value is found, the callback is applied to each element of array and undefined is returned.
     */
    function forEachUnique(array, callback) {
        if (array) {
            for (var i = 0; i < array.length; i++) {
                if (array.indexOf(array[i]) === i) {
                    var result = callback(array[i], i);
                    if (result) {
                        return result;
                    }
                }
            }
        }
        return undefined;
    }
    ts.forEachUnique = forEachUnique;
    function isTextWhiteSpaceLike(text, startPos, endPos) {
        for (var i = startPos; i < endPos; i++) {
            if (!ts.isWhiteSpaceLike(text.charCodeAt(i))) {
                return false;
            }
        }
        return true;
    }
    ts.isTextWhiteSpaceLike = isTextWhiteSpaceLike;
    // #endregion
    // Display-part writer helpers
    // #region
    function isFirstDeclarationOfSymbolParameter(symbol) {
        var declaration = symbol.declarations ? ts.firstOrUndefined(symbol.declarations) : undefined;
        return !!ts.findAncestor(declaration, function (n) {
            return ts.isParameter(n) ? true : ts.isBindingElement(n) || ts.isObjectBindingPattern(n) || ts.isArrayBindingPattern(n) ? false : "quit";
        });
    }
    ts.isFirstDeclarationOfSymbolParameter = isFirstDeclarationOfSymbolParameter;
    var displayPartWriter = getDisplayPartWriter();
    function getDisplayPartWriter() {
        var absoluteMaximumLength = ts.defaultMaximumTruncationLength * 10; // A hard cutoff to avoid overloading the messaging channel in worst-case scenarios
        var displayParts;
        var lineStart;
        var indent;
        var length;
        resetWriter();
        var unknownWrite = function (text) { return writeKind(text, ts.SymbolDisplayPartKind.text); };
        return {
            displayParts: function () {
                var finalText = displayParts.length && displayParts[displayParts.length - 1].text;
                if (length > absoluteMaximumLength && finalText && finalText !== "...") {
                    if (!ts.isWhiteSpaceLike(finalText.charCodeAt(finalText.length - 1))) {
                        displayParts.push(displayPart(" ", ts.SymbolDisplayPartKind.space));
                    }
                    displayParts.push(displayPart("...", ts.SymbolDisplayPartKind.punctuation));
                }
                return displayParts;
            },
            writeKeyword: function (text) { return writeKind(text, ts.SymbolDisplayPartKind.keyword); },
            writeOperator: function (text) { return writeKind(text, ts.SymbolDisplayPartKind.operator); },
            writePunctuation: function (text) { return writeKind(text, ts.SymbolDisplayPartKind.punctuation); },
            writeTrailingSemicolon: function (text) { return writeKind(text, ts.SymbolDisplayPartKind.punctuation); },
            writeSpace: function (text) { return writeKind(text, ts.SymbolDisplayPartKind.space); },
            writeStringLiteral: function (text) { return writeKind(text, ts.SymbolDisplayPartKind.stringLiteral); },
            writeParameter: function (text) { return writeKind(text, ts.SymbolDisplayPartKind.parameterName); },
            writeProperty: function (text) { return writeKind(text, ts.SymbolDisplayPartKind.propertyName); },
            writeLiteral: function (text) { return writeKind(text, ts.SymbolDisplayPartKind.stringLiteral); },
            writeSymbol: writeSymbol,
            writeLine: writeLine,
            write: unknownWrite,
            writeComment: unknownWrite,
            getText: function () { return ""; },
            getTextPos: function () { return 0; },
            getColumn: function () { return 0; },
            getLine: function () { return 0; },
            isAtStartOfLine: function () { return false; },
            hasTrailingWhitespace: function () { return false; },
            hasTrailingComment: function () { return false; },
            rawWrite: ts.notImplemented,
            getIndent: function () { return indent; },
            increaseIndent: function () { indent++; },
            decreaseIndent: function () { indent--; },
            clear: resetWriter,
            trackSymbol: function () { return false; },
            reportInaccessibleThisError: ts.noop,
            reportInaccessibleUniqueSymbolError: ts.noop,
            reportPrivateInBaseOfClassExpression: ts.noop,
        };
        function writeIndent() {
            if (length > absoluteMaximumLength)
                return;
            if (lineStart) {
                var indentString = ts.getIndentString(indent);
                if (indentString) {
                    length += indentString.length;
                    displayParts.push(displayPart(indentString, ts.SymbolDisplayPartKind.space));
                }
                lineStart = false;
            }
        }
        function writeKind(text, kind) {
            if (length > absoluteMaximumLength)
                return;
            writeIndent();
            length += text.length;
            displayParts.push(displayPart(text, kind));
        }
        function writeSymbol(text, symbol) {
            if (length > absoluteMaximumLength)
                return;
            writeIndent();
            length += text.length;
            displayParts.push(symbolPart(text, symbol));
        }
        function writeLine() {
            if (length > absoluteMaximumLength)
                return;
            length += 1;
            displayParts.push(lineBreakPart());
            lineStart = true;
        }
        function resetWriter() {
            displayParts = [];
            lineStart = true;
            indent = 0;
            length = 0;
        }
    }
    function symbolPart(text, symbol) {
        return displayPart(text, displayPartKind(symbol));
        function displayPartKind(symbol) {
            var flags = symbol.flags;
            if (flags & 3 /* SymbolFlags.Variable */) {
                return isFirstDeclarationOfSymbolParameter(symbol) ? ts.SymbolDisplayPartKind.parameterName : ts.SymbolDisplayPartKind.localName;
            }
            if (flags & 4 /* SymbolFlags.Property */)
                return ts.SymbolDisplayPartKind.propertyName;
            if (flags & 32768 /* SymbolFlags.GetAccessor */)
                return ts.SymbolDisplayPartKind.propertyName;
            if (flags & 65536 /* SymbolFlags.SetAccessor */)
                return ts.SymbolDisplayPartKind.propertyName;
            if (flags & 8 /* SymbolFlags.EnumMember */)
                return ts.SymbolDisplayPartKind.enumMemberName;
            if (flags & 16 /* SymbolFlags.Function */)
                return ts.SymbolDisplayPartKind.functionName;
            if (flags & 32 /* SymbolFlags.Class */)
                return ts.SymbolDisplayPartKind.className;
            if (flags & 64 /* SymbolFlags.Interface */)
                return ts.SymbolDisplayPartKind.interfaceName;
            if (flags & 384 /* SymbolFlags.Enum */)
                return ts.SymbolDisplayPartKind.enumName;
            if (flags & 1536 /* SymbolFlags.Module */)
                return ts.SymbolDisplayPartKind.moduleName;
            if (flags & 8192 /* SymbolFlags.Method */)
                return ts.SymbolDisplayPartKind.methodName;
            if (flags & 262144 /* SymbolFlags.TypeParameter */)
                return ts.SymbolDisplayPartKind.typeParameterName;
            if (flags & 524288 /* SymbolFlags.TypeAlias */)
                return ts.SymbolDisplayPartKind.aliasName;
            if (flags & 2097152 /* SymbolFlags.Alias */)
                return ts.SymbolDisplayPartKind.aliasName;
            return ts.SymbolDisplayPartKind.text;
        }
    }
    ts.symbolPart = symbolPart;
    function displayPart(text, kind) {
        return { text: text, kind: ts.SymbolDisplayPartKind[kind] };
    }
    ts.displayPart = displayPart;
    function spacePart() {
        return displayPart(" ", ts.SymbolDisplayPartKind.space);
    }
    ts.spacePart = spacePart;
    function keywordPart(kind) {
        return displayPart(ts.tokenToString(kind), ts.SymbolDisplayPartKind.keyword);
    }
    ts.keywordPart = keywordPart;
    function punctuationPart(kind) {
        return displayPart(ts.tokenToString(kind), ts.SymbolDisplayPartKind.punctuation);
    }
    ts.punctuationPart = punctuationPart;
    function operatorPart(kind) {
        return displayPart(ts.tokenToString(k