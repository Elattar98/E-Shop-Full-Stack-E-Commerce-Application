node, locationNode) {
    this.resetStartLocation(node, locationNode.start, locationNode.loc.start);
  }

}

const reservedTypes = new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
const FlowErrors = ParseErrorEnum`flow`(_ => ({
  AmbiguousConditionalArrow: _("Ambiguous expression: wrap the arrow functions in parentheses to disambiguate."),
  AmbiguousDeclareModuleKind: _("Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module."),
  AssignReservedType: _(({
    reservedType
  }) => `Cannot overwrite reserved type ${reservedType}.`),
  DeclareClassElement: _("The `declare` modifier can only appear on class fields."),
  DeclareClassFieldInitializer: _("Initializers are not allowed in fields with the `declare` modifier."),
  DuplicateDeclareModuleExports: _("Duplicate `declare module.exports` statement."),
  EnumBooleanMemberNotInitialized: _(({
    memberName,
    enumName
  }) => `Boolean enum members need to be initialized. Use either \`${memberName} = true,\` or \`${memberName} = false,\` in enum \`${enumName}\`.`),
  EnumDuplicateMemberName: _(({
    memberName,
    enumName
  }) => `Enum member names need to be unique, but the name \`${memberName}\` has already been used before in enum \`${enumName}\`.`),
  EnumInconsistentMemberValues: _(({
    enumName
  }) => `Enum \`${enumName}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`),
  EnumInvalidExplicitType: _(({
    invalidEnumType,
    enumName
  }) => `Enum type \`${invalidEnumType}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`),
  EnumInvalidExplicitTypeUnknownSupplied: _(({
    enumName
  }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`),
  EnumInvalidMemberInitializerPrimaryType: _(({
    enumName,
    memberName,
    explicitType
  }) => `Enum \`${enumName}\` has type \`${explicitType}\`, so the initializer of \`${memberName}\` needs to be a ${explicitType} literal.`),
  EnumInvalidMemberInitializerSymbolType: _(({
    enumName,
    memberName
  }) => `Symbol enum members cannot be initialized. Use \`${memberName},\` in enum \`${enumName}\`.`),
  EnumInvalidMemberInitializerUnknownType: _(({
    enumName,
    memberName
  }) => `The enum member initializer for \`${memberName}\` needs to be a literal (either a boolean, number, or string) in enum \`${enumName}\`.`),
  EnumInvalidMemberName: _(({
    enumName,
    memberName,
    suggestion
  }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${memberName}\`, consider using \`${suggestion}\`, in enum \`${enumName}\`.`),
  EnumNumberMemberNotInitialized: _(({
    enumName,
    memberName
  }) => `Number enum members need to be initialized, e.g. \`${memberName} = 1\` in enum \`${enumName}\`.`),
  EnumStringMemberInconsistentlyInitailized: _(({
    enumName
  }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${enumName}\`.`),
  GetterMayNotHaveThisParam: _("A getter cannot have a `this` parameter."),
  ImportTypeShorthandOnlyInPureImport: _("The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements."),
  InexactInsideExact: _("Explicit inexact syntax cannot appear inside an explicit exact object type."),
  InexactInsideNonObject: _("Explicit inexact syntax cannot appear in class or interface definitions."),
  InexactVariance: _("Explicit inexact syntax cannot have variance."),
  InvalidNonTypeImportInDeclareModule: _("Imports within a `declare module` body must always be `import type` or `import typeof`."),
  MissingTypeParamDefault: _("Type parameter declaration needs a default, since a preceding type parameter declaration has a default."),
  NestedDeclareModule: _("`declare module` cannot be used inside another `declare module`."),
  NestedFlowComment: _("Cannot have a flow comment inside another flow comment."),
  PatternIsOptional: _("A binding pattern parameter cannot be optional in an implementation signature.", {
    reasonCode: "OptionalBindingPattern"
  }),
  SetterMayNotHaveThisParam: _("A setter cannot have a `this` parameter."),
  SpreadVariance: _("Spread properties cannot have variance."),
  ThisParamAnnotationRequired: _("A type annotation is required for the `this` parameter."),
  ThisParamBannedInConstructor: _("Constructors cannot have a `thi