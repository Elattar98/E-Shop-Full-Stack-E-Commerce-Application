eclaration, viaModule, known: getTsHelperFnFromIdentifier(id) };
  }
  getExportsDeclaration(id) {
    if (!isExportsIdentifier(id)) {
      return null;
    }
    const exportsSymbol = this.checker.getSymbolsInScope(id, ts6.SymbolFlags.Variable).find((symbol) => symbol.name === "exports");
    const node = (exportsSymbol == null ? void 0 : exportsSymbol.valueDeclaration) !== void 0 && !ts6.isFunctionExpression(exportsSymbol.valueDeclaration.parent) ? exportsSymbol.valueDeclaration : id.getSourceFile();
    return {
      kind: 0,
      node,
      viaModule: null,
      known: null,
      identity: null
    };
  }
  getUmdModuleDeclaration(id) {
    const importPath = this.getImportPathFromParameter(id) || this.getImportPathFromRequireCall(id);
    if (importPath === null) {
      return null;
    }
    const module = this.resolveModuleName(importPath, id.getSourceFile());
    if (module === void 0) {
      return null;
    }
    const viaModule = isExternalImport(importPath) ? importPath : null;
    return { kind: 0, node: module, viaModule, known: null, identity: null };
  }
  getImportPathFromParameter(id) {
    const importParameter = this.findUmdImportParameter(id);
    if (importParameter === null) {
      return null;
    }
    return this.getUmdImportPath(importParameter);
  }
  getImportPathFromRequireCall(id) {
    const requireCall = findRequireCallReference(id, this.checker);
    if (requireCall === null) {
      return null;
    }
    return requireCall.arguments[0].text;
  }
  getDeclarationOfExpression(expression) {
    const inner = getInnerClassDeclaration(expression);
    if (inner !== null) {
      const outer = getOuterNodeFromInnerDeclaration(inner);
      if (outer !== null && isExportsAssignment(outer)) {
        return {
          kind: 1,
          node: outer.left,
          implementation: inner,
          known: null,
          viaModule: null
        };
      }
    }
    return super.getDeclarationOfExpression(expression);
  }
  resolveModuleName(moduleName, containingFile) {
    if (this.compilerHost.resolveModuleNames) {
      const moduleInfo = this.compilerHost.resolveModuleNames([moduleName], containingFile.fileName, void 0, void 0, this.program.getCompilerOptions())[0];
      return moduleInfo && this.program.getSourceFile(absoluteFrom(moduleInfo.resolvedFileName));
    } else {
      const moduleInfo = ts6.resolveModuleName(moduleName, containingFile.fileName, this.program.getCompilerOptions(), this.compilerHost);
      return moduleInfo.resolvedModule && this.program.getSourceFile(absoluteFrom(moduleInfo.resolvedModule.resolvedFileName));
    }
  }
};
function parseStatementForUmdModule(statement) {
  const wrapper = getUmdWrapper(statement);
  if (wrapper === null)
    return null;
  const factoryFnParamIndex = wrapper.fn.parameters.findIndex((parameter) => ts6.isIdentifier(parameter.name) && parameter.name.text === "factory");
  if (factoryFnParamIndex === -1)
    return null;
  const factoryFn = stripParentheses(wrapper.call.arguments[factoryFnParamIndex]);
  if (!factoryFn || !ts6.isFunctionExpression(factoryFn))
    return null;
  let factoryCalls = null;
  return {
    wrapperFn: wrapper.fn,
    factoryFn,
    get factoryCalls() {
      if (factoryCalls === null) {
        factoryCalls = parseUmdWrapperFunction(this.wrapperFn);
      }
      return factoryCalls;
    }
  };
}
function getUmdWrapper(statement) {
  if (!ts6.isExpressionStatement(statement))
    return null;
  if (ts6.isParenthesizedExpression(statement.expression) && ts6.isCallExpression(statement.expression.expression) && ts6.isFunctionExpression(statement.expression.expression.expression)) {
    const call = statement.expression.expression;
    const fn = statement.expression.expression.expression;
    return { call, fn };
  }
  if (ts6.isCallExpression(statement.expression) && ts6.isParenthesizedExpression(statement.expression.expression) && ts6.isFunctionExpression(statement.expression.expression.expression)) {
    const call = statement.expression;
    const fn = statement.expression.expression.expression;
    return { call, fn };
  }
  return null;
}
function parseUmdWrapperFunction(wrapperFn) {
  const stmt = wrapperFn.body.statements[0];
  let conditionalFactoryCalls;
  if (ts6.isExpressionStatement(stmt) && ts6.isConditionalExpression(stmt.expression)) {
    conditionalFactoryCalls = extractFactoryCallsFromConditionalExpression(stmt.expression);
  } else if (ts6.isIfStatement(stmt)) {
    conditionalFactoryCalls = extractFactoryCallsFromIfStatement(stmt);
  } else {
    throw new Error("UMD wrapper body is not in a supported 