 ts.isTypeNode), nodesVisitor(node.arguments, visitor, ts.isExpression));
                }
                ts.Debug.type(node);
                return factory.updateCallExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodesVisitor(node.typeArguments, visitor, ts.isTypeNode), nodesVisitor(node.arguments, visitor, ts.isExpression));
            case 209 /* SyntaxKind.NewExpression */:
                ts.Debug.type(node);
                return factory.updateNewExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodesVisitor(node.typeArguments, visitor, ts.isTypeNode), nodesVisitor(node.arguments, visitor, ts.isExpression));
            case 210 /* SyntaxKind.TaggedTemplateExpression */:
                ts.Debug.type(node);
                return factory.updateTaggedTemplateExpression(node, nodeVisitor(node.tag, visitor, ts.isExpression), visitNodes(node.typeArguments, visitor, ts.isTypeNode), nodeVisitor(node.template, visitor, ts.isTemplateLiteral));
            case 211 /* SyntaxKind.TypeAssertionExpression */:
                ts.Debug.type(node);
                return factory.updateTypeAssertion(node, nodeVisitor(node.type, visitor, ts.isTypeNode), nodeVisitor(node.expression, visitor, ts.isExpression));
            case 212 /* SyntaxKind.ParenthesizedExpression */:
                ts.Debug.type(node);
                return factory.updateParenthesizedExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression));
            case 213 /* SyntaxKind.FunctionExpression */:
                ts.Debug.type(node);
                return factory.updateFunctionExpression(node, nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.asteriskToken, tokenVisitor, ts.isAsteriskToken), nodeVisitor(node.name, visitor, ts.isIdentifier), nodesVisitor(node.typeParameters, visitor, ts.isTypeParameterDeclaration), visitParameterList(node.parameters, visitor, context, nodesVisitor), nodeVisitor(node.type, visitor, ts.isTypeNode), visitFunctionBody(node.body, visitor, context, nodeVisitor));
            case 214 /* SyntaxKind.ArrowFunction */:
                ts.Debug.type(node);
                return factory.updateArrowFunction(node, nodesVisitor(node.modifiers, visitor, ts.isModifier), nodesVisitor(node.typeParameters, visitor, ts.isTypeParameterDeclaration), visitParameterList(node.parameters, visitor, context, nodesVisitor), nodeVisitor(node.type, visitor, ts.isTypeNode), nodeVisitor(node.equalsGreaterThanToken, tokenVisitor, ts.isEqualsGreaterThanToken), visitFunctionBody(node.body, visitor, context, nodeVisitor));
            case 215 /* SyntaxKind.DeleteExpression */:
                ts.Debug.type(node);
                return factory.updateDeleteExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression));
            case 216 /* SyntaxKind.TypeOfExpression */:
                ts.Debug.type(node);
                return factory.updateTypeOfExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression));
            case 217 /* SyntaxKind.VoidExpression */:
                ts.Debug.type(node);
                return factory.updateVoidExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression));
            case 218 /* SyntaxKind.AwaitExpression */:
                ts.Debug.type(node);
                return factory.updateAwaitExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression));
            case 219 /* SyntaxKind.PrefixUnaryExpression */:
                ts.Debug.type(node);
                return factory.updatePrefixUnaryExpression(node, nodeVisitor(node.operand, visitor, ts.isExpression));
            case 220 /* SyntaxKind.PostfixUnaryExpression */:
                ts.Debug.type(node);
                return factory.updatePostfixUnaryExpression(node, nodeVisitor(node.operand, visitor, ts.isExpression));
            case 221 /* SyntaxKind.BinaryExpression */:
                ts.Debug.type(node);
                return factory.updateBinaryExpression(node, nodeVisitor(node.left, visitor, ts.isExpression), nodeVisitor(node.operatorToken, tokenVisitor, ts.isBinaryOperatorToken), nodeVisitor(node.right, visitor, ts.isExpression));
            case 222 /* SyntaxKind.ConditionalExpression */:
                ts.Debug.type(node);
                return factory.updateConditionalExpression(node, nodeVisitor(node.condition, visitor, ts.isExpression), nodeVisitor(node.questionToken, tokenVisitor, ts.isQuestionToken), nodeVisitor(node.whenTrue, visitor, ts.isExpression), nodeVisitor(node.colonToken, tokenVisitor, ts.isColonToken), nodeVisitor(node.whenFalse, visitor, ts.isExpression));
            case 223 /* SyntaxKind.TemplateExpression */:
                ts.Debug.type(node);
                return factory.updateTemplateExpression(node, nodeVisitor(node.head, visitor, ts.isTemplateHead), nodesVisitor(node.templateSpans, visitor, ts.isTemplateSpan));
            case 224 /* SyntaxKind.YieldExpression */:
                ts.Debug.type(node);
                return factory.updateYieldExpression(node, nodeVisitor(node.asteriskToken, tokenVisitor, ts.isAsteriskToken), nodeVisitor(node.expression, visitor, ts.isExpression));
            case 225 /* SyntaxKind.SpreadElement */:
                ts.Debug.type(node);
                return factory.updateSpreadElement(node, nodeVisitor(node.expression, visitor, ts.isExpression));
            case 226 /* SyntaxKind.ClassExpression */:
                ts.Debug.type(node);
                return factory.updateClassExpression(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.name, visitor, ts.isIdentifier), nodesVisitor(node.typeParameters, visitor, ts.isTypeParameterDeclaration), nodesVisitor(node.heritageClauses, visitor, ts.isHeritageClause), nodesVisitor(node.members, visitor, ts.isClassElement));
            case 228 /* SyntaxKind.ExpressionWithTypeArguments */:
                ts.Debug.type(node);
                return factory.updateExpressionWithTypeArguments(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodesVisitor(node.typeArguments, visitor, ts.isTypeNode));
            case 229 /* SyntaxKind.AsExpression */:
                ts.Debug.type(node);
                return factory.updateAsExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodeVisitor(node.type, visitor, ts.isTypeNode));
            case 230 /* SyntaxKind.NonNullExpression */:
                if (node.flags & 32 /* NodeFlags.OptionalChain */) {
                    ts.Debug.type(node);
                    return factory.updateNonNullChain(node, nodeVisitor(node.expression, visitor, ts.isExpression));
                }
                ts.Debug.type(node);
                return factory.updateNonNullExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression));
            case 231 /* SyntaxKind.MetaProperty */:
                ts.Debug.type(node);
                return factory.updateMetaProperty(node, nodeVisitor(node.name, visitor, ts.isIdentifier));
            // Misc
            case 233 /* SyntaxKind.TemplateSpan */:
                ts.Debug.type(node);
                return factory.updateTemplateSpan(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodeVisitor(node.literal, visitor, ts.isTemplateMiddleOrTemplateTail));
            // Element
            case 235 /* SyntaxKind.Block */:
                ts.Debug.type(node);
                return factory.updateBlock(node, nodesVisitor(node.statements, visitor, ts.isStatement));
            case 237 /* SyntaxKind.VariableStatement */:
                ts.Debug.type(node);
                return factory.updateVariableStatement(node, nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.declarationList, visitor, ts.isVariableDeclarationList));
            case 238 /* SyntaxKind.ExpressionStatement */:
                ts.Debug.type(node);
                return factory.updateExpressionStatement(node, nodeVisitor(node.expression, visitor, ts.isExpression));
            case 239 /* SyntaxKind.IfStatement */:
                ts.Debug.type(node);
                return factory.updateIfStatement(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodeVisitor(node.thenStatement, visitor, ts.isStatement, factory.liftToBlock), nodeVisitor(node.elseStatement, visitor, ts.isStatement, factory.liftToBlock));
            case 240 /* SyntaxKind.DoStatement */:
                ts.Debug.type(node);
                return factory.updateDoStatement(node, visitIterationBody(node.statement, visitor, context), nodeVisitor(node.expression, visitor, ts.isExpression));
            case 241 /* SyntaxKind.WhileStatement */:
                ts.Debug.type(node);
                return factory.updateWhileStatement(node, nodeVisitor(node.expression, visitor, ts.isExpression), visitIterationBody(node.statement, visitor, context));
            case 242 /* SyntaxKind.ForStatement */:
                ts.Debug.type(node);
                return factory.updateForStatement(node, nodeVisitor(node.initializer, visitor, ts.isForInitializer), nodeVisitor(node.condition, visitor, ts.isExpression), nodeVisitor(node.incrementor, visitor, ts.isExpression), visitIterationBody(node.statement, visitor, context));
            case 243 /* SyntaxKind.ForInStatement */:
                ts.Debug.type(node);
                return factory.updateForInStatement(node, nodeVisitor(node.initializer, visitor, ts.isForInitializer), nodeVisitor(node.expression, visitor, ts.isExpression), visitIterationBody(node.statement, visitor, context));
            case 244 /* SyntaxKind.ForOfStatement */:
                ts.Debug.type(node);
                return factory.updateForOfStatement(node, nodeVisitor(node.awaitModifier, tokenVisitor, ts.isAwaitKeyword), nodeVisitor(node.initializer, visitor, ts.isForInitializer), nodeVisitor(node.expression, visitor, ts.isExpression), visitIterationBody(node.statement, visitor, context));
            case 245 /* SyntaxKind.ContinueStatement */:
                ts.Debug.type(node);
                return factory.updateContinueStatement(node, nodeVisitor(node.label, visitor, ts.isIdentifier));
            case 246 /* SyntaxKind.BreakStatement */:
                ts.Debug.type(node);
                return factory.updateBreakStatement(node, nodeVisitor(node.label, visitor, ts.isIdentifier));
            case 247 /* SyntaxKind.ReturnStatement */:
                ts.Debug.type(node);
                return factory.updateReturnStatement(node, nodeVisitor(node.expression, visitor, ts.isExpression));
            case 248 /* SyntaxKind.WithStatement */:
                ts.Debug.type(node);
                return factory.updateWithStatement(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodeVisitor(node.statement, visitor, ts.isStatement, factory.liftToBlock));
            case 249 /* SyntaxKind.SwitchStatement */:
                ts.Debug.type(node);
                return factory.updateSwitchStatement(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodeVisitor(node.caseBlock, visitor, ts.isCaseBlock));
            case 250 /* SyntaxKind.LabeledStatement */:
                ts.Debug.type(node);
                return factory.updateLabeledStatement(node, nodeVisitor(node.label, visitor, ts.isIdentifier), nodeVisitor(node.statement, visitor, ts.isStatement, factory.liftToBlock));
            case 251 /* SyntaxKind.ThrowStatement */:
                ts.Debug.type(node);
                return factory.updateThrowStatement(node, nodeVisitor(node.expression, visitor, ts.isExpression));
            case 252 /* SyntaxKind.TryStatement */:
                ts.Debug.type(node);
                return factory.updateTryStatement(node, nodeVisitor(node.tryBlock, visitor, ts.isBlock), nodeVisitor(node.catchClause, visitor, ts.isCatchClause), nodeVisitor(node.finallyBlock, visitor, ts.isBlock));
            case 254 /* SyntaxKind.VariableDeclaration */:
                ts.Debug.type(node);
                return factory.updateVariableDeclaration(node, nodeVisitor(node.name, visitor, ts.isBindingName), nodeVisitor(node.exclamationToken, tokenVisitor, ts.isExclamationToken), nodeVisitor(node.type, visitor, ts.isTypeNode), nodeVisitor(node.initializer, visitor, ts.isExpression));
            case 255 /* SyntaxKind.VariableDeclarationList */:
                ts.Debug.type(node);
                return factory.updateVariableDeclarationList(node, nodesVisitor(node.declarations, visitor, ts.isVariableDeclaration));
            case 256 /* SyntaxKind.FunctionDeclaration */:
                ts.Debug.type(node);
                return factory.updateFunctionDeclaration(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.asteriskToken, tokenVisitor, ts.isAsteriskToken), nodeVisitor(node.name, visitor, ts.isIdentifier), nodesVisitor(node.typeParameters, visitor, ts.isTypeParameterDeclaration), visitParameterList(node.parameters, visitor, context, nodesVisitor), nodeVisitor(node.type, visitor, ts.isTypeNode), visitFunctionBody(node.body, visitor, context, nodeVisitor));
            case 257 /* SyntaxKind.ClassDeclaration */:
                ts.Debug.type(node);
                return factory.updateClassDeclaration(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.name, visitor, ts.isIdentifier), nodesVisitor(node.typeParameters, visitor, ts.isTypeParameterDeclaration), nodesVisitor(node.heritageClauses, visitor, ts.isHeritageClause), nodesVisitor(node.members, visitor, ts.isClassElement));
            case 258 /* SyntaxKind.InterfaceDeclaration */:
                ts.Debug.type(node);
                return factory.updateInterfaceDeclaration(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.name, visitor, ts.isIdentifier), nodesVisitor(node.typeParameters, visitor, ts.isTypeParameterDeclaration), nodesVisitor(node.heritageClauses, visitor, ts.isHeritageClause), nodesVisitor(node.members, visitor, ts.isTypeElement));
            case 259 /* SyntaxKind.TypeAliasDeclaration */:
                ts.Debug.type(node);
                return factory.updateTypeAliasDeclaration(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.name, visitor, ts.isIdentifier), nodesVisitor(node.typeParameters, visitor, ts.isTypeParameterDeclaration), nodeVisitor(node.type, visitor, ts.isTypeNode));
            case 260 /* SyntaxKind.EnumDeclaration */:
                ts.Debug.type(node);
                return factory.updateEnumDeclaration(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.name, visitor, ts.isIdentifier), nodesVisitor(node.members, visitor, ts.isEnumMember));
            case 261 /* SyntaxKind.ModuleDeclaration */:
                ts.Debug.type(node);
                return factory.updateModuleDeclaration(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.name, visitor, ts.isModuleName), nodeVisitor(node.body, visitor, ts.isModuleBody));
            case 262 /* SyntaxKind.ModuleBlock */:
                ts.Debug.type(node);
                return factory.updateModuleBlock(node, nodesVisitor(node.statements, visitor, ts.isStatement));
            case 263 /* SyntaxKind.CaseBlock */:
                ts.Debug.type(node);
                return factory.updateCaseBlock(node, nodesVisitor(node.clauses, visitor, ts.isCaseOrDefaultClause));
            case 264 /* SyntaxKind.NamespaceExportDeclaration */:
                ts.Debug.type(node);
                return factory.updateNamespaceExportDeclaration(node, nodeVisitor(node.name, visitor, ts.isIdentifier));
            case 265 /* SyntaxKind.ImportEqualsDeclaration */:
                ts.Debug.type(node);
                return factory.updateImportEqualsDeclaration(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), node.isTypeOnly, nodeVisitor(node.name, visitor, ts.isIdentifier), nodeVisitor(node.moduleReference, visitor, ts.isModuleReference));
            case 266 /* SyntaxKind.ImportDeclaration */:
                ts.Debug.type(node);
                return factory.updateImportDeclaration(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.importClause, visitor, ts.isImportClause), nodeVisitor(node.moduleSpecifier, visitor, ts.isExpression), nodeVisitor(node.assertClause, visitor, ts.isAssertClause));
            case 293 /* SyntaxKind.AssertClause */:
                ts.Debug.type(node);
                return factory.updateAssertClause(node, nodesVisitor(node.elements, visitor, ts.isAssertEntry), node.multiLine);
            case 294 /* SyntaxKind.AssertEntry */:
                ts.Debug.type(node);
                return factory.updateAssertEntry(node, nodeVisitor(node.name, visitor, ts.isAssertionKey), nodeVisitor(node.value, visitor, ts.isExpressionNode));
            case 267 /* SyntaxKind.ImportClause */:
                ts.Debug.type(node);
                return factory.updateImportClause(node, node.isTypeOnly, nodeVisitor(node.name, visitor, ts.isIdentifier), nodeVisitor(node.namedBindings, visitor, ts.isNamedImportBindings));
            case 268 /* SyntaxKind.NamespaceImport */:
                ts.Debug.type(node);
                return factory.updateNamespaceImport(node, nodeVisitor(node.name, visitor, ts.isIdentifier));
            case 274 /* SyntaxKind.NamespaceExport */:
                ts.Debug.type(node);
                return factory.updateNamespaceExport(node, nodeVisitor(node.name, visitor, ts.isIdentifier));
            case 269 /* SyntaxKind.NamedImports */:
                ts.Debug.type(node);
                return factory.updateNamedImports(node, nodesVisitor(node.elements, visitor, ts.isImportSpecifier));
            case 270 /* SyntaxKind.ImportSpecifier */:
                ts.Debug.type(node);
                return factory.updateImportSpecifier(node, node.isTypeOnly, nodeVisitor(node.propertyName, visitor, ts.isIdentifier), nodeVisitor(node.name, visitor, ts.isIdentifier));
            case 271 /* SyntaxKind.ExportAssignment */:
                ts.Debug.type(node);
                return factory.updateExportAssignment(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.expression, visitor, ts.isExpression));
            case 272 /* SyntaxKind.ExportDeclaration */:
                ts.Debug.type(node);
                return factory.updateExportDeclaration(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), node.isTypeOnly, nodeVisitor(node.exportClause, visitor, ts.isNamedExportBindings), nodeVisitor(node.moduleSpecifier, visitor, ts.isExpression), nodeVisitor(node.assertClause, visitor, ts.isAssertClause));
            case 273 /* SyntaxKind.NamedExports */:
                ts.Debug.type(node);
                return factory.updateNamedExports(node, nodesVisitor(node.elements, visitor, ts.isExportSpecifier));
            case 275 /* SyntaxKind.ExportSpecifier */:
                ts.Debug.type(node);
                return factory.updateExportSpecifier(node, node.isTypeOnly, nodeVisitor(node.propertyName, visitor, ts.isIdentifier), nodeVisitor(node.name, visitor, ts.isIdentifier));
            // Module references
            case 277 /* SyntaxKind.ExternalModuleReference */:
                ts.Debug.type(node);
                return factory.updateExternalModuleReference(node, nodeVisitor(node.expression, visitor, ts.isExpression));
            // JSX
            case 278 /* SyntaxKind.JsxElement */:
                ts.Debug.type(node);
                return factory.updateJsxElement(node, nodeVisitor(node.openingElement, visitor, ts.isJsxOpeningElement), nodesVisitor(node.children, visitor, ts.isJsxChild), nodeVisitor(node.closingElement, visitor, ts.isJsxClosingElement));
            case 279 /* SyntaxKind.JsxSelfClosingElement */:
                ts.Debug.type(node);
                return factory.updateJsxSelfClosingElement(node, nodeVisitor(node.tagName, visitor, ts.isJsxTagNameExpression), nodesVisitor(node.typeArguments, visitor, ts.isTypeNode), nodeVisitor(node.attributes, visitor, ts.isJsxAttributes));
            case 280 /* SyntaxKind.JsxOpeningElement */:
                ts.Debug.type(node);
                return factory.updateJsxOpeningElement(node, nodeVisitor(node.tagName, visitor, ts.isJsxTagNameExpression), nodesVisitor(node.typeArguments, visitor, ts.isTypeNode), nodeVisitor(node.attributes, visitor, ts.isJsxAttributes));
            case 281 /* SyntaxKind.JsxClosingElement */:
                ts.Debug.type(node);
                return factory.updateJsxClosingElement(node, nodeVisitor(node.tagName, visitor, ts.isJsxTagNameExpression));
            case 282 /* SyntaxKind.JsxFragment */:
                ts.Debug.type(node);
                return factory.updateJsxFragment(node, nodeVisitor(node.openingFragment, visitor, ts.isJsxOpeningFragment), nodesVisitor(node.children, visitor, ts.isJsxChild), nodeVisitor(node.closingFragment, visitor, ts.isJsxClosingFragment));
            case 285 /* SyntaxKind.JsxAttribute */:
                ts.Debug.type(node);
                return factory.updateJsxAttribute(node, nodeVisitor(node.name, visitor, ts.isIdentifier), nodeVisitor(node.initializer, visitor, ts.isStringLiteralOrJsxExpression));
            case 286 /* SyntaxKind.JsxAttributes */:
                ts.Debug.type(node);
                return factory.updateJsxAttributes(node, nodesVisitor(node.properties, visitor, ts.isJsxAttributeLike));
            case 287 /* SyntaxKind.JsxSpreadAttribute */:
                ts.Debug.type(node);
                return factory.updateJsxSpreadAttribute(node, nodeVisitor(node.expression, visitor, ts.isExpression));
            case 288 /* SyntaxKind.JsxExpression */:
                ts.Debug.type(node);
                return factory.updateJsxExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression));
            // Clauses
            case 289 /* SyntaxKind.CaseClause */:
                ts.Debug.type(node);
                return factory.updateCaseClause(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodesVisitor(node.statements, visitor, ts.isStatement));
            case 290 /* SyntaxKind.DefaultClause */:
                ts.Debug.type(node);
                return factory.updateDefaultClause(node, nodesVisitor(node.statements, visitor, ts.isStatement));
            case 291 /* SyntaxKind.HeritageClause */:
                ts.Debug.type(node);
                return factory.updateHeritageClause(node, nodesVisitor(node.types, visitor, ts.isExpressionWithTypeArguments));
            case 292 /* SyntaxKind.CatchClause */:
                ts.Debug.type(node);
                return factory.updateCatchClause(node, nodeVisitor(node.variableDeclaration, visitor, ts.isVariableDeclaration), nodeVisitor(node.block, visitor, ts.isBlock));
            // Property assignments
            case 296 /* SyntaxKind.PropertyAssignment */:
                ts.Debug.type(node);
                return factory.updatePropertyAssignment(node, nodeVisitor(node.name, visitor, ts.isPropertyName), nodeVisitor(node.initializer, visitor, ts.isExpression));
            case 297 /* SyntaxKind.ShorthandPropertyAssignment */:
                ts.Debug.type(node);
                return factory.updateShorthandPropertyAssignment(node, nodeVisitor(node.name, visitor, ts.isIdentifier), nodeVisitor(node.objectAssignmentInitializer, visitor, ts.isExpression));
            case 298 /* SyntaxKind.SpreadAssignment */:
                ts.Debug.type(node);
                return factory.updateSpreadAssignment(node, nodeVisitor(node.expression, visitor, ts.isExpression));
            // Enum
            case 299 /* SyntaxKind.EnumMember */:
                ts.Debug.type(node);
                return factory.updateEnumMember(node, nodeVisitor(node.name, visitor, ts.isPropertyName), nodeVisitor(node.initializer, visitor, ts.isExpression));
            // Top-level nodes
            case 305 /* SyntaxKind.SourceFile */:
                ts.Debug.type(node);
                return factory.updateSourceFile(node, visitLexicalEnvironment(node.statements, visitor, context));
            // Transformation nodes
            case 350 /* SyntaxKind.PartiallyEmittedExpression */:
                ts.Debug.type(node);
                return factory.updatePartiallyEmittedExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression));
            case 351 /* SyntaxKind.CommaListExpression */:
                ts.Debug.type(node);
                return factory.updateCommaListExpression(node, nodesVisitor(node.elements, visitor, ts.isExpression));
            default:
                // No need to visit nodes with no children.
                return node;
        }
    }
    ts.visitEachChild = visitEachChild;
    /**
     * Extracts the single node from a NodeArray.
     *
     * @param nodes The NodeArray.
     */
    function extractSingleNode(nodes) {
        ts.Debug.assert(nodes.length <= 1, "Too many nodes written to output.");
        return ts.singleOrUndefined(nodes);
    }
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    function createSourceMapGenerator(host, file, sourceRoot, sourcesDirectoryPath, generatorOptions) {
        var _a = generatorOptions.extendedDiagnostics
            ? ts.performance.createTimer("Source Map", "beforeSourcemap", "afterSourcemap")
            : ts.performance.nullTimer, enter = _a.enter, exit = _a.exit;
        // Current source map file and its index in the sources list
        var rawSources = [];
        var sources = [];
        var sourceToSourceIndexMap = new ts.Map();
        var sourcesContent;
        var names = [];
        var nameToNameIndexMap;
        var mappingCharCodes = [];
        var mappings = "";
        // Last recorded and encoded mappings
        var lastGeneratedLine = 0;
        var lastGeneratedCharacter = 0;
        var lastSourceIndex = 0;
        var lastSourceLine = 0;
        var lastSourceCharacter = 0;
        var lastNameIndex = 0;
        var hasLast = false;
        var pendingGeneratedLine = 0;
        var pendingGeneratedCharacter = 0;
        var pendingSourceIndex = 0;
        var pendingSourceLine = 0;
        var pendingSourceCharacter = 0;
        var pendingNameIndex = 0;
        var hasPending = false;
        var hasPendingSource = false;
        var hasPendingName = false;
        return {
            getSources: function () { return rawSources; },
            addSource: addSource,
            setSourceContent: setSourceContent,
            addName: addName,
            addMapping: addMapping,
            appendSourceMap: appendSourceMap,
            toJSON: toJSON,
            toString: function () { return JSON.stringify(toJSON()); }
        };
        function addSource(fileName) {
            enter();
            var source = ts.getRelativePathToDirectoryOrUrl(sourcesDirectoryPath, fileName, host.getCurrentDirectory(), host.getCanonicalFileName, 
            /*isAbsolutePathAnUrl*/ true);
            var sourceIndex = sourceToSourceIndexMap.get(source);
            if (sourceIndex === undefined) {
                sourceIndex = sources.length;
                sources.push(source);
                rawSources.push(fileName);
                sourceToSourceIndexMap.set(source, sourceIndex);
            }
            exit();
            return sourceIndex;
        }
        /* eslint-disable boolean-trivia, no-null/no-null */
        function setSourceContent(sourceIndex, content) {
            enter();
            if (content !== null) {
                if (!sourcesContent)
                    sourcesContent = [];
                while (sourcesContent.length < sourceIndex) {
                    sourcesContent.push(null);
                }
                sourcesContent[sourceIndex] = content;
            }
            exit();
        }
        /* eslint-enable boolean-trivia, no-null/no-null */
        function addName(name) {
            enter();
            if (!nameToNameIndexMap)
                nameToNameIndexMap = new ts.Map();
            var nameIndex = nameToNameIndexMap.get(name);
            if (nameIndex === undefined) {
                nameIndex = names.length;
                names.push(name);
                nameToNameIndexMap.set(name, nameIndex);
            }
            exit();
            return nameIndex;
        }
        function isNewGeneratedPosition(generatedLine, generatedCharacter) {
            return !hasPending
                || pendingGeneratedLine !== generatedLine
                || pendingGeneratedCharacter !== generatedCharacter;
        }
        function isBacktrackingSourcePosition(sourceIndex, sourceLine, sourceCharacter) {
            return sourceIndex !== undefined
                && sourceLine !== undefined
                && sourceCharacter !== undefined
                && pendingSourceIndex === sourceIndex
                && (pendingSourceLine > sourceLine
                    || pendingSourceLine === sourceLine && pendingSourceCharacter > sourceCharacter);
        }
        function addMapping(generatedLine, generatedCharacter, sourceIndex, sourceLine, sourceCharacter, nameIndex) {
            ts.Debug.assert(generatedLine >= pendingGeneratedLine, "generatedLine cannot backtrack");
            ts.Debug.assert(generatedCharacter >= 0, "generatedCharacter cannot be negative");
            ts.Debug.assert(sourceIndex === undefined || sourceIndex >= 0, "sourceIndex cannot be negative");
            ts.Debug.assert(sourceLine === undefined || sourceLine >= 0, "sourceLine cannot be negative");
            ts.Debug.assert(sourceCharacter === undefined || sourceCharacter >= 0, "sourceCharacter cannot be negative");
            enter();
            // If this location wasn't recorded or the location in source is going backwards, record the mapping
            if (isNewGeneratedPosition(generatedLine, generatedCharacter) ||
                isBacktrackingSourcePosition(sourceIndex, sourceLine, sourceCharacter)) {
                commitPendingMapping();
                pendingGeneratedLine = generatedLine;
                pendingGeneratedCharacter = generatedCharacter;
                hasPendingSource = false;
                hasPendingName = false;
                hasPending = true;
            }
            if (sourceIndex !== undefined && sourceLine !== undefined && sourceCharacter !== undefined) {
                pendingSourceIndex = sourceIndex;
                pendingSourceLine = sourceLine;
                pendingSourceCharacter = sourceCharacter;
                hasPendingSource = true;
                if (nameIndex !== undefined) {
                    pendingNameIndex = nameIndex;
                    hasPendingName = true;
                }
            }
            exit();
        }
        function appendSourceMap(generatedLine, generatedCharacter, map, sourceMapPath, start, end) {
            ts.Debug.assert(generatedLine >= pendingGeneratedLine, "generatedLine cannot backtrack");
            ts.Debug.assert(generatedCharacter >= 0, "generatedCharacter cannot be negative");
            enter();
            // First, decode the old component sourcemap
            var sourceIndexToNewSourceIndexMap = [];
            var nameIndexToNewNameIndexMap;
            var mappingIterator = decodeMappings(map.mappings);
            for (var iterResult = mappingIterator.next(); !iterResult.done; iterResult = mappingIterator.next()) {
                var raw = iterResult.value;
                if (end && (raw.generatedLine > end.line ||
                    (raw.generatedLine === end.line && raw.generatedCharacter > end.character))) {
                    break;
                }
                if (start && (raw.generatedLine < start.line ||
                    (start.line === raw.generatedLine && raw.generatedCharacter < start.character))) {
                    continue;
                }
                // Then reencode all the updated mappings into the overall map
                var newSourceIndex = void 0;
                var newSourceLine = void 0;
                var newSourceCharacter = void 0;
                var newNameIndex = void 0;
                if (raw.sourceIndex !== undefined) {
                    newSourceIndex = sourceIndexToNewSourceIndexMap[raw.sourceIndex];
                    if (newSourceIndex === undefined) {
                        // Apply offsets to each position and fixup source entries
                        var rawPath = map.sources[raw.sourceIndex];
                        var relativePath = map.sourceRoot ? ts.combinePaths(map.sourceRoot, rawPath) : rawPath;
                        var combinedPath = ts.combinePaths(ts.getDirectoryPath(sourceMapPath), relativePath);
                        sourceIndexToNewSourceIndexMap[raw.sourceIndex] = newSourceIndex = addSource(combinedPath);
                        if (map.sourcesContent && typeof map.sourcesContent[raw.sourceIndex] === "string") {
                            setSourceContent(newSourceIndex, map.sourcesContent[raw.sourceIndex]);
                        }
                    }
                    newSourceLine = raw.sourceLine;
                    newSourceCharacter = raw.sourceCharacter;
                    if (map.names && raw.nameIndex !== undefined) {
                        if (!nameIndexToNewNameIndexMap)
                            nameIndexToNewNameIndexMap = [];
                        newNameIndex = nameIndexToNewNameIndexMap[raw.nameIndex];
                        if (newNameIndex === undefined) {
                            nameIndexToNewNameIndexMap[raw.nameIndex] = newNameIndex = addName(map.names[raw.nameIndex]);
                        }
                    }
                }
                var rawGeneratedLine = raw.generatedLine - (start ? start.line : 0);
                var newGeneratedLine = rawGeneratedLine + generatedLine;
                var rawGeneratedCharacter = start && start.line === raw.generatedLine ? raw.generatedCharacter - start.character : raw.generatedCharacter;
                var newGeneratedCharacter = rawGeneratedLine === 0 ? rawGeneratedCharacter + generatedCharacter : rawGeneratedCharacter;
                addMapping(newGeneratedLine, newGeneratedCharacter, newSourceIndex, newSourceLine, newSourceCharacter, newNameIndex);
            }
            exit();
        }
        function shouldCommitMapping() {
            return !hasLast
                || lastGeneratedLine !== pendingGeneratedLine
                || lastGeneratedCharacter !== pendingGeneratedCharacter
                || lastSourceIndex !== pendingSourceIndex
                || lastSourceLine !== pendingSourceLine
                || lastSourceCharacter !== pendingSourceCharacter
                || lastNameIndex !== pendingNameIndex;
        }
        function appendMappingCharCode(charCode) {
            mappingCharCodes.push(charCode);
            // String.fromCharCode accepts its arguments on the stack, so we have to chunk the input,
            // otherwise we can get stack overflows for large source maps
            if (mappingCharCodes.length >= 1024) {
                flushMappingBuffer();
            }
        }
        function commitPendingMapping() {
            if (!hasPending || !shouldCommitMapping()) {
                return;
            }
            enter();
            // Line/Comma delimiters
            if (lastGeneratedLine < pendingGeneratedLine) {
                // Emit line delimiters
                do {
                    appendMappingCharCode(59 /* CharacterCodes.semicolon */);
                    lastGeneratedLine++;
                } while (lastGeneratedLine < pendingGeneratedLine);
                // Only need to set this once
                lastGeneratedCharacter = 0;
            }
            else {
                ts.Debug.assertEqual(lastGeneratedLine, pendingGeneratedLine, "generatedLine cannot backtrack");
                // Emit comma to separate the entry
                if (hasLast) {
                    appendMappingCharCode(44 /* CharacterCodes.comma */);
                }
            }
            // 1. Relative generated character
            appendBase64VLQ(pendingGeneratedCharacter - lastGeneratedCharacter);
            lastGeneratedCharacter = pendingGeneratedCharacter;
            if (hasPendingSource) {
                // 2. Relative sourceIndex
                appendBase64VLQ(pendingSourceIndex - lastSourceIndex);
                lastSourceIndex = pendingSourceIndex;
                // 3. Relative source line
                appendBase64VLQ(pendingSourceLine - lastSourceLine);
                lastSourceLine = pendingSourceLine;
                // 4. Relative source character
                appendBase64VLQ(pendingSourceCharacter - lastSourceCharacter);
                lastSourceCharacter = pendingSourceCharacter;
                if (hasPendingName) {
                    // 5. Relative nameIndex
                    appendBase64VLQ(pendingNameIndex - lastNameIndex);
                    lastNameIndex = pendingNameIndex;
                }
            }
            hasLast = true;
            exit();
        }
        function flushMappingBuffer() {
            if (mappingCharCodes.length > 0) {
                mappings += String.fromCharCode.apply(undefined, mappingCharCodes);
                mappingCharCodes.length = 0;
            }
        }
        function toJSON() {
            commitPendingMapping();
            flushMappingBuffer();
            return {
                version: 3,
                file: file,
                sourceRoot: sourceRoot,
                sources: sources,
                names: names,
                mappings: mappings,
                sourcesContent: sourcesContent,
            };
        }
        function appendBase64VLQ(inValue) {
            // Add a new least significant bit that has the sign of the value.
            // if negative number the least significant bit that gets added to the number has value 1
            // else least significant bit value that gets added is 0
            // eg. -1 changes to binary : 01 [1] => 3
            //     +1 changes to binary : 01 [0] => 2
            if (inValue < 0) {
                inValue = ((-inValue) << 1) + 1;
            }
            else {
                inValue = inValue << 1;
            }
            // Encode 5 bits at a time starting from least significant bits
            do {
                var currentDigit = inValue & 31; // 11111
                inValue = inValue >> 5;
                if (inValue > 0) {
                    // There are still more digits to decode, set the msb (6th bit)
                    currentDigit = currentDigit | 32;
                }
                appendMappingCharCode(base64FormatEncode(currentDigit));
            } while (inValue > 0);
        }
    }
    ts.createSourceMapGenerator = createSourceMapGenerator;
    // Sometimes tools can see the following line as a source mapping url comment, so we mangle it a bit (the [M])
    var sourceMapCommentRegExp = /^\/\/[@#] source[M]appingURL=(.+)\r?\n?$/;
    var whitespaceOrMapCommentRegExp = /^\s*(\/\/[@#] .*)?$/;
    function getLineInfo(text, lineStarts) {
        return {
            getLineCount: function () { return lineStarts.length; },
            getLineText: function (line) { return text.substring(lineStarts[line], lineStarts[line + 1]); }
        };
    }
    ts.getLineInfo = getLineInfo;
    /**
     * Tries to find the sourceMappingURL comment at the end of a file.
     */
    function tryGetSourceMappingURL(lineInfo) {
        for (var index = lineInfo.getLineCount() - 1; index >= 0; index--) {
            var line = lineInfo.getLineText(index);
            var comment = sourceMapCommentRegExp.exec(line);
            if (comment) {
                return ts.trimStringEnd(comment[1]);
            }
            // If we see a non-whitespace/map comment-like line, break, to avoid scanning up the entire file
            else if (!line.match(whitespaceOrMapCommentRegExp)) {
                break;
            }
        }
    }
    ts.tryGetSourceMappingURL = tryGetSourceMappingURL;
    /* eslint-disable no-null/no-null */
    function isStringOrNull(x) {
        return typeof x === "string" || x === null;
    }
    function isRawSourceMap(x) {
        return x !== null
            && typeof x === "object"
            && x.version === 3
            && typeof x.file === "string"
            && typeof x.mappings === "string"
            && ts.isArray(x.sources) && ts.every(x.sources, ts.isString)
            && (x.sourceRoot === undefined || x.sourceRoot === null || typeof x.sourceRoot === "string")
            && (x.sourcesContent === undefined || x.sourcesContent === null || ts.isArray(x.sourcesContent) && ts.every(x.sourcesContent, isStringOrNull))
            && (x.names === undefined || x.names === null || ts.isArray(x.names) && ts.every(x.names, ts.isString));
    }
    ts.isRawSourceMap = isRawSourceMap;
    /* eslint-enable no-null/no-null */
    function tryParseRawSourceMap(text) {
        try {
            var parsed = JSON.parse(text);
            if (isRawSourceMap(parsed)) {
                return parsed;
            }
        }
        catch (_a) {
            // empty
        }
        return undefined;
    }
    ts.tryParseRawSourceMap = tryParseRawSourceMap;
    function decodeMappings(mappings) {
        var done = false;
        var pos = 0;
        var generatedLine = 0;
        var generatedCharacter = 0;
        var sourceIndex = 0;
        var sourceLine = 0;
        var sourceCharacter = 0;
        var nameIndex = 0;
        var error;
        return {
            get pos() { return pos; },
            get error() { return error; },
            get state() { return captureMapping(/*hasSource*/ true, /*hasName*/ true); },
            next: function () {
                while (!done && pos < mappings.length) {
                    var ch = mappings.charCodeAt(pos);
                    if (ch === 59 /* CharacterCodes.semicolon */) {
                        // new line
                        generatedLine++;
                        generatedCharacter = 0;
                        pos++;
                        continue;
                    }
                    if (ch === 44 /* CharacterCodes.comma */) {
                        // Next entry is on same line - no action needed
                        pos++;
                        continue;
                    }
                    var hasSource = false;
                    var hasName = false;
                    generatedCharacter += base64VLQFormatDecode();
                    if (hasReportedError())
                        return stopIterating();
                    if (generatedCharacter < 0)
                        return setErrorAndStopIterating("Invalid generatedCharacter found");
                    if (!isSourceMappingSegmentEnd()) {
                        hasSource = true;
                        sourceIndex += base64VLQFormatDecode();
                        if (hasReportedError())
                            return stopIterating();
                        if (sourceIndex < 0)
                            return setErrorAndStopIterating("Invalid sourceIndex found");
                        if (isSourceMappingSegmentEnd())
                            return setErrorAndStopIterating("Unsupported Format: No entries after sourceIndex");
                        sourceLine += base64VLQFormatDecode();
                        if (hasReportedError())
                            return stopIterating();
                        if (sourceLine < 0)
                            return setErrorAndStopIterating("Invalid sourceLine found");
                        if (isSourceMappingSegmentEnd())
                            return setErrorAndStopIterating("Unsupported Format: No entries after sourceLine");
                        sourceCharacter += base64VLQFormatDecode();
                        if (hasReportedError())
                            return stopIterating();
                        if (sourceCharacter < 0)
                            return setErrorAndStopIterating("Invalid sourceCharacter found");
                        if (!isSourceMappingSegmentEnd()) {
                            hasName = true;
                            nameIndex += base64VLQFormatDecode();
                            if (hasReportedError())
                                return stopIterating();
                            if (nameIndex < 0)
                                return setErrorAndStopIterating("Invalid nameIndex found");
                            if (!isSourceMappingSegmentEnd())
                                return setErrorAndStopIterating("Unsupported Error Format: Entries after nameIndex");
                        }
                    }
                    return { value: captureMapping(hasSource, hasName), done: done };
                }
                return stopIterating();
            }
        };
        function captureMapping(hasSource, hasName) {
            return {
                generatedLine: generatedLine,
                generatedCharacter: generatedCharacter,
                sourceIndex: hasSource ? sourceIndex : undefined,
                sourceLine: hasSource ? sourceLine : undefined,
                sourceCharacter: hasSource ? sourceCharacter : undefined,
                nameIndex: hasName ? nameIndex : undefined
            };
        }
        function stopIterating() {
            done = true;
            return { value: undefined, done: true };
        }
        function setError(message) {
            if (error === undefined) {
                error = message;
            }
        }
        function setErrorAndStopIterating(message) {
            setError(message);
            return stopIterating();
        }
        function hasReportedError() {
            return error !== undefined;
        }
        function isSourceMappingSegmentEnd() {
            return (pos === mappings.length ||
                mappings.charCodeAt(pos) === 44 /* CharacterCodes.comma */ ||
                mappings.charCodeAt(pos) === 59 /* CharacterCodes.semicolon */);
        }
        function base64VLQFormatDecode() {
            var moreDigits = true;
            var shiftCount = 0;
            var value = 0;
            for (; moreDigits; pos++) {
                if (pos >= mappings.length)
                    return setError("Error in decoding base64VLQFormatDecode, past the mapping string"), -1;
                // 6 digit number
                var currentByte = base64FormatDecode(mappings.charCodeAt(pos));
                if (currentByte === -1)
                    return setError("Invalid character in VLQ"), -1;
                // If msb is set, we still have more bits to continue
                moreDigits = (currentByte & 32) !== 0;
                // least significant 5 bits are the next msbs in the final value.
                value = value | ((currentByte & 31) << shiftCount);
                shiftCount += 5;
            }
            // Least significant bit if 1 represents negative and rest of the msb is actual absolute value
            if ((value & 1) === 0) {
                // + number
                value = value >> 1;
            }
            else {
                // - number
                value = value >> 1;
                value = -value;
            }
            return value;
        }
    }
    ts.decodeMappings = decodeMappings;
    function sameMapping(left, right) {
        return left === right
            || left.generatedLine === right.generatedLine
                && left.generatedCharacter === right.generatedCharacter
                && left.sourceIndex === right.sourceIndex
                && left.sourceLine === right.sourceLine
                && left.sourceCharacter === right.sourceCharacter
                && left.nameIndex === right.nameIndex;
    }
    ts.sameMapping = sameMapping;
    function isSourceMapping(mapping) {
        return mapping.sourceIndex !== undefined
            && mapping.sourceLine !== undefined
            && mapping.sourceCharacter !== undefined;
    }
    ts.isSourceMapping = isSourceMapping;
    function base64FormatEncode(value) {
        return value >= 0 && value < 26 ? 65 /* CharacterCodes.A */ + value :
            value >= 26 && value < 52 ? 97 /* CharacterCodes.a */ + value - 26 :
                value >= 52 && value < 62 ? 48 /* CharacterCodes._0 */ + value - 52 :
                    value === 62 ? 43 /* CharacterCodes.plus */ :
                        value === 63 ? 47 /* CharacterCodes.slash */ :
                            ts.Debug.fail("".concat(value, ": not a base64 value"));
    }
    function base64FormatDecode(ch) {
        return ch >= 65 /* CharacterCodes.A */ && ch <= 90 /* CharacterCodes.Z */ ? ch - 65 /* CharacterCodes.A */ :
            ch >= 97 /* CharacterCodes.a */ && ch <= 122 /* CharacterCodes.z */ ? ch - 97 /* CharacterCodes.a */ + 26 :
                ch >= 48 /* CharacterCodes._0 */ && ch <= 57 /* CharacterCodes._9 */ ? ch - 48 /* CharacterCodes._0 */ + 52 :
                    ch === 43 /* CharacterCodes.plus */ ? 62 :
                        ch === 47 /* CharacterCodes.slash */ ? 63 :
                            -1;
    }
    function isSourceMappedPosition(value) {
        return value.sourceIndex !== undefined
            && value.sourcePosition !== undefined;
    }
    function sameMappedPosition(left, right) {
        return left.generatedPosition === right.generatedPosition
            && left.sourceIndex === right.sourceIndex
            && left.sourcePosition === right.sourcePosition;
    }
    function compareSourcePositions(left, right) {
        // Compares sourcePosition without comparing sourceIndex
        // since the mappings are grouped by sourceIndex
        ts.Debug.assert(left.sourceIndex === right.sourceIndex);
        return ts.compareValues(left.sourcePosition, right.sourcePosition);
    }
    function compareGeneratedPositions(left, right) {
        return ts.compareValues(left.generatedPosition, right.generatedPosition);
    }
    function getSourcePositionOfMapping(value) {
        return value.sourcePosition;
    }
    function getGeneratedPositionOfMapping(value) {
        return value.generatedPosition;
    }
    function createDocumentPositionMapper(host, map, mapPath) {
        var mapDirectory = ts.getDirectoryPath(mapPath);
        var sourceRoot = map.sourceRoot ? ts.getNormalizedAbsolutePath(map.sourceRoot, mapDirectory) : mapDirectory;
        var generatedAbsoluteFilePath = ts.getNormalizedAbsolutePath(map.file, mapDirectory);
        var generatedFile = host.getSourceFileLike(generatedAbsoluteFilePath);
        var sourceFileAbsolutePaths = map.sources.map(function (source) { return ts.getNormalizedAbsolutePath(source, sourceRoot); });
        var sourceToSourceIndexMap = new ts.Map(sourceFileAbsolutePaths.map(function (source, i) { return [host.getCanonicalFileName(source), i]; }));
        var decodedMappings;
        var generatedMappings;
        var sourceMappings;
        return {
            getSourcePosition: getSourcePosition,
            getGeneratedPosition: getGeneratedPosition
        };
        function processMapping(mapping) {
            var generatedPosition = generatedFile !== undefined
                ? ts.getPositionOfLineAndCharacter(generatedFile, mapping.generatedLine, mapping.generatedCharacter, /*allowEdits*/ true)
                : -1;
            var source;
            var sourcePosition;
            if (isSourceMapping(mapping)) {
                var sourceFile = host.getSourceFileLike(sourceFileAbsolutePaths[mapping.sourceIndex]);
                source = map.sources[mapping.sourceIndex];
                sourcePosition = sourceFile !== undefined
                    ? ts.getPositionOfLineAndCharacter(sourceFile, mapping.sourceLine, mapping.sourceCharacter, /*allowEdits*/ true)
                    : -1;
            }
            return {
                generatedPosition: generatedPosition,
                source: source,
                sourceIndex: mapping.sourceIndex,
                sourcePosition: sourcePosition,
                nameIndex: mapping.nameIndex
            };
        }
        function getDecodedMappings() {
            if (decodedMappings === undefined) {
                var decoder = decodeMappings(map.mappings);
                var mappings = ts.arrayFrom(decoder, processMapping);
                if (decoder.error !== undefined) {
                    if (host.log) {
                        host.log("Encountered error while decoding sourcemap: ".concat(decoder.error));
                    }
                    decodedMappings = ts.emptyArray;
                }
                else {
                    decodedMappings = mappings;
                }
            }
            return decodedMappings;
        }
        function getSourceMappings(sourceIndex) {
            if (sourceMappings === undefined) {
                var lists = [];
                for (var _i = 0, _a = getDecodedMappings(); _i < _a.length; _i++) {
                    var mapping = _a[_i];
                    if (!isSourceMappedPosition(mapping))
                        continue;
                    var list = lists[mapping.sourceIndex];
                    if (!list)
                        lists[mapping.sourceIndex] = list = [];
                    list.push(mapping);
                }
                sourceMappings = lists.map(function (list) { return ts.sortAndDeduplicate(list, compareSourcePositions, sameMappedPosition); });
            }
            return sourceMappings[sourceIndex];
        }
        function getGeneratedMappings() {
            if (generatedMappings === undefined) {
                var list = [];
                for (var _i = 0, _a = getDecodedMappings(); _i < _a.length; _i++) {
                    var mapping = _a[_i];
                    list.push(mapping);
                }
                generatedMappings = ts.sortAndDeduplicate(list, compareGeneratedPositions, sameMappedPosition);
            }
            return generatedMappings;
        }
        function getGeneratedPosition(loc) {
            var sourceIndex = sourceToSourceIndexMap.get(host.getCanonicalFileName(loc.fileName));
            if (sourceIndex === undefined)
                return loc;
            var sourceMappings = getSourceMappings(sourceIndex);
            if (!ts.some(sourceMappings))
                return loc;
            var targetIndex = ts.binarySearchKey(sourceMappings, loc.pos, getSourcePositionOfMapping, ts.compareValues);
            if (targetIndex < 0) {
                // if no exact match, closest is 2's complement of result
                targetIndex = ~targetIndex;
            }
            var mapping = sourceMappings[targetIndex];
            if (mapping === undefined || mapping.sourceIndex !== sourceIndex) {
                return loc;
            }
            return { fileName: generatedAbsoluteFilePath, pos: mapping.generatedPosition }; // Closest pos
        }
        function getSourcePosition(loc) {
            var generatedMappings = getGeneratedMappings();
            if (!ts.some(generatedMappings))
                return loc;
            var targetIndex = ts.binarySearchKey(generatedMappings, loc.pos, getGeneratedPositionOfMapping, ts.compareValues);
            if (targetIndex < 0) {
                // if no exact match, closest is 2's complement of result
                targetIndex = ~targetIndex;
            }
            var mapping = generatedMappings[targetIndex];
            if (mapping === undefined || !isSourceMappedPosition(mapping)) {
                return loc;
            }
            return { fileName: sourceFileAbsolutePaths[mapping.sourceIndex], pos: mapping.sourcePosition }; // Closest pos
        }
    }
    ts.createDocumentPositionMapper = createDocumentPositionMapper;
    ts.identitySourceMapConsumer = {
        getSourcePosition: ts.identity,
        getGeneratedPosition: ts.identity
    };
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    function getOriginalNodeId(node) {
        node = ts.getOriginalNode(node);
        return node ? ts.getNodeId(node) : 0;
    }
    ts.getOriginalNodeId = getOriginalNodeId;
    function containsDefaultReference(node) {
        if (!node)
            return false;
        if (!ts.isNamedImports(node))
            return false;
        return ts.some(node.elements, isNamedDefaultReference);
    }
    function isNamedDefaultReference(e) {
        return e.propertyName !== undefined && e.propertyName.escapedText === "default" /* InternalSymbolName.Default */;
    }
    function chainBundle(context, transformSourceFile) {
        return transformSourceFileOrBundle;
        function transformSourceFileOrBundle(node) {
            return node.kind === 305 /* SyntaxKind.SourceFile */ ? transformSourceFile(node) : transformBundle(node);
        }
        function transformBundle(node) {
            return context.factory.createBundle(ts.map(node.sourceFiles, transformSourceFile), node.prepends);
        }
    }
    ts.chainBundle = chainBundle;
    function getExportNeedsImportStarHelper(node) {
        return !!ts.getNamespaceDeclarationNode(node);
    }
    ts.getExportNeedsImportStarHelper = getExportNeedsImportStarHelper;
    function getImportNeedsImportStarHelper(node) {
        if (!!ts.getNamespaceDeclarationNode(node)) {
            return true;
        }
        var bindings = node.importClause && node.importClause.namedBindings;
        if (!bindings) {
            return false;
        }
        if (!ts.isNamedImports(bindings))
            return false;
        var defaultRefCount = 0;
        for (var _i = 0, _a = bindings.elements; _i < _a.length; _i++) {
            var binding = _a[_i];
            if (isNamedDefaultReference(binding)) {
                defaultRefCount++;
            }
        }
        // Import star is required if there's default named refs mixed with non-default refs, or if theres non-default refs and it has a default import
        return (defaultRefCount > 0 && defaultRefCount !== bindings.elements.length) || (!!(bindings.elements.length - defaultRefCount) && ts.isDefaultImport(node));
    }
    ts.getImportNeedsImportStarHelper = getImportNeedsImportStarHelper;
    function getImportNeedsImportDefaultHelper(node) {
        // Import default is needed if there's a default import or a default ref and no other refs (meaning an import star helper wasn't requested)
        return !getImportNeedsImportStarHelper(node) && (ts.isDefaultImport(node) || (!!node.importClause && ts.isNamedImports(node.importClause.namedBindings) && containsDefaultReference(node.importClause.namedBindings))); // TODO: GH#18217
    }
    ts.getImportNeedsImportDefaultHelper = getImportNeedsImportDefaultHelper;
    function collectExternalModuleInfo(context, sourceFile, resolver, compilerOptions) {
        var externalImports = [];
        var exportSpecifiers = ts.createMultiMap();
        var exportedBindings = [];
        var uniqueExports = new ts.Map();
        var exportedNames;
        var hasExportDefault = false;
        var exportEquals;
        var hasExportStarsToExportValues = false;
        var hasImportStar = false;
        var hasImportDefault = false;
        for (var _i = 0, _a = sourceFile.statements; _i < _a.length; _i++) {
            var node = _a[_i];
            switch (node.kind) {
                case 266 /* SyntaxKind.ImportDeclaration */:
                    // import "mod"
                    // import x from "mod"
                    // import * as x from "mod"
                    // import { x, y } from "mod"
                    externalImports.push(node);
                    if (!hasImportStar && getImportNeedsImportStarHelper(node)) {
                        hasImportStar = true;
                    }
                    if (!hasImportDefault && getImportNeedsImportDefaultHelper(node)) {
                        hasImportDefault = true;
                    }
                    break;
                case 265 /* SyntaxKind.ImportEqualsDeclaration */:
                    if (node.moduleReference.kind === 277 /* SyntaxKind.ExternalModuleReference */) {
                        // import x = require("mod")
                        externalImports.push(node);
                    }
                    break;
                case 272 /* SyntaxKind.ExportDeclaration */:
                    if (node.moduleSpecifier) {
                        if (!node.exportClause) {
                            // export * from "mod"
                            externalImports.push(node);
                            hasExportStarsToExportValues = true;
                        }
                        else {
                            // export * as ns from "mod"
                            // export { x, y } from "mod"
                            externalImports.push(node);
                            if (ts.isNamedExports(node.exportClause)) {
                                addExportedNamesForExportDeclaration(node);
                            }
                            else {
                                var name = node.exportClause.name;
                                if (!uniqueExports.get(ts.idText(name))) {
                                    multiMapSparseArrayAdd(exportedBindings, getOriginalNodeId(node), name);
                                    uniqueExports.set(ts.idText(name), true);
                                    exportedNames = ts.append(exportedNames, name);
                                }
                                // we use the same helpers for `export * as ns` as we do for `import * as ns`
                                hasImportStar = true;
                            }
                        }
                    }
                    else {
                        // export { x, y }
                        addExportedNamesForExportDeclaration(node);
                    }
                    break;
                case 271 /* SyntaxKind.ExportAssignment */:
                    if (node.isExportEquals && !exportEquals) {
                        // export = x
                        exportEquals = node;
                    }
                    break;
                case 237 /* SyntaxKind.VariableStatement */:
                    if (ts.hasSyntacticModifier(node, 1 /* ModifierFlags.Export */)) {
                        for (var _b = 0, _c = node.declarationList.declarations; _b < _c.length; _b++) {
                            var decl = _c[_b];
                            exportedNames = collectExportedVariableInfo(decl, uniqueExports, exportedNames);
                        }
                    }
                    break;
                case 256 /* SyntaxKind.FunctionDeclaration */:
                    if (ts.hasSyntacticModifier(node, 1 /* ModifierFlags.Export */)) {
                        if (ts.hasSyntacticModifier(node, 512 /* ModifierFlags.Default */)) {
                            // export default function() { }
                            if (!hasExportDefault) {
                                multiMapSparseArrayAdd(exportedBindings, getOriginalNodeId(node), context.factory.getDeclarationName(node));
                                hasExportDefault = true;
                            }
                        }
                        else {
                            // export function x() { }
                            var name = node.name;
                            if (!uniqueExports.get(ts.idText(name))) {
                                multiMapSparseArrayAdd(exportedBindings, getOriginalNodeId(node), name);
                                uniqueExports.set(ts.idText(name), true);
                                exportedNames = ts.append(exportedNames, name);
                            }
                        }
                    }
                    break;
                case 257 /* SyntaxKind.ClassDeclaration */:
                    if (ts.hasSyntacticModifier(node, 1 /* ModifierFlags.Export */)) {
                        if (ts.hasSyntacticModifier(node, 512 /* ModifierFlags.Default */)) {
                            // export default class { }
                            if (!hasExportDefault) {
                                multiMapSparseArrayAdd(exportedBindings, getOriginalNodeId(node), context.factory.getDeclarationName(node));
                                hasExportDefault = true;
                            }
                        }
                        else {
                            // export class x { }
                            var name = node.name;
                            if (name && !uniqueExports.get(ts.idText(name))) {
                                multiMapSparseArrayAdd(exportedBindings, getOriginalNodeId(node), name);
                                uniqueExports.set(ts.idText(name), true);
                                exportedNames = ts.append(exportedNames, name);
                            }
                        }
                    }
                    break;
            }
        }
        var externalHelpersImportDeclaration = ts.createExternalHelpersImportDeclarationIfNeeded(context.factory, context.getEmitHelperFactory(), sourceFile, compilerOptions, hasExportStarsToExportValues, hasImportStar, hasImportDefault);
        if (externalHelpersImportDeclaration) {
            externalImports.unshift(externalHelpersImportDeclaration);
        }
        return { externalImports: externalImports, exportSpecifiers: exportSpecifiers, exportEquals: exportEquals, hasExportStarsToExportValues: hasExportStarsToExportValues, exportedBindings: exportedBindings, exportedNames: exportedNames, externalHelpersImportDeclaration: externalHelpersImportDeclaration };
        function addExportedNamesForExportDeclaration(node) {
            for (var _i = 0, _a = ts.cast(node.exportClause, ts.isNamedExports).elements; _i < _a.length; _i++) {
                var specifier = _a[_i];
                if (!uniqueExports.get(ts.idText(specifier.name))) {
                    var name = specifier.propertyName || specifier.name;
                    if (!node.moduleSpecifier) {
                        exportSpecifiers.add(ts.idText(name), specifier);
                    }
                    var decl = resolver.getReferencedImportDeclaration(name)
                        || resolver.getReferencedValueDeclaration(name);
                    if (decl) {
                        multiMapSparseArrayAdd(exportedBindings, getOriginalNodeId(decl), specifier.name);
                    }
                    uniqueExports.set(ts.idText(specifier.name), true);
                    exportedNames = ts.append(exportedNames, specifier.name);
                }
            }
        }
    }
    ts.collectExternalModuleInfo = collectExternalModuleInfo;
    function collectExportedVariableInfo(decl, uniqueExports, exportedNames) {
        if (ts.isBindingPattern(decl.name)) {
            for (var _i = 0, _a = decl.name.elements; _i < _a.length; _i++) {
                var element = _a[_i];
                if (!ts.isOmittedExpression(element)) {
                    exportedNames = collectExportedVariableInfo(element, uniqueExports, exportedNames);
                }
            }
        }
        else if (!ts.isGeneratedIdentifier(decl.name)) {
            var text = ts.idText(decl.name);
            if (!uniqueExports.get(text)) {
                uniqueExports.set(text, true);
                exportedNames = ts.append(exportedNames, decl.name);
            }
        }
        return exportedNames;
    }
    /** Use a sparse array as a multi-map. */
    function multiMapSparseArrayAdd(map, key, value) {
        var values = map[key];
        if (values) {
            values.push(value);
        }
        else {
            map[key] = values = [value];
        }
        return values;
    }
    /**
     * Used in the module transformer to check if an expression is reasonably without sideeffect,
     *  and thus better to copy into multiple places rather than to cache in a temporary variable
     *  - this is mostly subjective beyond the requirement that the expression not be sideeffecting
     */
    function isSimpleCopiableExpression(expression) {
        return ts.isStringLiteralLike(expression) ||
            expression.kind === 8 /* SyntaxKind.NumericLiteral */ ||
            ts.isKeyword(expression.kind) ||
            ts.isIdentifier(expression);
    }
    ts.isSimpleCopiableExpression = isSimpleCopiableExpression;
    /**
     * A simple inlinable expression is an expression which can be copied into multiple locations
     * without risk of repeating any sideeffects and whose value could not possibly change between
     * any such locations
     */
    function isSimpleInlineableExpression(expression) {
        return !ts.isIdentifier(expression) && isSimpleCopiableExpression(expression);
    }
    ts.isSimpleInlineableExpression = isSimpleInlineableExpression;
    function isCompoundAssignment(kind) {
        return kind >= 64 /* SyntaxKind.FirstCompoundAssignment */
            && kind <= 78 /* SyntaxKind.LastCompoundAssignment */;
    }
    ts.isCompoundAssignment = isCompoundAssignment;
    function getNonAssignmentOperatorForCompoundAssignment(kind) {
        switch (kind) {
            case 64 /* SyntaxKind.PlusEqualsToken */: return 39 /* SyntaxKind.PlusToken */;
            case 65 /* SyntaxKind.MinusEqualsToken */: return 40 /* SyntaxKind.MinusToken */;
            case 66 /* SyntaxKind.AsteriskEqualsToken */: return 41 /* SyntaxKind.AsteriskToken */;
            case 67 /* SyntaxKind.AsteriskAsteriskEqualsToken */: return 42 /* SyntaxKind.AsteriskAsteriskToken */;
            case 68 /* SyntaxKind.SlashEqualsToken */: return 43 /* SyntaxKind.SlashToken */;
            case 69 /* SyntaxKind.PercentEqualsToken */: return 44 /* SyntaxKind.PercentToken */;
            case 70 /* SyntaxKind.LessThanLessThanEqualsToken */: return 47 /* SyntaxKind.LessThanLessThanToken */;
            case 71 /* SyntaxKind.GreaterThanGreaterThanEqualsToken */: return 48 /* SyntaxKind.GreaterThanGreaterThanToken */;
            case 72 /* SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken */: return 49 /* SyntaxKind.GreaterThanGreaterThanGreaterThanToken */;
            case 73 /* SyntaxKind.AmpersandEqualsToken */: return 50 /* SyntaxKind.AmpersandToken */;
            case 74 /* SyntaxKind.BarEqualsToken */: return 51 /* SyntaxKind.BarToken */;
            case 78 /* SyntaxKind.CaretEqualsToken */: return 52 /* SyntaxKind.CaretToken */;
            case 75 /* SyntaxKind.BarBarEqualsToken */: return 56 /* SyntaxKind.BarBarToken */;
            case 76 /* SyntaxKind.AmpersandAmpersandEqualsToken */: return 55 /* SyntaxKind.AmpersandAmpersandToken */;
            case 77 /* SyntaxKind.QuestionQuestionEqualsToken */: return 60 /* SyntaxKind.QuestionQuestionToken */;
        }
    }
    ts.getNonAssignmentOperatorForCompoundAssignment = getNonAssignmentOperatorForCompoundAssignment;
    /**
     * @returns Contained super() call from descending into the statement ignoring parentheses, if that call exists.
     */
    function getSuperCallFromStatement(statement) {
        if (!ts.isExpressionStatement(statement)) {
            return undefined;
        }
        var expression = ts.skipParentheses(statement.expression);
        return ts.isSuperCall(expression)
            ? expression
            : undefined;
    }
    ts.getSuperCallFromStatement = getSuperCallFromStatement;
    /**
     * @returns The index (after prologue statements) of a super call, or -1 if not found.
     */
    function findSuperStatementIndex(statements, indexAfterLastPrologueStatement) {
        for (var i = indexAfterLastPrologueStatement; i < statements.length; i += 1) {
            var statement = statements[i];
            if (getSuperCallFromStatement(statement)) {
                return i;
            }
        }
        return -1;
    }
    ts.findSuperStatementIndex = findSuperStatementIndex;
    function getProperties(node, requireInitializer, isStatic) {
        return ts.filter(node.members, function (m) { return isInitializedOrStaticProperty(m, requireInitializer, isStatic); });
    }
    ts.getProperties = getProperties;
    function isStaticPropertyDeclarationOrClassStaticBlockDeclaration(element) {
        return isStaticPropertyDeclaration(element) || ts.isClassStaticBlockDeclaration(element);
    }
    function getStaticPropertiesAndClassStaticBlock(node) {
        return ts.filter(node.members, isStaticPropertyDeclarationOrClassStaticBlockDeclaration);
    }
    ts.getStaticPropertiesAndClassStaticBlock = getStaticPropertiesAndClassStaticBlock;
    /**
     * Is a class element either a static or an instance property declaration with an initializer?
     *
     * @param member The class element node.
     * @param isStatic A value indicating whether the member should be a static or instance member.
     */
    function isInitializedOrStaticProperty(member, requireInitializer, isStatic) {
        return ts.isPropertyDeclaration(member)
            && (!!member.initializer || !requireInitializer)
            && ts.hasStaticModifier(member) === isStatic;
    }
    function isStaticPropertyDeclaration(member) {
        return ts.isPropertyDeclaration(member) && ts.hasStaticModifier(member);
    }
    /**
     * Gets a value indicating whether a class element is either a static or an instance property declaration with an initializer.
     *
     * @param member The class element node.
     * @param isStatic A value indicating whether the member should be a static or instance member.
     */
    function isInitializedProperty(member) {
        return member.kind === 167 /* SyntaxKind.PropertyDeclaration */
            && member.initializer !== undefined;
    }
    ts.isInitializedProperty = isInitializedProperty;
    /**
     * Gets a value indicating whether a class element is a private instance method or accessor.
     *
     * @param member The class element node.
     */
    function isNonStaticMethodOrAccessorWithPrivateName(member) {
        return !ts.isStatic(member) && ts.isMethodOrAccessor(member) && ts.isPrivateIdentifier(member.name);
    }
    ts.isNonStaticMethodOrAccessorWithPrivateName = isNonStaticMethodOrAccessorWithPrivateName;
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    var FlattenLevel;
    (function (FlattenLevel) {
        FlattenLevel[FlattenLevel["All"] = 0] = "All";
        FlattenLevel[FlattenLevel["ObjectRest"] = 1] = "ObjectRest";
    })(FlattenLevel = ts.FlattenLevel || (ts.FlattenLevel = {}));
    /**
     * Flattens a DestructuringAssignment or a VariableDeclaration to an expression.
     *
     * @param node The node to flatten.
     * @param visitor An optional visitor used to visit initializers.
     * @param context The transformation context.
     * @param level Indicates the extent to which flattening should occur.
     * @param needsValue An optional value indicating whether the value from the right-hand-side of
     * the destructuring assignment is needed as part of a larger expression.
     * @param createAssignmentCallback An optional callback used to create the assignment expression.
     */
    function flattenDestructuringAssignment(node, visitor, context, level, needsValue, createAssignmentCallback) {
        var location = node;
        var value;
        if (ts.isDestructuringAssignment(node)) {
            value = node.right;
            while (ts.isEmptyArrayLiteral(node.left) || ts.isEmptyObjectLiteral(node.left)) {
                if (ts.isDestructuringAssignment(value)) {
                    location = node = value;
                    value = node.right;
                }
                else {
                    return ts.visitNode(value, visitor, ts.isExpression);
                }
            }
        }
        var expressions;
        var flattenContext = {
            context: context,
            level: level,
            downlevelIteration: !!context.getCompilerOptions().downlevelIteration,
            hoistTempVariables: true,
            emitExpression: emitExpression,
            emitBindingOrAssignment: emitBindingOrAssignment,
            createArrayBindingOrAssignmentPattern: function (elements) { return makeArrayAssignmentPattern(context.factory, elements); },
            createObjectBindingOrAssignmentPattern: function (elements) { return makeObjectAssignmentPattern(context.factory, elements); },
            createArrayBindingOrAssignmentElement: makeAssignmentElement,
            visitor: visitor
        };
        if (value) {
            value = ts.visitNode(value, visitor, ts.isExpression);
            if (ts.isIdentifier(value) && bindingOrAssignmentElementAssignsToName(node, value.escapedText) ||
                bindingOrAssignmentElementContainsNonLiteralComputedName(node)) {
                // If the right-hand value of the assignment is also an assignment target then
                // we need to cache the right-hand value.
                value = ensureIdentifier(flattenContext, value, /*reuseIdentifierExpressions*/ false, location);
            }
            else if (needsValue) {
                // If the right-hand value of the destructuring assignment needs to be preserved (as
                // is the case when the destructuring assignment is part of a larger expression),
                // then we need to cache the right-hand value.
                //
                // The source map location for the assignment should point to the entire binary
                // expression.
                value = ensureIdentifier(flattenContext, value, /*reuseIdentifierExpressions*/ true, location);
            }
            else if (ts.nodeIsSynthesized(node)) {
                // Generally, the source map location for a destructuring assignment is the root
                // expression.
                //
                // However, if the root expression is synthesized (as in the case
                // of the initializer when transforming a ForOfStatement), then the source map
                // location should point to the right-hand value of the expression.
                location = value;
            }
        }
        flattenBindingOrAssignmentElement(flattenContext, node, value, location, /*skipInitializer*/ ts.isDestructuringAssignment(node));
        if (value && needsValue) {
            if (!ts.some(expressions)) {
                return value;
            }
            expressions.push(value);
        }
        return context.factory.inlineExpressions(expressions) || context.factory.createOmittedExpression();
        function emitExpression(expression) {
            expressions = ts.append(expressions, expression);
        }
        function emitBindingOrAssignment(target, value, location, original) {
            ts.Debug.assertNode(target, createAssignmentCallback ? ts.isIdentifier : ts.isExpression);
            var expression = createAssignmentCallback
                ? createAssignmentCallback(target, value, location)
                : ts.setTextRange(context.factory.createAssignment(ts.visitNode(target, visitor, ts.isExpression), value), location);
            expression.original = original;
            emitExpression(expression);
        }
    }
    ts.flattenDestructuringAssignment = flattenDestructuringAssignment;
    function bindingOrAssignmentElementAssignsToName(element, escapedName) {
        var target = ts.getTargetOfBindingOrAssignmentElement(element); // TODO: GH#18217
        if (ts.isBindingOrAssignmentPattern(target)) {
            return bindingOrAssignmentPatternAssignsToName(target, escapedName);
        }
        else if (ts.isIdentifier(target)) {
            return target.escapedText === escapedName;
        }
        return false;
    }
    function bindingOrAssignmentPatternAssignsToName(pattern, escapedName) {
        var elements = ts.getElementsOfBindingOrAssignmentPattern(pattern);
        for (var _i = 0, elements_4 = elements; _i < elements_4.length; _i++) {
            var element = elements_4[_i];
            if (bindingOrAssignmentElementAssignsToName(element, escapedName)) {
                return true;
            }
        }
        return false;
    }
    function bindingOrAssignmentElementContainsNonLiteralComputedName(element) {
        var propertyName = ts.tryGetPropertyNameOfBindingOrAssignmentElement(element);
        if (propertyName && ts.isComputedPropertyName(propertyName) && !ts.isLiteralExpression(propertyName.expression)) {
            return true;
        }
        var target = ts.getTargetOfBindingOrAssignmentElement(element);
        return !!target && ts.isBindingOrAssignmentPattern(target) && bindingOrAssignmentPatternContainsNonLiteralComputedName(target);
    }
    function bindingOrAssignmentPatternContainsNonLiteralComputedName(pattern) {
        return !!ts.forEach(ts.getElementsOfBindingOrAssignmentPattern(pattern), bindingOrAssignmentElementContainsNonLiteralComputedName);
    }
    /**
     * Flattens a VariableDeclaration or ParameterDeclaration to one or more variable declarations.
     *
     * @param node The node to flatten.
     * @param visitor An optional visitor used to visit initializers.
     * @param context The transformation context.
     * @param boundValue The value bound to the declaration.
     * @param skipInitializer A value indicating whether to ignore the initializer of `node`.
     * @param hoistTempVariables Indicates whether temporary variables should not be recorded in-line.
     * @param level Indicates the extent to which flattening should occur.
     */
    function flattenDestructuringBinding(node, visitor, context, level, rval, hoistTempVariables, skipInitializer) {
        if (hoistTempVariables === void 0) { hoistTempVariables = false; }
        var pendingExpressions;
        var pendingDeclarations = [];
        var declarations = [];
        var flattenContext = {
            context: context,
            level: level,
            downlevelIteration: !!context.getCompilerOptions().downlevelIteration,
            hoistTempVariables: hoistTempVariables,
            emitExpression: emitExpression,
            emitBindingOrAssignment: emitBindingOrAssignment,
            createArrayBindingOrAssignmentPattern: function (elements) { return makeArrayBindingPattern(context.factory, elements); },
            createObjectBindingOrAssignmentPattern: function (elements) { return makeObjectBindingPattern(context.factory, elements); },
            createArrayBindingOrAssignmentElement: function (name) { return makeBindingElement(context.factory, name); },
            visitor: visitor
        };
        if (ts.isVariableDeclaration(node)) {
            var initializer = ts.getInitializerOfBindingOrAssignmentElement(node);
            if (initializer && (ts.isIdentifier(initializer) && bindingOrAssignmentElementAssignsToName(node, initializer.escapedText) ||
                bindingOrAssignmentElementContainsNonLiteralComputedName(node))) {
                // If the right-hand value of the assignment is also an assignment target then
                // we need to cache the right-hand value.
                initializer = ensureIdentifier(flattenContext, ts.visitNode(initializer, flattenContext.visitor), /*reuseIdentifierExpressions*/ false, initializer);
                node = context.factory.updateVariableDeclaration(node, node.name, /*exclamationToken*/ undefined, /*type*/ undefined, initializer);
            }
        }
        flattenBindingOrAssignmentElement(flattenContext, node, rval, node, skipInitializer);
        if (pendingExpressions) {
            var temp = context.factory.createTempVariable(/*recordTempVariable*/ undefined);
            if (hoistTempVariables) {
                var value = context.factory.inlineExpressions(pendingExpressions);
                pendingExpressions = undefined;
                emitBindingOrAssignment(temp, value, /*location*/ undefined, /*original*/ undefined);
            }
            else {
                context.hoistVariableDeclaration(temp);
                var pendingDeclaration = ts.last(pendingDeclarations);
                pendingDeclaration.pendingExpressions = ts.append(pendingDeclaration.pendingExpressions, context.factory.createAssignment(temp, pendingDeclaration.value));
                ts.addRange(pendingDeclaration.pendingExpressions, pendingExpressions);
                pendingDeclaration.value = temp;
            }
        }
        for (var _i = 0, pendingDeclarations_1 = pendingDeclarations; _i < pendingDeclarations_1.length; _i++) {
            var _a = pendingDeclarations_1[_i], pendingExpressions_1 = _a.pendingExpressions, name = _a.name, value = _a.value, location = _a.location, original = _a.original;
            var variable = context.factory.createVariableDeclaration(name, 
            /*exclamationToken*/ undefined, 
            /*type*/ undefined, pendingExpressions_1 ? context.factory.inlineExpressions(ts.append(pendingExpressions_1, value)) : value);
            variable.original = original;
            ts.setTextRange(variable, location);
            declarations.push(variable);
        }
        return declarations;
        function emitExpression(value) {
            pendingExpressions = ts.append(pendingExpressions, value);
        }
        function emitBindingOrAssignment(target, value, location, original) {
            ts.Debug.assertNode(target, ts.isBindingName);
            if (pendingExpressions) {
                value = context.factory.inlineExpressions(ts.append(pendingExpressions, value));
                pendingExpressions = undefined;
            }
            pendingDeclarations.push({ pendingExpressions: pendingExpressions, name: target, value: value, location: location, original: original });
        }
    }
    ts.flattenDestructuringBinding = flattenDestructuringBinding;
    /**
     * Flattens a BindingOrAssignmentElement into zero or more bindings or assignments.
     *
     * @param flattenContext Options used to control flattening.
     * @param element The element to flatten.
     * @param value The current RHS value to assign to the element.
     * @param location The location to use for source maps and comments.
     * @param skipInitializer An optional value indicating whether to include the initializer
     * for the element.
     */
    function flattenBindingOrAssignmentElement(flattenContext, element, value, location, skipInitializer) {
        var bindingTarget = ts.getTargetOfBindingOrAssignmentElement(element); // TODO: GH#18217
        if (!skipInitializer) {
            var initializer = ts.visitNode(ts.getInitializerOfBindingOrAssignmentElement(element), flattenContext.visitor, ts.isExpression);
            if (initializer) {
                // Combine value and initializer
                if (value) {
                    value = createDefaultValueCheck(flattenContext, value, initializer, location);
                    // If 'value' is not a simple expression, it could contain side-effecting code that should evaluate before an object or array binding pattern.
                    if (!ts.isSimpleInlineableExpression(initializer) && ts.isBindingOrAssignmentPattern(bindingTarget)) {
                        value = ensureIdentifier(flattenContext, value, /*reuseIdentifierExpressions*/ true, location);
                    }
                }
                else {
                    value = initializer;
                }
            }
            else if (!value) {
                // Use 'void 0' in absence of value and initializer
                value = flattenContext.context.factory.createVoidZero();
            }
        }
        if (ts.isObjectBindingOrAssignmentPattern(bindingTarget)) {
            flattenObjectBindingOrAssignmentPattern(flattenContext, element, bindingTarget, value, location);
        }
        else if (ts.isArrayBindingOrAssignmentPattern(bindingTarget)) {
            flattenArrayBindingOrAssignmentPattern(flattenContext, element, bindingTarget, value, location);
        }
        else {
            flattenContext.emitBindingOrAssignment(bindingTarget, value, location, /*original*/ element); // TODO: GH#18217
        }
    }
    /**
     * Flattens an ObjectBindingOrAssignmentPattern into zero or more bindings or assignments.
     *
     * @param flattenContext Options used to control flattening.
     * @param parent The parent element of the pattern.
     * @param pattern The ObjectBindingOrAssignmentPattern to flatten.
     * @param value The current RHS value to assign to the element.
     * @param location The location to use for source maps and comments.
     */
    function flattenObjectBindingOrAssignmentPattern(flattenContext, parent, pattern, value, location) {
        var elements = ts.getElementsOfBindingOrAssignmentPattern(pattern);
        var numElements = elements.length;
        if (numElements !== 1) {
            // For anything other than a single-element destructuring we need to generate a temporary
            // to ensure value is evaluated exactly once. Additionally, if we have zero elements
            // we need to emit *something* to ensure that in case a 'var' keyword was already emitted,
            // so in that case, we'll intentionally create that temporary.
            var reuseIdentifierExpressions = !ts.isDeclarationBindingElement(parent) || numElements !== 0;
            value = ensureIdentifier(flattenContext, value, reuseIdentifierExpressions, location);
        }
        var bindingElements;
        var computedTempVariables;
        for (var i = 0; i < numElements; i++) {
            var element = elements[i];
            if (!ts.getRestIndicatorOfBindingOrAssignmentElement(element)) {
                var propertyName = ts.getPropertyNameOfBindingOrAssignmentElement(element);
                if (flattenContext.level >= 1 /* FlattenLevel.ObjectRest */
                    && !(element.transformFlags & (16384 /* TransformFlags.ContainsRestOrSpread */ | 32768 /* TransformFlags.ContainsObjectRestOrSpread */))
                    && !(ts.getTargetOfBindingOrAssignmentElement(element).transformFlags & (16384 /* TransformFlags.ContainsRestOrSpread */ | 32768 /* TransformFlags.ContainsObjectRestOrSpread */))
                    && !ts.isComputedPropertyName(propertyName)) {
                    bindingElements = ts.append(bindingElements, ts.visitNode(element, flattenContext.visitor));
                }
                else {
                    if (bindingElements) {
                        flattenContext.emitBindingOrAssignment(flattenContext.createObjectBindingOrAssignmentPattern(bindingElements), value, location, pattern);
                        bindingElements = undefined;
                    }
                    var rhsValue = createDestructuringPropertyAccess(flattenContext, value, propertyName);
                    if (ts.isComputedPropertyName(propertyName)) {
                        computedTempVariables = ts.append(computedTempVariables, rhsValue.argumentExpression);
                    }
                    flattenBindingOrAssignmentElement(flattenContext, element, rhsValue, /*location*/ element);
                }
            }
            else if (i === numElements - 1) {
                if (bindingElements) {
                    flattenContext.emitBindingOrAssignment(flattenContext.createObjectBindingOrAssignmentPattern(bindingElements), value, location, pattern);
                    bindingElements = undefined;
                }
                var rhsValue = flattenContext.context.getEmitHelperFactory().createRestHelper(value, elements, computedTempVariables, pattern);
                flattenBindingOrAssignmentElement(flattenContext, element, rhsValue, element);
            }
        }
        if (bindingElements) {
            flattenContext.emitBindingOrAssignment(flattenContext.createObjectBindingOrAssignmentPattern(bindingElements), value, location, pattern);
        }
    }
    /**
     * Flattens an ArrayBindingOrAssignmentPattern into zero or more bindings or assignments.
     *
     * @param flattenContext Options used to control flattening.
     * @param parent The parent element of the pattern.
     * @param pattern The ArrayBindingOrAssignmentPattern to flatten.
     * @param value The current RHS value to assign to the element.
     * @param location The location to use for source maps and comments.
     */
    function flattenArrayBindingOrAssignmentPattern(flattenContext, parent, pattern, value, location) {
        var elements = ts.getElementsOfBindingOrAssignmentPattern(pattern);
        var numElements = elements.length;
        if (flattenContext.level < 1 /* FlattenLevel.ObjectRest */ && flattenContext.downlevelIteration) {
            // Read the elements of the iterable into an array
            value = ensureIdentifier(flattenContext, ts.setTextRange(flattenContext.context.getEmitHelperFactory().createReadHelper(value, numElements > 0 && ts.getRestIndicatorOfBindingOrAssignmentElement(elements[numElements - 1])
                ? undefined
                : numElements), location), 
            /*reuseIdentifierExpressions*/ false, location);
        }
        else if (numElements !== 1 && (flattenContext.level < 1 /* FlattenLevel.ObjectRest */ || numElements === 0)
            || ts.every(elements, ts.isOmittedExpression)) {
            // For anything other than a single-element destructuring we need to generate a temporary
            // to ensure value is evaluated exactly once. Additionally, if we have zero elements
            // we need to emit *something* to ensure that in case a 'var' keyword was already emitted,
            // so in that case, we'll intentionally create that temporary.
            // Or all the elements of the binding pattern are omitted expression such as "var [,] = [1,2]",
            // then we will create temporary variable.
            var reuseIdentifierExpressions = !ts.isDeclarationBindingElement(parent) || numElements !== 0;
            value = ensureIdentifier(flattenContext, value, reuseIdentifierExpressions, location);
        }
        var bindingElements;
        var restContainingElements;
        for (var i = 0; i < numElements; i++) {
            var element = elements[i];
            if (flattenContext.level >= 1 /* FlattenLevel.ObjectRest */) {
                // If an array pattern contains an ObjectRest, we must cache the result so that we
                // can perform the ObjectRest destructuring in a different declaration
                if (element.transformFlags & 32768 /* TransformFlags.ContainsObjectRestOrSpread */ || flattenContext.hasTransformedPriorElement && !isSimpleBindingOrAssignmentElement(element)) {
                    flattenContext.hasTransformedPriorElement = true;
                    var temp = flattenContext.context.factory.createTempVariable(/*recordTempVariable*/ undefined);
                    if (flattenContext.hoistTempVariables) {
                        flattenContext.context.hoistVariableDeclaration(temp);
                    }
                    restContainingElements = ts.append(restContainingElements, [temp, element]);
                    bindingElements = ts.append(bindingElements, flattenContext.createArrayBindingOrAssignmentElement(temp));
                }
                else {
                    bindingElements = ts.append(bindingElements, element);
                }
            }
            else if (ts.isOmittedExpression(element)) {
                continue;
            }
            else if (!ts.getRestIndicatorOfBindingOrAssignmentElement(element)) {
                var rhsValue = flattenContext.context.factory.createElementAccessExpression(value, i);
                flattenBindingOrAssignmentElement(flattenContext, element, rhsValue, /*location*/ element);
            }
            else if (i === numElements - 1) {
                var rhsValue = flattenContext.context.factory.createArraySliceCall(value, i);
                flattenBindingOrAssignmentElement(flattenContext, element, rhsValue, /*location*/ element);
            }
        }
        if (bindingElements) {
            flattenContext.emitBindingOrAssignment(flattenContext.createArrayBindingOrAssignmentPattern(bindingElements), value, location, pattern);
        }
        if (restContainingElements) {
            for (var _i = 0, restContainingElements_1 = restContainingElements; _i < restContainingElements_1.length; _i++) {
                var _a = restContainingElements_1[_i], id = _a[0], element = _a[1];
                flattenBindingOrAssignmentElement(flattenContext, element, id, element);
            }
        }
    }
    function isSimpleBindingOrAssignmentElement(element) {
        var target = ts.getTargetOfBindingOrAssignmentElement(element);
        if (!target || ts.isOmittedExpression(target))
            return true;
        var propertyName = ts.tryGetPropertyNameOfBindingOrAssignmentElement(element);
        if (propertyName && !ts.isPropertyNameLiteral(propertyName))
            return false;
        var initializer = ts.getInitializerOfBindingOrAssignmentElement(element);
        if (initializer && !ts.isSimpleInlineableExpression(initializer))
            return false;
        if (ts.isBindingOrAssignmentPattern(target))
            return ts.every(ts.getElementsOfBindingOrAssignmentPattern(target), isSimpleBindingOrAssignmentElement);
        return ts.isIdentifier(target);
    }
    /**
     * Creates an expression used to provide a default value if a value is `undefined` at runtime.
     *
     * @param flattenContext Options used to control flattening.
     * @param value The RHS value to test.
     * @param defaultValue The default value to use if `value` is `undefined` at runtime.
     * @param location The location to use for source maps and comments.
     */
    function createDefaultValueCheck(flattenContext, value, defaultValue, location) {
        value = ensureIdentifier(flattenContext, value, /*reuseIdentifierExpressions*/ true, location);
        return flattenContext.context.factory.createConditionalExpression(flattenContext.context.factory.createTypeCheck(value, "undefined"), /*questionToken*/ undefined, defaultValue, /*colonToken*/ undefined, value);
    }
    /**
     * Creates either a PropertyAccessExpression or an ElementAccessExpression for the
     * right-hand side of a transformed destructuring assignment.
     *
     * @link https://tc39.github.io/ecma262/#sec-runtime-semantics-keyeddestructuringassignmentevaluation
     *
     * @param flattenContext Options used to control flattening.
     * @param value The RHS value that is the source of the property.
     * @param propertyName The destructuring property name.
     */
    function createDestructuringPropertyAccess(flattenContext, value, propertyName) {
        if (ts.isComputedPropertyName(propertyName)) {
            var argumentExpression = ensureIdentifier(flattenContext, ts.visitNode(propertyName.expression, flattenContext.visitor), /*reuseIdentifierExpressions*/ false, /*location*/ propertyName);
            return flattenContext.context.factory.createElementAccessExpression(value, argumentExpression);
        }
        else if (ts.isStringOrNumericLiteralLike(propertyName)) {
            var argumentExpression = ts.factory.cloneNode(propertyName);
            return flattenContext.context.factory.createElementAccessExpression(value, argumentExpression);
        }
        else {
            var name = flattenContext.context.factory.createIdentifier(ts.idText(propertyName));
            return flattenContext.context.factory.createPropertyAccessExpression(value, name);
        }
    }
    /**
     * Ensures that there exists a declared identifier whose value holds the given expression.
     * This function is useful to ensure that the expression's value can be read from in subsequent expressions.
     * Unless 'reuseIdentifierExpressions' is false, 'value' will be returned if it is just an identifier.
     *
     * @param flattenContext Options used to control flattening.
     * @param value the expression whose value needs to be bound.
     * @param reuseIdentifierExpressions true if identifier expressions can simply be returned;
     * false if it is necessary to always emit an identifier.
     * @param location The location to use for source maps and comments.
     */
    function ensureIdentifier(flattenContext, value, reuseIdentifierExpressions, location) {
        if (ts.isIdentifier(value) && reuseIdentifierExpressions) {
            return value;
        }
        else {
            var temp = flattenContext.context.factory.createTempVariable(/*recordTempVariable*/ undefined);
            if (flattenContext.hoistTempVariables) {
                flattenContext.context.hoistVariableDeclaration(temp);
                flattenContext.emitExpression(ts.setTextRange(flattenContext.context.factory.createAssignment(temp, value), location));
            }
            else {
                flattenContext.emitBindingOrAssignment(temp, value, location, /*original*/ undefined);
            }
            return temp;
        }
    }
    function makeArrayBindingPattern(factory, elements) {
        ts.Debug.assertEachNode(elements, ts.isArrayBindingElement);
        return factory.createArrayBindingPattern(elements);
    }
    function makeArrayAssignmentPattern(factory, elements) {
        return factory.createArrayLiteralExpression(ts.map(elements, factory.converters.convertToArrayAssignmentElement));
    }
    function makeObjectBindingPattern(factory, elements) {
        ts.Debug.assertEachNode(elements, ts.isBindingElement);
        return factory.createObjectBindingPattern(elements);
    }
    function makeObjectAssignmentPattern(factory, elements) {
        return factory.createObjectLiteralExpression(ts.map(elements, factory.converters.convertToObjectAssignmentElement));
    }
    function makeBindingElement(factory, name) {
        return factory.createBindingElement(/*dotDotDotToken*/ undefined, /*propertyName*/ undefined, name);
    }
    function makeAssignmentElement(name) {
        return name;
    }
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    var ProcessLevel;
    (function (ProcessLevel) {
        ProcessLevel[ProcessLevel["LiftRestriction"] = 0] = "LiftRestriction";
        ProcessLevel[ProcessLevel["All"] = 1] = "All";
    })(ProcessLevel = ts.ProcessLevel || (ts.ProcessLevel = {}));
    function processTaggedTemplateExpression(context, node, visitor, currentSourceFile, recordTaggedTemplateString, level) {
        // Visit the tag expression
        var tag = ts.visitNode(node.tag, visitor, ts.isExpression);
        // Build up the template arguments and the raw and cooked strings for the template.
        // We start out with 'undefined' for the first argument and revisit later
        // to avoid walking over the template string twice and shifting all our arguments over after the fact.
        var templateArguments = [undefined];
        var cookedStrings = [];
        var rawStrings = [];
        var template = node.template;
        if (level === ProcessLevel.LiftRestriction && !ts.hasInvalidEscape(template)) {
            return ts.visitEachChild(node, visitor, context);
        }
        if (ts.isNoSubstitutionTemplateLiteral(template)) {
            cookedStrings.push(createTemplateCooked(template));
            rawStrings.push(getRawLiteral(template, currentSourceFile));
        }
        else {
            cookedStrings.push(createTemplateCooked(template.head));
            rawStrings.push(getRawLiteral(template.head, currentSourceFile));
            for (var _i = 0, _a = template.templateSpans; _i < _a.length; _i++) {
                var templateSpan = _a[_i];
                cookedStrings.push(createTemplateCooked(templateSpan.literal));
                rawStrings.push(getRawLiteral(templateSpan.literal, currentSourceFile));
                templateArguments.push(ts.visitNode(templateSpan.expression, visitor, ts.isExpression));
            }
        }
        var helperCall = context.getEmitHelperFactory().createTemplateObjectHelper(ts.factory.createArrayLiteralExpression(cookedStrings), ts.factory.createArrayLiteralExpression(rawStrings));
        // Create a variable to cache the template object if we're in a module.
        // Do not do this in the global scope, as any variable we currently generate could conflict with
        // variables from outside of the current compilation. In the future, we can revisit this behavior.
        if (ts.isExternalModule(currentSourceFile)) {
            var tempVar = ts.factory.createUniqueName("templateObject");
            recordTaggedTemplateString(tempVar);
            templateArguments[0] = ts.factory.createLogicalOr(tempVar, ts.factory.createAssignment(tempVar, helperCall));
        }
        else {
            templateArguments[0] = helperCall;
        }
        return ts.factory.createCallExpression(tag, /*typeArguments*/ undefined, templateArguments);
    }
    ts.processTaggedTemplateExpression = processTaggedTemplateExpression;
    function createTemplateCooked(template) {
        return template.templateFlags ? ts.factory.createVoidZero() : ts.factory.createStringLiteral(template.text);
    }
    /**
     * Creates an ES5 compatible literal from an ES6 template literal.
     *
     * @param node The ES6 template literal.
     */
    function getRawLiteral(node, currentSourceFile) {
        // Find original source text, since we need to emit the raw strings of the tagged template.
        // The raw strings contain the (escaped) strings of what the user wrote.
        // Examples: `\n` is converted to "\\n", a template string with a newline to "\n".
        var text = node.rawText;
        if (text === undefined) {
            ts.Debug.assertIsDefined(currentSourceFile, "Template literal node is missing 'rawText' and does not have a source file. Possibly bad transform.");
            text = ts.getSourceTextOfNodeFromSourceFile(currentSourceFile, node);
            // text contains the original source, it will also contain quotes ("`"), dolar signs and braces ("${" and "}"),
            // thus we need to remove those characters.
            // First template piece starts with "`", others with "}"
            // Last template piece ends with "`", others with "${"
            var isLast = node.kind === 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */ || node.kind === 17 /* SyntaxKind.TemplateTail */;
            text = text.substring(1, text.length - (isLast ? 1 : 2));
        }
        // Newline normalization:
        // ES6 Spec 11.8.6.1 - Static Semantics of TV's and TRV's
        // <CR><LF> and <CR> LineTerminatorSequences are normalized to <LF> for both TV and TRV.
        text = text.replace(/\r\n?/g, "\n");
        return ts.setTextRange(ts.factory.createStringLiteral(text), node);
    }
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    /**
     * Indicates whether to emit type metadata in the new format.
     */
    var USE_NEW_TYPE_METADATA_FORMAT = false;
    var TypeScriptSubstitutionFlags;
    (function (TypeScriptSubstitutionFlags) {
        /** Enables substitutions for decorated classes. */
        TypeScriptSubstitutionFlags[TypeScriptSubstitutionFlags["ClassAliases"] = 1] = "ClassAliases";
        /** Enables substitutions for namespace exports. */
        TypeScriptSubstitutionFlags[TypeScriptSubstitutionFlags["NamespaceExports"] = 2] = "NamespaceExports";
        /* Enables substitutions for unqualified enum members */
        TypeScriptSubstitutionFlags[TypeScriptSubstitutionFlags["NonQualifiedEnumMembers"] = 8] = "NonQualifiedEnumMembers";
    })(TypeScriptSubstitutionFlags || (TypeScriptSubstitutionFlags = {}));
    var ClassFacts;
    (function (ClassFacts) {
        ClassFacts[ClassFacts["None"] = 0] = "None";
        ClassFacts[ClassFacts["HasStaticInitializedProperties"] = 1] = "HasStaticInitializedProperties";
        ClassFacts[ClassFacts["HasConstructorDecorators"] = 2] = "HasConstructorDecorators";
        ClassFacts[ClassFacts["HasMemberDecorators"] = 4] = "HasMemberDecorators";
        ClassFacts[ClassFacts["IsExportOfNamespace"] = 8] = "IsExportOfNamespace";
        ClassFacts[ClassFacts["IsNamedExternalExport"] = 16] = "IsNamedExternalExport";
        ClassFacts[ClassFacts["IsDefaultExternalExport"] = 32] = "IsDefaultExternalExport";
        ClassFacts[ClassFacts["IsDerivedClass"] = 64] = "IsDerivedClass";
        ClassFacts[ClassFacts["UseImmediatelyInvokedFunctionExpression"] = 128] = "UseImmediatelyInvokedFunctionExpression";
        ClassFacts[ClassFacts["HasAnyDecorators"] = 6] = "HasAnyDecorators";
        ClassFacts[ClassFacts["NeedsName"] = 5] = "NeedsName";
        ClassFacts[ClassFacts["MayNeedImmediatelyInvokedFunctionExpression"] = 7] = "MayNeedImmediatelyInvokedFunctionExpression";
        ClassFacts[ClassFacts["IsExported"] = 56] = "IsExported";
    })(ClassFacts || (ClassFacts = {}));
    function transformTypeScript(context) {
        var factory = context.factory, emitHelpers = context.getEmitHelperFactory, startLexicalEnvironment = context.startLexicalEnvironment, resumeLexicalEnvironment = context.resumeLexicalEnvironment, endLexicalEnvironment = context.endLexicalEnvironment, hoistVariableDeclaration = context.hoistVariableDeclaration;
        var resolver = context.getEmitResolver();
        var compilerOptions = context.getCompilerOptions();
        var strictNullChecks = ts.getStrictOptionValue(compilerOptions, "strictNullChecks");
        var languageVersion = ts.getEmitScriptTarget(compilerOptions);
        var moduleKind = ts.getEmitModuleKind(compilerOptions);
        // Save the previous transformation hooks.
        var previousOnEmitNode = context.onEmitNode;
        var previousOnSubstituteNode = context.onSubstituteNode;
        // Set new transformation hooks.
        context.onEmitNode = onEmitNode;
        context.onSubstituteNode = onSubstituteNode;
        // Enable substitution for property/element access to emit const enum values.
        context.enableSubstitution(206 /* SyntaxKind.PropertyAccessExpression */);
        context.enableSubstitution(207 /* SyntaxKind.ElementAccessExpression */);
        // These variables contain state that changes as we descend into the tree.
        var currentSourceFile;
        var currentNamespace;
        var currentNamespaceContainerName;
        var currentLexicalScope;
        var currentNameScope;
        var currentScopeFirstDeclarationsOfName;
        var currentClassHasParameterProperties;
        /**
         * Keeps track of whether expression substitution has been enabled for specific edge cases.
         * They are persisted between each SourceFile transformation and should not be reset.
         */
        var enabledSubstitutions;
        /**
         * A map that keeps track of aliases created for classes with decorators to avoid issues
         * with the double-binding behavior of classes.
         */
        var classAliases;
        /**
         * Keeps track of whether we are within any containing namespaces when performing
         * just-in-time substitution while printing an expression identifier.
         */
        var applicableSubstitutions;
        return transformSourceFileOrBundle;
        function transformSourceFileOrBundle(node) {
            if (node.kind === 306 /* SyntaxKind.Bundle */) {
                return transformBundle(node);
            }
            return transformSourceFile(node);
        }
        function transformBundle(node) {
            return factory.createBundle(node.sourceFiles.map(transformSourceFile), ts.mapDefined(node.prepends, function (prepend) {
                if (prepend.kind === 308 /* SyntaxKind.InputFiles */) {
                    return ts.createUnparsedSourceFile(prepend, "js");
                }
                return prepend;
            }));
        }
        /**
         * Transform TypeScript-specific syntax in a SourceFile.
         *
         * @param node A SourceFile node.
         */
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            currentSourceFile = node;
            var visited = saveStateAndInvoke(node, visitSourceFile);
            ts.addEmitHelpers(visited, context.readEmitHelpers());
            currentSourceFile = undefined;
            return visited;
        }
        /**
         * Visits a node, saving and restoring state variables on the stack.
         *
         * @param node The node to visit.
         */
        function saveStateAndInvoke(node, f) {
            // Save state
            var savedCurrentScope = currentLexicalScope;
            var savedCurrentNameScope = currentNameScope;
            var savedCurrentScopeFirstDeclarationsOfName = currentScopeFirstDeclarationsOfName;
            var savedCurrentClassHasParameterProperties = currentClassHasParameterProperties;
            // Handle state changes before visiting a node.
            onBeforeVisitNode(node);
            var visited = f(node);
            // Restore state
            if (currentLexicalScope !== savedCurrentScope) {
                currentScopeFirstDeclarationsOfName = savedCurrentScopeFirstDeclarationsOfName;
            }
            currentLexicalScope = savedCurrentScope;
            currentNameScope = savedCurrentNameScope;
            currentClassHasParameterProperties = savedCurrentClassHasParameterProperties;
            return visited;
        }
        /**
         * Performs actions that should always occur immediately before visiting a node.
         *
         * @param node The node to visit.
         */
        function onBeforeVisitNode(node) {
            switch (node.kind) {
                case 305 /* SyntaxKind.SourceFile */:
                case 263 /* SyntaxKind.CaseBlock */:
                case 262 /* SyntaxKind.ModuleBlock */:
                case 235 /* SyntaxKind.Block */:
                    currentLexicalScope = node;
                    currentNameScope = undefined;
                    currentScopeFirstDeclarationsOfName = undefined;
                    break;
                case 257 /* SyntaxKind.ClassDeclaration */:
                case 256 /* SyntaxKind.FunctionDeclaration */:
                    if (ts.hasSyntacticModifier(node, 2 /* ModifierFlags.Ambient */)) {
                        break;
                    }
                    // Record these declarations provided that they have a name.
                    if (node.name) {
                        recordEmittedDeclarationInScope(node);
                    }
                    else {
                        // These nodes should always have names unless they are default-exports;
                        // however, class declaration parsing allows for undefined names, so syntactically invalid
                        // programs may also have an undefined name.
                        ts.Debug.assert(node.kind === 257 /* SyntaxKind.ClassDeclaration */ || ts.hasSyntacticModifier(node, 512 /* ModifierFlags.Default */));
                    }
                    if (ts.isClassDeclaration(node)) {
                        // XXX: should probably also cover interfaces and type aliases that can have type variables?
                        currentNameScope = node;
                    }
                    break;
            }
        }
        /**
         * General-purpose node visitor.
         *
         * @param node The node to visit.
         */
        function visitor(node) {
            return saveStateAndInvoke(node, visitorWorker);
        }
        /**
         * Visits and possibly transforms any node.
         *
         * @param node The node to visit.
         */
        function visitorWorker(node) {
            if (node.transformFlags & 1 /* TransformFlags.ContainsTypeScript */) {
                return visitTypeScript(node);
            }
            return node;
        }
        /**
         * Specialized visitor that visits the immediate children of a SourceFile.
         *
         * @param node The node to visit.
         */
        function sourceElementVisitor(node) {
            return saveStateAndInvoke(node, sourceElementVisitorWorker);
        }
        /**
         * Specialized visitor that visits the immediate children of a SourceFile.
         *
         * @param node The node to visit.
         */
        function sourceElementVisitorWorker(node) {
            switch (node.kind) {
                case 266 /* SyntaxKind.ImportDeclaration */:
                case 265 /* SyntaxKind.ImportEqualsDeclaration */:
                case 271 /* SyntaxKind.ExportAssignment */:
                case 272 /* SyntaxKind.ExportDeclaration */:
                    return visitElidableStatement(node);
                default:
                    return visitorWorker(node);
            }
        }
        function visitElidableStatement(node) {
            var parsed = ts.getParseTreeNode(node);
            if (parsed !== node) {
                // If the node has been transformed by a `before` transformer, perform no ellision on it
                // As the type information we would attempt to lookup to perform ellision is potentially unavailable for the synthesized nodes
                // We do not reuse `visitorWorker`, as the ellidable statement syntax kinds are technically unrecognized by the switch-case in `visitTypeScript`,
                // and will trigger debug failures when debug verbosity is turned up
                if (node.transformFlags & 1 /* TransformFlags.ContainsTypeScript */) {
                    // This node contains TypeScript, so we should visit its children.
                    return ts.visitEachChild(node, visitor, context);
                }
                // Otherwise, we can just return the node
                return node;
            }
            switch (node.kind) {
                case 266 /* SyntaxKind.ImportDeclaration */:
                    return visitImportDeclaration(node);
                case 265 /* SyntaxKind.ImportEqualsDeclaration */:
                    return visitImportEqualsDeclaration(node);
                case 271 /* SyntaxKind.ExportAssignment */:
                    return visitExportAssignment(node);
                case 272 /* SyntaxKind.ExportDeclaration */:
                    return visitExportDeclaration(node);
                default:
                    ts.Debug.fail("Unhandled ellided statement");
            }
        }
        /**
         * Specialized visitor that visits the immediate children of a namespace.
         *
         * @param node The node to visit.
         */
        function namespaceElementVisitor(node) {
            return saveStateAndInvoke(node, namespaceElementVisitorWorker);
        }
        /**
         * Specialized visitor that visits the immediate children of a namespace.
         *
         * @param node The node to visit.
         */
        function namespaceElementVisitorWorker(node) {
            if (node.kind === 272 /* SyntaxKind.ExportDeclaration */ ||
                node.kind === 266 /* SyntaxKind.ImportDeclaration */ ||
                node.kind === 267 /* SyntaxKind.ImportClause */ ||
                (node.kind === 265 /* SyntaxKind.ImportEqualsDeclaration */ &&
                    node.moduleReference.kind === 277 /* SyntaxKind.ExternalModuleReference */)) {
                // do not emit ES6 imports and exports since they are illegal inside a namespace
                return undefined;
            }
            else if (node.transformFlags & 1 /* TransformFlags.ContainsTypeScript */ || ts.hasSyntacticModifier(node, 1 /* ModifierFlags.Export */)) {
                return visitTypeScript(node);
            }
            return node;
        }
        /**
         * Specialized visitor that visits the immediate children of a class with TypeScript syntax.
         *
         * @param node The node to visit.
         */
        function classElementVisitor(node) {
            return saveStateAndInvoke(node, classElementVisitorWorker);
        }
        /**
         * Specialized visitor that visits the immediate children of a class with TypeScript syntax.
         *
         * @param node The node to visit.
         */
        function classElementVisitorWorker(node) {
            switch (node.kind) {
                case 171 /* SyntaxKind.Constructor */:
                    return visitConstructor(node);
                case 167 /* SyntaxKind.PropertyDeclaration */:
                    // Property declarations are not TypeScript syntax, but they must be visited
                    // for the decorator transformation.
                    return visitPropertyDeclaration(node);
                case 176 /* SyntaxKind.IndexSignature */:
                case 172 /* SyntaxKind.GetAccessor */:
                case 173 /* SyntaxKind.SetAccessor */:
                case 169 /* SyntaxKind.MethodDeclaration */:
                case 170 /* SyntaxKind.ClassStaticBlockDeclaration */:
                    // Fallback to the default visit behavior.
                    return visitorWorker(node);
                case 234 /* SyntaxKind.SemicolonClassElement */:
                    return node;
                default:
                    return ts.Debug.failBadSyntaxKind(node);
            }
        }
        function modifierVisitor(node) {
            if (ts.modifierToFlag(node.kind) & 116958 /* ModifierFlags.TypeScriptModifier */) {
                return undefined;
            }
            else if (currentNamespace && node.kind === 93 /* SyntaxKind.ExportKeyword */) {
                return undefined;
            }
            return node;
        }
        /**
         * Branching visitor, visits a TypeScript syntax node.
         *
         * @param node The node to visit.
         */
        function visitTypeScript(node) {
            if (ts.isStatement(node) && ts.hasSyntacticModifier(node, 2 /* ModifierFlags.Ambient */)) {
                // TypeScript ambient declarations are elided, but some comments may be preserved.
                // See the implementation of `getLeadingComments` in comments.ts for more details.
                return factory.createNotEmittedStatement(node);
            }
            switch (node.kind) {
                case 93 /* SyntaxKind.ExportKeyword */:
                case 88 /* SyntaxKind.DefaultKeyword */:
                    // ES6 export and default modifiers are elided when inside a namespace.
                    return currentNamespace ? undefined : node;
                case 123 /* SyntaxKind.PublicKeyword */:
                case 121 /* SyntaxKind.PrivateKeyword */:
                case 122 /* SyntaxKind.ProtectedKeyword */:
                case 126 /* SyntaxKind.AbstractKeyword */:
                case 159 /* SyntaxKind.OverrideKeyword */:
                case 85 /* SyntaxKind.ConstKeyword */:
                case 135 /* SyntaxKind.DeclareKeyword */:
                case 145 /* SyntaxKind.ReadonlyKeyword */:
                case 101 /* SyntaxKind.InKeyword */:
                case 144 /* SyntaxKind.OutKeyword */:
                // TypeScript accessibility and readonly modifiers are elided
                // falls through
                case 183 /* SyntaxKind.ArrayType */:
                case 184 /* SyntaxKind.TupleType */:
                case 185 /* SyntaxKind.OptionalType */:
                case 186 /* SyntaxKind.RestType */:
                case 182 /* SyntaxKind.TypeLiteral */:
                case 177 /* SyntaxKind.TypePredicate */:
                case 163 /* SyntaxKind.TypeParameter */:
                case 130 /* SyntaxKind.AnyKeyword */:
                case 155 /* SyntaxKind.UnknownKeyword */:
                case 133 /* SyntaxKind.BooleanKeyword */:
                case 150 /* SyntaxKind.StringKeyword */:
                case 147 /* SyntaxKind.NumberKeyword */:
                case 143 /* SyntaxKind.NeverKeyword */:
                case 114 /* SyntaxKind.VoidKeyword */:
                case 151 /* SyntaxKind.SymbolKeyword */:
                case 180 /* SyntaxKind.ConstructorType */:
                case 179 /* SyntaxKind.FunctionType */:
                case 181 /* SyntaxKind.TypeQuery */:
                case 178 /* SyntaxKind.TypeReference */:
                case 187 /* SyntaxKind.UnionType */:
                case 188 /* SyntaxKind.IntersectionType */:
                case 189 /* SyntaxKind.ConditionalType */:
                case 191 /* SyntaxKind.ParenthesizedType */:
                case 192 /* SyntaxKind.ThisType */:
                case 193 /* SyntaxKind.TypeOperator */:
                case 194 /* SyntaxKind.IndexedAccessType */:
                case 195 /* SyntaxKind.MappedType */:
                case 196 /* SyntaxKind.LiteralType */:
                // TypeScript type nodes are elided.
                // falls through
                case 176 /* SyntaxKind.IndexSignature */:
                // TypeScript index signatures are elided.
                // falls through
                case 165 /* SyntaxKind.Decorator */:
                    // TypeScript decorators are elided. They will be emitted as part of visitClassDeclaration.
                    return undefined;
                case 259 /* SyntaxKind.TypeAliasDeclaration */:
                    // TypeScript type-only declarations are elided.
                    return factory.createNotEmittedStatement(node);
                case 167 /* SyntaxKind.PropertyDeclaration */:
                    // TypeScript property declarations are elided. However their names are still visited, and can potentially be retained if they could have sideeffects
                    return visitPropertyDeclaration(node);
                case 264 /* SyntaxKind.NamespaceExportDeclaration */:
                    // TypeScript namespace export declarations are elided.
                    return undefined;
                case 171 /* SyntaxKind.Constructor */:
                    return visitConstructor(node);
                case 258 /* SyntaxKind.InterfaceDeclaration */:
                    // TypeScript interfaces are elided, but some comments may be preserved.
                    // See the implementation of `getLeadingComments` in comments.ts for more details.
                    return factory.createNotEmittedStatement(node);
                case 257 /* SyntaxKind.ClassDeclaration */:
                    // This may be a class declaration with TypeScript syntax extensions.
                    //
                    // TypeScript class syntax extensions include:
                    // - decorators
                    // - optional `implements` heritage clause
                    // - parameter property assignments in the constructor
                    // - index signatures
                    // - method overload signatures
                    return visitClassDeclaration(node);
                case 226 /* SyntaxKind.ClassExpression */:
                    // This may be a class expression with TypeScript syntax extensions.
                    //
                    // TypeScript class syntax extensions include:
                    // - decorators
                    // - optional `implements` heritage clause
                    // - parameter property assignments in the constructor
                    // - index signatures
                    // - method overload signatures
                    return visitClassExpression(node);
                case 291 /* SyntaxKind.HeritageClause */:
                    // This may be a heritage clause with TypeScript syntax extensions.
                    //
                    // TypeScript heritage clause extensions include:
                    // - `implements` clause
                    return visitHeritageClause(node);
                case 228 /* SyntaxKind.ExpressionWithTypeArguments */:
                    // TypeScript supports type arguments on an expression in an `extends` heritage clause.
                    return visitExpressionWithTypeArguments(node);
                case 169 /* SyntaxKind.MethodDeclaration */:
                    // TypeScript method declarations may have decorators, modifiers
                    // or type annotations.
                    return visitMethodDeclaration(node);
                case 172 /* SyntaxKind.GetAccessor */:
                    // Get Accessors can have TypeScript modifiers, decorators, and type annotations.
                    return visitGetAccessor(node);
                case 173 /* SyntaxKind.SetAccessor */:
                    // Set Accessors can have TypeScript modifiers and type annotations.
                    return visitSetAccessor(node);
                case 256 /* SyntaxKind.FunctionDeclaration */:
                    // Typescript function declarations can have modifiers, decorators, and type annotations.
                    return visitFunctionDeclaration(node);
                case 213 /* SyntaxKind.FunctionExpression */:
                    // TypeScript function expressions can have modifiers and type annotations.
                    return visitFunctionExpression(node);
                case 214 /* SyntaxKind.ArrowFunction */:
                    // TypeScript arrow functions can have modifiers and type annotations.
                    return visitArrowFunction(node);
                case 164 /* SyntaxKind.Parameter */:
                    // This may be a parameter declaration with TypeScript syntax extensions.
                    //
                    // TypeScript parameter declaration syntax extensions include:
                    // - decorators
                    // - accessibility modifiers
                    // - the question mark (?) token for optional parameters
                    // - type annotations
                    // - this parameters
                    return visitParameter(node);
                case 212 /* SyntaxKind.ParenthesizedExpression */:
                    // ParenthesizedExpressions are TypeScript if their expression is a
                    // TypeAssertion or AsExpression
                    return visitParenthesizedExpression(node);
                case 211 /* SyntaxKind.TypeAssertionExpression */:
                case 229 /* SyntaxKind.AsExpression */:
                    // TypeScript type assertions are removed, but their subtrees are preserved.
                    return visitAssertionExpression(node);
                case 208 /* SyntaxKind.CallExpression */:
                    return visitCallExpression(node);
                case 209 /* SyntaxKind.NewExpression */:
                    return visitNewExpression(node);
                case 210 /* SyntaxKind.TaggedTemplateExpression */:
                    return visitTaggedTemplateExpression(node);
                case 230 /* SyntaxKind.NonNullExpression */:
                    // TypeScript non-null expressions are removed, but their subtrees are preserved.
                    return visitNonNullExpression(node);
                case 260 /* SyntaxKind.EnumDeclaration */:
                    // TypeScript enum declarations do not exist in ES6 and must be rewritten.
                    return visitEnumDeclaration(node);
                case 237 /* SyntaxKind.VariableStatement */:
                    // TypeScript namespace exports for variable statements must be transformed.
                    return visitVariableStatement(node);
                case 254 /* SyntaxKind.VariableDeclaration */:
                    return visitVariableDeclaration(node);
                case 261 /* SyntaxKind.ModuleDeclaration */:
                    // TypeScript namespace declarations must be transformed.
                    return visitModuleDeclaration(node);
                case 265 /* SyntaxKind.ImportEqualsDeclaration */:
                    // TypeScript namespace or external module import.
                    return visitImportEqualsDeclaration(node);
                case 279 /* SyntaxKind.JsxSelfClosingElement */:
                    return visitJsxSelfClosingElement(node);
                case 280 /* SyntaxKind.JsxOpeningElement */:
                    return visitJsxJsxOpeningElement(node);
                default:
                    // node contains some other TypeScript syntax
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function visitSourceFile(node) {
            var alwaysStrict = ts.getStrictOptionValue(compilerOptions, "alwaysStrict") &&
                !(ts.isExternalModule(node) && moduleKind >= ts.ModuleKind.ES2015) &&
                !ts.isJsonSourceFile(node);
            return factory.updateSourceFile(node, ts.visitLexicalEnvironment(node.statements, sourceElementVisitor, context, /*start*/ 0, alwaysStrict));
        }
        function getClassFacts(node, staticProperties) {
            var facts = 0 /* ClassFacts.None */;
            if (ts.some(staticProperties))
                facts |= 1 /* ClassFacts.HasStaticInitializedProperties */;
            var extendsClauseElement = ts.getEffectiveBaseTypeNode(node);
            if (extendsClauseElement && ts.skipOuterExpressions(extendsClauseElement.expression).kind !== 104 /* SyntaxKind.NullKeyword */)
                facts |= 64 /* ClassFacts.IsDerivedClass */;
            if (ts.classOrConstructorParameterIsDecorated(node))
                facts |= 2 /* ClassFacts.HasConstructorDecorators */;
            if (ts.childIsDecorated(node))
                facts |= 4 /* ClassFacts.HasMemberDecorators */;
            if (isExportOfNamespace(node))
                facts |= 8 /* ClassFacts.IsExportOfNamespace */;
            else if (isDefaultExternalModuleExport(node))
                facts |= 32 /* ClassFacts.IsDefaultExternalExport */;
            else if (isNamedExternalModuleExport(node))
                facts |= 16 /* ClassFacts.IsNamedExternalExport */;
            if (languageVersion <= 1 /* ScriptTarget.ES5 */ && (facts & 7 /* ClassFacts.MayNeedImmediatelyInvokedFunctionExpression */))
                facts |= 128 /* ClassFacts.UseImmediatelyInvokedFunctionExpression */;
            return facts;
        }
        function hasTypeScriptClassSyntax(node) {
            return !!(node.transformFlags & 4096 /* TransformFlags.ContainsTypeScriptClassSyntax */);
        }
        function isClassLikeDeclarationWithTypeScriptSyntax(node) {
            return ts.some(node.decorators)
                || ts.some(node.typeParameters)
                || ts.some(node.heritageClauses, hasTypeScriptClassSyntax)
                || ts.some(node.members, hasTypeScriptClassSyntax);
        }
        function visitClassDeclaration(node) {
            if (!isClassLikeDeclarationWithTypeScriptSyntax(node) && !(currentNamespace && ts.hasSyntacticModifier(node, 1 /* ModifierFlags.Export */))) {
                return ts.visitEachChild(node, visitor, context);
            }
            var staticProperties = ts.getProperties(node, /*requireInitializer*/ true, /*isStatic*/ true);
            var facts = getClassFacts(node, staticProperties);
            if (facts & 128 /* ClassFacts.UseImmediatelyInvokedFunctionExpression */) {
                context.startLexicalEnvironment();
            }
            var name = node.name || (facts & 5 /* ClassFacts.NeedsName */ ? factory.getGeneratedNameForNode(node) : undefined);
            var classStatement = facts & 2 /* ClassFacts.HasConstructorDecorators */
                ? createClassDeclarationHeadWithDecorators(node, name)
                : createClassDeclarationHeadWithoutDecorators(node, name, facts);
            var statements = [classStatement];
            // Write any decorators of the node.
            addClassElementDecorationStatements(statements, node, /*isStatic*/ false);
            addClassElementDecorationStatements(statements, node, /*isStatic*/ true);
            addConstructorDecorationStatement(statements, node);
            if (facts & 128 /* ClassFacts.UseImmediatelyInvokedFunctionExpression */) {
                // When we emit a TypeScript class down to ES5, we must wrap it in an IIFE so that the
                // 'es2015' transformer can properly nest static initializers and decorators. The result
                // looks something like:
                //
                //  var C = function () {
                //      class C {
                //      }
                //      C.static_prop = 1;
                //      return C;
                //  }();
                //
                var closingBraceLocation = ts.createTokenRange(ts.skipTrivia(currentSourceFile.text, node.members.end), 19 /* SyntaxKind.CloseBraceToken */);
                var localName = factory.getInternalName(node);
                // The following partially-emitted expression exists purely to align our sourcemap
                // emit with the original emitter.
                var outer = factory.createPartiallyEmittedExpression(localName);
                ts.setTextRangeEnd(outer, closingBraceLocation.end);
                ts.setEmitFlags(outer, 1536 /* EmitFlags.NoComments */);
                var statement = factory.createReturnStatement(outer);
                ts.setTextRangePos(statement, closingBraceLocation.pos);
                ts.setEmitFlags(statement, 1536 /* EmitFlags.NoComments */ | 384 /* EmitFlags.NoTokenSourceMaps */);
                statements.push(statement);
                ts.insertStatementsAfterStandardPrologue(statements, context.endLexicalEnvironment());
                var iife = factory.createImmediatelyInvokedArrowFunction(statements);
                ts.setEmitFlags(iife, 33554432 /* EmitFlags.TypeScriptClassWrapper */);
                var varStatement = factory.createVariableStatement(
                /*modifiers*/ undefined, factory.createVariableDeclarationList([
                    factory.createVariableDeclaration(factory.getLocalName(node, /*allowComments*/ false, /*allowSourceMaps*/ false), 
                    /*exclamationToken*/ undefined, 
                    /*type*/ undefined, iife)
                ]));
                ts.setOriginalNode(varStatement, node);
                ts.setCommentRange(varStatement, node);
                ts.setSourceMapRange(varStatement, ts.moveRangePastDecorators(node));
                ts.startOnNewLine(varStatement);
                statements = [varStatement];
            }
            // If the class is exported as part of a TypeScript namespace, emit the namespace export.
            // Otherwise, if the class was exported at the top level and was decorated, emit an export
            // declaration or export default for the class.
            if (facts & 8 /* ClassFacts.IsExportOfNamespace */) {
                addExportMemberAssignment(statements, node);
            }
            else if (facts & 128 /* ClassFacts.UseImmediatelyInvokedFunctionExpression */ || facts & 2 /* ClassFacts.HasConstructorDecorators */) {
                if (facts & 32 /* ClassFacts.IsDefaultExternalExport */) {
                    statements.push(factory.createExportDefault(factory.getLocalName(node, /*allowComments*/ false, /*allowSourceMaps*/ true)));
                }
                else if (facts & 16 /* ClassFacts.IsNamedExternalExport */) {
                    statements.push(factory.createExternalModuleExport(factory.getLocalName(node, /*allowComments*/ false, /*allowSourceMaps*/ true)));
                }
            }
            if (statements.length > 1) {
                // Add a DeclarationMarker as a marker for the end of the declaration
                statements.push(factory.createEndOfDeclarationMarker(node));
                ts.setEmitFlags(classStatement, ts.getEmitFlags(classStatement) | 4194304 /* EmitFlags.HasEndOfDeclarationMarker */);
            }
            return ts.singleOrMany(statements);
        }
        /**
         * Transforms a non-decorated class declaration and appends the resulting statements.
         *
         * @param node A ClassDeclaration node.
         * @param name The name of the class.
         * @param facts Precomputed facts about the class.
         */
        function createClassDeclarationHeadWithoutDecorators(node, name, facts) {
            //  ${modifiers} class ${name} ${heritageClauses} {
            //      ${members}
            //  }
            // we do not emit modifiers on the declaration if we are emitting an IIFE
            var modifiers = !(facts & 128 /* ClassFacts.UseImmediatelyInvokedFunctionExpression */)
                ? ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier)
                : undefined;
            var classDeclaration = factory.createClassDeclaration(
            /*decorators*/ undefined, modifiers, name, 
            /*typeParameters*/ undefined, ts.visitNodes(node.heritageClauses, visitor, ts.isHeritageClause), transformClassMembers(node));
            // To better align with the old emitter, we should not emit a trailing source map
            // entry if the class has static properties.
            var emitFlags = ts.getEmitFlags(node);
            if (facts & 1 /* ClassFacts.HasStaticInitializedProperties */) {
                emitFlags |= 32 /* EmitFlags.NoTrailingSourceMap */;
            }
            ts.setTextRange(classDeclaration, node);
            ts.setOriginalNode(classDeclaration, node);
            ts.setEmitFlags(classDeclaration, emitFlags);
            return classDeclaration;
        }
        /**
         * Transforms a decorated class declaration and appends the resulting statements. If
         * the class requires an alias to avoid issues with double-binding, the alias is returned.
         */
        function createClassDeclarationHeadWithDecorators(node, name) {
            // When we emit an ES6 class that has a class decorator, we must tailor the
            // emit to certain specific cases.
            //
            // In the simplest case, we emit the class declaration as a let declaration, and
            // evaluate decorators after the close of the class body:
            //
            //  [Example 1]
            //  ---------------------------------------------------------------------
            //  TypeScript                      | Javascript
            //  ---------------------------------------------------------------------
            //  @dec                            | let C = class C {
            //  class C {                       | }
            //  }                               | C = __decorate([dec], C);
            //  ---------------------------------------------------------------------
            //  @dec                            | let C = class C {
            //  export class C {                | }
            //  }                               | C = __decorate([dec], C);
            //                                  | export { C };
            //  ---------------------------------------------------------------------
            //
            // If a class declaration contains a reference to itself *inside* of the class body,
            // this introduces two bindings to the class: One outside of the class body, and one
            // inside of the class body. If we apply decorators as in [Example 1] above, there
            // is the possibility that the decorator `dec` will return a new value for the
            // constructor, which would result in the binding inside of the class no longer
            // pointing to the same reference as the binding outside of the class.
            //
            // As a result, we must instead rewrite all references to the class *inside* of the
            // class body to instead point to a local temporary alias for the class:
            //
            //  [Example 2]
            //  ---------------------------------------------------------------------
            //  TypeScript                      | Javascript
            //  ---------------------------------------------------------------------
            //  @dec                            | let C = C_1 = class C {
            //  class C {                       |   static x() { return C_1.y; }
            //    static x() { return C.y; }    | }
            //    static y = 1;                 | C.y = 1;
            //  }                               | C = C_1 = __decorate([dec], C);
            //                                  | var C_1;
            //  ---------------------------------------------------------------------
            //  @dec                            | let C = class C {
            //  export class C {                |   static x() { return C_1.y; }
            //    static x() { return C.y; }    | }
            //    static y = 1;                 | C.y = 1;
            //  }                               | C = C_1 = __decorate([dec], C);
            //                                  | export { C };
            //                                  | var C_1;
            //  ---------------------------------------------------------------------
            //
            // If a class declaration is the default export of a module, we instead emit
            // the export after the decorated declaration:
            //
            //  [Example 3]
            //  ---------------------------------------------------------------------
            //  TypeScript                      | Javascript
            //  ---------------------------------------------------------------------
            //  @dec                            | let default_1 = class {
            //  export default class {          | }
            //  }                               | default_1 = __decorate([dec], default_1);
            //                                  | export default default_1;
            //  ---------------------------------------------------------------------
            //  @dec                            | let C = class C {
            //  export default class C {        | }
            //  }                               | C = __decorate([dec], C);
            //                                  | export default C;
            //  ---------------------------------------------------------------------
            //
            // If the class declaration is the default export and a reference to itself
            // inside of the class body, we must emit both an alias for the class *and*
            // move the export after the declaration:
            //
            //  [Example 4]
            //  ---------------------------------------------------------------------
            //  TypeScript                      | Javascript
            //  ---------------------------------------------------------------------
            //  @dec                            | let C = class C {
            //  export default class C {        |   static x() { return C_1.y; }
            //    static x() { return C.y; }    | }
            //    static y = 1;                 | C.y = 1;
            //  }                               | C = C_1 = __decorate([dec], C);
            //                                  | export default C;
            //                                  | var C_1;
            //  ---------------------------------------------------------------------
            //
            var location = ts.moveRangePastDecorators(node);
            var classAlias = getClassAliasIfNeeded(node);
            // When we transform to ES5/3 this will be moved inside an IIFE and should reference the name
            // without any block-scoped variable collision handling
            var declName = languageVersion <= 2 /* ScriptTarget.ES2015 */ ?
                factory.getInternalName(node, /*allowComments*/ false, /*allowSourceMaps*/ true) :
                factory.getLocalName(node, /*allowComments*/ false, /*allowSourceMaps*/ true);
            //  ... = class ${name} ${heritageClauses} {
            //      ${members}
            //  }
            var heritageClauses = ts.visitNodes(node.heritageClauses, visitor, ts.isHeritageClause);
            var members = transformClassMembers(node);
            var classExpression = factory.createClassExpression(/*decorators*/ undefined, /*modifiers*/ undefined, name, /*typeParameters*/ undefined, heritageClauses, members);
            ts.setOriginalNode(classExpression, node);
            ts.setTextRange(classExpression, location);
            //  let ${name} = ${classExpression} where name is either declaredName if the class doesn't contain self-reference
            //                                         or decoratedClassAlias if the class contain self-reference.
            var statement = factory.createVariableStatement(
            /*modifiers*/ undefined, factory.createVariableDeclarationList([
                factory.createVariableDeclaration(declName, 
                /*exclamationToken*/ undefined, 
                /*type*/ undefined, classAlias ? factory.createAssignment(classAlias, classExpression) : classExpression)
            ], 1 /* NodeFlags.Let */));
            ts.setOriginalNode(statement, node);
            ts.setTextRange(statement, location);
            ts.setCommentRange(statement, node);
            return statement;
        }
        function visitClassExpression(node) {
            if (!isClassLikeDeclarationWithTypeScriptSyntax(node)) {
                return ts.visitEachChild(node, visitor, context);
            }
            var classExpression = factory.createClassExpression(
            /*decorators*/ undefined, 
            /*modifiers*/ undefined, node.name, 
            /*typeParameters*/ undefined, ts.visitNodes(node.heritageClauses, visitor, ts.isHeritageClause), transformClassMembers(node));
            ts.setOriginalNode(classExpression, node);
            ts.setTextRange(classExpression, node);
            return classExpression;
        }
        /**
         * Transforms the members of a class.
         *
         * @param node The current class.
         */
        function transformClassMembers(node) {
            var members = [];
            var constructor = ts.getFirstConstructorWithBody(node);
            var parametersWithPropertyAssignments = constructor &&
                ts.filter(constructor.parameters, function (p) { return ts.isParameterPropertyDeclaration(p, constructor); });
            if (parametersWithPropertyAssignments) {
                for (var _i = 0, parametersWithPropertyAssignments_1 = parametersWithPropertyAssignments; _i < parametersWithPropertyAssignments_1.length; _i++) {
                    var parameter = parametersWithPropertyAssignments_1[_i];
                    if (ts.isIdentifier(parameter.name)) {
                        members.push(ts.setOriginalNode(factory.createPropertyDeclaration(
                        /*decorators*/ undefined, 
                        /*modifiers*/ undefined, parameter.name, 
                        /*questionOrExclamationToken*/ undefined, 
                        /*type*/ undefined, 
                        /*initializer*/ undefined), parameter));
                    }
                }
            }
            ts.addRange(members, ts.visitNodes(node.members, classElementVisitor, ts.isClassElement));
            return ts.setTextRange(factory.createNodeArray(members), /*location*/ node.members);
        }
        /**
         * Gets either the static or instance members of a class that are decorated, or have
         * parameters that are decorated.
         *
         * @param node The class containing the member.
         * @param isStatic A value indicating whether to retrieve static or instance members of
         *                 the class.
         */
        function getDecoratedClassElements(node, isStatic) {
            return ts.filter(node.members, isStatic ? function (m) { return isStaticDecoratedClassElement(m, node); } : function (m) { return isInstanceDecoratedClassElement(m, node); });
        }
        /**
         * Determines whether a class member is a static member of a class that is decorated, or
         * has parameters that are decorated.
         *
         * @param member The class member.
         */
        function isStaticDecoratedClassElement(member, parent) {
            return isDecoratedClassElement(member, /*isStaticElement*/ true, parent);
        }
        /**
         * Determines whether a class member is an instance member of a class that is decorated,
         * or has parameters that are decorated.
         *
         * @param member The class member.
         */
        function isInstanceDecoratedClassElement(member, parent) {
            return isDecoratedClassElement(member, /*isStaticElement*/ false, parent);
        }
        /**
         * Determines whether a class member is either a static or an instance member of a class
         * that is decorated, or has parameters that are decorated.
         *
         * @param member The class member.
         */
        function isDecoratedClassElement(member, isStaticElement, parent) {
            return ts.nodeOrChildIsDecorated(member, parent)
                && isStaticElement === ts.isStatic(member);
        }
        /**
         * Gets an array of arrays of decorators for the parameters of a function-like node.
         * The offset into the result array should correspond to the offset of the parameter.
         *
         * @param node The function-like node.
         */
        function getDecoratorsOfParameters(node) {
            var decorators;
            if (node) {
                var parameters = node.parameters;
                var firstParameterIsThis = parameters.length > 0 && ts.parameterIsThisKeyword(parameters[0]);
                var firstParameterOffset = firstParameterIsThis ? 1 : 0;
                var numParameters = firstParameterIsThis ? parameters.length - 1 : parameters.length;
                for (var i = 0; i < numParameters; i++) {
                    var parameter = parameters[i + firstParameterOffset];
                    if (decorators || parameter.decorators) {
                        if (!decorators) {
                            decorators = new Array(numParameters);
                        }
                        decorators[i] = parameter.decorators;
                    }
                }
            }
            return decorators;
        }
        /**
         * Gets an AllDecorators object containing the decorators for the class and the decorators for the
         * parameters of the constructor of the class.
         *
         * @param node The class node.
         */
        function getAllDecoratorsOfConstructor(node) {
            var decorators = node.decorators;
            var parameters = getDecoratorsOfParameters(ts.getFirstConstructorWithBody(node));
            if (!decorators && !parameters) {
                return undefined;
            }
            return {
                decorators: decorators,
                parameters: parameters
            };
        }
        /**
         * Gets an AllDecorators object containing the decorators for the member and its parameters.
         *
         * @param node The class node that contains the member.
         * @param member The class member.
         */
        function getAllDecoratorsOfClassElement(node, member) {
            switch (member.kind) {
                case 172 /* SyntaxKind.GetAccessor */:
                case 173 /* SyntaxKind.SetAccessor */:
                    return getAllDecoratorsOfAccessors(node, member);
                case 169 /* SyntaxKind.MethodDeclaration */:
                    return getAllDecoratorsOfMethod(member);
                case 167 /* SyntaxKind.PropertyDeclaration */:
                    return getAllDecoratorsOfProperty(member);
                default:
                    return undefined;
            }
        }
        /**
         * Gets an AllDecorators object containing the decorators for the accessor and its parameters.
         *
         * @param node The class node that contains the accessor.
         * @param accessor The class accessor member.
         */
        function getAllDecoratorsOfAccessors(node, accessor) {
            if (!accessor.body) {
                return undefined;
            }
            var _a = ts.getAllAccessorDeclarations(node.members, accessor), firstAccessor = _a.firstAccessor, secondAccessor = _a.secondAccessor, setAccessor = _a.setAccessor;
            var firstAccessorWithDecorators = firstAccessor.decorators ? firstAccessor : secondAccessor && secondAccessor.decorators ? secondAccessor : undefined;
            if (!firstAccessorWithDecorators || accessor !== firstAccessorWithDecorators) {
                return undefined;
            }
            var decorators = firstAccessorWithDecorators.decorators;
            var parameters = getDecoratorsOfParameters(setAccessor);
            if (!decorators && !parameters) {
                return undefined;
            }
            return { decorators: decorators, parameters: parameters };
        }
        /**
         * Gets an AllDecorators object containing the decorators for the method and its parameters.
         *
         * @param method The class method member.
         */
        function getAllDecoratorsOfMethod(method) {
            if (!method.body) {
                return undefined;
            }
            var decorators = method.decorators;
            var parameters = getDecoratorsOfParameters(method);
            if (!decorators && !parameters) {
                return undefined;
            }
            return { decorators: decorators, parameters: parameters };
        }
        /**
         * Gets an AllDecorators object containing the decorators for the property.
         *
         * @param property The class property member.
         */
        function getAllDecoratorsOfProperty(property) {
            var decorators = property.decorators;
            if (!decorators) {
                return undefined;
            }
            return { decorators: decorators };
        }
        /**
         * Transforms all of the decorators for a declaration into an array of expressions.
         *
         * @param node The declaration node.
         * @param allDecorators An object containing all of the decorators for the declaration.
         */
        function transformAllDecoratorsOfDeclaration(node, container, allDecorators) {
            if (!allDecorators) {
                return undefined;
            }
            var decoratorExpressions = [];
            ts.addRange(decoratorExpressions, ts.map(allDecorators.decorators, transformDecorator));
            ts.addRange(decoratorExpressions, ts.flatMap(allDecorators.parameters, transformDecoratorsOfParameter));
            addTypeMetadata(node, container, decoratorExpressions);
            return decoratorExpressions;
        }
        /**
         * Generates statements used to apply decorators to either the static or instance members
         * of a class.
         *
         * @param node The class node.
         * @param isStatic A value indicating whether to generate statements for static or
         *                 instance members.
         */
        function addClassElementDecorationStatements(statements, node, isStatic) {
            ts.addRange(statements, ts.map(generateClassElementDecorationExpressions(node, isStatic), expressionToStatement));
        }
        /**
         * Generates expressions used to apply decorators to either the static or instance members
         * of a class.
         *
         * @param node The class node.
         * @param isStatic A value indicating whether to generate expressions for static or
         *                 instance members.
         */
        function generateClassElementDecorationExpressions(node, isStatic) {
            var members = getDecoratedClassElements(node, isStatic);
            var expressions;
            for (var _i = 0, members_8 = members; _i < members_8.length; _i++) {
                var member = members_8[_i];
                var expression = generateClassElementDecorationExpression(node, member);
                if (expression) {
                    if (!expressions) {
                        expressions = [expression];
                    }
                    else {
                        expressions.push(expression);
                    }
                }
            }
            return expressions;
        }
        /**
         * Generates an expression used to evaluate class element decorators at runtime.
         *
         * @param node The class node that contains the member.
         * @param member The class member.
         */
        function generateClassElementDecorationExpression(node, member) {
            var allDecorators = getAllDecoratorsOfClassElement(node, member);
            var decoratorExpressions = transformAllDecoratorsOfDeclaration(member, node, allDecorators);
            if (!decoratorExpressions) {
                return undefined;
            }
            // Emit the call to __decorate. Given the following:
            //
            //   class C {
            //     @dec method(@dec2 x) {}
            //     @dec get accessor() {}
            //     @dec prop;
            //   }
            //
            // The emit for a method is:
            //
            //   __decorate([
            //       dec,
            //       __param(0, dec2),
            //       __metadata("design:type", Function),
            //       __metadata("design:paramtypes", [Object]),
            //       __metadata("design:returntype", void 0)
            //   ], C.prototype, "method", null);
            //
            // The emit for an accessor is:
            //
            //   __decorate([
            //       dec
            //   ], C.prototype, "accessor", null);
            //
            // The emit for a property is:
            //
            //   __decorate([
            //       dec
            //   ], C.prototype, "prop");
            //
            var prefix = getClassMemberPrefix(node, member);
            var memberName = getExpressionForPropertyName(member, /*generateNameForComputedPropertyName*/ !ts.hasSyntacticModifier(member, 2 /* ModifierFlags.Ambient */));
            var descriptor = languageVersion > 0 /* ScriptTarget.ES3 */
                ? member.kind === 167 /* SyntaxKind.PropertyDeclaration */
                    // We emit `void 0` here to indicate to `__decorate` that it can invoke `Object.defineProperty` directly, but that it
                    // should not invoke `Object.getOwnPropertyDescriptor`.
                    ? factory.createVoidZero()
                    // We emit `null` here to indicate to `__decorate` that it can invoke `Object.getOwnPropertyDescriptor` directly.
                    // We have this extra argument here so that we can inject an explicit property descriptor at a later date.
                    : factory.createNull()
                : undefined;
            var helper = emitHelpers().createDecorateHelper(decoratorExpressions, prefix, memberName, descriptor);
            ts.setTextRange(helper, ts.moveRangePastDecorators(member));
            ts.setEmitFlags(helper, 1536 /* EmitFlags.NoComments */);
            return helper;
        }
        /**
         * Generates a __decorate helper call for a class constructor.
         *
         * @param node The class node.
         */
        function addConstructorDecorationStatement(statements, node) {
            var expression = generateConstructorDecorationExpression(node);
            if (expression) {
                statements.push(ts.setOriginalNode(factory.createExpressionStatement(expression), node));
            }
        }
        /**
         * Generates a __decorate helper call for a class constructor.
         *
         * @param node The class node.
         */
        function generateConstructorDecorationExpression(node) {
            var allDecorators = getAllDecoratorsOfConstructor(node);
            var decoratorExpressions = transformAllDecoratorsOfDeclaration(node, node, allDecorators);
            if (!decoratorExpressions) {
                return undefined;
            }
            var classAlias = classAliases && classAliases[ts.getOriginalNodeId(node)];
            // When we transform to ES5/3 this will be moved inside an IIFE and should reference the name
            // without any block-scoped variable collision handling
            var localName = languageVersion <= 2 /* ScriptTarget.ES2015 */ ?
                factory.getInternalName(node, /*allowComments*/ false, /*allowSourceMaps*/ true) :
                factory.getLocalName(node, /*allowComments*/ false, /*allowSourceMaps*/ true);
            var decorate = emitHelpers().createDecorateHelper(decoratorExpressions, localName);
            var expression = factory.createAssignment(localName, classAlias ? factory.createAssignment(classAlias, decorate) : decorate);
            ts.setEmitFlags(expression, 1536 /* EmitFlags.NoComments */);
            ts.setSourceMapRange(expression, ts.moveRangePastDecorators(node));
            return expression;
        }
        /**
         * Transforms a decorator into an expression.
         *
         * @param decorator The decorator node.
         */
        function transformDecorator(decorator) {
            return ts.visitNode(decorator.expression, visitor, ts.isExpression);
        }
        /**
         * Transforms the decorators of a parameter.
         *
         * @param decorators The decorators for the parameter at the provided offset.
         * @param parameterOffset The offset of the parameter.
         */
        function transformDecoratorsOfParameter(decorators, parameterOffset) {
            var expressions;
            if (decorators) {
                expressions = [];
                for (var _i = 0, decorators_1 = decorators; _i < decorators_1.length; _i++) {
                    var decorator = decorators_1[_i];
                    var helper = emitHelpers().createParamHelper(transformDecorator(decorator), parameterOffset);
                    ts.setTextRange(helper, decorator.expression);
                    ts.setEmitFlags(helper, 1536 /* EmitFlags.NoComments */);
                    expressions.push(helper);
                }
            }
            return expressions;
        }
        /**
         * Adds optional type metadata for a declaration.
         *
         * @param node The declaration node.
         * @param decoratorExpressions The destination array to which to add new decorator expressions.
         */
        function addTypeMetadata(node, container, decoratorExpressions) {
            if (USE_NEW_TYPE_METADATA_FORMAT) {
                addNewTypeMetadata(node, container, decoratorExpressions);
            }
            else {
                addOldTypeMetadata(node, container, decoratorExpressions);
            }
        }
        function addOldTypeMetadata(node, container, decoratorExpressions) {
            if (compilerOptions.emitDecoratorMetadata) {
                if (shouldAddTypeMetadata(node)) {
                    decoratorExpressions.push(emitHelpers().createMetadataHelper("design:type", serializeTypeOfNode(node)));
                }
                if (shouldAddParamTypesMetadata(node)) {
                    decoratorExpressions.push(emitHelpers().createMetadataHelper("design:paramtypes", serializeParameterTypesOfNode(node, container)));
                }
                if (shouldAddReturnTypeMetadata(node)) {
                    decoratorExpressions.push(emitHelpers().createMetadataHelper("design:returntype", serializeReturnTypeOfNode(node)));
                }
            }
        }
        function addNewTypeMetadata(node, container, decoratorExpressions) {
            if (compilerOptions.emitDecoratorMetadata) {
                var properties = void 0;
                if (shouldAddTypeMetadata(node)) {
                    (properties || (properties = [])).push(factory.createPropertyAssignment("type", factory.createArrowFunction(/*modifiers*/ undefined, /*typeParameters*/ undefined, [], /*type*/ undefined, factory.createToken(38 /* SyntaxKind.EqualsGreaterThanToken */), serializeTypeOfNode(node))));
                }
                if (shouldAddParamTypesMetadata(node)) {
                    (properties || (properties = [])).push(factory.createPropertyAssignment("paramTypes", factory.createArrowFunction(/*modifiers*/ undefined, /*typeParameters*/ undefined, [], /*type*/ undefined, factory.createToken(38 /* SyntaxKind.EqualsGreaterThanToken */), serializeParameterTypesOfNode(node, container))));
                }
                if (shouldAddReturnTypeMetadata(node)) {
                    (properties || (properties = [])).push(factory.createPropertyAssignment("returnType", factory.createArrowFunction(/*modifiers*/ undefined, /*typeParameters*/ undefined, [], /*type*/ undefined, factory.createToken(38 /* SyntaxKind.EqualsGreaterThanToken */), serializeReturnTypeOfNode(node))));
                }
                if (properties) {
                    decoratorExpressions.push(emitHelpers().createMetadataHelper("design:typeinfo", factory.createObjectLiteralExpression(properties, /*multiLine*/ true)));
                }
            }
        }
        /**
         * Determines whether to emit the "design:type" metadata based on the node's kind.
         * The caller should have already tested whether the node has decorators and whether the
         * emitDecoratorMetadata compiler option is set.
         *
         * @param node The node to test.
         */
        function shouldAddTypeMetadata(node) {
            var kind = node.kind;
            return kind === 169 /* SyntaxKind.MethodDeclaration */
                || kind === 172 /* SyntaxKind.GetAccessor */
                || kind === 173 /* SyntaxKind.SetAccessor */
                || kind === 167 /* SyntaxKind.PropertyDeclaration */;
        }
        /**
         * Determines whether to emit the "design:returntype" metadata based on the node's kind.
         * The caller should have already tested whether the node has decorators and whether the
         * emitDecoratorMetadata compiler option is set.
         *
         * @param node The node to test.
         */
        function shouldAddReturnTypeMetadata(node) {
            return node.kind === 169 /* SyntaxKind.MethodDeclaration */;
        }
        /**
         * Determines whether to emit the "design:paramtypes" metadata based on the node's kind.
         * The caller should have already tested whether the node has decorators and whether the
         * emitDecoratorMetadata compiler option is set.
         *
         * @param node The node to test.
         */
        function shouldAddParamTypesMetadata(node) {
            switch (node.kind) {
                case 257 /* SyntaxKind.ClassDeclaration */:
                case 226 /* SyntaxKind.ClassExpression */:
                    return ts.getFirstConstructorWithBody(node) !== undefined;
                case 169 /* SyntaxKind.MethodDeclaration */:
                case 172 /* SyntaxKind.GetAccessor */:
                case 173 /* SyntaxKind.SetAccessor */:
                    return true;
            }
            return false;
        }
        function getAccessorTypeNode(node) {
            var accessors = resolver.getAllAccessorDeclarations(node);
            return accessors.setAccessor && ts.getSetAccessorTypeAnnotationNode(accessors.setAccessor)
                || accessors.getAccessor && ts.getEffectiveReturnTypeNode(accessors.getAccessor);
        }
        /**
         * Serializes the type of a node for use with decorator type metadata.
         *
         * @param node The node that should have its type serialized.
         */
        function serializeTypeOfNode(node) {
            switch (node.kind) {
                case 167 /* SyntaxKind.PropertyDeclaration */:
                case 164 /* SyntaxKind.Parameter */:
                    return serializeTypeNode(node.type);
                case 173 /* SyntaxKind.SetAccessor */:
                case 172 /* SyntaxKind.GetAccessor */:
                    return serializeTypeNode(getAccessorTypeNode(node));
                case 257 /* SyntaxKind.ClassDeclaration */:
                case 226 /* SyntaxKind.ClassExpression */:
                case 169 /* SyntaxKind.MethodDeclaration */:
                    return factory.createIdentifier("Function");
                default:
                    return factory.createVoidZero();
            }
        }
        /**
         * Serializes the types of the parameters of a node for use with decorator type metadata.
         *
         * @param node The node that should have its parameter types serialized.
         */
        function serializeParameterTypesOfNode(node, container) {
            var valueDeclaration = ts.isClassLike(node)
                ? ts.getFirstConstructorWithBody(node)
                : ts.isFunctionLike(node) && ts.nodeIsPresent(node.body)
                    ? node
                    : undefined;
            var expressions = [];
            if (valueDeclaration) {
                var parameters = getParametersOfDecoratedDeclaration(valueDeclaration, container);
                var numParameters = parameters.length;
                for (var i = 0; i < numParameters; i++) {
                    var parameter = parameters[i];
                    if (i === 0 && ts.isIdentifier(parameter.name) && parameter.name.escapedText === "this") {
                        continue;
                    }
                    if (parameter.dotDotDotToken) {
                        expressions.push(serializeTypeNode(ts.getRestParameterElementType(parameter.type)));
                    }
                    else {
                        expressions.push(serializeTypeOfNode(parameter));
                    }
                }
            }
            return factory.createArrayLiteralExpression(expressions);
        }
        function getParametersOfDecoratedDeclaration(node, container) {
            if (container && node.kind === 172 /* SyntaxKind.GetAccessor */) {
                var setAccessor = ts.getAllAccessorDeclarations(container.members, node).setAccessor;
                if (setAccessor) {
                    return setAccessor.parameters;
                }
            }
            return node.parameters;
        }
        /**
         * Serializes the return type of a node for use with decorator type metadata.
         *
         * @param node The node that should have its return type serialized.
         */
        function serializeReturnTypeOfNode(node) {
            if (ts.isFunctionLike(node) && node.type) {
                return serializeTypeNode(node.type);
            }
            else if (ts.isAsyncFunction(node)) {
                return factory.createIdentifier("Promise");
            }
            return factory.createVoidZero();
        }
        /**
         * Serializes a type node for use with decorator type metadata.
         *
         * Types are serialized in the following fashion:
         * - Void types point to "undefined" (e.g. "void 0")
         * - Function and Constructor types point to the global "Function" constructor.
         * - Interface types with a call or construct signature types point to the global
         *   "Function" constructor.
         * - Array and Tuple types point to the global "Array" constructor.
         * - Type predicates and booleans point to the global "Boolean" constructor.
         * - String literal types and strings point to the global "String" constructor.
         * - Enum and number types point to the global "Number" constructor.
         * - Symbol types point to the global "Symbol" constructor.
         * - Type references to classes (or class-like variables) point to the constructor for the class.
         * - Anything else points to the global "Object" constructor.
         *
         * @param node The type node to serialize.
         */
        function serializeTypeNode(node) {
            if (node === undefined) {
                return factory.createIdentifier("Object");
            }
            switch (node.kind) {
                case 114 /* SyntaxKind.VoidKeyword */:
                case 153 /* SyntaxKind.UndefinedKeyword */:
                case 143 /* SyntaxKind.NeverKeyword */:
                    return factory.createVoidZero();
                case 191 /* SyntaxKind.ParenthesizedType */:
                    return serializeTypeNode(node.type);
                case 179 /* SyntaxKind.FunctionType */:
                case 180 /* SyntaxKind.ConstructorType */:
                    return factory.createIdentifier("Function");
                case 183 /* SyntaxKind.ArrayType */:
                case 184 /* SyntaxKind.TupleType */:
                    return factory.createIdentifier("Array");
                case 177 /* SyntaxKind.TypePredicate */:
                case 133 /* SyntaxKind.BooleanKeyword */:
                    return factory.createIdentifier("Boolean");
                case 198 /* SyntaxKind.TemplateLiteralType */:
                case 150 /* SyntaxKind.StringKeyword */:
                    return factory.createIdentifier("String");
                case 148 /* SyntaxKind.ObjectKeyword */:
                    return factory.createIdentifier("Object");
                case 196 /* SyntaxKind.LiteralType */:
                    switch (node.literal.kind) {
                        case 10 /* SyntaxKind.StringLiteral */:
                        case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
                            return factory.createIdentifier("String");
                        case 219 /* SyntaxKind.PrefixUnaryExpression */:
                        case 8 /* SyntaxKind.NumericLiteral */:
                            return factory.createIdentifier("Number");
                        case 9 /* SyntaxKind.BigIntLiteral */:
                            return getGlobalBigIntNameWithFallback();
                        case 110 /* SyntaxKind.TrueKeyword */:
                        case 95 /* SyntaxKind.FalseKeyword */:
                            return factory.createIdentifier("Boolean");
                        case 104 /* SyntaxKind.NullKeyword */:
                            return factory.createVoidZero();
                        default:
                            return ts.Debug.failBadSyntaxKind(node.literal);
                    }
                case 147 /* SyntaxKind.NumberKeyword */:
                    return factory.createIdentifier("Number");
                case 158 /* SyntaxKind.BigIntKeyword */:
                    return getGlobalBigIntNameWithFallback();
                case 151 /* SyntaxKind.SymbolKeyword */:
                    return languageVersion < 2 /* ScriptTarget.ES2015 */
                        ? getGlobalSymbolNameWithFallback()
                        : factory.createIdentifier("Symbol");
                case 178 /* SyntaxKind.TypeReference */:
                    return serializeTypeReferenceNode(node);
                case 188 /* SyntaxKind.IntersectionType */:
                case 187 /* SyntaxKind.UnionType */:
                    return serializeTypeList(node.types);
                case 189 /* SyntaxKind.ConditionalType */:
                    return serializeTypeList([node.trueType, node.falseType]);
                case 193 /* SyntaxKind.TypeOperator */:
                    if (node.operator === 145 /* SyntaxKind.ReadonlyKeyword */) {
                        return serializeTypeNode(node.type);
                    }
                    break;
                case 181 /* SyntaxKind.TypeQuery */:
                case 194 /* SyntaxKind.IndexedAccessType */:
                case 195 /* SyntaxKind.MappedType */:
                case 182 /* SyntaxKind.TypeLiteral */:
                case 130 /* SyntaxKind.AnyKeyword */:
                case 155 /* SyntaxKind.UnknownKeyword */:
                case 192 /* SyntaxKind.ThisType */:
                case 200 /* SyntaxKind.ImportType */:
                    break;
                // handle JSDoc types from an invalid parse
                case 312 /* SyntaxKind.JSDocAllType */:
                case 313 /* SyntaxKind.JSDocUnknownType */:
                case 317 /* SyntaxKind.JSDocFunctionType */:
                case 318 /* SyntaxKind.JSDocVariadicType */:
                case 319 /* SyntaxKind.JSDocNamepathType */:
                    break;
                case 314 /* SyntaxKind.JSDocNullableType */:
                case 315 /* SyntaxKind.JSDocNonNullableType */:
                case 316 /* SyntaxKind.JSDocOptionalType */:
                    return serializeTypeNode(node.type);
                default:
                    return ts.Debug.failBadSyntaxKind(node);
            }
            return factory.createIdentifier("Object");
        }
        function serializeTypeList(types) {
            // Note when updating logic here also update getEntityNameForDecoratorMetadata
            // so that aliases can be marked as referenced
            var serializedUnion;
            for (var _i = 0, types_23 = types; _i < types_23.length; _i++) {
                var typeNode = types_23[_i];
                while (typeNode.kind === 191 /* SyntaxKind.ParenthesizedType */) {
                    typeNode = typeNode.type; // Skip parens if need be
                }
                if (typeNode.kind === 143 /* SyntaxKind.NeverKeyword */) {
                    continue; // Always elide `never` from the union/intersection if possible
                }
                if (!strictNullChecks && (typeNode.kind === 196 /* SyntaxKind.LiteralType */ && typeNode.literal.kind === 104 /* SyntaxKind.NullKeyword */ || typeNode.kind === 153 /* SyntaxKind.UndefinedKeyword */)) {
                    continue; // Elide null and undefined from unions for metadata, just like what we did prior to the implementation of strict null checks
                }
                var serializedIndividual = serializeTypeNode(typeNode);
                if (ts.isIdentifier(serializedIndividual) && serializedIndividual.escapedText === "Object") {
                    // One of the individual is global object, return immediately
                    return serializedIndividual;
                }
                // If there exists union that is not void 0 expression, check if the the common type is identifier.
                // anything more complex and we will just default to Object
                else if (serializedUnion) {
                    // Different types
                    if (!ts.isIdentifier(serializedUnion) ||
                        !ts.isIdentifier(serializedIndividual) ||
                        serializedUnion.escapedText !== serializedIndividual.escapedText) {
                        return factory.createIdentifier("Object");
                    }
                }
                else {
                    // Initialize the union type
                    serializedUnion = serializedIndividual;
                }
            }
            // If we were able to find common type, use it
            return serializedUnion || factory.createVoidZero(); // Fallback is only hit if all union constituients are null/undefined/never
        }
        /**
         * Serializes a TypeReferenceNode to an appropriate JS constructor value for use with
         * decorator type metadata.
         *
         * @param node The type reference node.
         */
        function serializeTypeReferenceNode(node) {
            var kind = resolver.getTypeReferenceSerializationKind(node.typeName, currentNameScope || currentLexicalScope);
            switch (kind) {
                case ts.TypeReferenceSerializationKind.Unknown:
                    // From conditional type type reference that cannot be resolved is Similar to any or unknown
                    if (ts.findAncestor(node, function (n) { return n.parent && ts.isConditionalTypeNode(n.parent) && (n.parent.trueType === n || n.parent.falseType === n); })) {
                        return factory.createIdentifier("Object");
                    }
                    var serialized = serializeEntityNameAsExpressionFallback(node.typeName);
                    var temp = factory.createTempVariable(hoistVariableDeclaration);
                    return factory.createConditionalExpression(factory.createTypeCheck(factory.createAssignment(temp, serialized), "function"), 
                    /*questionToken*/ undefined, temp, 
                    /*colonToken*/ undefined, factory.createIdentifier("Object"));
                case ts.TypeReferenceSerializationKind.TypeWithConstructSignatureAndValue:
                    return serializeEntityNameAsExpression(node.typeName);
                case ts.TypeReferenceSerializationKind.VoidNullableOrNeverType:
                    return factory.createVoidZero();
                case ts.TypeReferenceSerializationKind.BigIntLikeType:
                    return getGlobalBigIntNameWithFallback();
                case ts.TypeReferenceSerializationKind.BooleanType:
                    return factory.createIdentifier("Boolean");
                case ts.TypeReferenceSerializationKind.NumberLikeType:
                    return factory.createIdentifier("Number");
                case ts.TypeReferenceSerializationKind.StringLikeType:
                    return factory.createIdentifier("String");
                case ts.TypeReferenceSerializationKind.ArrayLikeType:
                    return factory.createIdentifier("Array");
                case ts.TypeReferenceSerializationKind.ESSymbolType:
                    return languageVersion < 2 /* ScriptTarget.ES2015 */
                        ? getGlobalSymbolNameWithFallback()
                        : factory.createIdentifier("Symbol");
                case ts.TypeReferenceSerializationKind.TypeWithCallSignature:
                    return factory.createIdentifier("Function");
                case ts.TypeReferenceSerializationKind.Promise:
                    return factory.createIdentifier("Promise");
                case ts.TypeReferenceSerializationKind.ObjectType:
                    return factory.createIdentifier("Object");
                default:
                    return ts.Debug.assertNever(kind);
            }
        }
        function createCheckedValue(left, right) {
            return factory.createLogicalAnd(factory.createStrictInequality(factory.createTypeOfExpression(left), factory.createStringLiteral("undefined")), right);
        }
        /**
         * Serializes an entity name which may not exist at runtime, but whose access shouldn't throw
         *
         * @param node The entity name to serialize.
         */
        function serializeEntityNameAsExpressionFallback(node) {
            if (node.kind === 79 /* SyntaxKind.Identifier */) {
                // A -> typeof A !== undefined && A
                var copied = serializeEntityNameAsExpression(node);
                return createCheckedValue(copied, copied);
            }
            if (node.left.kind === 79 /* SyntaxKind.Identifier */) {
                // A.B -> typeof A !== undefined && A.B
                return createCheckedValue(serializeEntityNameAsExpression(node.left), serializeEntityNameAsExpression(node));
            }
            // A.B.C -> typeof A !== undefined && (_a = A.B) !== void 0 && _a.C
            var left = serializeEntityNameAsExpressionFallback(node.left);
            var temp = factory.createTempVariable(hoistVariableDeclaration);
            return factory.createLogicalAnd(factory.createLogicalAnd(left.left, factory.createStrictInequality(factory.createAssignment(temp, left.right), factory.createVoidZero())), factory.createPropertyAccessExpression(temp, node.right));
        }
        /**
         * Serializes an entity name as an expression for decorator type metadata.
         *
         * @param node The entity name to serialize.
         */
        function serializeEntityNameAsExpression(node) {
            switch (node.kind) {
                case 79 /* SyntaxKind.Identifier */:
                    // Create a clone of the name with a new parent, and treat it as if it were
                    // a source tree node for the purposes of the checker.
                    var name = ts.setParent(ts.setTextRange(ts.parseNodeFactory.cloneNode(node), node), node.parent);
                    name.original = undefined;
                    ts.setParent(name, ts.getParseTreeNode(currentLexicalScope)); // ensure the parent is set to a parse tree node.
                    return name;
                case 161 /* SyntaxKind.QualifiedName */:
                    return serializeQualifiedNameAsExpression(node);
            }
        }
        /**
         * Serializes an qualified name as an expression for decorator type metadata.
         *
         * @param node The qualified name to serialize.
         * @param useFallback A value indicating whether to use logical operators to test for the
         *                    qualified name at runtime.
         */
        function serializeQualifiedNameAsExpression(node) {
            return factory.createPropertyAccessExpression(serializeEntityNameAsExpression(node.left), node.right);
        }
        /**
         * Gets an expression that points to the global "Symbol" constructor at runtime if it is
         * available.
         */
        function getGlobalSymbolNameWithFallback() {
            return factory.createConditionalExpression(factory.createTypeCheck(factory.createIdentifier("Symbol"), "function"), 
            /*questionToken*/ undefined, factory.createIdentifier("Symbol"), 
            /*colonToken*/ undefined, factory.createIdentifier("Object"));
        }
        /**
         * Gets an expression that points to the global "BigInt" constructor at runtime if it is
         * available.
         */
        function getGlobalBigIntNameWithFallback() {
            return languageVersion < 99 /* ScriptTarget.ESNext */
                ? factory.createConditionalExpression(factory.createTypeCheck(factory.createIdentifier("BigInt"), "function"), 
                /*questionToken*/ undefined, factory.createIdentifier("BigInt"), 
                /*colonToken*/ undefined, factory.createIdentifier("Object"))
                : factory.createIdentifier("BigInt");
        }
        /**
         * Gets an expression that represents a property name (for decorated properties or enums).
         * For a computed property, a name is generated for the node.
         *
         * @param member The member whose name should be converted into an expression.
         */
        function getExpressionForPropertyName(member, generateNameForComputedPropertyName) {
            var name = member.name;
            if (ts.isPrivateIdentifier(name)) {
                return factory.createIdentifier("");
            }
            else if (ts.isComputedPropertyName(name)) {
                return generateNameForComputedPropertyName && !ts.isSimpleInlineableExpression(name.expression)
                    ? factory.getGeneratedNameForNode(name)
                    : name.expression;
            }
            else if (ts.isIdentifier(name)) {
                return factory.createStringLiteral(ts.idText(name));
            }
            else {
                return factory.cloneNode(name);
            }
        }
        /**
         * Visits the property name of a class element, for use when emitting property
         * initializers. For a computed property on a node with decorators, a temporary
         * value is stored for later use.
         *
         * @param member The member whose name should be visited.
         */
        function visitPropertyNameOfClassElement(member) {
            var name = member.name;
            // Computed property names need to be transformed into a hoisted variable when they are used more than once.
            // The names are used more than once when:
            //   - the property is non-static and its initializer is moved to the constructor (when there are parameter property assignments).
            //   - the property has a decorator.
            if (ts.isComputedPropertyName(name) && ((!ts.hasStaticModifier(member) && currentClassHasParameterProperties) || ts.some(member.decorators))) {
                var expression = ts.visitNode(name.expression, visitor, ts.isExpression);
                var innerExpression = ts.skipPartiallyEmittedExpressions(expression);
                if (!ts.isSimpleInlineableExpression(innerExpression)) {
                    var generatedName = factory.getGeneratedNameForNode(name);
                    hoistVariableDeclaration(generatedName);
                    return factory.updateComputedPropertyName(name, factory.createAssignment(generatedName, expression));
                }
            }
            return ts.visitNode(name, visitor, ts.isPropertyName);
        }
        /**
         * Transforms a HeritageClause with TypeScript syntax.
         *
         * This function will only be called when one of the following conditions are met:
         * - The node is a non-`extends` heritage clause that should be elided.
         * - The node is an `extends` heritage clause that should be visited, but only allow a single type.
         *
         * @param node The HeritageClause to transform.
         */
        function visitHeritageClause(node) {
            if (node.token === 117 /* SyntaxKind.ImplementsKeyword */) {
                // implements clauses are elided
                return undefined;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        /**
         * Transforms an ExpressionWithTypeArguments with TypeScript syntax.
         *
         * This function will only be called when one of the following conditions are met:
         * - The node contains type arguments that should be elided.
         *
         * @param node The ExpressionWithTypeArguments to transform.
         */
        function visitExpressionWithTypeArguments(node) {
            return factory.updateExpressionWithTypeArguments(node, ts.visitNode(node.expression, visitor, ts.isLeftHandSideExpression), 
            /*typeArguments*/ undefined);
        }
        /**
         * Determines whether to emit a function-like declaration. We should not emit the
         * declaration if it does not have a body.
         *
         * @param node The declaration node.
         */
        function shouldEmitFunctionLikeDeclaration(node) {
            return !ts.nodeIsMissing(node.body);
        }
        function visitPropertyDeclaration(node) {
            if (node.flags & 16777216 /* NodeFlags.Ambient */ || ts.hasSyntacticModifier(node, 128 /* ModifierFlags.Abstract */)) {
                return undefined;
            }
            var updated = factory.updatePropertyDeclaration(node, 
            /*decorators*/ undefined, ts.visitNodes(node.modifiers, visitor, ts.isModifier), visitPropertyNameOfClassElement(node), 
            /*questionOrExclamationToken*/ undefined, 
            /*type*/ undefined, ts.visitNode(node.initializer, visitor));
            if (updated !== node) {
                // While we emit the source map for the node after skipping decorators and modifiers,
                // we need to emit the comments for the original range.
                ts.setCommentRange(updated, node);
                ts.setSourceMapRange(updated, ts.moveRangePastDecorators(node));
            }
            return updated;
        }
        function visitConstructor(node) {
            if (!shouldEmitFunctionLikeDeclaration(node)) {
                return undefined;
            }
            return factory.updateConstructorDeclaration(node, 
            /*decorators*/ undefined, 
            /*modifiers*/ undefined, ts.visitParameterList(node.parameters, visitor, context), transformConstructorBody(node.body, node));
        }
        function transformConstructorBody(body, constructor) {
            var parametersWithPropertyAssignments = constructor &&
                ts.filter(constructor.parameters, function (p) { return ts.isParameterPropertyDeclaration(p, constructor); });
            if (!ts.some(parametersWithPropertyAssignments)) {
                return ts.visitFunctionBody(body, visitor, context);
            }
            var statements = [];
            resumeLexicalEnvironment();
            var prologueStatementCount = factory.copyPrologue(body.statements, statements, /*ensureUseStrict*/ false, visitor);
            var superStatementIndex = ts.findSuperStatementIndex(body.statements, prologueStatementCount);
            // If there was a super call, visit existing statements up to and including it
            if (superStatementIndex >= 0) {
                ts.addRange(statements, ts.visitNodes(body.statements, visitor, ts.isStatement, prologueStatementCount, superStatementIndex + 1 - prologueStatementCount));
            }
            // Transform parameters into property assignments. Transforms this:
            //
            //  constructor (public x, public y) {
            //  }
            //
            // Into this:
            //
            //  constructor (x, y) {
            //      this.x = x;
            //      this.y = y;
            //  }
            //
            var parameterPropertyAssignments = ts.mapDefined(parametersWithPropertyAssignments, transformParameterWithPropertyAssignment);
            // If there is a super() call, the parameter properties go immediately after it
            if (superStatementIndex >= 0) {
                ts.addRange(statements, parameterPropertyAssignments);
            }
            // Since there was no super() call, parameter properties are the first statements in the constructor after any prologue statements
            else {
                statements = __spreadArray(__spreadArray(__spreadArray([], statements.slice(0, prologueStatementCount), true), parameterPropertyAssignments, true), statements.slice(prologueStatementCount), true);
            }
            // Add remaining statements from the body, skipping the super() call if it was found and any (already added) prologue statements
            ts.addRange(statements, ts.visitNodes(body.statements, visitor, ts.isStatement, superStatementIndex + 1 + prologueStatementCount));
            // End the lexical environment.
            statements = factory.mergeLexicalEnvironment(statements, endLexicalEnvironment());
            var block = factory.createBlock(ts.setTextRange(factory.createNodeArray(statements), body.statements), /*multiLine*/ true);
            ts.setTextRange(block, /*location*/ body);
            ts.setOriginalNode(block, body);
            return block;
        }
        /**
         * Transforms a parameter into a property assignment statement.
         *
         * @param node The parameter declaration.
         */
        function transformParameterWithPropertyAssignment(node) {
            var name = node.name;
            if (!ts.isIdentifier(name)) {
                return undefined;
            }
            // TODO(rbuckton): Does this need to be parented?
            var propertyName = ts.setParent(ts.setTextRange(factory.cloneNode(name), name), name.parent);
            ts.setEmitFlags(propertyName, 1536 /* EmitFlags.NoComments */ | 48 /* EmitFlags.NoSourceMap */);
            // TODO(rbuckton): Does this need to be parented?
            var localName = ts.setParent(ts.setTextRange(factory.cloneNode(name), name), name.parent);
            ts.setEmitFlags(localName, 1536 /* EmitFlags.NoComments */);
            return ts.startOnNewLine(ts.removeAllComments(ts.setTextRange(ts.setOriginalNode(factory.createExpressionStatement(factory.createAssignment(ts.setTextRange(factory.createPropertyAccessExpression(factory.createThis(), propertyName), node.name), localName)), node), ts.moveRangePos(node, -1))));
        }
        function visitMethodDeclaration(node) {
            if (!shouldEmitFunctionLikeDeclaration(node)) {
                return undefined;
            }
            var updated = factory.updateMethodDeclaration(node, 
            /*decorators*/ undefined, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), node.asteriskToken, visitPropertyNameOfClassElement(node), 
            /*questionToken*/ undefined, 
            /*typeParameters*/ undefined, ts.visitParameterList(node.parameters, visitor, context), 
            /*type*/ undefined, ts.visitFunctionBody(node.body, visitor, context));
            if (updated !== node) {
                // While we emit the source map for the node after skipping decorators and modifiers,
                // we need to emit the comments for the original range.
                ts.setCommentRange(updated, node);
                ts.setSourceMapRange(updated, ts.moveRangePastDecorators(node));
            }
            return updated;
        }
        /**
         * Determines whether to emit an accessor declaration. We should not emit the
         * declaration if it does not have a body and is abstract.
         *
         * @param node The declaration node.
         */
        function shouldEmitAccessorDeclaration(node) {
            return !(ts.nodeIsMissing(node.body) && ts.hasSyntacticModifier(node, 128 /* ModifierFlags.Abstract */));
        }
        function visitGetAccessor(node) {
            if (!shouldEmitAccessorDeclaration(node)) {
                return undefined;
            }
            var updated = factory.updateGetAccessorDeclaration(node, 
            /*decorators*/ undefined, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), visitPropertyNameOfClassElement(node), ts.visitParameterList(node.parameters, visitor, context), 
            /*type*/ undefined, ts.visitFunctionBody(node.body, visitor, context) || factory.createBlock([]));
            if (updated !== node) {
                // While we emit the source map for the node after skipping decorators and modifiers,
                // we need to emit the comments for the original range.
                ts.setCommentRange(updated, node);
                ts.setSourceMapRange(updated, ts.moveRangePastDecorators(node));
            }
            return updated;
        }
        function visitSetAccessor(node) {
            if (!shouldEmitAccessorDeclaration(node)) {
                return undefined;
            }
            var updated = factory.updateSetAccessorDeclaration(node, 
            /*decorators*/ undefined, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), visitPropertyNameOfClassElement(node), ts.visitParameterList(node.parameters, visitor, context), ts.visitFunctionBody(node.body, visitor, context) || factory.createBlock([]));
            if (updated !== node) {
                // While we emit the source map for the node after skipping decorators and modifiers,
                // we need to emit the comments for the original range.
                ts.setCommentRange(updated, node);
                ts.setSourceMapRange(updated, ts.moveRangePastDecorators(node));
            }
            return updated;
        }
        function visitFunctionDeclaration(node) {
            if (!shouldEmitFunctionLikeDeclaration(node)) {
                return factory.createNotEmittedStatement(node);
            }
            var updated = factory.updateFunctionDeclaration(node, 
            /*decorators*/ undefined, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), node.asteriskToken, node.name, 
            /*typeParameters*/ undefined, ts.visitParameterList(node.parameters, visitor, context), 
            /*type*/ undefined, ts.visitFunctionBody(node.body, visitor, context) || factory.createBlock([]));
            if (isExportOfNamespace(node)) {
                var statements = [updated];
                addExportMemberAssignment(statements, node);
                return statements;
            }
            return updated;
        }
        function visitFunctionExpression(node) {
            if (!shouldEmitFunctionLikeDeclaration(node)) {
                return factory.createOmittedExpression();
            }
            var updated = factory.updateFunctionExpression(node, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), node.asteriskToken, node.name, 
            /*typeParameters*/ undefined, ts.visitParameterList(node.parameters, visitor, context), 
            /*type*/ undefined, ts.visitFunctionBody(node.body, visitor, context) || factory.createBlock([]));
            return updated;
        }
        function visitArrowFunction(node) {
            var updated = factory.updateArrowFunction(node, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), 
            /*typeParameters*/ undefined, ts.visitParameterList(node.parameters, visitor, context), 
            /*type*/ undefined, node.equalsGreaterThanToken, ts.visitFunctionBody(node.body, visitor, context));
            return updated;
        }
        function visitParameter(node) {
            if (ts.parameterIsThisKeyword(node)) {
                return undefined;
            }
            var updated = factory.updateParameterDeclaration(node, 
            /*decorators*/ undefined, 
            /*modifiers*/ undefined, node.dotDotDotToken, ts.visitNode(node.name, visitor, ts.isBindingName), 
            /*questionToken*/ undefined, 
            /*type*/ undefined, ts.visitNode(node.initializer, visitor, ts.isExpression));
            if (updated !== node) {
                // While we emit the source map for the node after skipping decorators and modifiers,
                // we need to emit the comments for the original range.
                ts.setCommentRange(updated, node);
                ts.setTextRange(updated, ts.moveRangePastModifiers(node));
                ts.setSourceMapRange(updated, ts.moveRangePastModifiers(node));
                ts.setEmitFlags(updated.name, 32 /* EmitFlags.NoTrailingSourceMap */);
            }
            return updated;
        }
        function visitVariableStatement(node) {
            if (isExportOfNamespace(node)) {
                var variables = ts.getInitializedVariables(node.declarationList);
                if (variables.length === 0) {
                    // elide statement if there are no initialized variables.
                    return undefined;
                }
                return ts.setTextRange(factory.createExpressionStatement(factory.inlineExpressions(ts.map(variables, transformInitializedVariable))), node);
            }
            else {
                return ts.visitEachChild(node, visitor, context);
            }
        }
        function transformInitializedVariable(node) {
            var name = node.name;
            if (ts.isBindingPattern(name)) {
                return ts.flattenDestructuringAssignment(node, visitor, context, 0 /* FlattenLevel.All */, 
                /*needsValue*/ false, createNamespaceExportExpression);
            }
            else {
                return ts.setTextRange(factory.createAssignment(getNamespaceMemberNameWithSourceMapsAndWithoutComments(name), ts.visitNode(node.initializer, visitor, ts.isExpression)), 
                /*location*/ node);
            }
        }
        function visitVariableDeclaration(node) {
            var updated = factory.updateVariableDeclaration(node, ts.visitNode(node.name, visitor, ts.isBindingName), 
            /*exclamationToken*/ undefined, 
            /*type*/ undefined, ts.visitNode(node.initializer, visitor, ts.isExpression));
            if (node.type) {
                ts.setTypeNode(updated.name, node.type);
            }
            return updated;
        }
        function visitParenthesizedExpression(node) {
            var innerExpression = ts.skipOuterExpressions(node.expression, ~6 /* OuterExpressionKinds.Assertions */);
            if (ts.isAssertionExpression(innerExpression)) {
                // Make sure we consider all nested cast expressions, e.g.:
                // (<any><number><any>-A).x;
                var expression = ts.visitNode(node.expression, visitor, ts.isExpression);
                // We have an expression of the form: (<Type>SubExpr). Emitting this as (SubExpr)
                // is really not desirable. We would like to emit the subexpression as-is. Omitting
                // the parentheses, however, could cause change in the semantics of the generated
                // code if the casted expression has a lower precedence than the rest of the
                // expression.
                //
                // To preserve comments, we return a "PartiallyEmittedExpression" here which will
                // preserve the position information of the original expression.
                //
                // Due to the auto-parenthesization rules used by the visitor and factory functions
                // we can safely elide the parentheses here, as a new synthetic
                // ParenthesizedExpression will be inserted if we remove parentheses too
                // aggressively.
                //
                // If there are leading comments on the expression itself, the emitter will handle ASI
                // for return, throw, and yield by re-introducing parenthesis during emit on an as-need
                // basis.
                return factory.createPartiallyEmittedExpression(expression, node);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitAssertionExpression(node) {
            var expression = ts.visitNode(node.expression, visitor, ts.isExpression);
            return factory.createPartiallyEmittedExpression(expression, node);
        }
        function visitNonNullExpression(node) {
            var expression = ts.visitNode(node.expression, visitor, ts.isLeftHandSideExpression);
            return factory.createPartiallyEmittedExpression(expression, node);
        }
        function visitCallExpression(node) {
            return factory.updateCallExpression(node, ts.visitNode(node.expression, visitor, ts.isExpression), 
            /*typeArguments*/ undefined, ts.visitNodes(node.arguments, visitor, ts.isExpression));
        }
        function visitNewExpression(node) {
            return factory.updateNewExpression(node, ts.visitNode(node.expression, visitor, ts.isExpression), 
            /*typeArguments*/ undefined, ts.visitNodes(node.arguments, visitor, ts.isExpression));
        }
        function visitTaggedTemplateExpression(node) {
            return factory.updateTaggedTemplateExpression(node, ts.visitNode(node.tag, visitor, ts.isExpression), 
            /*typeArguments*/ undefined, ts.visitNode(node.template, visitor, ts.isExpression));
        }
        function visitJsxSelfClosingElement(node) {
            return factory.updateJsxSelfClosingElement(node, ts.visitNode(node.tagName, visitor, ts.isJsxTagNameExpression), 
            /*typeArguments*/ undefined, ts.visitNode(node.attributes, visitor, ts.isJsxAttributes));
        }
        function visitJsxJsxOpeningElement(node) {
            return factory.updateJsxOpeningElement(node, ts.visitNode(node.tagName, visitor, ts.isJsxTagNameExpression), 
            /*typeArguments*/ undefined, ts.visitNode(node.attributes, visitor, ts.isJsxAttributes));
        }
        /**
         * Determines whether to emit an enum declaration.
         *
         * @param node The enum declaration node.
         */
        function shouldEmitEnumDeclaration(node) {
            return !ts.isEnumConst(node)
                || ts.shouldPreserveConstEnums(compilerOptions);
        }
        /**
         * Visits an enum declaration.
         *
         * This function will be called any time a TypeScript enum is encountered.
         *
         * @param node The enum declaration node.
         */
        function visitEnumDeclaration(node) {
            if (!shouldEmitEnumDeclaration(node)) {
                return factory.createNotEmittedStatement(node);
            }
            var statements = [];
            // We request to be advised when the printer is about to print this node. This allows
            // us to set up the correct state for later substitutions.
            var emitFlags = 2 /* EmitFlags.AdviseOnEmitNode */;
            // If needed, we should emit a variable declaration for the enum. If we emit
            // a leading variable declaration, we should not emit leading comments for the
            // enum body.
            var varAdded = addVarForEnumOrModuleDeclaration(statements, node);
            if (varAdded) {
                // We should still emit the comments if we are emitting a system module.
                if (moduleKind !== ts.ModuleKind.System || currentLexicalScope !== currentSourceFile) {
                    emitFlags |= 512 /* EmitFlags.NoLeadingComments */;
                }
            }
            // `parameterName` is the declaration name used inside of the enum.
            var parameterName = getNamespaceParameterName(node);
            // `containerName` is the expression used inside of the enum for assignments.
            var containerName = getNamespaceContainerName(node);
            // `exportName` is the expression used within this node's container for any exported references.
            var exportName = ts.hasSyntacticModifier(node, 1 /* ModifierFlags.Export */)
                ? factory.getExternalModuleOrNamespaceExportName(currentNamespaceContainerName, node, /*allowComments*/ false, /*allowSourceMaps*/ true)
                : factory.getLocalName(node, /*allowComments*/ false, /*allowSourceMaps*/ true);
            //  x || (x = {})
            //  exports.x || (exports.x = {})
            var moduleArg = factory.createLogicalOr(exportName, factory.createAssignment(exportName, factory.createObjectLiteralExpression()));
            if (hasNamespaceQualifiedExportName(node)) {
                // `localName` is the expression used within this node's containing scope for any local references.
                var localName = factory.getLocalName(node, /*allowComments*/ false, /*allowSourceMaps*/ true);
                //  x = (exports.x || (exports.x = {}))
                moduleArg = factory.createAssignment(localName, moduleArg);
            }
            //  (function (x) {
            //      x[x["y"] = 0] = "y";
            //      ...
            //  })(x || (x = {}));
            var enumStatement = factory.createExpressionStatement(factory.createCallExpression(factory.createFunctionExpression(
            /*modifiers*/ undefined, 
            /*asteriskToken*/ undefined, 
            /*name*/ undefined, 
            /*typeParameters*/ undefined, [factory.createParameterDeclaration(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, parameterName)], 
            /*type*/ undefined, transformEnumBody(node, containerName)), 
            /*typeArguments*/ undefined, [moduleArg]));
            ts.setOriginalNode(enumStatement, node);
            if (varAdded) {
                // If a variable was added, synthetic comments are emitted on it, not on the moduleStatement.
                ts.setSyntheticLeadingComments(enumStatement, undefined);
                ts.setSyntheticTrailingComments(enumStatement, undefined);
            }
            ts.setTextRange(enumStatement, node);
            ts.addEmitFlags(enumStatement, emitFlags);
            statements.push(enumStatement);
            // Add a DeclarationMarker for the enum to preserve trailing comments and mark
            // the end of the declaration.
            statements.push(factory.createEndOfDeclarationMarker(node));
            return statements;
        }
        /**
         * Transforms the body of an enum declaration.
         *
         * @param node The enum declaration node.
         */
        function transformEnumBody(node, localName) {
            var savedCurrentNamespaceLocalName = currentNamespaceContainerName;
            currentNamespaceContainerName = localName;
            var statements = [];
            startLexicalEnvironment();
            var members = ts.map(node.members, transformEnumMember);
            ts.insertStatementsAfterStandardPrologue(statements, endLexicalEnvironment());
            ts.addRange(statements, members);
            currentNamespaceContainerName = savedCurrentNamespaceLocalName;
            return factory.createBlock(ts.setTextRange(factory.createNodeArray(statements), /*location*/ node.members), 
            /*multiLine*/ true);
        }
        /**
         * Transforms an enum member into a statement.
         *
         * @param member The enum member node.
         */
        function transformEnumMember(member) {
            // enums don't support computed properties
            // we pass false as 'generateNameForComputedPropertyName' for a backward compatibility purposes
            // old emitter always generate 'expression' part of the name as-is.
            var name = getExpressionForPropertyName(member, /*generateNameForComputedPropertyName*/ false);
            var valueExpression = transformEnumMemberDeclarationValue(member);
            var innerAssignment = factory.createAssignment(factory.createElementAccessExpression(currentNamespaceContainerName, name), valueExpression);
            var outerAssignment = valueExpression.kind === 10 /* SyntaxKind.StringLiteral */ ?
                innerAssignment :
                factory.createAssignment(factory.createElementAccessExpression(currentNamespaceContainerName, innerAssignment), name);
            return ts.setTextRange(factory.createExpressionStatement(ts.setTextRange(outerAssignment, member)), member);
        }
        /**
         * Transforms the value of an enum member.
         *
         * @param member The enum member node.
         */
        function transformEnumMemberDeclarationValue(member) {
            var value = resolver.getConstantValue(member);
            if (value !== undefined) {
                return typeof value === "string" ? factory.createStringLiteral(value) : factory.createNumericLiteral(value);
            }
            else {
                enableSubstitutionForNonQualifiedEnumMembers();
                if (member.initializer) {
                    return ts.visitNode(member.initializer, visitor, ts.isExpression);
                }
                else {
                    return factory.createVoidZero();
                }
            }
        }
        /**
         * Determines whether to elide a module declaration.
         *
         * @param node The module declaration node.
         */
        function shouldEmitModuleDeclaration(nodeIn) {
            var node = ts.getParseTreeNode(nodeIn, ts.isModuleDeclaration);
            if (!node) {
                // If we can't find a parse tree node, assume the node is instantiated.
                return true;
            }
            return ts.isInstantiatedModule(node, ts.shouldPreserveConstEnums(compilerOptions));
        }
        /**
         * Determines whether an exported declaration will have a qualified export name (e.g. `f.x`
         * or `exports.x`).
         */
        function hasNamespaceQualifiedExportName(node) {
            return isExportOfNamespace(node)
                || (isExternalModuleExport(node)
                    && moduleKind !== ts.ModuleKind.ES2015
                    && moduleKind !== ts.ModuleKind.ES2020
                    && moduleKind !== ts.ModuleKind.ES2022
                    && moduleKind !== ts.ModuleKind.ESNext
                    && moduleKind !== ts.ModuleKind.System);
        }
        /**
         * Records that a declaration was emitted in the current scope, if it was the first
         * declaration for the provided symbol.
         */
        function recordEmittedDeclarationInScope(node) {
            if (!currentScopeFirstDeclarationsOfName) {
                currentScopeFirstDeclarationsOfName = new ts.Map();
            }
            var name = declaredNameInScope(node);
            if (!currentScopeFirstDeclarationsOfName.has(name)) {
                currentScopeFirstDeclarationsOfName.set(name, node);
            }
        }
        /**
         * Determines whether a declaration is the first declaration with
         * the same name emitted in the current scope.
         */
        function isFirstEmittedDeclarationInScope(node) {
            if (currentScopeFirstDeclarationsOfName) {
                var name = declaredNameInScope(node);
                return currentScopeFirstDeclarationsOfName.get(name) === node;
            }
            return true;
        }
        function declaredNameInScope(node) {
            ts.Debug.assertNode(node.name, ts.isIdentifier);
            return node.name.escapedText;
        }
        /**
         * Adds a leading VariableStatement for a enum or module declaration.
         */
        function addVarForEnumOrModuleDeclaration(statements, node) {
            // Emit a variable statement for the module. We emit top-level enums as a `var`
            // declaration to avoid static errors in global scripts scripts due to redeclaration.
            // enums in any other scope are emitted as a `let` declaration.
            var statement = factory.createVariableStatement(ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), factory.createVariableDeclarationList([
                factory.createVariableDeclaration(factory.getLocalName(node, /*allowComments*/ false, /*allowSourceMaps*/ true))
            ], currentLexicalScope.kind === 305 /* SyntaxKind.SourceFile */ ? 0 /* NodeFlags.None */ : 1 /* NodeFlags.Let */));
            ts.setOriginalNode(statement, node);
            recordEmittedDeclarationInScope(node);
            if (isFirstEmittedDeclarationInScope(node)) {
                // Adjust the source map emit to match the old emitter.
                if (node.kind === 260 /* SyntaxKind.EnumDeclaration */) {
                    ts.setSourceMapRange(statement.declarationList, node);
                }
                else {
                    ts.setSourceMapRange(statement, node);
                }
                // Trailing comments for module declaration should be emitted after the function closure
                // instead of the variable statement:
                //
                //     /** Module comment*/
                //     module m1 {
                //         function foo4Export() {
                //         }
                //     } // trailing comment module
                //
                // Should emit:
                //
                //     /** Module comment*/
                //     var m1;
                //     (function (m1) {
                //         function foo4Export() {
                //         }
                //     })(m1 || (m1 = {})); // trailing comment module
                //
                ts.setCommentRange(statement, node);
                ts.addEmitFlags(statement, 1024 /* EmitFlags.NoTrailingComments */ | 4194304 /* EmitFlags.HasEndOfDeclarationMarker */);
                statements.push(statement);
                return true;
            }
            else {
                // For an EnumDeclaration or ModuleDeclaration that merges with a preceeding
                // declaration we do not emit a leading variable declaration. To preserve the
                // begin/end semantics of the declararation and to properly handle exports
                // we wrap the leading variable declaration in a `MergeDeclarationMarker`.
                var mergeMarker = factory.createMergeDeclarationMarker(statement);
                ts.setEmitFlags(mergeMarker, 1536 /* EmitFlags.NoComments */ | 4194304 /* EmitFlags.HasEndOfDeclarationMarker */);
                statements.push(mergeMarker);
                return false;
            }
        }
        /**
         * Visits a module declaration node.
         *
         * This function will be called any time a TypeScript namespace (ModuleDeclaration) is encountered.
         *
         * @param node The module declaration node.
         */
        function visitModuleDeclaration(node) {
            if (!shouldEmitModuleDeclaration(node)) {
                return factory.createNotEmittedStatement(node);
            }
            ts.Debug.assertNode(node.name, ts.isIdentifier, "A TypeScript namespace should have an Identifier name.");
            enableSubstitutionForNamespaceExports();
            var statements = [];
            // We request to be advised when the printer is about to print this node. This allows
            // us to set up the correct state for later substitutions.
            var emitFlags = 2 /* EmitFlags.AdviseOnEmitNode */;
            // If needed, we should emit a variable declaration for the module. If we emit
            // a leading variable declaration, we should not emit leading comments for the
            // module body.
            var varAdded = addVarForEnumOrModuleDeclaration(statements, node);
            if (varAdded) {
                // We should still emit the comments if we are emitting a system module.
                if (moduleKind !== ts.ModuleKind.System || currentLexicalScope !== currentSourceFile) {
                    emitFlags |= 512 /* EmitFlags.NoLeadingComments */;
                }
            }
            // `parameterName` is the declaration name used inside of the namespace.
            var parameterName = getNamespaceParameterName(node);
            // `containerName` is the expression used inside of the namespace for exports.
            var containerName = getNamespaceContainerName(node);
            // `exportName` is the expression used within this node's container for any exported references.
            var exportName = ts.hasSyntacticModifier(node, 1 /* ModifierFlags.Export */)
                ? factory.getExternalModuleOrNamespaceExportName(currentNamespaceContainerName, node, /*allowComments*/ false, /*allowSourceMaps*/ true)
                : factory.getLocalName(node, /*allowComments*/ false, /*allowSourceMaps*/ true);
            //  x || (x = {})
            //  exports.x || (exports.x = {})
            var moduleArg = factory.createLogicalOr(exportName, factory.createAssignment(exportName, factory.createObjectLiteralExpression()));
            if (hasNamespaceQualifiedExportName(node)) {
                // `localName` is the expression used within this node's containing scope for any local references.
                var localName = factory.getLocalName(node, /*allowComments*/ false, /*allowSourceMaps*/ true);
                //  x = (exports.x || (exports.x = {}))
                moduleArg = factory.createAssignment(localName, moduleArg);
            }
            //  (function (x_1) {
            //      x_1.y = ...;
            //  })(x || (x = {}));
            var moduleStatement = factory.createExpressionStatement(factory.createCallExpression(factory.createFunctionExpression(
            /*modifiers*/ undefined, 
            /*asteriskToken*/ undefined, 
            /*name*/ undefined, 
            /*typeParameters*/ undefined, [factory.createParameterDeclaration(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, parameterName)], 
            /*type*/ undefined, transformModuleBody(node, containerName)), 
            /*typeArguments*/ undefined, [moduleArg]));
            ts.setOriginalNode(moduleStatement, node);
            if (varAdded) {
                // If a variable was added, synthetic comments are emitted on it, not on the moduleStatement.
                ts.setSyntheticLeadingComments(moduleStatement, undefined);
                ts.setSyntheticTrailingComments(moduleStatement, undefined);
            }
            ts.setTextRange(moduleStatement, node);
            ts.addEmitFlags(moduleStatement, emitFlags);
            statements.push(moduleStatement);
            // Add a DeclarationMarker for the namespace to preserve trailing comments and mark
            // the end of the declaration.
            statements.push(factory.createEndOfDeclarationMarker(node));
            return statements;
        }
        /**
         * Transforms the body of a module declaration.
         *
         * @param node The module declaration node.
         */
        function transformModuleBody(node, namespaceLocalName) {
            var savedCurrentNamespaceContainerName = currentNamespaceContainerName;
            var savedCurrentNamespace = currentNamespace;
            var savedCurrentScopeFirstDeclarationsOfName = currentScopeFirstDeclarationsOfName;
            currentNamespaceContainerName = namespaceLocalName;
            currentNamespace = node;
            currentScopeFirstDeclarationsOfName = undefined;
            var statements = [];
            startLexicalEnvironment();
            var statementsLocation;
            var blockLocation;
            if (node.body) {
                if (node.body.kind === 262 /* SyntaxKind.ModuleBlock */) {
                    saveStateAndInvoke(node.body, function (body) { return ts.addRange(statements, ts.visitNodes(body.statements, namespaceElementVisitor, ts.isStatement)); });
                    statementsLocation = node.body.statements;
                    blockLocation = node.body;
                }
                else {
                    var result = visitModuleDeclaration(node.body);
                    if (result) {
                        if (ts.isArray(result)) {
                            ts.addRange(statements, result);
                        }
                        else {
                            statements.push(result);
                        }
                    }
                    var moduleBlock = getInnerMostModuleDeclarationFromDottedModule(node).body;
                    statementsLocation = ts.moveRangePos(moduleBlock.statements, -1);
                }
            }
            ts.insertStatementsAfterStandardPrologue(statements, endLexicalEnvironment());
            currentNamespaceContainerName = savedCurrentNamespaceContainerName;
            currentNamespace = savedCurrentNamespace;
            currentScopeFirstDeclarationsOfName = savedCurrentScopeFirstDeclarationsOfName;
            var block = factory.createBlock(ts.setTextRange(factory.createNodeArray(statements), 
            /*location*/ statementsLocation), 
            /*multiLine*/ true);
            ts.setTextRange(block, blockLocation);
            // namespace hello.hi.world {
            //      function foo() {}
            //
            //      // TODO, blah
            // }
            //
            // should be emitted as
            //
            // var hello;
            // (function (hello) {
            //     var hi;
            //     (function (hi) {
            //         var world;
            //         (function (world) {
            //             function foo() { }
            //             // TODO, blah
            //         })(world = hi.world || (hi.world = {}));
            //     })(hi = hello.hi || (hello.hi = {}));
            // })(hello || (hello = {}));
            // We only want to emit comment on the namespace which contains block body itself, not the containing namespaces.
            if (!node.body || node.body.kind !== 262 /* SyntaxKind.ModuleBlock */) {
                ts.setEmitFlags(block, ts.getEmitFlags(block) | 1536 /* EmitFlags.NoComments */);
            }
            return block;
        }
        function getInnerMostModuleDeclarationFromDottedModule(moduleDeclaration) {
            if (moduleDeclaration.body.kind === 261 /* SyntaxKind.ModuleDeclaration */) {
                var recursiveInnerModule = getInnerMostModuleDeclarationFromDottedModule(moduleDeclaration.body);
                return recursiveInnerModule || moduleDeclaration.body;
            }
        }
        /**
         * Visits an import declaration, eliding it if it is type-only or if it has an import clause that may be elided.
         *
         * @param node The import declaration node.
         */
        function visitImportDeclaration(node) {
            if (!node.importClause) {
                // Do not elide a side-effect only import declaration.
                //  import "foo";
                return node;
            }
            if (node.importClause.isTypeOnly) {
                // Always elide type-only imports
                return undefined;
            }
            // Elide the declaration if the import clause was elided.
            var importClause = ts.visitNode(node.importClause, visitImportClause, ts.isImportClause);
            return importClause ||
                compilerOptions.importsNotUsedAsValues === 1 /* ImportsNotUsedAsValues.Preserve */ ||
                compilerOptions.importsNotUsedAsValues === 2 /* ImportsNotUsedAsValues.Error */
                ? factory.updateImportDeclaration(node, 
                /*decorators*/ undefined, 
                /*modifiers*/ undefined, importClause, node.moduleSpecifier, node.assertClause)
                : undefined;
        }
        /**
         * Visits an import clause, eliding it if its `name` and `namedBindings` may both be elided.
         *
         * @param node The import clause node.
         */
        function visitImportClause(node) {
            ts.Debug.assert(!node.isTypeOnly);
            // Elide the import clause if we elide both its name and its named bindings.
            var name = shouldEmitAliasDeclaration(node) ? node.name : undefined;
            var namedBindings = ts.visitNode(node.namedBindings, visitNamedImportBindings, ts.isNamedImportBindings);
            return (name || namedBindings) ? factory.updateImportClause(node, /*isTypeOnly*/ false, name, namedBindings) : undefined;
        }
        /**
         * Visits named import bindings, eliding them if their targets, their references, and the compilation settings allow.
         *
         * @param node The named import bindings node.
         */
        function visitNamedImportBindings(node) {
            if (node.kind === 268 /* SyntaxKind.NamespaceImport */) {
                // Elide a namespace import if it is not referenced.
                return shouldEmitAliasDeclaration(node) ? node : undefined;
            }
            else {
                // Elide named imports if all of its import specifiers are elided and settings allow.
                var allowEmpty = compilerOptions.preserveValueImports && (compilerOptions.importsNotUsedAsValues === 1 /* ImportsNotUsedAsValues.Preserve */ ||
                    compilerOptions.importsNotUsedAsValues === 2 /* ImportsNotUsedAsValues.Error */);
                var elements = ts.visitNodes(node.elements, visitImportSpecifier, ts.isImportSpecifier);
                return allowEmpty || ts.some(elements) ? factory.updateNamedImports(node, elements) : undefined;
            }
        }
        /**
         * Visits an import specifier, eliding it if its target, its references, and the compilation settings allow.
         *
         * @param node The import specifier node.
         */
        function visitImportSpecifier(node) {
            return !node.isTypeOnly && shouldEmitAliasDeclaration(node) ? node : undefined;
        }
        /**
         * Visits an export assignment, eliding it if it does not contain a clause that resolves
         * to a value.
         *
         * @param node The export assignment node.
         */
        function visitExportAssignment(node) {
            // Elide the export assignment if it does not reference a value.
            return resolver.isValueAliasDeclaration(node)
                ? ts.visitEachChild(node, visitor, context)
                : undefined;
        }
        /**
         * Visits an export declaration, eliding it if it does not contain a clause that resolves to a value.
         *
         * @param node The export declaration node.
         */
        function visitExportDeclaration(node) {
            if (node.isTypeOnly) {
                return undefined;
            }
            if (!node.exportClause || ts.isNamespaceExport(node.exportClause)) {
                // never elide `export <whatever> from <whereever>` declarations -
                // they should be kept for sideffects/untyped exports, even when the
                // type checker doesn't know about any exports
                return node;
            }
            // Elide the export declaration if all of its named exports are elided.
            var allowEmpty = !!node.moduleSpecifier && (compilerOptions.importsNotUsedAsValues === 1 /* ImportsNotUsedAsValues.Preserve */ ||
                compilerOptions.importsNotUsedAsValues === 2 /* ImportsNotUsedAsValues.Error */);
            var exportClause = ts.visitNode(node.exportClause, function (bindings) { return visitNamedExportBindings(bindings, allowEmpty); }, ts.isNamedExportBindings);
            return exportClause
                ? factory.updateExportDeclaration(node, 
                /*decorators*/ undefined, 
                /*modifiers*/ undefined, node.isTypeOnly, exportClause, node.moduleSpecifier, node.assertClause)
                : undefined;
        }
        /**
         * Visits named exports, eliding it if it does not contain an export specifier that
         * resolves to a value.
         *
         * @param node The named exports node.
         */
        function visitNamedExports(node, allowEmpty) {
            // Elide the named exports if all of its export specifiers were elided.
            var elements = ts.visitNodes(node.elements, visitExportSpecifier, ts.isExportSpecifier);
            return allowEmpty || ts.some(elements) ? factory.updateNamedExports(node, elements) : undefined;
        }
        function visitNamespaceExports(node) {
            return factory.updateNamespaceExport(node, ts.visitNode(node.name, visitor, ts.isIdentifier));
        }
        function visitNamedExportBindings(node, allowEmpty) {
            return ts.isNamespaceExport(node) ? visitNamespaceExports(node) : visitNamedExports(node, allowEmpty);
        }
        /**
         * Visits an export specifier, eliding it if it does not resolve to a value.
         *
         * @param node The export specifier node.
         */
        function visitExportSpecifier(node) {
            // Elide an export specifier if it does not reference a value.
            return !node.isTypeOnly && resolver.isValueAliasDeclaration(node) ? node : undefined;
        }
        /**
         * Determines whether to emit an import equals declaration.
         *
         * @param node The import equals declaration node.
         */
        function shouldEmitImportEqualsDeclaration(node) {
            // preserve old compiler's behavior: emit 'var' for import declaration (even if we do not consider them referenced) when
            // - current file is not external module
            // - import declaration is top level and target is value imported by entity name
            return shouldEmitAliasDeclaration(node)
                || (!ts.isExternalModule(currentSourceFile)
                    && resolver.isTopLevelValueImportEqualsWithEntityName(node));
        }
        /**
         * Visits an import equals declaration.
         *
         * @param node The import equals declaration node.
         */
        function visitImportEqualsDeclaration(node) {
            // Always elide type-only imports
            if (node.isTypeOnly) {
                return undefined;
            }
            if (ts.isExternalModuleImportEqualsDeclaration(node)) {
                var isReferenced = shouldEmitAliasDeclaration(node);
                // If the alias is unreferenced but we want to keep the import, replace with 'import "mod"'.
                if (!isReferenced && compilerOptions.importsNotUsedAsValues === 1 /* ImportsNotUsedAsValues.Preserve */) {
                    return ts.setOriginalNode(ts.setTextRange(factory.createImportDeclaration(
                    /*decorators*/ undefined, 
                    /*modifiers*/ undefined, 
                    /*importClause*/ undefined, node.moduleReference.expression, 
                    /*assertClause*/ undefined), node), node);
                }
                return isReferenced ? ts.visitEachChild(node, visitor, context) : undefined;
            }
            if (!shouldEmitImportEqualsDeclaration(node)) {
                return undefined;
            }
            var moduleReference = ts.createExpressionFromEntityName(factory, node.moduleReference);
            ts.setEmitFlags(moduleReference, 1536 /* EmitFlags.NoComments */ | 2048 /* EmitFlags.NoNestedComments */);
            if (isNamedExternalModuleExport(node) || !isExportOfNamespace(node)) {
                //  export var ${name} = ${moduleReference};
                //  var ${name} = ${moduleReference};
                return ts.setOriginalNode(ts.setTextRange(factory.createVariableStatement(ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), factory.createVariableDeclarationList([
                    ts.setOriginalNode(factory.createVariableDeclaration(node.name, 
                    /*exclamationToken*/ undefined, 
                    /*type*/ undefined, moduleReference), node)
                ])), node), node);
            }
            else {
                // exports.${name} = ${moduleReference};
                return ts.setOriginalNode(createNamespaceExport(node.name, moduleReference, node), node);
            }
        }
        /**
         * Gets a value indicating whether the node is exported from a namespace.
         *
         * @param node The node to test.
         */
        function isExportOfNamespace(node) {
            return currentNamespace !== undefined && ts.hasSyntacticModifier(node, 1 /* ModifierFlags.Export */);
        }
        /**
         * Gets a value indicating whether the node is exported from an external module.
         *
         * @param node The node to test.
         */
        function isExternalModuleExport(node) {
            return currentNamespace === undefined && ts.hasSyntacticModifier(node, 1 /* ModifierFlags.Export */);
        }
        /**
         * Gets a value indicating whether the node is a named export from an external module.
         *
         * @param node The node to test.
         */
        function isNamedExternalModuleExport(node) {
            return isExternalModuleExport(node)
                && !ts.hasSyntacticModifier(node, 512 /* ModifierFlags.Default */);
        }
        /**
         * Gets a value indicating whether the node is the default export of an external module.
         *
         * @param node The node to test.
         */
        function isDefaultExternalModuleExport(node) {
            return isExternalModuleExport(node)
                && ts.hasSyntacticModifier(node, 512 /* ModifierFlags.Default */);
        }
        /**
         * Creates a statement for the provided expression. This is used in calls to `map`.
         */
        function expressionToStatement(expression) {
            return factory.createExpressionStatement(expression);
        }
        function addExportMemberAssignment(statements, node) {
            var expression = factory.createAssignment(factory.getExternalModuleOrNamespaceExportName(currentNamespaceContainerName, node, /*allowComments*/ false, /*allowSourceMaps*/ true), factory.getLocalName(node));
            ts.setSourceMapRange(expression, ts.createRange(node.name ? node.name.pos : node.pos, node.end));
            var statement = factory.createExpressionStatement(expression);
            ts.setSourceMapRange(statement, ts.createRange(-1, node.end));
            statements.push(statement);
        }
        function createNamespaceExport(exportName, exportValue, location) {
            return ts.setTextRange(factory.createExpressionStatement(factory.createAssignment(factory.getNamespaceMemberName(currentNamespaceContainerName, exportName, /*allowComments*/ false, /*allowSourceMaps*/ true), exportValue)), location);
        }
        function createNamespaceExportExpression(exportName, exportValue, location) {
            return ts.setTextRange(factory.createAssignment(getNamespaceMemberNameWithSourceMapsAndWithoutComments(exportName), exportValue), location);
        }
        function getNamespaceMemberNameWithSourceMapsAndWithoutComments(name) {
            return factory.getNamespaceMemberName(currentNamespaceContainerName, name, /*allowComments*/ false, /*allowSourceMaps*/ true);
        }
        /**
         * Gets the declaration name used inside of a namespace or enum.
         */
        function getNamespaceParameterName(node) {
            var name = factory.getGeneratedNameForNode(node);
            ts.setSourceMapRange(name, node.name);
            return name;
        }
        /**
         * Gets the expression used to refer to a namespace or enum within the body
         * of its declaration.
         */
        function getNamespaceContainerName(node) {
            return factory.getGeneratedNameForNode(node);
        }
        /**
         * Gets a local alias for a class declaration if it is a decorated class with an internal
         * reference to the static side of the class. This is necessary to avoid issues with
         * double-binding semantics for the class name.
         */
        function getClassAliasIfNeeded(node) {
            if (resolver.getNodeCheckFlags(node) & 16777216 /* NodeCheckFlags.ClassWithConstructorReference */) {
                enableSubstitutionForClassAliases();
                var classAlias = factory.createUniqueName(node.name && !ts.isGeneratedIdentifier(node.name) ? ts.idText(node.name) : "default");
                classAliases[ts.getOriginalNodeId(node)] = classAlias;
                hoistVariableDeclaration(classAlias);
                return classAlias;
            }
        }
        function getClassPrototype(node) {
            return factory.createPropertyAccessExpression(factory.getDeclarationName(node), "prototype");
        }
        function getClassMemberPrefix(node, member) {
            return ts.isStatic(member)
                ? factory.getDeclarationName(node)
                : getClassPrototype(node);
        }
        function enableSubstitutionForNonQualifiedEnumMembers() {
            if ((enabledSubstitutions & 8 /* TypeScriptSubstitutionFlags.NonQualifiedEnumMembers */) === 0) {
                enabledSubstitutions |= 8 /* TypeScriptSubstitutionFlags.NonQualifiedEnumMembers */;
                context.enableSubstitution(79 /* SyntaxKind.Identifier */);
            }
        }
        function enableSubstitutionForClassAliases() {
            if ((enabledSubstitutions & 1 /* TypeScriptSubstitutionFlags.ClassAliases */) === 0) {
                enabledSubstitutions |= 1 /* TypeScriptSubstitutionFlags.ClassAliases */;
                // We need to enable substitutions for identifiers. This allows us to
                // substitute class names inside of a class declaration.
                context.enableSubstitution(79 /* SyntaxKind.Identifier */);
                // Keep track of class aliases.
                classAliases = [];
            }
        }
        function enableSubstitutionForNamespaceExports() {
            if ((enabledSubstitutions & 2 /* TypeScriptSubstitutionFlags.NamespaceExports */) === 0) {
                enabledSubstitutions |= 2 /* TypeScriptSubstitutionFlags.NamespaceExports */;
                // We need to enable substitutions for identifiers and shorthand property assignments. This allows us to
                // substitute the names of exported members of a namespace.
                context.enableSubstitution(79 /* SyntaxKind.Identifier */);
                context.enableSubstitution(297 /* SyntaxKind.ShorthandPropertyAssignment */);
                // We need to be notified when entering and exiting namespaces.
                context.enableEmitNotification(261 /* SyntaxKind.ModuleDeclaration */);
            }
        }
        function isTransformedModuleDeclaration(node) {
            return ts.getOriginalNode(node).kind === 261 /* SyntaxKind.ModuleDeclaration */;
        }
        function isTransformedEnumDeclaration(node) {
            return ts.getOriginalNode(node).kind === 260 /* SyntaxKind.EnumDeclaration */;
        }
        /**
         * Hook for node emit.
         *
         * @param hint A hint as to the intended usage of the node.
         * @param node The node to emit.
         * @param emit A callback used to emit the node in the printer.
         */
        function onEmitNode(hint, node, emitCallback) {
            var savedApplicableSubstitutions = applicableSubstitutions;
            var savedCurrentSourceFile = currentSourceFile;
            if (ts.isSourceFile(node)) {
                currentSourceFile = node;
            }
            if (enabledSubstitutions & 2 /* TypeScriptSubstitutionFlags.NamespaceExports */ && isTransformedModuleDeclaration(node)) {
                applicableSubstitutions |= 2 /* TypeScriptSubstitutionFlags.NamespaceExports */;
            }
            if (enabledSubstitutions & 8 /* TypeScriptSubstitutionFlags.NonQualifiedEnumMembers */ && isTransformedEnumDeclaration(node)) {
                applicableSubstitutions |= 8 /* TypeScriptSubstitutionFlags.NonQualifiedEnumMembers */;
            }
            previousOnEmitNode(hint, node, emitCallback);
            applicableSubstitutions = savedApplicableSubstitutions;
            currentSourceFile = savedCurrentSourceFile;
        }
        /**
         * Hooks node substitutions.
         *
         * @param hint A hint as to the intended usage of the node.
         * @param node The node to substitute.
         */
        function onSubstituteNode(hint, node) {
            node = previousOnSubstituteNode(hint, node);
            if (hint === 1 /* EmitHint.Expression */) {
                return substituteExpression(node);
            }
            else if (ts.isShorthandPropertyAssignment(node)) {
                return substituteShorthandPropertyAssignment(node);
            }
            return node;
        }
        function substituteShorthandPropertyAssignment(node) {
            if (enabledSubstitutions & 2 /* TypeScriptSubstitutionFlags.NamespaceExports */) {
                var name = node.name;
                var exportedName = trySubstituteNamespaceExportedName(name);
                if (exportedName) {
                    // A shorthand property with an assignment initializer is probably part of a
                    // destructuring assignment
                    if (node.objectAssignmentInitializer) {
                        var initializer = factory.createAssignment(exportedName, node.objectAssignmentInitializer);
                        return ts.setTextRange(factory.createPropertyAssignment(name, initializer), node);
                    }
                    return ts.setTextRange(factory.createPropertyAssignment(name, exportedName), node);
                }
            }
            return node;
        }
        function substituteExpression(node) {
            switch (node.kind) {
                case 79 /* SyntaxKind.Identifier */:
                    return substituteExpressionIdentifier(node);
                case 206 /* SyntaxKind.PropertyAccessExpression */:
                    return substitutePropertyAccessExpression(node);
                case 207 /* SyntaxKind.ElementAccessExpression */:
                    return substituteElementAccessExpression(node);
            }
            return node;
        }
        function substituteExpressionIdentifier(node) {
            return trySubstituteClassAlias(node)
                || trySubstituteNamespaceExportedName(node)
                || node;
        }
        function trySubstituteClassAlias(node) {
            if (enabledSubstitutions & 1 /* TypeScriptSubstitutionFlags.ClassAliases */) {
                if (resolver.getNodeCheckFlags(node) & 33554432 /* NodeCheckFlags.ConstructorReferenceInClass */) {
                    // Due to the emit for class decorators, any reference to the class from inside of the class body
                    // must instead be rewritten to point to a temporary variable to avoid issues with the double-bind
                    // behavior of class names in ES6.
                    // Also, when emitting statics for class expressions, we must substitute a class alias for
                    // constructor references in static property initializers.
                    var declaration = resolver.getReferencedValueDeclaration(node);
                    if (declaration) {
                        var classAlias = classAliases[declaration.id]; // TODO: GH#18217
                        if (classAlias) {
                            var clone_2 = factory.cloneNode(classAlias);
                            ts.setSourceMapRange(clone_2, node);
                            ts.setCommentRange(clone_2, node);
                            return clone_2;
                        }
                    }
                }
            }
            return undefined;
        }
        function trySubstituteNamespaceExportedName(node) {
            // If this is explicitly a local name, do not substitute.
            if (enabledSubstitutions & applicableSubstitutions && !ts.isGeneratedIdentifier(node) && !ts.isLocalName(node)) {
                // If we are nested within a namespace declaration, we may need to qualifiy
                // an identifier that is exported from a merged namespace.
                var container = resolver.getReferencedExportContainer(node, /*prefixLocals*/ false);
                if (container && container.kind !== 305 /* SyntaxKind.SourceFile */) {
                    var substitute = (applicableSubstitutions & 2 /* TypeScriptSubstitutionFlags.NamespaceExports */ && container.kind === 261 /* SyntaxKind.ModuleDeclaration */) ||
                        (applicableSubstitutions & 8 /* TypeScriptSubstitutionFlags.NonQualifiedEnumMembers */ && container.kind === 260 /* SyntaxKind.EnumDeclaration */);
                    if (substitute) {
                        return ts.setTextRange(factory.createPropertyAccessExpression(factory.getGeneratedNameForNode(container), node), 
                        /*location*/ node);
                    }
                }
            }
            return undefined;
        }
        function substitutePropertyAccessExpression(node) {
            return substituteConstantValue(node);
        }
        function substituteElementAccessExpression(node) {
            return substituteConstantValue(node);
        }
        function safeMultiLineComment(value) {
            return value.replace(/\*\//g, "*_/");
        }
        function substituteConstantValue(node) {
            var constantValue = tryGetConstEnumValue(node);
            if (constantValue !== undefined) {
                // track the constant value on the node for the printer in needsDotDotForPropertyAccess
                ts.setConstantValue(node, constantValue);
                var substitute = typeof constantValue === "string" ? factory.createStringLiteral(constantValue) : factory.createNumericLiteral(constantValue);
                if (!compilerOptions.removeComments) {
                    var originalNode = ts.getOriginalNode(node, ts.isAccessExpression);
                    ts.addSyntheticTrailingComment(substitute, 3 /* SyntaxKind.MultiLineCommentTrivia */, " ".concat(safeMultiLineComment(ts.getTextOfNode(originalNode)), " "));
                }
                return substitute;
            }
            return node;
        }
        function tryGetConstEnumValue(node) {
            if (compilerOptions.isolatedModules) {
                return undefined;
            }
            return ts.isPropertyAccessExpression(node) || ts.isElementAccessExpression(node) ? resolver.getConstantValue(node) : undefined;
        }
        function shouldEmitAliasDeclaration(node) {
            return compilerOptions.preserveValueImports
                ? resolver.isValueAliasDeclaration(node)
                : resolver.isReferencedAliasDeclaration(node);
        }
    }
    ts.transformTypeScript = transformTypeScript;
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    var ClassPropertySubstitutionFlags;
    (function (ClassPropertySubstitutionFlags) {
        /**
         * Enables substitutions for class expressions with static fields
         * which have initializers that reference the class name.
         */
        ClassPropertySubstitutionFlags[ClassPropertySubstitutionFlags["ClassAliases"] = 1] = "ClassAliases";
        /**
         * Enables substitutions for class expressions with static fields
         * which have initializers that reference the 'this' or 'super'.
         */
        ClassPropertySubstitutionFlags[ClassPropertySubstitutionFlags["ClassStaticThisOrSuperReference"] = 2] = "ClassStaticThisOrSuperReference";
    })(ClassPropertySubstitutionFlags || (ClassPropertySubstitutionFlags = {}));
    var PrivateIdentifierKind;
    (function (PrivateIdentifierKind) {
        PrivateIdentifierKind["Field"] = "f";
        PrivateIdentifierKind["Method"] = "m";
        PrivateIdentifierKind["Accessor"] = "a";
    })(PrivateIdentifierKind = ts.PrivateIdentifierKind || (ts.PrivateIdentifierKind = {}));
    var ClassFacts;
    (function (ClassFacts) {
        ClassFacts[ClassFacts["None"] = 0] = "None";
        ClassFacts[ClassFacts["ClassWasDecorated"] = 1] = "ClassWasDecorated";
        ClassFacts[ClassFacts["NeedsClassConstructorReference"] = 2] = "NeedsClassConstructorReference";
        ClassFacts[ClassFacts["NeedsClassSuperReference"] = 4] = "NeedsClassSuperReference";
        ClassFacts[ClassFacts["NeedsSubstitutionForThisInClassStaticField"] = 8] = "NeedsSubstitutionForThisInClassStaticField";
    })(ClassFacts || (ClassFacts = {}));
    /**
     * Transforms ECMAScript Class Syntax.
     * TypeScript parameter property syntax is transformed in the TypeScript transformer.
     * For now, this transforms public field declarations using TypeScript class semantics,
     * where declarations are elided and initializers are transformed as assignments in the constructor.
     * When --useDefineForClassFields is on, this transforms to ECMAScript semantics, with Object.defineProperty.
     */
    function transformClassFields(context) {
        var factory = context.factory, hoistVariableDeclaration = context.hoistVariableDeclaration, endLexicalEnvironment = context.endLexicalEnvironment, startLexicalEnvironment = context.startLexicalEnvironment, resumeLexicalEnvironment = context.resumeLexicalEnvironment, addBlockScopedVariable = context.addBlockScopedVariable;
        var resolver = context.getEmitResolver();
        var compilerOptions = context.getCompilerOptions();
        var languageVersion = ts.getEmitScriptTarget(compilerOptions);
        var useDefineForClassFields = ts.getUseDefineForClassFields(compilerOptions);
        var shouldTransformPrivateElementsOrClassStaticBlocks = languageVersion < 9 /* ScriptTarget.ES2022 */;
        // We need to transform `this` in a static initializer into a reference to the class
        // when targeting < ES2022 since the assignment will be moved outside of the class body.
        var shouldTransformThisInStaticInitializers = languageVersion < 9 /* ScriptTarget.ES2022 */;
        // We don't need to transform `super` property access when targeting ES5, ES3 because
        // the es2015 transformation handles those.
        var shouldTransformSuperInStaticInitializers = shouldTransformThisInStaticInitializers && languageVersion >= 2 /* ScriptTarget.ES2015 */;
        var previousOnSubstituteNode = context.onSubstituteNode;
        context.onSubstituteNode = onSubstituteNode;
        var previousOnEmitNode = context.onEmitNode;
        context.onEmitNode = onEmitNode;
        var enabledSubstitutions;
        var classAliases;
        /**
         * Tracks what computed name expressions originating from elided names must be inlined
         * at the next execution site, in document order
         */
        var pendingExpressions;
        /**
         * Tracks what computed name expression statements and static property initializers must be
         * emitted at the next execution site, in document order (for decorated classes).
         */
        var pendingStatements;
        var classLexicalEnvironmentStack = [];
        var classLexicalEnvironmentMap = new ts.Map();
        var currentClassLexicalEnvironment;
        var currentComputedPropertyNameClassLexicalEnvironment;
        var currentStaticPropertyDeclarationOrStaticBlock;
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            var options = context.getCompilerOptions();
            if (node.isDeclarationFile
                || useDefineForClassFields && ts.getEmitScriptTarget(options) >= 9 /* ScriptTarget.ES2022 */) {
                return node;
            }
            var visited = ts.visitEachChild(node, visitor, context);
            ts.addEmitHelpers(visited, context.readEmitHelpers());
            return visited;
        }
        function visitorWorker(node, valueIsDiscarded) {
            if (node.transformFlags & 8388608 /* TransformFlags.ContainsClassFields */) {
                switch (node.kind) {
                    case 226 /* SyntaxKind.ClassExpression */:
                    case 257 /* SyntaxKind.ClassDeclaration */:
                        return visitClassLike(node);
                    case 167 /* SyntaxKind.PropertyDeclaration */:
                        return visitPropertyDeclaration(node);
                    case 237 /* SyntaxKind.VariableStatement */:
                        return visitVariableStatement(node);
                    case 80 /* SyntaxKind.PrivateIdentifier */:
                        return visitPrivateIdentifier(node);
                    case 170 /* SyntaxKind.ClassStaticBlockDeclaration */:
                        return visitClassStaticBlockDeclaration(node);
                }
            }
            if (node.transformFlags & 8388608 /* TransformFlags.ContainsClassFields */ ||
                node.transformFlags & 33554432 /* TransformFlags.ContainsLexicalSuper */ &&
                    shouldTransformSuperInStaticInitializers &&
                    currentStaticPropertyDeclarationOrStaticBlock &&
                    currentClassLexicalEnvironment) {
                switch (node.kind) {
                    case 219 /* SyntaxKind.PrefixUnaryExpression */:
                    case 220 /* SyntaxKind.PostfixUnaryExpression */:
                        return visitPreOrPostfixUnaryExpression(node, valueIsDiscarded);
                    case 221 /* SyntaxKind.BinaryExpression */:
                        return visitBinaryExpression(node, valueIsDiscarded);
                    case 208 /* SyntaxKind.CallExpression */:
                        return visitCallExpression(node);
                    case 210 /* SyntaxKind.TaggedTemplateExpression */:
                        return visitTaggedTemplateExpression(node);
                    case 206 /* SyntaxKind.PropertyAccessExpression */:
                        return visitPropertyAccessExpression(node);
                    case 207 /* SyntaxKind.ElementAccessExpression */:
                        return visitElementAccessExpression(node);
                    case 238 /* SyntaxKind.ExpressionStatement */:
                        return visitExpressionStatement(node);
                    case 242 /* SyntaxKind.ForStatement */:
                        return visitForStatement(node);
                    case 256 /* SyntaxKind.FunctionDeclaration */:
                    case 213 /* SyntaxKind.FunctionExpression */:
                    case 171 /* SyntaxKind.Constructor */:
                    case 169 /* SyntaxKind.MethodDeclaration */:
                    case 172 /* SyntaxKind.GetAccessor */:
                    case 173 /* SyntaxKind.SetAccessor */: {
                        var savedCurrentStaticPropertyDeclarationOrStaticBlock = currentStaticPropertyDeclarationOrStaticBlock;
                        currentStaticPropertyDeclarationOrStaticBlock = undefined;
                        var result = ts.visitEachChild(node, visitor, context);
                        currentStaticPropertyDeclarationOrStaticBlock = savedCurrentStaticPropertyDeclarationOrStaticBlock;
                        return result;
                    }
                }
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function discardedValueVisitor(node) {
            return visitorWorker(node, /*valueIsDiscarded*/ true);
        }
        function visitor(node) {
            return visitorWorker(node, /*valueIsDiscarded*/ false);
        }
        function heritageClauseVisitor(node) {
            switch (node.kind) {
                case 291 /* SyntaxKind.HeritageClause */:
                    return ts.visitEachChild(node, heritageClauseVisitor, context);
                case 228 /* SyntaxKind.ExpressionWithTypeArguments */:
                    return visitExpressionWithTypeArguments(node);
            }
            return visitor(node);
        }
        function visitorDestructuringTarget(node) {
            switch (node.kind) {
                case 205 /* SyntaxKind.ObjectLiteralExpression */:
                case 204 /* SyntaxKind.ArrayLiteralExpression */:
                    return visitAssignmentPattern(node);
                default:
                    return visitor(node);
            }
        }
        /**
         * If we visit a private name, this means it is an undeclared private name.
         * Replace it with an empty identifier to indicate a problem with the code,
         * unless we are in a statement position - otherwise this will not trigger
         * a SyntaxError.
         */
        function visitPrivateIdentifier(node) {
            if (!shouldTransformPrivateElementsOrClassStaticBlocks) {
                return node;
            }
            if (ts.isStatement(node.parent)) {
                return node;
            }
            return ts.setOriginalNode(factory.createIdentifier(""), node);
        }
        /**
         * Visits `#id in expr`
         */
        function visitPrivateIdentifierInInExpression(node) {
            if (!shouldTransformPrivateElementsOrClassStaticBlocks) {
                return node;
            }
            var privId = node.left;
            ts.Debug.assertNode(privId, ts.isPrivateIdentifier);
            ts.Debug.assert(node.operatorToken.kind === 101 /* SyntaxKind.InKeyword */);
            var info = accessPrivateIdentifier(privId);
            if (info) {
                var receiver = ts.visitNode(node.right, visitor, ts.isExpression);
                return ts.setOriginalNode(context.getEmitHelperFactory().createClassPrivateFieldInHelper(info.brandCheckIdentifier, receiver), node);
            }
            // Private name has not been declared. Subsequent transformers will handle this error
            return ts.visitEachChild(node, visitor, context);
        }
        /**
         * Visits the members of a class that has fields.
         *
         * @param node The node to visit.
         */
        function classElementVisitor(node) {
            switch (node.kind) {
                case 171 /* SyntaxKind.Constructor */:
                    // Constructors for classes using class fields are transformed in
                    // `visitClassDeclaration` or `visitClassExpression`.
                    return undefined;
                case 172 /* SyntaxKind.GetAccessor */:
                case 173 /* SyntaxKind.SetAccessor */:
                case 169 /* SyntaxKind.MethodDeclaration */:
                    return visitMethodOrAccessorDeclaration(node);
                case 167 /* SyntaxKind.PropertyDeclaration */:
                    return visitPropertyDeclaration(node);
                case 162 /* SyntaxKind.ComputedPropertyName */:
                    return visitComputedPropertyName(node);
                case 234 /* SyntaxKind.SemicolonClassElement */:
                    return node;
                default:
                    return visitor(node);
            }
        }
        function visitVariableStatement(node) {
            var savedPendingStatements = pendingStatements;
            pendingStatements = [];
            var visitedNode = ts.visitEachChild(node, visitor, context);
            var statement = ts.some(pendingStatements) ? __spreadArray([visitedNode], pendingStatements, true) :
                visitedNode;
            pendingStatements = savedPendingStatements;
            return statement;
        }
        function visitComputedPropertyName(name) {
            var node = ts.visitEachChild(name, visitor, context);
            if (ts.some(pendingExpressions)) {
                var expressions = pendingExpressions;
                expressions.push(node.expression);
                pendingExpressions = [];
                node = factory.updateComputedPropertyName(node, factory.inlineExpressions(expressions));
            }
            return node;
        }
        function visitMethodOrAccessorDeclaration(node) {
            ts.Debug.assert(!ts.some(node.decorators));
            if (!shouldTransformPrivateElementsOrClassStaticBlocks || !ts.isPrivateIdentifier(node.name)) {
                return ts.visitEachChild(node, classElementVisitor, context);
            }
            // leave invalid code untransformed
            var info = accessPrivateIdentifier(node.name);
            ts.Debug.assert(info, "Undeclared private name for property declaration.");
            if (!info.isValid) {
                return node;
            }
            var functionName = getHoistedFunctionName(node);
            if (functionName) {
                getPendingExpressions().push(factory.createAssignment(functionName, factory.createFunctionExpression(ts.filter(node.modifiers, function (m) { return !ts.isStaticModifier(m); }), node.asteriskToken, functionName, 
                /* typeParameters */ undefined, ts.visitParameterList(node.parameters, classElementVisitor, context), 
                /* type */ undefined, ts.visitFunctionBody(node.body, classElementVisitor, context))));
            }
            // remove method declaration from class
            return undefined;
        }
        function getHoistedFunctionName(node) {
            ts.Debug.assert(ts.isPrivateIdentifier(node.name));
            var info = accessPrivateIdentifier(node.name);
            ts.Debug.assert(info, "Undeclared private name for property declaration.");
            if (info.kind === "m" /* PrivateIdentifierKind.Method */) {
                return info.methodName;
            }
            if (info.kind === "a" /* PrivateIdentifierKind.Accessor */) {
                if (ts.isGetAccessor(node)) {
                    return info.getterName;
                }
                if (ts.isSetAccessor(node)) {
                    return info.setterName;
                }
            }
        }
        function visitPropertyDeclaration(node) {
            ts.Debug.assert(!ts.some(node.decorators));
            if (ts.isPrivateIdentifier(node.name)) {
                if (!shouldTransformPrivateElementsOrClassStaticBlocks) {
                    if (ts.isStatic(node)) {
                        // static fields are left as is
                        return ts.visitEachChild(node, visitor, context);
                    }
                    // Initializer is elided as the field is initialized in transformConstructor.
                    return factory.updatePropertyDeclaration(node, 
                    /*decorators*/ undefined, ts.visitNodes(node.modifiers, visitor, ts.isModifier), node.name, 
                    /*questionOrExclamationToken*/ undefined, 
                    /*type*/ undefined, 
                    /*initializer*/ undefined);
                }
                // leave invalid code untransformed
                var info = accessPrivateIdentifier(node.name);
                ts.Debug.assert(info, "Undeclared private name for property declaration.");
                if (!info.isValid) {
                    return node;
                }
            }
            // Create a temporary variable to store a computed property name (if necessary).
            // If it's not inlineable, then we emit an expression after the class which assigns
            // the property name to the temporary variable.
            var expr = getPropertyNameExpressionIfNeeded(node.name, !!node.initializer || useDefineForClassFields);
            if (expr && !ts.isSimpleInlineableExpression(expr)) {
                getPendingExpressions().push(expr);
            }
            if (ts.isStatic(node) && !shouldTransformPrivateElementsOrClassStaticBlocks && !useDefineForClassFields) {
                var initializerStatement = transformPropertyOrClassStaticBlock(node, factory.createThis());
                if (initializerStatement) {
                    var staticBlock = factory.createClassStaticBlockDeclaration(
                    /*decorators*/ undefined, 
                    /*modifiers*/ undefined, factory.createBlock([initializerStatement]));
                    ts.setOriginalNode(staticBlock, node);
                    ts.setCommentRange(staticBlock, node);
                    // Set the comment range for the statement to an empty synthetic range
                    // and drop synthetic comments from the statement to avoid printing them twice.
                    ts.setCommentRange(initializerStatement, { pos: -1, end: -1 });
                    ts.setSyntheticLeadingComments(initializerStatement, undefined);
                    ts.setSyntheticTrailingComments(initializerStatement, undefined);
                    return staticBlock;
                }
            }
            return undefined;
        }
        function createPrivateIdentifierAccess(info, receiver) {
            return createPrivateIdentifierAccessHelper(info, ts.visitNode(receiver, visitor, ts.isExpression));
        }
        function createPrivateIdentifierAccessHelper(info, receiver) {
            ts.setCommentRange(receiver, ts.moveRangePos(receiver, -1));
            switch (info.kind) {
                case "a" /* PrivateIdentifierKind.Accessor */:
                    return context.getEmitHelperFactory().createClassPrivateFieldGetHelper(receiver, info.brandCheckIdentifier, info.kind, info.getterName);
                case "m" /* PrivateIdentifierKind.Method */:
                    return context.getEmitHelperFactory().createClassPrivateFieldGetHelper(receiver, info.brandCheckIdentifier, info.kind, info.methodName);
                case "f" /* PrivateIdentifierKind.Field */:
                    return context.getEmitHelperFactory().createClassPrivateFieldGetHelper(receiver, info.brandCheckIdentifier, info.kind, info.variableName);
                default:
                    ts.Debug.assertNever(info, "Unknown private element type");
            }
        }
        function visitPropertyAccessExpression(node) {
            if (shouldTransformPrivateElementsOrClassStaticBlocks && ts.isPrivateIdentifier(node.name)) {
                var privateIdentifierInfo = accessPrivateIdentifier(node.name);
                if (privateIdentifierInfo) {
                    return ts.setTextRange(ts.setOriginalNode(createPrivateIdentifierAccess(privateIdentifierInfo, node.expression), node), node);
                }
            }
            if (shouldTransformSuperInStaticInitializers &&
                ts.isSuperProperty(node) &&
                ts.isIdentifier(node.name) &&
                currentStaticPropertyDeclarationOrStaticBlock &&
                currentClassLexicalEnvironment) {
                var classConstructor = currentClassLexicalEnvironment.classConstructor, superClassReference = currentClassLexicalEnvironment.superClassReference, facts = currentClassLexicalEnvironment.facts;
                if (facts & 1 /* ClassFacts.ClassWasDecorated */) {
                    return visitInvalidSuperProperty(node);
                }
                if (classConstructor && superClassReference) {
                    // converts `super.x` into `Reflect.get(_baseTemp, "x", _classTemp)`
                    var superProperty = factory.createReflectGetCall(superClassReference, factory.createStringLiteralFromNode(node.name), classConstructor);
                    ts.setOriginalNode(superProperty, node.expression);
                    ts.setTextRange(superProperty, node.expression);
                    return superProperty;
                }
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitElementAccessExpression(node) {
            if (shouldTransformSuperInStaticInitializers &&
                ts.isSuperProperty(node) &&
                currentStaticPropertyDeclarationOrStaticBlock &&
                currentClassLexicalEnvironment) {
                var classConstructor = currentClassLexicalEnvironment.classConstructor, superClassReference = currentClassLexicalEnvironment.superClassReference, facts = currentClassLexicalEnvironment.facts;
                if (facts & 1 /* ClassFacts.ClassWasDecorated */) {
                    return visitInvalidSuperProperty(node);
                }
                if (classConstructor && superClassReference) {
                    // converts `super[x]` into `Reflect.get(_baseTemp, x, _classTemp)`
                    var superProperty = factory.createReflectGetCall(superClassReference, ts.visitNode(node.argumentExpression, visitor, ts.isExpression), classConstructor);
                    ts.setOriginalNode(superProperty, node.expression);
                    ts.setTextRange(superProperty, node.expression);
                    return superProperty;
                }
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitPreOrPostfixUnaryExpression(node, valueIsDiscarded) {
            if (node.operator === 45 /* SyntaxKind.PlusPlusToken */ || node.operator === 46 /* SyntaxKind.MinusMinusToken */) {
                if (shouldTransformPrivateElementsOrClassStaticBlocks && ts.isPrivateIdentifierPropertyAccessExpression(node.operand)) {
                    var info = void 0;
                    if (info = accessPrivateIdentifier(node.operand.name)) {
                        var receiver = ts.visitNode(node.operand.expression, visitor, ts.isExpression);
                        var _a = createCopiableReceiverExpr(receiver), readExpression = _a.readExpression, initializeExpression = _a.initializeExpression;
                        var expression = createPrivateIdentifierAccess(info, readExpression);
                        var temp = ts.isPrefixUnaryExpression(node) || valueIsDiscarded ? undefined : factory.createTempVariable(hoistVariableDeclaration);
                        expression = ts.expandPreOrPostfixIncrementOrDecrementExpression(factory, node, expression, hoistVariableDeclaration, temp);
                        expression = createPrivateIdentifierAssignment(info, initializeExpression || readExpression, expression, 63 /* SyntaxKind.EqualsToken */);
                        ts.setOriginalNode(expression, node);
                        ts.setTextRange(expression, node);
                        if (temp) {
                            expression = factory.createComma(expression, temp);
                            ts.setTextRange(expression, node);
                        }
                        return expression;
                    }
                }
                else if (shouldTransformSuperInStaticInitializers &&
                    ts.isSuperProperty(node.operand) &&
                    currentStaticPropertyDeclarationOrStaticBlock &&
                    currentClassLexicalEnvironment) {
                    // converts `++super.a` into `(Reflect.set(_baseTemp, "a", (_a = Reflect.get(_baseTemp, "a", _classTemp), _b = ++_a), _classTemp), _b)`
                    // converts `++super[f()]` into `(Reflect.set(_baseTemp, _a = f(), (_b = Reflect.get(_baseTemp, _a, _classTemp), _c = ++_b), _classTemp), _c)`
                    // converts `--super.a` into `(Reflect.set(_baseTemp, "a", (_a = Reflect.get(_baseTemp, "a", _classTemp), _b = --_a), _classTemp), _b)`
                    // converts `--super[f()]` into `(Reflect.set(_baseTemp, _a = f(), (_b = Reflect.get(_baseTemp, _a, _classTemp), _c = --_b), _classTemp), _c)`
                    // converts `super.a++` into `(Reflect.set(_baseTemp, "a", (_a = Reflect.get(_baseTemp, "a", _classTemp), _b = _a++), _classTemp), _b)`
                    // converts `super[f()]++` into `(Reflect.set(_baseTemp, _a = f(), (_b = Reflect.get(_baseTemp, _a, _classTemp), _c = _b++), _classTemp), _c)`
                    // converts `super.a--` into `(Reflect.set(_baseTemp, "a", (_a = Reflect.get(_baseTemp, "a", _classTemp), _b = _a--), _classTemp), _b)`
                    // converts `super[f()]--` into `(Reflect.set(_baseTemp, _a = f(), (_b = Reflect.get(_baseTemp, _a, _classTemp), _c = _b--), _classTemp), _c)`
                    var classConstructor = currentClassLexicalEnvironment.classConstructor, superClassReference = currentClassLexicalEnvironment.superClassReference, facts = currentClassLexicalEnvironment.facts;
                    if (facts & 1 /* ClassFacts.ClassWasDecorated */) {
                        var operand = visitInvalidSuperProperty(node.operand);
                        return ts.isPrefixUnaryExpression(node) ?
                            factory.updatePrefixUnaryExpression(node, operand) :
                            factory.updatePostfixUnaryExpression(node, operand);
                    }
                    if (classConstructor && superClassReference) {
                        var setterName = void 0;
                        var getterName = void 0;
                        if (ts.isPropertyAccessExpression(node.operand)) {
                            if (ts.isIdentifier(node.operand.name)) {
                                getterName = setterName = factory.createStringLiteralFromNode(node.operand.name);
                            }
                        }
                        else {
                            if (ts.isSimpleInlineableExpression(node.operand.argumentExpression)) {
                                getterName = setterName = node.operand.argumentExpression;
                            }
                            else {
                                getterName = factory.createTempVariable(hoistVariableDeclaration);
                                setterName = factory.createAssignment(getterName, ts.visitNode(node.operand.argumentExpression, visitor, ts.isExpression));
                            }
                        }
                        if (setterName && getterName) {
                            var expression = factory.createReflectGetCall(superClassReference, getterName, classConstructor);
                            ts.setTextRange(expression, node.operand);
                            var temp = valueIsDiscarded ? undefined : factory.createTempVariable(hoistVariableDeclaration);
                            expression = ts.expandPreOrPostfixIncrementOrDecrementExpression(factory, node, expression, hoistVariableDeclaration, temp);
                            expression = factory.createReflectSetCall(superClassReference, setterName, expression, classConstructor);
                            ts.setOriginalNode(expression, node);
                            ts.setTextRange(expression, node);
                            if (temp) {
                                expression = factory.createComma(expression, temp);
                                ts.setTextRange(expression, node);
                            }
                            return expression;
                        }
                    }
                }
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitForStatement(node) {
            return factory.updateForStatement(node, ts.visitNode(node.initializer, discardedValueVisitor, ts.isForInitializer), ts.visitNode(node.condition, visitor, ts.isExpression), ts.visitNode(node.incrementor, discardedValueVisitor, ts.isExpression), ts.visitIterationBody(node.statement, visitor, context));
        }
        function visitExpressionStatement(node) {
            return factory.updateExpressionStatement(node, ts.visitNode(node.expression, discardedValueVisitor, ts.isExpression));
        }
        function createCopiableReceiverExpr(receiver) {
            var clone = ts.nodeIsSynthesized(receiver) ? receiver : factory.cloneNode(receiver);
            if (ts.isSimpleInlineableExpression(receiver)) {
                return { readExpression: clone, initializeExpression: undefined };
            }
            var readExpression = factory.createTempVariable(hoistVariableDeclaration);
            var initializeExpression = factory.createAssignment(readExpression, clone);
            return { readExpression: readExpression, initializeExpression: initializeExpression };
        }
        function visitCallExpression(node) {
            if (shouldTransformPrivateElementsOrClassStaticBlocks && ts.isPrivateIdentifierPropertyAccessExpression(node.expression)) {
                // Transform call expressions of private names to properly bind the `this` parameter.
                var _a = factory.createCallBinding(node.expression, hoistVariableDeclaration, languageVersion), thisArg = _a.thisArg, target = _a.target;
                if (ts.isCallChain(node)) {
                    return factory.updateCallChain(node, factory.createPropertyAccessChain(ts.visitNode(target, visitor), node.questionDotToken, "call"), 
                    /*questionDotToken*/ undefined, 
                    /*typeArguments*/ undefined, __spreadArray([ts.visitNode(thisArg, visitor, ts.isExpression)], ts.visitNodes(node.arguments, visitor, ts.isExpression), true));
                }
                return factory.updateCallExpression(node, factory.createPropertyAccessExpression(ts.visitNode(target, visitor), "call"), 
                /*typeArguments*/ undefined, __spreadArray([ts.visitNode(thisArg, visitor, ts.isExpression)], ts.visitNodes(node.arguments, visitor, ts.isExpression), true));
            }
            if (shouldTransformSuperInStaticInitializers &&
                ts.isSuperProperty(node.expression) &&
                currentStaticPropertyDeclarationOrStaticBlock &&
                (currentClassLexicalEnvironment === null || currentClassLexicalEnvironment === void 0 ? void 0 : currentClassLexicalEnvironment.classConstructor)) {
                // converts `super.f(...)` into `Reflect.get(_baseTemp, "f", _classTemp).call(_classTemp, ...)`
                var invocation = factory.createFunctionCallCall(ts.visitNode(node.expression, visitor, ts.isExpression), currentClassLexicalEnvironment.classConstructor, ts.visitNodes(node.arguments, visitor, ts.isExpression));
                ts.setOriginalNode(invocation, node);
                ts.setTextRange(invocation, node);
                return invocation;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitTaggedTemplateExpression(node) {
            if (shouldTransformPrivateElementsOrClassStaticBlocks && ts.isPrivateIdentifierPropertyAccessExpression(node.tag)) {
                // Bind the `this` correctly for tagged template literals when the tag is a private identifier property access.
                var _a = factory.createCallBinding(node.tag, hoistVariableDeclaration, languageVersion), thisArg = _a.thisArg, target = _a.target;
                return factory.updateTaggedTemplateExpression(node, factory.createCallExpression(factory.createPropertyAccessExpression(ts.visitNode(target, visitor), "bind"), 
                /*typeArguments*/ undefined, [ts.visitNode(thisArg, visitor, ts.isExpression)]), 
                /*typeArguments*/ undefined, ts.visitNode(node.template, visitor, ts.isTemplateLiteral));
            }
            if (shouldTransformSuperInStaticInitializers &&
                ts.isSuperProperty(node.tag) &&
                currentStaticPropertyDeclarationOrStaticBlock &&
                (currentClassLexicalEnvironment === null || currentClassLexicalEnvironment === void 0 ? void 0 : currentClassLexicalEnvironment.classConstructor)) {
                // converts `` super.f`x` `` into `` Reflect.get(_baseTemp, "f", _classTemp).bind(_classTemp)`x` ``
                var invocation = factory.createFunctionBindCall(ts.visitNode(node.tag, visitor, ts.isExpression), currentClassLexicalEnvironment.classConstructor, []);
                ts.setOriginalNode(invocation, node);
                ts.setTextRange(invocation, node);
                return factory.updateTaggedTemplateExpression(node, invocation, 
                /*typeArguments*/ undefined, ts.visitNode(node.template, visitor, ts.isTemplateLiteral));
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function transformClassStaticBlockDeclaration(node) {
            if (shouldTransformPrivateElementsOrClassStaticBlocks) {
                if (currentClassLexicalEnvironment) {
                    classLexicalEnvironmentMap.set(ts.getOriginalNodeId(node), currentClassLexicalEnvironment);
                }
                startLexicalEnvironment();
                var savedCurrentStaticPropertyDeclarationOrStaticBlock = currentStaticPropertyDeclarationOrStaticBlock;
                currentStaticPropertyDeclarationOrStaticBlock = node;
                var statements = ts.visitNodes(node.body.statements, visitor, ts.isStatement);
                statements = factory.mergeLexicalEnvironment(statements, endLexicalEnvironment());
                currentStaticPropertyDeclarationOrStaticBlock = savedCurrentStaticPropertyDeclarationOrStaticBlock;
                var iife = factory.createImmediatelyInvokedArrowFunction(statements);
                ts.setOriginalNode(iife, node);
                ts.setTextRange(iife, node);
                ts.addEmitFlags(iife, 2 /* EmitFlags.AdviseOnEmitNode */);
                return iife;
            }
        }
        function visitBinaryExpression(node, valueIsDiscarded) {
            if (ts.isDestructuringAssignment(node)) {
                var savedPendingExpressions = pendingExpressions;
                pendingExpressions = undefined;
                node = factory.updateBinaryExpression(node, ts.visitNode(node.left, visitorDestructuringTarget), node.operatorToken, ts.visitNode(node.right, visitor));
                var expr = ts.some(pendingExpressions) ?
                    factory.inlineExpressions(ts.compact(__spreadArray(__spreadArray([], pendingExpressions, true), [node], false))) :
                    node;
                pendingExpressions = savedPendingExpressions;
                return expr;
            }
            if (ts.isAssignmentExpression(node)) {
                if (shouldTransformPrivateElementsOrClassStaticBlocks && ts.isPrivateIdentifierPropertyAccessExpression(node.left)) {
                    var info = accessPrivateIdentifier(node.left.name);
                    if (info) {
                        return ts.setTextRange(ts.setOriginalNode(createPrivateIdentifierAssignment(info, node.left.expression, node.right, node.operatorToken.kind), node), node);
                    }
                }
                else if (shouldTransformSuperInStaticInitializers &&
                    ts.isSuperProperty(node.left) &&
                    currentStaticPropertyDeclarationOrStaticBlock &&
                    currentClassLexicalEnvironment) {
                    var classConstructor = currentClassLexicalEnvironment.classConstructor, superClassReference = currentClassLexicalEnvironment.superClassReference, facts = currentClassLexicalEnvironment.facts;
                    if (facts & 1 /* ClassFacts.ClassWasDecorated */) {
                        return factory.updateBinaryExpression(node, visitInvalidSuperProperty(node.left), node.operatorToken, ts.visitNode(node.right, visitor, ts.isExpression));
                    }
                    if (classConstructor && superClassReference) {
                        var setterName = ts.isElementAccessExpression(node.left) ? ts.visitNode(node.left.argumentExpression, visitor, ts.isExpression) :
                            ts.isIdentifier(node.left.name) ? factory.createStringLiteralFromNode(node.left.name) :
                                undefined;
                        if (setterName) {
                            // converts `super.x = 1` into `(Reflect.set(_baseTemp, "x", _a = 1, _classTemp), _a)`
                            // converts `super[f()] = 1` into `(Reflect.set(_baseTemp, f(), _a = 1, _classTemp), _a)`
                            // converts `super.x += 1` into `(Reflect.set(_baseTemp, "x", _a = Reflect.get(_baseTemp, "x", _classtemp) + 1, _classTemp), _a)`
                            // converts `super[f()] += 1` into `(Reflect.set(_baseTemp, _a = f(), _b = Reflect.get(_baseTemp, _a, _classtemp) + 1, _classTemp), _b)`
                            var expression = ts.visitNode(node.right, visitor, ts.isExpression);
                            if (ts.isCompoundAssignment(node.operatorToken.kind)) {
                                var getterName = setterName;
                                if (!ts.isSimpleInlineableExpression(setterName)) {
                                    getterName = factory.createTempVariable(hoistVariableDeclaration);
                                    setterName = factory.createAssignment(getterName, setterName);
                                }
                                var superPropertyGet = factory.createReflectGetCall(superClassReference, getterName, classConstructor);
                                ts.setOriginalNode(superPropertyGet, node.left);
                                ts.setTextRange(superPropertyGet, node.left);
                                expression = factory.createBinaryExpression(superPropertyGet, ts.getNonAssignmentOperatorForCompoundAssignment(node.operatorToken.kind), expression);
                                ts.setTextRange(expression, node);
                            }
                            var temp = valueIsDiscarded ? undefined : factory.createTempVariable(hoistVariableDeclaration);
                            if (temp) {
                                expression = factory.createAssignment(temp, expression);
                                ts.setTextRange(temp, node);
                            }
                            expression = factory.createReflectSetCall(superClassReference, setterName, expression, classConstructor);
                            ts.setOriginalNode(expression, node);
                            ts.setTextRange(expression, node);
                            if (temp) {
                                expression = factory.createComma(expression, temp);
                                ts.setTextRange(expression, node);
                            }
                            return expression;
                        }
                    }
                }
            }
            if (node.operatorToken.kind === 101 /* SyntaxKind.InKeyword */ && ts.isPrivateIdentifier(node.left)) {
                return visitPrivateIdentifierInInExpression(node);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function createPrivateIdentifierAssignment(info, receiver, right, operator) {
            receiver = ts.visitNode(receiver, visitor, ts.isExpression);
            right = ts.visitNode(right, visitor, ts.isExpression);
            if (ts.isCompoundAssignment(operator)) {
                var _a = createCopiableReceiverExpr(receiver), readExpression = _a.readExpression, initializeExpression = _a.initializeExpression;
                receiver = initializeExpression || readExpression;
                right = factory.createBinaryExpression(createPrivateIdentifierAccessHelper(info, readExpression), ts.getNonAssignmentOperatorForCompoundAssignment(operator), right);
            }
            ts.setCommentRange(receiver, ts.moveRangePos(receiver, -1));
            switch (info.kind) {
                case "a" /* PrivateIdentifierKind.Accessor */:
                    return context.getEmitHelperFactory().createClassPrivateFieldSetHelper(receiver, info.brandCheckIdentifier, right, info.kind, info.setterName);
                case "m" /* PrivateIdentifierKind.Method */:
                    return context.getEmitHelperFactory().createClassPrivateFieldSetHelper(receiver, info.brandCheckIdentifier, right, info.kind, 
                    /* f */ undefined);
                case "f" /* PrivateIdentifierKind.Field */:
                    return context.getEmitHelperFactory().createClassPrivateFieldSetHelper(receiver, info.brandCheckIdentifier, right, info.kind, info.variableName);
                default:
                    ts.Debug.assertNever(info, "Unknown private element type");
            }
        }
        /**
         * Set up the environment for a class.
         */
        function visitClassLike(node) {
            if (!ts.forEach(node.members, doesClassElementNeedTransform)) {
                return ts.visitEachChild(node, visitor, context);
            }
            var savedPendingExpressions = pendingExpressions;
            pendingExpressions = undefined;
            startClassLexicalEnvironment();
            if (shouldTransformPrivateElementsOrClassStaticBlocks) {
                var name = ts.getNameOfDeclaration(node);
                if (name && ts.isIdentifier(name)) {
                    getPrivateIdentifierEnvironment().className = ts.idText(name);
                }
                var privateInstanceMethodsAndAccessors = getPrivateInstanceMethodsAndAccessors(node);
                if (ts.some(privateInstanceMethodsAndAccessors)) {
                    getPrivateIdentifierEnvironment().weakSetName = createHoistedVariableForClass("instances", privateInstanceMethodsAndAccessors[0].name);
                }
            }
            var result = ts.isClassDeclaration(node) ?
                visitClassDeclaration(node) :
                visitClassExpression(node);
            endClassLexicalEnvironment();
            pendingExpressions = savedPendingExpressions;
            return result;
        }
        function doesClassElementNeedTransform(node) {
            return ts.isPropertyDeclaration(node) || ts.isClassStaticBlockDeclaration(node) || (shouldTransformPrivateElementsOrClassStaticBlocks && node.name && ts.isPrivateIdentifier(node.name));
        }
        function getPrivateInstanceMethodsAndAccessors(node) {
            return ts.filter(node.members, ts.isNonStaticMethodOrAccessorWithPrivateName);
        }
        function getClassFacts(node) {
            var facts = 0 /* ClassFacts.None */;
            var original = ts.getOriginalNode(node);
            if (ts.isClassDeclaration(original) && ts.classOrConstructorParameterIsDecorated(original)) {
                facts |= 1 /* ClassFacts.ClassWasDecorated */;
            }
            for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
                var member = _a[_i];
                if (!ts.isStatic(member))
                    continue;
                if (member.name && ts.isPrivateIdentifier(member.name) && shouldTransformPrivateElementsOrClassStaticBlocks) {
                    facts |= 2 /* ClassFacts.NeedsClassConstructorReference */;
                }
                if (ts.isPropertyDeclaration(member) || ts.isClassStaticBlockDeclaration(member)) {
                    if (shouldTransformThisInStaticInitializers && member.transformFlags & 8192 /* TransformFlags.ContainsLexicalThis */) {
                        facts |= 8 /* ClassFacts.NeedsSubstitutionForThisInClassStaticField */;
                        if (!(facts & 1 /* ClassFacts.ClassWasDecorated */)) {
                            facts |= 2 /* ClassFacts.NeedsClassConstructorReference */;
                        }
                    }
                    if (shouldTransformSuperInStaticInitializers && member.transformFlags & 33554432 /* TransformFlags.ContainsLexicalSuper */) {
                        if (!(facts & 1 /* ClassFacts.ClassWasDecorated */)) {
                            facts |= 2 /* ClassFacts.NeedsClassConstructorReference */ | 4 /* ClassFacts.NeedsClassSuperReference */;
                        }
                    }
                }
            }
            return facts;
        }
        function visitExpressionWithTypeArguments(node) {
            var facts = (currentClassLexicalEnvironment === null || currentClassLexicalEnvironment === void 0 ? void 0 : currentClassLexicalEnvironment.facts) || 0 /* ClassFacts.None */;
            if (facts & 4 /* ClassFacts.NeedsClassSuperReference */) {
                var temp = factory.createTempVariable(hoistVariableDeclaration, /*reserveInNestedScopes*/ true);
                getClassLexicalEnvironment().superClassReference = temp;
                return factory.updateExpressionWithTypeArguments(node, factory.createAssignment(temp, ts.visitNode(node.expression, visitor, ts.isExpression)), 
                /*typeArguments*/ undefined);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitClassDeclaration(node) {
            var facts = getClassFacts(node);
            if (facts) {
                getClassLexicalEnvironment().facts = facts;
            }
            if (facts & 8 /* ClassFacts.NeedsSubstitutionForThisInClassStaticField */) {
                enableSubstitutionForClassStaticThisOrSuperReference();
            }
            // If a class has private static fields, or a static field has a `this` or `super` reference,
            // then we need to allocate a temp variable to hold on to that reference.
            var pendingClassReferenceAssignment;
            if (facts & 2 /* ClassFacts.NeedsClassConstructorReference */) {
                var temp = factory.createTempVariable(hoistVariableDeclaration, /*reservedInNestedScopes*/ true);
                getClassLexicalEnvironment().classConstructor = factory.cloneNode(temp);
                pendingClassReferenceAssignment = factory.createAssignment(temp, factory.getInternalName(node));
            }
            var extendsClauseElement = ts.getEffectiveBaseTypeNode(node);
            var isDerivedClass = !!(extendsClauseElement && ts.skipOuterExpressions(extendsClauseElement.expression).kind !== 104 /* SyntaxKind.NullKeyword */);
            var statements = [
                factory.updateClassDeclaration(node, 
                /*decorators*/ undefined, node.modifiers, node.name, 
                /*typeParameters*/ undefined, ts.visitNodes(node.heritageClauses, heritageClauseVisitor, ts.isHeritageClause), transformClassMembers(node, isDerivedClass))
            ];
            if (pendingClassReferenceAssignment) {
                getPendingExpressions().unshift(pendingClassReferenceAssignment);
            }
            // Write any pending expressions from elided or moved computed property names
            if (ts.some(pendingExpressions)) {
                statements.push(factory.createExpressionStatement(factory.inlineExpressions(pendingExpressions)));
            }
            // Emit static property assignment. Because classDeclaration is lexically evaluated,
            // it is safe to emit static property assignment after classDeclaration
            // From ES6 specification:
            //      HasLexicalDeclaration (N) : Determines if the argument identifier has a binding in this environment record that was created using
            //                                  a lexical declaration such as a LexicalDeclaration or a ClassDeclaration.
            var staticProperties = ts.getStaticPropertiesAndClassStaticBlock(node);
            if (ts.some(staticProperties)) {
                addPropertyOrClassStaticBlockStatements(statements, staticProperties, factory.getInternalName(node));
            }
            return statements;
        }
        function visitClassExpression(node) {
            var facts = getClassFacts(node);
            if (facts) {
                getClassLexicalEnvironment().facts = facts;
            }
            if (facts & 8 /* ClassFacts.NeedsSubstitutionForThisInClassStaticField */) {
                enableSubstitutionForClassStaticThisOrSuperReference();
            }
            // If this class expression is a transformation of a decorated class declaration,
            // then we want to output the pendingExpressions as statements, not as inlined
            // expressions with the class statement.
            //
            // In this case, we use pendingStatements to produce the same output as the
            // class declaration transformation. The VariableStatement visitor will insert
            // these statements after the class expression variable statement.
            var isDecoratedClassDeclaration = !!(facts & 1 /* ClassFacts.ClassWasDecorated */);
            var staticPropertiesOrClassStaticBlocks = ts.getStaticPropertiesAndClassStaticBlock(node);
            var extendsClauseElement = ts.getEffectiveBaseTypeNode(node);
            var isDerivedClass = !!(extendsClauseElement && ts.skipOuterExpressions(extendsClauseElement.expression).kind !== 104 /* SyntaxKind.NullKeyword */);
            var isClassWithConstructorReference = resolver.getNodeCheckFlags(node) & 16777216 /* NodeCheckFlags.ClassWithConstructorReference */;
            var temp;
            function createClassTempVar() {
                var classCheckFlags = resolver.getNodeCheckFlags(node);
                var isClassWithConstructorReference = classCheckFlags & 16777216 /* NodeCheckFlags.ClassWithConstructorReference */;
                var requiresBlockScopedVar = classCheckFlags & 524288 /* NodeCheckFlags.BlockScopedBindingInLoop */;
                return factory.createTempVariable(requiresBlockScopedVar ? addBlockScopedVariable : hoistVariableDeclaration, !!isClassWithConstructorReference);
            }
            if (facts & 2 /* ClassFacts.NeedsClassConstructorReference */) {
                temp = createClassTempVar();
                getClassLexicalEnvironment().classConstructor = factory.cloneNode(temp);
            }
            var classExpression = factory.updateClassExpression(node, ts.visitNodes(node.decorators, visitor, ts.isDecorator), node.modifiers, node.name, 
            /*typeParameters*/ undefined, ts.visitNodes(node.heritageClauses, heritageClauseVisitor, ts.isHeritageClause), transformClassMembers(node, isDerivedClass));
            var hasTransformableStatics = shouldTransformPrivateElementsOrClassStaticBlocks && ts.some(staticPropertiesOrClassStaticBlocks, function (p) { return ts.isClassStaticBlockDeclaration(p) || !!p.initializer || ts.isPrivateIdentifier(p.name); });
            if (hasTransformableStatics || ts.some(pendingExpressions)) {
                if (isDecoratedClassDeclaration) {
                    ts.Debug.assertIsDefined(pendingStatements, "Decorated classes transformed by TypeScript are expected to be within a variable declaration.");
                    // Write any pending expressions from elided or moved computed property names
                    if (pendingStatements && pendingExpressions && ts.some(pendingExpressions)) {
                        pendingStatements.push(factory.createExpressionStatement(factory.inlineExpressions(pendingExpressions)));
                    }
                    if (pendingStatements && ts.some(staticPropertiesOrClassStaticBlocks)) {
                        addPropertyOrClassStaticBlockStatements(pendingStatements, staticPropertiesOrClassStaticBlocks, factory.getInternalName(node));
                    }
                    if (temp) {
                        return factory.inlineExpressions([factory.createAssignment(temp, classExpression), temp]);
                    }
                    return classExpression;
                }
                else {
                    var expressions = [];
                    temp || (temp = createClassTempVar());
                    if (isClassWithConstructorReference) {
                        // record an alias as the class name is not in scope for statics.
                        enableSubstitutionForClassAliases();
                        var alias = factory.cloneNode(temp);
                        alias.autoGenerateFlags &= ~8 /* GeneratedIdentifierFlags.ReservedInNestedScopes */;
                        classAliases[ts.getOriginalNodeId(node)] = alias;
                    }
                    // To preserve the behavior of the old emitter, we explicitly indent
                    // the body of a class with static initializers.
                    ts.setEmitFlags(classExpression, 65536 /* EmitFlags.Indented */ | ts.getEmitFlags(classExpression));
                    expressions.push(ts.startOnNewLine(factory.createAssignment(temp, classExpression)));
                    // Add any pending expressions leftover from elided or relocated computed property names
                    ts.addRange(expressions, ts.map(pendingExpressions, ts.startOnNewLine));
                    ts.addRange(expressions, generateInitializedPropertyExpressionsOrClassStaticBlock(staticPropertiesOrClassStaticBlocks, temp));
                    expressions.push(ts.startOnNewLine(temp));
                    return factory.inlineExpressions(expressions);
                }
            }
            return classExpression;
        }
        function visitClassStaticBlockDeclaration(node) {
            if (!shouldTransformPrivateElementsOrClassStaticBlocks) {
                return ts.visitEachChild(node, classElementVisitor, context);
            }
            // ClassStaticBlockDeclaration for classes are transformed in `visitClassDeclaration` or `visitClassExpression`.
            return undefined;
        }
        function transformClassMembers(node, isDerivedClass) {
            var members = [];
            if (shouldTransformPrivateElementsOrClassStaticBlocks) {
                // Declare private names.
                for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
                    var member = _a[_i];
                    if (ts.isPrivateIdentifierClassElementDeclaration(member)) {
                        addPrivateIdentifierToEnvironment(member);
                    }
                }
                if (ts.some(getPrivateInstanceMethodsAndAccessors(node))) {
                    createBrandCheckWeakSetForPrivateMethods();
                }
            }
            var constructor = transformConstructor(node, isDerivedClass);
            var visitedMembers = ts.visitNodes(node.members, classElementVisitor, ts.isClassElement);
            if (constructor) {
                members.push(constructor);
            }
            if (!shouldTransformPrivateElementsOrClassStaticBlocks && ts.some(pendingExpressions)) {
                members.push(factory.createClassStaticBlockDeclaration(
                /*decorators*/ undefined, 
                /*modifiers*/ undefined, factory.createBlock([
                    factory.createExpressionStatement(factory.inlineExpressions(pendingExpressions))
                ])));
                pendingExpressions = undefined;
            }
            ts.addRange(members, visitedMembers);
            return ts.setTextRange(factory.createNodeArray(members), /*location*/ node.members);
        }
        function createBrandCheckWeakSetForPrivateMethods() {
            var weakSetName = getPrivateIdentifierEnvironment().weakSetName;
            ts.Debug.assert(weakSetName, "weakSetName should be set in private identifier environment");
            getPendingExpressions().push(factory.createAssignment(weakSetName, factory.createNewExpression(factory.createIdentifier("WeakSet"), 
            /*typeArguments*/ undefined, [])));
        }
        function isClassElementThatRequiresConstructorStatement(member) {
            if (ts.isStatic(member) || ts.hasSyntacticModifier(ts.getOriginalNode(member), 128 /* ModifierFlags.Abstract */)) {
                return false;
            }
            if (useDefineForClassFields) {
                // If we are using define semantics and targeting ESNext or higher,
                // then we don't need to transform any class properties.
                return languageVersion < 9 /* ScriptTarget.ES2022 */;
            }
            return ts.isInitializedProperty(member) || shouldTransformPrivateElementsOrClassStaticBlocks && ts.isPrivateIdentifierClassElementDeclaration(member);
        }
        function transformConstructor(node, isDerivedClass) {
            var constructor = ts.visitNode(ts.getFirstConstructorWithBody(node), visitor, ts.isConstructorDeclaration);
            var elements = node.members.filter(isClassElementThatRequiresConstructorStatement);
            if (!ts.some(elements)) {
                return constructor;
            }
            var parameters = ts.visitParameterList(constructor ? constructor.parameters : undefined, visitor, context);
            var body = transformConstructorBody(node, constructor, isDerivedClass);
            if (!body) {
                return undefined;
            }
            return ts.startOnNewLine(ts.setOriginalNode(ts.setTextRange(factory.createConstructorDeclaration(
            /*decorators*/ undefined, 
            /*modifiers*/ undefined, parameters !== null && parameters !== void 0 ? parameters : [], body), constructor || node), constructor));
        }
        function transformConstructorBody(node, constructor, isDerivedClass) {
            var _a;
            var properties = ts.getProperties(node, /*requireInitializer*/ false, /*isStatic*/ false);
            if (!useDefineForClassFields) {
                properties = ts.filter(properties, function (property) { return !!property.initializer || ts.isPrivateIdentifier(property.name); });
            }
            var privateMethodsAndAccessors = getPrivateInstanceMethodsAndAccessors(node);
            var needsConstructorBody = ts.some(properties) || ts.some(privateMethodsAndAccessors);
            // Only generate synthetic constructor when there are property initializers to move.
            if (!constructor && !needsConstructorBody) {
                return ts.visitFunctionBody(/*node*/ undefined, visitor, context);
            }
            resumeLexicalEnvironment();
            var needsSyntheticConstructor = !constructor && isDerivedClass;
            var indexOfFirstStatementAfterSuperAndPrologue = 0;
            var prologueStatementCount = 0;
            var superStatementIndex = -1;
            var statements = [];
            if ((_a = constructor === null || constructor === void 0 ? void 0 : constructor.body) === null || _a === void 0 ? void 0 : _a.statements) {
                prologueStatementCount = factory.copyPrologue(constructor.body.statements, statements, /*ensureUseStrict*/ false, visitor);
                superStatementIndex = ts.findSuperStatementIndex(constructor.body.statements, prologueStatementCount);
                // If there was a super call, visit existing statements up to and including it
                if (superStatementIndex >= 0) {
                    indexOfFirstStatementAfterSuperAndPrologue = superStatementIndex + 1;
                    statements = __spreadArray(__spreadArray(__spreadArray([], statements.slice(0, prologueStatementCount), true), ts.visitNodes(constructor.body.statements, visitor, ts.isStatement, prologueStatementCount, indexOfFirstStatementAfterSuperAndPrologue - prologueStatementCount), true), statements.slice(prologueStatementCount), true);
                }
                else if (prologueStatementCount >= 0) {
                    indexOfFirstStatementAfterSuperAndPrologue = prologueStatementCount;
                }
            }
            if (needsSyntheticConstructor) {
                // Add a synthetic `super` call:
                //
                //  super(...arguments);
                //
                statements.push(factory.createExpressionStatement(factory.createCallExpression(factory.createSuper(), 
                /*typeArguments*/ undefined, [factory.createSpreadElement(factory.createIdentifier("arguments"))])));
            }
            // Add the property initializers. Transforms this:
            //
            //  public x = 1;
            //
            // Into this:
            //
            //  constructor() {
            //      this.x = 1;
            //  }
            //
            // If we do useDefineForClassFields, they'll be converted elsewhere.
            // We instead *remove* them from the transformed output at this stage.
            var parameterPropertyDeclarationCount = 0;
            if (constructor === null || constructor === void 0 ? void 0 : constructor.body) {
                if (useDefineForClassFields) {
                    statements = statements.filter(function (statement) { return !ts.isParameterPropertyDeclaration(ts.getOriginalNode(statement), constructor); });
                }
                else {
                    for (var _i = 0, _b = constructor.body.statements; _i < _b.length; _i++) {
                        var statement = _b[_i];
                        if (ts.isParameterPropertyDeclaration(ts.getOriginalNode(statement), constructor)) {
                            parameterPropertyDeclarationCount++;
                        }
                    }
                    if (parameterPropertyDeclarationCount > 0) {
                        var parameterProperties = ts.visitNodes(constructor.body.statements, visitor, ts.isStatement, indexOfFirstStatementAfterSuperAndPrologue, parameterPropertyDeclarationCount);
                        // If there was a super() call found, add parameter properties immediately after it
                        if (superStatementIndex >= 0) {
                            ts.addRange(statements, parameterProperties);
                        }
                        else {
                            // Add add parameter properties to the top of the constructor after the prologue
                            var superAndPrologueStatementCount = prologueStatementCount;
                            // If a synthetic super() call was added, need to account for that
                            if (needsSyntheticConstructor)
                                superAndPrologueStatementCount++;
                            statements = __spreadArray(__spreadArray(__spreadArray([], statements.slice(0, superAndPrologueStatementCount), true), parameterProperties, true), statements.slice(superAndPrologueStatementCount), true);
                        }
                        indexOfFirstStatementAfterSuperAndPrologue += parameterPropertyDeclarationCount;
                    }
                }
            }
            var receiver = factory.createThis();
            // private methods can be called in property initializers, they should execute first.
            addMethodStatements(statements, privateMethodsAndAccessors, receiver);
            addPropertyOrClassStaticBlockStatements(statements, properties, receiver);
            // Add existing statements after the initial prologues and super call
            if (constructor) {
                ts.addRange(statements, ts.visitNodes(constructor.body.statements, visitBodyStatement, ts.isStatement, indexOfFirstStatementAfterSuperAndPrologue));
            }
            statements = factory.mergeLexicalEnvironment(statements, endLexicalEnvironment());
            return ts.setTextRange(factory.createBlock(ts.setTextRange(factory.createNodeArray(statements), 
            /*location*/ constructor ? constructor.body.statements : node.members), 
            /*multiLine*/ true), 
            /*location*/ constructor ? constructor.body : undefined);
            function visitBodyStatement(statement) {
                if (useDefineForClassFields && ts.isParameterPropertyDeclaration(ts.getOriginalNode(statement), constructor)) {
                    return undefined;
                }
                return visitor(statement);
            }
        }
        /**
         * Generates assignment statements for property initializers.
         *
         * @param properties An array of property declarations to transform.
         * @param receiver The receiver on which each property should be assigned.
         */
        function addPropertyOrClassStaticBlockStatements(statements, properties, receiver) {
            for (var _i = 0, properties_7 = properties; _i < properties_7.length; _i++) {
                var property = properties_7[_i];
                if (ts.isStatic(property) && !shouldTransformPrivateElementsOrClassStaticBlocks && !useDefineForClassFields) {
                    continue;
                }
                var statement = transformPropertyOrClassStaticBlock(property, receiver);
                if (!statement) {
                    continue;
                }
                statements.push(statement);
            }
        }
        function transformPropertyOrClassStaticBlock(property, receiver) {
            var expression = ts.isClassStaticBlockDeclaration(property) ?
                transformClassStaticBlockDeclaration(property) :
                transformProperty(property, receiver);
            if (!expression) {
                return undefined;
            }
            var statement = factory.createExpressionStatement(expression);
            ts.setSourceMapRange(statement, ts.moveRangePastModifiers(property));
            ts.setCommentRange(statement, property);
            ts.setOriginalNode(statement, property);
            // `setOriginalNode` *copies* the `emitNode` from `property`, so now both
            // `statement` and `expression` have a copy of the synthesized comments.
            // Drop the comments from expression to avoid printing them twice.
            ts.setSyntheticLeadingComments(expression, undefined);
            ts.setSyntheticTrailingComments(expression, undefined);
            return statement;
        }
        /**
         * Generates assignment expressions for property initializers.
         *
         * @param propertiesOrClassStaticBlocks An array of property declarations to transform.
         * @param receiver The receiver on which each property should be assigned.
         */
        function generateInitializedPropertyExpressionsOrClassStaticBlock(propertiesOrClassStaticBlocks, receiver) {
            var expressions = [];
            for (var _i = 0, propertiesOrClassStaticBlocks_1 = propertiesOrClassStaticBlocks; _i < propertiesOrClassStaticBlocks_1.length; _i++) {
                var property = propertiesOrClassStaticBlocks_1[_i];
                var expression = ts.isClassStaticBlockDeclaration(property) ? transformClassStaticBlockDeclaration(property) : transformProperty(property, receiver);
                if (!expression) {
                    continue;
                }
                ts.startOnNewLine(expression);
                ts.setSourceMapRange(expression, ts.moveRangePastModifiers(property));
                ts.setCommentRange(expression, property);
                ts.setOriginalNode(expression, property);
                expressions.push(expression);
            }
            return expressions;
        }
        /**
         * Transforms a property initializer into an assignment statement.
         *
         * @param property The property declaration.
         * @param receiver The object receiving the property assignment.
         */
        function transformProperty(property, receiver) {
            var savedCurrentStaticPropertyDeclarationOrStaticBlock = currentStaticPropertyDeclarationOrStaticBlock;
            var transformed = transformPropertyWorker(property, receiver);
            if (transformed && ts.hasStaticModifier(property) && (currentClassLexicalEnvironment === null || currentClassLexicalEnvironment === void 0 ? void 0 : currentClassLexicalEnvironment.facts)) {
                // capture the lexical environment for the member
                ts.setOriginalNode(transformed, property);
                ts.addEmitFlags(transformed, 2 /* EmitFlags.AdviseOnEmitNode */);
                classLexicalEnvironmentMap.set(ts.getOriginalNodeId(transformed), currentClassLexicalEnvironment);
            }
            currentStaticPropertyDeclarationOrStaticBlock = savedCurrentStaticPropertyDeclarationOrStaticBlock;
            return transformed;
        }
        function transformPropertyWorker(property, receiver) {
            var _a;
            // We generate a name here in order to reuse the value cached by the relocated computed name expression (which uses the same generated name)
            var emitAssignment = !useDefineForClassFields;
            var propertyName = ts.isComputedPropertyName(property.name) && !ts.isSimpleInlineableExpression(property.name.expression)
                ? factory.updateComputedPropertyName(property.name, factory.getGeneratedNameForNode(property.name))
                : property.name;
            if (ts.hasStaticModifier(property)) {
                currentStaticPropertyDeclarationOrStaticBlock = property;
            }
            if (shouldTransformPrivateElementsOrClassStaticBlocks && ts.isPrivateIdentifier(propertyName)) {
                var privateIdentifierInfo = accessPrivateIdentifier(propertyName);
                if (privateIdentifierInfo) {
                    if (privateIdentifierInfo.kind === "f" /* PrivateIdentifierKind.Field */) {
                        if (!privateIdentifierInfo.isStatic) {
                            return createPrivateInstanceFieldInitializer(receiver, ts.visitNode(property.initializer, visitor, ts.isExpression), privateIdentifierInfo.brandCheckIdentifier);
                        }
                        else {
                            return createPrivateStaticFieldInitializer(privateIdentifierInfo.variableName, ts.visitNode(property.initializer, visitor, ts.isExpression));
                        }
                    }
                    else {
                        return undefined;
                    }
                }
                else {
                    ts.Debug.fail("Undeclared private name for property declaration.");
                }
            }
            if ((ts.isPrivateIdentifier(propertyName) || ts.hasStaticModifier(property)) && !property.initializer) {
                return undefined;
            }
            var propertyOriginalNode = ts.getOriginalNode(property);
            if (ts.hasSyntacticModifier(propertyOriginalNode, 128 /* ModifierFlags.Abstract */)) {
                return undefined;
            }
            var initializer = property.initializer || emitAssignment ? (_a = ts.visitNode(property.initializer, visitor, ts.isExpression)) !== null && _a !== void 0 ? _a : factory.createVoidZero()
                : ts.isParameterPropertyDeclaration(propertyOriginalNode, propertyOriginalNode.parent) && ts.isIdentifier(propertyName) ? propertyName
                    : factory.createVoidZero();
            if (emitAssignment || ts.isPrivateIdentifier(propertyName)) {
                var memberAccess = ts.createMemberAccessForPropertyName(factory, receiver, propertyName, /*location*/ propertyName);
                return factory.createAssignment(memberAccess, initializer);
            }
            else {
                var name = ts.isComputedPropertyName(propertyName) ? propertyName.expression
                    : ts.isIdentifier(propertyName) ? factory.createStringLiteral(ts.unescapeLeadingUnderscores(propertyName.escapedText))
                        : propertyName;
                var descriptor = factory.createPropertyDescriptor({ value: initializer, configurable: true, writable: true, enumerable: true });
                return factory.createObjectDefinePropertyCall(receiver, name, descriptor);
            }
        }
        function enableSubstitutionForClassAliases() {
            if ((enabledSubstitutions & 1 /* ClassPropertySubstitutionFlags.ClassAliases */) === 0) {
                enabledSubstitutions |= 1 /* ClassPropertySubstitutionFlags.ClassAliases */;
                // We need to enable substitutions for identifiers. This allows us to
                // substitute class names inside of a class declaration.
                context.enableSubstitution(79 /* SyntaxKind.Identifier */);
                // Keep track of class aliases.
                classAliases = [];
            }
        }
        function enableSubstitutionForClassStaticThisOrSuperReference() {
            if ((enabledSubstitutions & 2 /* ClassPropertySubstitutionFlags.ClassStaticThisOrSuperReference */) === 0) {
                enabledSubstitutions |= 2 /* ClassPropertySubstitutionFlags.ClassStaticThisOrSuperReference */;
                // substitute `this` in a static field initializer
                context.enableSubstitution(108 /* SyntaxKind.ThisKeyword */);
                // these push a new lexical environment that is not the class lexical environment
                context.enableEmitNotification(256 /* SyntaxKind.FunctionDeclaration */);
                context.enableEmitNotification(213 /* SyntaxKind.FunctionExpression */);
                context.enableEmitNotification(171 /* SyntaxKind.Constructor */);
                // these push a new lexical environment that is not the class lexical environment, except
                // when they have a computed property name
                context.enableEmitNotification(172 /* SyntaxKind.GetAccessor */);
                context.enableEmitNotification(173 /* SyntaxKind.SetAccessor */);
                context.enableEmitNotification(169 /* SyntaxKind.MethodDeclaration */);
                context.enableEmitNotification(167 /* SyntaxKind.PropertyDeclaration */);
                // class lexical environments are restored when entering a computed property name
                context.enableEmitNotification(162 /* SyntaxKind.ComputedPropertyName */);
            }
        }
        /**
         * Generates brand-check initializer for private methods.
         *
         * @param statements Statement list that should be used to append new statements.
         * @param methods An array of method declarations.
         * @param receiver The receiver on which each method should be assigned.
         */
        function addMethodStatements(statements, methods, receiver) {
            if (!shouldTransformPrivateElementsOrClassStaticBlocks || !ts.some(methods)) {
                return;
            }
            var weakSetName = getPrivateIdentifierEnvironment().weakSetName;
            ts.Debug.assert(weakSetName, "weakSetName should be set in private identifier environment");
            statements.push(factory.createExpressionStatement(createPrivateInstanceMethodInitializer(receiver, weakSetName)));
        }
        function visitInvalidSuperProperty(node) {
            return ts.isPropertyAccessExpression(node) ?
                factory.updatePropertyAccessExpression(node, factory.createVoidZero(), node.name) :
                factory.updateElementAccessExpression(node, factory.createVoidZero(), ts.visitNode(node.argumentExpression, visitor, ts.isExpression));
        }
        function onEmitNode(hint, node, emitCallback) {
            var original = ts.getOriginalNode(node);
            if (original.id) {
                var classLexicalEnvironment = classLexicalEnvironmentMap.get(original.id);
                if (classLexicalEnvironment) {
                    var savedClassLexicalEnvironment = currentClassLexicalEnvironment;
                    var savedCurrentComputedPropertyNameClassLexicalEnvironment = currentComputedPropertyNameClassLexicalEnvironment;
                    currentClassLexicalEnvironment = classLexicalEnvironment;
                    currentComputedPropertyNameClassLexicalEnvironment = classLexicalEnvironment;
                    previousOnEmitNode(hint, node, emitCallback);
                    currentClassLexicalEnvironment = savedClassLexicalEnvironment;
                    currentComputedPropertyNameClassLexicalEnvironment = savedCurrentComputedPropertyNameClassLexicalEnvironment;
                    return;
                }
            }
            switch (node.kind) {
                case 213 /* SyntaxKind.FunctionExpression */:
                    if (ts.isArrowFunction(original) || ts.getEmitFlags(node) & 262144 /* EmitFlags.AsyncFunctionBody */) {
                        break;
                    }
                // falls through
                case 256 /* SyntaxKind.FunctionDeclaration */:
                case 171 /* SyntaxKind.Constructor */: {
                    var savedClassLexicalEnvironment = currentClassLexicalEnvironment;
                    var savedCurrentComputedPropertyNameClassLexicalEnvironment = currentComputedPropertyNameClassLexicalEnvironment;
                    currentClassLexicalEnvironment = undefined;
                    currentComputedPropertyNameClassLexicalEnvironment = undefined;
                    previousOnEmitNode(hint, node, emitCallback);
                    currentClassLexicalEnvironment = savedClassLexicalEnvironment;
                    currentComputedPropertyNameClassLexicalEnvironment = savedCurrentComputedPropertyNameClassLexicalEnvironment;
                    return;
                }
                case 172 /* SyntaxKind.GetAccessor */:
                case 173 /* SyntaxKind.SetAccessor */:
                case 169 /* SyntaxKind.MethodDeclaration */:
                case 167 /* SyntaxKind.PropertyDeclaration */: {
                    var savedClassLexicalEnvironment = currentClassLexicalEnvironment;
                    var savedCurrentComputedPropertyNameClassLexicalEnvironment = currentComputedPropertyNameClassLexicalEnvironment;
                    currentComputedPropertyNameClassLexicalEnvironment = currentClassLexicalEnvironment;
                    currentClassLexicalEnvironment = undefined;
                    previousOnEmitNode(hint, node, emitCallback);
                    currentClassLexicalEnvironment = savedClassLexicalEnvironment;
                    currentComputedPropertyNameClassLexicalEnvironment = savedCurrentComputedPropertyNameClassLexicalEnvironment;
                    return;
                }
                case 162 /* SyntaxKind.ComputedPropertyName */: {
                    var savedClassLexicalEnvironment = currentClassLexicalEnvironment;
                    var savedCurrentComputedPropertyNameClassLexicalEnvironment = currentComputedPropertyNameClassLexicalEnvironment;
                    currentClassLexicalEnvironment = currentComputedPropertyNameClassLexicalEnvironment;
                    currentComputedPropertyNameClassLexicalEnvironment = undefined;
                    previousOnEmitNode(hint, node, emitCallback);
                    currentClassLexicalEnvironment = savedClassLexicalEnvironment;
                    currentComputedPropertyNameClassLexicalEnvironment = savedCurrentComputedPropertyNameClassLexicalEnvironment;
                    return;
                }
            }
            previousOnEmitNode(hint, node, emitCallback);
        }
        /**
         * Hooks node substitutions.
         *
         * @param hint The context for the emitter.
         * @param node The node to substitute.
         */
        function onSubstituteNode(hint, node) {
            node = previousOnSubstituteNode(hint, node);
            if (hint === 1 /* EmitHint.Expression */) {
                return substituteExpression(node);
            }
            return node;
        }
        function substituteExpression(node) {
            switch (node.kind) {
                case 79 /* SyntaxKind.Identifier */:
                    return substituteExpressionIdentifier(node);
                case 108 /* SyntaxKind.ThisKeyword */:
                    return substituteThisExpression(node);
            }
            return node;
        }
        function substituteThisExpression(node) {
            if (enabledSubstitutions & 2 /* ClassPropertySubstitutionFlags.ClassStaticThisOrSuperReference */ && currentClassLexicalEnvironment) {
                var facts = currentClassLexicalEnvironment.facts, classConstructor = currentClassLexicalEnvironment.classConstructor;
                if (facts & 1 /* ClassFacts.ClassWasDecorated */) {
                    return factory.createParenthesizedExpression(factory.createVoidZero());
                }
                if (classConstructor) {
                    return ts.setTextRange(ts.setOriginalNode(factory.cloneNode(classConstructor), node), node);
                }
            }
            return node;
        }
        function substituteExpressionIdentifier(node) {
            return trySubstituteClassAlias(node) || node;
        }
        function trySubstituteClassAlias(node) {
            if (enabledSubstitutions & 1 /* ClassPropertySubstitutionFlags.ClassAliases */) {
                if (resolver.getNodeCheckFlags(node) & 33554432 /* NodeCheckFlags.ConstructorReferenceInClass */) {
                    // Due to the emit for class decorators, any reference to the class from inside of the class body
                    // must instead be rewritten to point to a temporary variable to avoid issues with the double-bind
                    // behavior of class names in ES6.
                    // Also, when emitting statics for class expressions, we must substitute a class alias for
                    // constructor references in static property initializers.
                    var declaration = resolver.getReferencedValueDeclaration(node);
                    if (declaration) {
                        var classAlias = classAliases[declaration.id]; // TODO: GH#18217
                        if (classAlias) {
                            var clone_3 = factory.cloneNode(classAlias);
                            ts.setSourceMapRange(clone_3, node);
                            ts.setCommentRange(clone_3, node);
                            return clone_3;
                        }
                    }
                }
            }
            return undefined;
        }
        /**
         * If the name is a computed property, this function transforms it, then either returns an expression which caches the
         * value of the result or the expression itself if the value is either unused or safe to inline into multiple locations
         * @param shouldHoist Does the expression need to be reused? (ie, for an initializer or a decorator)
         */
        function getPropertyNameExpressionIfNeeded(name, shouldHoist) {
            if (ts.isComputedPropertyName(name)) {
                var expression = ts.visitNode(name.expression, visitor, ts.isExpression);
                var innerExpression = ts.skipPartiallyEmittedExpressions(expression);
                var inlinable = ts.isSimpleInlineableExpression(innerExpression);
                var alreadyTransformed = ts.isAssignmentExpression(innerExpression) && ts.isGeneratedIdentifier(innerExpression.left);
                if (!alreadyTransformed && !inlinable && shouldHoist) {
                    var generatedName = factory.getGeneratedNameForNode(name);
                    if (resolver.getNodeCheckFlags(name) & 524288 /* NodeCheckFlags.BlockScopedBindingInLoop */) {
                        addBlockScopedVariable(generatedName);
                    }
                    else {
                        hoistVariableDeclaration(generatedName);
                    }
                    return factory.createAssignment(generatedName, expression);
                }
                return (inlinable || ts.isIdentifier(innerExpression)) ? undefined : expression;
            }
        }
        function startClassLexicalEnvironment() {
            classLexicalEnvironmentStack.push(currentClassLexicalEnvironment);
            currentClassLexicalEnvironment = undefined;
        }
        function endClassLexicalEnvironment() {
            currentClassLexicalEnvironment = classLexicalEnvironmentStack.pop();
        }
        function getClassLexicalEnvironment() {
            return currentClassLexicalEnvironment || (currentClassLexicalEnvironment = {
                facts: 0 /* ClassFacts.None */,
                classConstructor: undefined,
                superClassReference: undefined,
                privateIdentifierEnvironment: undefined,
            });
        }
        function getPrivateIdentifierEnvironment() {
            var lex = getClassLexicalEnvironment();
            lex.privateIdentifierEnvironment || (lex.privateIdentifierEnvironment = {
                className: "",
                identifiers: new ts.Map()
            });
            return lex.privateIdentifierEnvironment;
        }
        function getPendingExpressions() {
            return pendingExpressions || (pendingExpressions = []);
        }
        function addPrivateIdentifierToEnvironment(node) {
            var _a;
            var text = ts.getTextOfPropertyName(node.name);
            var lex = getClassLexicalEnvironment();
            var classConstructor = lex.classConstructor;
            var privateEnv = getPrivateIdentifierEnvironment();
            var weakSetName = privateEnv.weakSetName;
            var assignmentExpressions = [];
            var privateName = node.name.escapedText;
            var previousInfo = privateEnv.identifiers.get(privateName);
            var isValid = !isReservedPrivateName(node.name) && previousInfo === undefined;
            if (ts.hasStaticModifier(node)) {
                ts.Debug.assert(classConstructor, "weakSetName should be set in private identifier environment");
                if (ts.isPropertyDeclaration(node)) {
                    var variableName = createHoistedVariableForPrivateName(text, node);
                    privateEnv.identifiers.set(privateName, {
                        kind: "f" /* PrivateIdentifierKind.Field */,
                        variableName: variableName,
                        brandCheckIdentifier: classConstructor,
                        isStatic: true,
                        isValid: isValid,
                    });
                }
                else if (ts.isMethodDeclaration(node)) {
                    var functionName = createHoistedVariableForPrivateName(text, node);
                    privateEnv.identifiers.set(privateName, {
                        kind: "m" /* PrivateIdentifierKind.Method */,
                        methodName: functionName,
                        brandCheckIdentifier: classConstructor,
                        isStatic: true,
                        isValid: isValid,
                    });
                }
                else if (ts.isGetAccessorDeclaration(node)) {
                    var getterName = createHoistedVariableForPrivateName(text + "_get", node);
                    if ((previousInfo === null || previousInfo === void 0 ? void 0 : previousInfo.kind) === "a" /* PrivateIdentifierKind.Accessor */ && previousInfo.isStatic && !previousInfo.getterName) {
                        previousInfo.getterName = getterName;
                    }
                    else {
                        privateEnv.identifiers.set(privateName, {
                            kind: "a" /* PrivateIdentifierKind.Accessor */,
                            getterName: getterName,
                            setterName: undefined,
                            brandCheckIdentifier: classConstructor,
                            isStatic: true,
                            isValid: isValid,
                        });
                    }
                }
                else if (ts.isSetAccessorDeclaration(node)) {
                    var setterName = createHoistedVariableForPrivateName(text + "_set", node);
                    if ((previousInfo === null || previousInfo === void 0 ? void 0 : previousInfo.kind) === "a" /* PrivateIdentifierKind.Accessor */ && previousInfo.isStatic && !previousInfo.setterName) {
                        previousInfo.setterName = setterName;
                    }
                    else {
                        privateEnv.identifiers.set(privateName, {
                            kind: "a" /* PrivateIdentifierKind.Accessor */,
                            getterName: undefined,
                            setterName: setterName,
                            brandCheckIdentifier: classConstructor,
                            isStatic: true,
                            isValid: isValid,
                        });
                    }
                }
                else {
                    ts.Debug.assertNever(node, "Unknown class element type.");
                }
            }
            else if (ts.isPropertyDeclaration(node)) {
                var weakMapName = createHoistedVariableForPrivateName(text, node);
                privateEnv.identifiers.set(privateName, {
                    kind: "f" /* PrivateIdentifierKind.Field */,
                    brandCheckIdentifier: weakMapName,
                    isStatic: false,
                    variableName: undefined,
                    isValid: isValid,
                });
                assignmentExpressions.push(factory.createAssignment(weakMapName, factory.createNewExpression(factory.createIdentifier("WeakMap"), 
                /*typeArguments*/ undefined, [])));
            }
            else if (ts.isMethodDeclaration(node)) {
                ts.Debug.assert(weakSetName, "weakSetName should be set in private identifier environment");
                privateEnv.identifiers.set(privateName, {
                    kind: "m" /* PrivateIdentifierKind.Method */,
                    methodName: createHoistedVariableForPrivateName(text, node),
                    brandCheckIdentifier: weakSetName,
                    isStatic: false,
                    isValid: isValid,
                });
            }
            else if (ts.isAccessor(node)) {
                ts.Debug.assert(weakSetName, "weakSetName should be set in private identifier environment");
                if (ts.isGetAccessor(node)) {
                    var getterName = createHoistedVariableForPrivateName(text + "_get", node);
                    if ((previousInfo === null || previousInfo === void 0 ? void 0 : previousInfo.kind) === "a" /* PrivateIdentifierKind.Accessor */ && !previousInfo.isStatic && !previousInfo.getterName) {
                        previousInfo.getterName = getterName;
                    }
                    else {
                        privateEnv.identifiers.set(privateName, {
                            kind: "a" /* PrivateIdentifierKind.Accessor */,
                            getterName: getterName,
                            setterName: undefined,
                            brandCheckIdentifier: weakSetName,
                            isStatic: false,
                            isValid: isValid,
                        });
                    }
                }
                else {
                    var setterName = createHoistedVariableForPrivateName(text + "_set", node);
                    if ((previousInfo === null || previousInfo === void 0 ? void 0 : previousInfo.kind) === "a" /* PrivateIdentifierKind.Accessor */ && !previousInfo.isStatic && !previousInfo.setterName) {
                        previousInfo.setterName = setterName;
                    }
                    else {
                        privateEnv.identifiers.set(privateName, {
                            kind: "a" /* PrivateIdentifierKind.Accessor */,
                            getterName: undefined,
                            setterName: setterName,
                            brandCheckIdentifier: weakSetName,
                            isStatic: false,
                            isValid: isValid,
                        });
                    }
                }
            }
            else {
                ts.Debug.assertNever(node, "Unknown class element type.");
            }
            (_a = getPendingExpressions()).push.apply(_a, assignmentExpressions);
        }
        function createHoistedVariableForClass(name, node) {
            var className = getPrivateIdentifierEnvironment().className;
            var prefix = className ? "_".concat(className) : "";
            var identifier = factory.createUniqueName("".concat(prefix, "_").concat(name), 16 /* GeneratedIdentifierFlags.Optimistic */);
            if (resolver.getNodeCheckFlags(node) & 524288 /* NodeCheckFlags.BlockScopedBindingInLoop */) {
                addBlockScopedVariable(identifier);
            }
            else {
                hoistVariableDeclaration(identifier);
            }
            return identifier;
        }
        function createHoistedVariableForPrivateName(privateName, node) {
            return createHoistedVariableForClass(privateName.substring(1), node.name);
        }
        function accessPrivateIdentifier(name) {
            var _a;
            if (currentClassLexicalEnvironment === null || currentClassLexicalEnvironment === void 0 ? void 0 : currentClassLexicalEnvironment.privateIdentifierEnvironment) {
                var info = currentClassLexicalEnvironment.privateIdentifierEnvironment.identifiers.get(name.escapedText);
                if (info) {
                    return info;
                }
            }
            for (var i = classLexicalEnvironmentStack.length - 1; i >= 0; --i) {
                var env = classLexicalEnvironmentStack[i];
                if (!env) {
                    continue;
                }
                var info = (_a = env.privateIdentifierEnvironment) === null || _a === void 0 ? void 0 : _a.identifiers.get(name.escapedText);
                if (info) {
                    return info;
                }
            }
            return undefined;
        }
        function wrapPrivateIdentifierForDestructuringTarget(node) {
            var parameter = factory.getGeneratedNameForNode(node);
            var info = accessPrivateIdentifier(node.name);
            if (!info) {
                return ts.visitEachChild(node, visitor, context);
            }
            var receiver = node.expression;
            // We cannot copy `this` or `super` into the function because they will be bound
            // differently inside the function.
            if (ts.isThisProperty(node) || ts.isSuperProperty(node) || !ts.isSimpleCopiableExpression(node.expression)) {
                receiver = factory.createTempVariable(hoistVariableDeclaration, /*reservedInNestedScopes*/ true);
                getPendingExpressions().push(factory.createBinaryExpression(receiver, 63 /* SyntaxKind.EqualsToken */, ts.visitNode(node.expression, visitor, ts.isExpression)));
            }
            return factory.createAssignmentTargetWrapper(parameter, createPrivateIdentifierAssignment(info, receiver, parameter, 63 /* SyntaxKind.EqualsToken */));
        }
        function visitArrayAssignmentTarget(node) {
            var target = ts.getTargetOfBindingOrAssignmentElement(node);
            if (target) {
                var wrapped = void 0;
                if (ts.isPrivateIdentifierPropertyAccessExpression(target)) {
                    wrapped = wrapPrivateIdentifierForDestructuringTarget(target);
                }
                else if (shouldTransformSuperInStaticInitializers &&
                    ts.isSuperProperty(target) &&
                    currentStaticPropertyDeclarationOrStaticBlock &&
                    currentClassLexicalEnvironment) {
                    var classConstructor = currentClassLexicalEnvironment.classConstructor, superClassReference = currentClassLexicalEnvironment.superClassReference, facts = currentClassLexicalEnvironment.facts;
                    if (facts & 1 /* ClassFacts.ClassWasDecorated */) {
                        wrapped = visitInvalidSuperProperty(target);
                    }
                    else if (classConstructor && superClassReference) {
                        var name = ts.isElementAccessExpression(target) ? ts.visitNode(target.argumentExpression, visitor, ts.isExpression) :
                            ts.isIdentifier(target.name) ? factory.createStringLiteralFromNode(target.name) :
                                undefined;
                        if (name) {
                            var temp = factory.createTempVariable(/*recordTempVariable*/ undefined);
                            wrapped = factory.createAssignmentTargetWrapper(temp, factory.createReflectSetCall(superClassReference, name, temp, classConstructor));
                        }
                    }
                }
                if (wrapped) {
                    if (ts.isAssignmentExpression(node)) {
                        return factory.updateBinaryExpression(node, wrapped, node.operatorToken, ts.visitNode(node.right, visitor, ts.isExpression));
                    }
                    else if (ts.isSpreadElement(node)) {
                        return factory.updateSpreadElement(node, wrapped);
                    }
                    else {
                        return wrapped;
                    }
                }
            }
            return ts.visitNode(node, visitorDestructuringTarget);
        }
        function visitObjectAssignmentTarget(node) {
            if (ts.isObjectBindingOrAssignmentElement(node) && !ts.isShorthandPropertyAssignment(node)) {
                var target = ts.getTargetOfBindingOrAssignmentElement(node);
                var wrapped = void 0;
                if (target) {
                    if (ts.isPrivateIdentifierPropertyAccessExpression(target)) {
                        wrapped = wrapPrivateIdentifierForDestructuringTarget(target);
                    }
                    else if (shouldTransformSuperInStaticInitializers &&
                        ts.isSuperProperty(target) &&
                        currentStaticPropertyDeclarationOrStaticBlock &&
                        currentClassLexicalEnvironment) {
                        var classConstructor = currentClassLexicalEnvironment.classConstructor, superClassReference = currentClassLexicalEnvironment.superClassReference, facts = currentClassLexicalEnvironment.facts;
                        if (facts & 1 /* ClassFacts.ClassWasDecorated */) {
                            wrapped = visitInvalidSuperProperty(target);
                        }
                        else if (classConstructor && superClassReference) {
                            var name = ts.isElementAccessExpression(target) ? ts.visitNode(target.argumentExpression, visitor, ts.isExpression) :
                                ts.isIdentifier(target.name) ? factory.createStringLiteralFromNode(target.name) :
                                    undefined;
                            if (name) {
                                var temp = factory.createTempVariable(/*recordTempVariable*/ undefined);
                                wrapped = factory.createAssignmentTargetWrapper(temp, factory.createReflectSetCall(superClassReference, name, temp, classConstructor));
                            }
                        }
                    }
                }
                if (ts.isPropertyAssignment(node)) {
                    var initializer = ts.getInitializerOfBindingOrAssignmentElement(node);
                    return factory.updatePropertyAssignment(node, ts.visitNode(node.name, visitor, ts.isPropertyName), wrapped ?
                        initializer ? factory.createAssignment(wrapped, ts.visitNode(initializer, visitor)) : wrapped :
                        ts.visitNode(node.initializer, visitorDestructuringTarget, ts.isExpression));
                }
                if (ts.isSpreadAssignment(node)) {
                    return factory.updateSpreadAssignment(node, wrapped || ts.visitNode(node.expression, visitorDestructuringTarget, ts.isExpression));
                }
                ts.Debug.assert(wrapped === undefined, "Should not have generated a wrapped target");
            }
            return ts.visitNode(node, visitor);
        }
        function visitAssignmentPattern(node) {
            if (ts.isArrayLiteralExpression(node)) {
                // Transforms private names in destructuring assignment array bindings.
                // Transforms SuperProperty assignments in destructuring assignment array bindings in static initializers.
                //
                // Source:
                // ([ this.#myProp ] = [ "hello" ]);
                //
                // Transformation:
                // [ { set value(x) { this.#myProp = x; } }.value ] = [ "hello" ];
                return factory.updateArrayLiteralExpression(node, ts.visitNodes(node.elements, visitArrayAssignmentTarget, ts.isExpression));
            }
            else {
                // Transforms private names in destructuring assignment object bindings.
                // Transforms SuperProperty assignments in destructuring assignment object bindings in static initializers.
                //
                // Source:
                // ({ stringProperty: this.#myProp } = { stringProperty: "hello" });
                //
                // Transformation:
                // ({ stringProperty: { set value(x) { this.#myProp = x; } }.value }) = { stringProperty: "hello" };
                return factory.updateObjectLiteralExpression(node, ts.visitNodes(node.properties, visitObjectAssignmentTarget, ts.isObjectLiteralElementLike));
            }
        }
    }
    ts.transformClassFields = transformClassFields;
    function createPrivateStaticFieldInitializer(variableName, initializer) {
        return ts.factory.createAssignment(variableName, ts.factory.createObjectLiteralExpression([
            ts.factory.createPropertyAssignment("value", initializer || ts.factory.createVoidZero())
        ]));
    }
    function createPrivateInstanceFieldInitializer(receiver, initializer, weakMapName) {
        return ts.factory.createCallExpression(ts.factory.createPropertyAccessExpression(weakMapName, "set"), 
        /*typeArguments*/ undefined, [receiver, initializer || ts.factory.createVoidZero()]);
    }
    function createPrivateInstanceMethodInitializer(receiver, weakSetName) {
        return ts.factory.createCallExpression(ts.factory.createPropertyAccessExpression(weakSetName, "add"), 
        /*typeArguments*/ undefined, [receiver]);
    }
    function isReservedPrivateName(node) {
        return node.escapedText === "#constructor";
    }
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    var ES2017SubstitutionFlags;
    (function (ES2017SubstitutionFlags) {
        /** Enables substitutions for async methods with `super` calls. */
        ES2017SubstitutionFlags[ES2017SubstitutionFlags["AsyncMethodsWithSuper"] = 1] = "AsyncMethodsWithSuper";
    })(ES2017SubstitutionFlags || (ES2017SubstitutionFlags = {}));
    var ContextFlags;
    (function (ContextFlags) {
        ContextFlags[ContextFlags["NonTopLevel"] = 1] = "NonTopLevel";
        ContextFlags[ContextFlags["HasLexicalThis"] = 2] = "HasLexicalThis";
    })(ContextFlags || (ContextFlags = {}));
    function transformES2017(context) {
        var factory = context.factory, emitHelpers = context.getEmitHelperFactory, resumeLexicalEnvironment = context.resumeLexicalEnvironment, endLexicalEnvironment = context.endLexicalEnvironment, hoistVariableDeclaration = context.hoistVariableDeclaration;
        var resolver = context.getEmitResolver();
        var compilerOptions = context.getCompilerOptions();
        var languageVersion = ts.getEmitScriptTarget(compilerOptions);
        /**
         * Keeps track of whether expression substitution has been enabled for specific edge cases.
         * They are persisted between each SourceFile transformation and should not be reset.
         */
        var enabledSubstitutions;
        /**
         * This keeps track of containers where `super` is valid, for use with
         * just-in-time substitution for `super` expressions inside of async methods.
         */
        var enclosingSuperContainerFlags = 0;
        var enclosingFunctionParameterNames;
        /**
         * Keeps track of property names accessed on super (`super.x`) within async functions.
         */
        var capturedSuperProperties;
        /** Whether the async function contains an element access on super (`super[x]`). */
        var hasSuperElementAccess;
        /** A set of node IDs for generated super accessors (variable statements). */
        var substitutedSuperAccessors = [];
        var contextFlags = 0;
        // Save the previous transformation hooks.
        var previousOnEmitNode = context.onEmitNode;
        var previousOnSubstituteNode = context.onSubstituteNode;
        // Set new transformation hooks.
        context.onEmitNode = onEmitNode;
        context.onSubstituteNode = onSubstituteNode;
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            setContextFlag(1 /* ContextFlags.NonTopLevel */, false);
            setContextFlag(2 /* ContextFlags.HasLexicalThis */, !ts.isEffectiveStrictModeSourceFile(node, compilerOptions));
            var visited = ts.visitEachChild(node, visitor, context);
            ts.addEmitHelpers(visited, context.readEmitHelpers());
            return visited;
        }
        function setContextFlag(flag, val) {
            contextFlags = val ? contextFlags | flag : contextFlags & ~flag;
        }
        function inContext(flags) {
            return (contextFlags & flags) !== 0;
        }
        function inTopLevelContext() {
            return !inContext(1 /* ContextFlags.NonTopLevel */);
        }
        function inHasLexicalThisContext() {
            return inContext(2 /* ContextFlags.HasLexicalThis */);
        }
        function doWithContext(flags, cb, value) {
            var contextFlagsToSet = flags & ~contextFlags;
            if (contextFlagsToSet) {
                setContextFlag(contextFlagsToSet, /*val*/ true);
                var result = cb(value);
                setContextFlag(contextFlagsToSet, /*val*/ false);
                return result;
            }
            return cb(value);
        }
        function visitDefault(node) {
            return ts.visitEachChild(node, visitor, context);
        }
        function visitor(node) {
            if ((node.transformFlags & 256 /* TransformFlags.ContainsES2017 */) === 0) {
                return node;
            }
            switch (node.kind) {
                case 131 /* SyntaxKind.AsyncKeyword */:
                    // ES2017 async modifier should be elided for targets < ES2017
                    return undefined;
                case 218 /* SyntaxKind.AwaitExpression */:
                    return visitAwaitExpression(node);
                case 169 /* SyntaxKind.MethodDeclaration */:
                    return doWithContext(1 /* ContextFlags.NonTopLevel */ | 2 /* ContextFlags.HasLexicalThis */, visitMethodDeclaration, node);
                case 256 /* SyntaxKind.FunctionDeclaration */:
                    return doWithContext(1 /* ContextFlags.NonTopLevel */ | 2 /* ContextFlags.HasLexicalThis */, visitFunctionDeclaration, node);
                case 213 /* SyntaxKind.FunctionExpression */:
                    return doWithContext(1 /* ContextFlags.NonTopLevel */ | 2 /* ContextFlags.HasLexicalThis */, visitFunctionExpression, node);
                case 214 /* SyntaxKind.ArrowFunction */:
                    return doWithContext(1 /* ContextFlags.NonTopLevel */, visitArrowFunction, node);
                case 206 /* SyntaxKind.PropertyAccessExpression */:
                    if (capturedSuperProperties && ts.isPropertyAccessExpression(node) && node.expression.kind === 106 /* SyntaxKind.SuperKeyword */) {
                        capturedSuperProperties.add(node.name.escapedText);
                    }
                    return ts.visitEachChild(node, visitor, context);
                case 207 /* SyntaxKind.ElementAccessExpression */:
                    if (capturedSuperProperties && node.expression.kind === 106 /* SyntaxKind.SuperKeyword */) {
                        hasSuperElementAccess = true;
                    }
                    return ts.visitEachChild(node, visitor, context);
                case 172 /* SyntaxKind.GetAccessor */:
                case 173 /* SyntaxKind.SetAccessor */:
                case 171 /* SyntaxKind.Constructor */:
                case 257 /* SyntaxKind.ClassDeclaration */:
                case 226 /* SyntaxKind.ClassExpression */:
                    return doWithContext(1 /* ContextFlags.NonTopLevel */ | 2 /* ContextFlags.HasLexicalThis */, visitDefault, node);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function asyncBodyVisitor(node) {
            if (ts.isNodeWithPossibleHoistedDeclaration(node)) {
                switch (node.kind) {
                    case 237 /* SyntaxKind.VariableStatement */:
                        return visitVariableStatementInAsyncBody(node);
                    case 242 /* SyntaxKind.ForStatement */:
                        return visitForStatementInAsyncBody(node);
                    case 243 /* SyntaxKind.ForInStatement */:
                        return visitForInStatementInAsyncBody(node);
                    case 244 /* SyntaxKind.ForOfStatement */:
                        return visitForOfStatementInAsyncBody(node);
                    case 292 /* SyntaxKind.CatchClause */:
                        return visitCatchClauseInAsyncBody(node);
                    case 235 /* SyntaxKind.Block */:
                    case 249 /* SyntaxKind.SwitchStatement */:
                    case 263 /* SyntaxKind.CaseBlock */:
                    case 289 /* SyntaxKind.CaseClause */:
                    case 290 /* SyntaxKind.DefaultClause */:
                    case 252 /* SyntaxKind.TryStatement */:
                    case 240 /* SyntaxKind.DoStatement */:
                    case 241 /* SyntaxKind.WhileStatement */:
                    case 239 /* SyntaxKind.IfStatement */:
                    case 248 /* SyntaxKind.WithStatement */:
                    case 250 /* SyntaxKind.LabeledStatement */:
                        return ts.visitEachChild(node, asyncBodyVisitor, context);
                    default:
                        return ts.Debug.assertNever(node, "Unhandled node.");
                }
            }
            return visitor(node);
        }
        function visitCatchClauseInAsyncBody(node) {
            var catchClauseNames = new ts.Set();
            recordDeclarationName(node.variableDeclaration, catchClauseNames); // TODO: GH#18217
            // names declared in a catch variable are block scoped
            var catchClauseUnshadowedNames;
            catchClauseNames.forEach(function (_, escapedName) {
                if (enclosingFunctionParameterNames.has(escapedName)) {
                    if (!catchClauseUnshadowedNames) {
                        catchClauseUnshadowedNames = new ts.Set(enclosingFunctionParameterNames);
                    }
                    catchClauseUnshadowedNames.delete(escapedName);
                }
            });
            if (catchClauseUnshadowedNames) {
                var savedEnclosingFunctionParameterNames = enclosingFunctionParameterNames;
                enclosingFunctionParameterNames = catchClauseUnshadowedNames;
                var result = ts.visitEachChild(node, asyncBodyVisitor, context);
                enclosingFunctionParameterNames = savedEnclosingFunctionParameterNames;
                return result;
            }
            else {
                return ts.visitEachChild(node, asyncBodyVisitor, context);
            }
        }
        function visitVariableStatementInAsyncBody(node) {
            if (isVariableDeclarationListWithCollidingName(node.declarationList)) {
                var expression = visitVariableDeclarationListWithCollidingNames(node.declarationList, /*hasReceiver*/ false);
                return expression ? factory.createExpressionStatement(expression) : undefined;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitForInStatementInAsyncBody(node) {
            return factory.updateForInStatement(node, isVariableDeclarationListWithCollidingName(node.initializer)
                ? visitVariableDeclarationListWithCollidingNames(node.initializer, /*hasReceiver*/ true)
                : ts.visitNode(node.initializer, visitor, ts.isForInitializer), ts.visitNode(node.expression, visitor, ts.isExpression), ts.visitIterationBody(node.statement, asyncBodyVisitor, context));
        }
        function visitForOfStatementInAsyncBody(node) {
            return factory.updateForOfStatement(node, ts.visitNode(node.awaitModifier, visitor, ts.isToken), isVariableDeclarationListWithCollidingName(node.initializer)
                ? visitVariableDeclarationListWithCollidingNames(node.initializer, /*hasReceiver*/ true)
                : ts.visitNode(node.initializer, visitor, ts.isForInitializer), ts.visitNode(node.expression, visitor, ts.isExpression), ts.visitIterationBody(node.statement, asyncBodyVisitor, context));
        }
        function visitForStatementInAsyncBody(node) {
            var initializer = node.initializer; // TODO: GH#18217
            return factory.updateForStatement(node, isVariableDeclarationListWithCollidingName(initializer)
                ? visitVariableDeclarationListWithCollidingNames(initializer, /*hasReceiver*/ false)
                : ts.visitNode(node.initializer, visitor, ts.isForInitializer), ts.visitNode(node.condition, visitor, ts.isExpression), ts.visitNode(node.incrementor, visitor, ts.isExpression), ts.visitIterationBody(node.statement, asyncBodyVisitor, context));
        }
        /**
         * Visits an AwaitExpression node.
         *
         * This function will be called any time a ES2017 await expression is encountered.
         *
         * @param node The node to visit.
         */
        function visitAwaitExpression(node) {
            // do not downlevel a top-level await as it is module syntax...
            if (inTopLevelContext()) {
                return ts.visitEachChild(node, visitor, context);
            }
            return ts.setOriginalNode(ts.setTextRange(factory.createYieldExpression(
            /*asteriskToken*/ undefined, ts.visitNode(node.expression, visitor, ts.isExpression)), node), node);
        }
        /**
         * Visits a MethodDeclaration node.
         *
         * This function will be called when one of the following conditions are met:
         * - The node is marked as async
         *
         * @param node The node to visit.
         */
        function visitMethodDeclaration(node) {
            return factory.updateMethodDeclaration(node, 
            /*decorators*/ undefined, ts.visitNodes(node.modifiers, visitor, ts.isModifier), node.asteriskToken, node.name, 
            /*questionToken*/ undefined, 
            /*typeParameters*/ undefined, ts.visitParameterList(node.parameters, visitor, context), 
            /*type*/ undefined, ts.getFunctionFlags(node) & 2 /* FunctionFlags.Async */
                ? transformAsyncFunctionBody(node)
                : ts.visitFunctionBody(node.body, visitor, context));
        }
        /**
         * Visits a FunctionDeclaration node.
         *
         * This function will be called when one of the following conditions are met:
         * - The node is marked async
         *
         * @param node The node to visit.
         */
        function visitFunctionDeclaration(node) {
            return factory.updateFunctionDeclaration(node, 
            /*decorators*/ undefined, ts.visitNodes(node.modifiers, visitor, ts.isModifier), node.asteriskToken, node.name, 
            /*typeParameters*/ undefined, ts.visitParameterList(node.parameters, visitor, context), 
            /*type*/ undefined, ts.getFunctionFlags(node) & 2 /* FunctionFlags.Async */
                ? transformAsyncFunctionBody(node)
                : ts.visitFunctionBody(node.body, visitor, context));
        }
        /**
         * Visits a FunctionExpression node.
         *
         * This function will be called when one of the following conditions are met:
         * - The node is marked async
         *
         * @param node The node to visit.
         */
        function visitFunctionExpression(node) {
            return factory.updateFunctionExpression(node, ts.visitNodes(node.modifiers, visitor, ts.isModifier), node.asteriskToken, node.name, 
            /*typeParameters*/ undefined, ts.visitParameterList(node.parameters, visitor, context), 
            /*type*/ undefined, ts.getFunctionFlags(node) & 2 /* FunctionFlags.Async */
                ? transformAsyncFunctionBody(node)
                : ts.visitFunctionBody(node.body, visitor, context));
        }
        /**
         * Visits an ArrowFunction.
         *
         * This function will be called when one of the following conditions are met:
         * - The node is marked async
         *
         * @param node The node to visit.
         */
        function visitArrowFunction(node) {
            return factory.updateArrowFunction(node, ts.visitNodes(node.modifiers, visitor, ts.isModifier), 
            /*typeParameters*/ undefined, ts.visitParameterList(node.parameters, visitor, context), 
            /*type*/ undefined, node.equalsGreaterThanToken, ts.getFunctionFlags(node) & 2 /* FunctionFlags.Async */
                ? transformAsyncFunctionBody(node)
                : ts.visitFunctionBody(node.body, visitor, context));
        }
        function recordDeclarationName(_a, names) {
            var name = _a.name;
            if (ts.isIdentifier(name)) {
                names.add(name.escapedText);
            }
            else {
                for (var _i = 0, _b = name.elements; _i < _b.length; _i++) {
                    var element = _b[_i];
                    if (!ts.isOmittedExpression(element)) {
                        recordDeclarationName(element, names);
                    }
                }
            }
        }
        function isVariableDeclarationListWithCollidingName(node) {
            return !!node
                && ts.isVariableDeclarationList(node)
                && !(node.flags & 3 /* NodeFlags.BlockScoped */)
                && node.declarations.some(collidesWithParameterName);
        }
        function visitVariableDeclarationListWithCollidingNames(node, hasReceiver) {
            hoistVariableDeclarationList(node);
            var variables = ts.getInitializedVariables(node);
            if (variables.length === 0) {
                if (hasReceiver) {
                    return ts.visitNode(factory.converters.convertToAssignmentElementTarget(node.declarations[0].name), visitor, ts.isExpression);
                }
                return undefined;
            }
            return factory.inlineExpressions(ts.map(variables, transformInitializedVariable));
        }
        function hoistVariableDeclarationList(node) {
            ts.forEach(node.declarations, hoistVariable);
        }
        function hoistVariable(_a) {
            var name = _a.name;
            if (ts.isIdentifier(name)) {
                hoistVariableDeclaration(name);
            }
            else {
                for (var _i = 0, _b = name.elements; _i < _b.length; _i++) {
                    var element = _b[_i];
                    if (!ts.isOmittedExpression(element)) {
                        hoistVariable(element);
                    }
                }
            }
        }
        function transformInitializedVariable(node) {
            var converted = ts.setSourceMapRange(factory.createAssignment(factory.converters.convertToAssignmentElementTarget(node.name), node.initializer), node);
            return ts.visitNode(converted, visitor, ts.isExpression);
        }
        function collidesWithParameterName(_a) {
            var name = _a.name;
            if (ts.isIdentifier(name)) {
                return enclosingFunctionParameterNames.has(name.escapedText);
            }
            else {
                for (var _i = 0, _b = name.elements; _i < _b.length; _i++) {
                    var element = _b[_i];
                    if (!ts.isOmittedExpression(element) && collidesWithParameterName(element)) {
                        return true;
                    }
                }
            }
            return false;
        }
        function transformAsyncFunctionBody(node) {
            resumeLexicalEnvironment();
            var original = ts.getOriginalNode(node, ts.isFunctionLike);
            var nodeType = original.type;
            var promiseConstructor = languageVersion < 2 /* ScriptTarget.ES2015 */ ? getPromiseConstructor(nodeType) : undefined;
            var isArrowFunction = node.kind === 214 /* SyntaxKind.ArrowFunction */;
            var hasLexicalArguments = (resolver.getNodeCheckFlags(node) & 8192 /* NodeCheckFlags.CaptureArguments */) !== 0;
            // An async function is emit as an outer function that calls an inner
            // generator function. To preserve lexical bindings, we pass the current
            // `this` and `arguments` objects to `__awaiter`. The generator function
            // passed to `__awaiter` is executed inside of the callback to the
            // promise constructor.
            var savedEnclosingFunctionParameterNames = enclosingFunctionParameterNames;
            enclosingFunctionParameterNames = new ts.Set();
            for (var _i = 0, _a = node.parameters; _i < _a.length; _i++) {
                var parameter = _a[_i];
                recordDeclarationName(parameter, enclosingFunctionParameterNames);
            }
            var savedCapturedSuperProperties = capturedSuperProperties;
            var savedHasSuperElementAccess = hasSuperElementAccess;
            if (!isArrowFunction) {
                capturedSuperProperties = new ts.Set();
                hasSuperElementAccess = false;
            }
            var result;
            if (!isArrowFunction) {
                var statements = [];
                var statementOffset = factory.copyPrologue(node.body.statements, statements, /*ensureUseStrict*/ false, visitor);
                statements.push(factory.createReturnStatement(emitHelpers().createAwaiterHelper(inHasLexicalThisContext(), hasLexicalArguments, promiseConstructor, transformAsyncFunctionBodyWorker(node.body, statementOffset))));
                ts.insertStatementsAfterStandardPrologue(statements, endLexicalEnvironment());
                // Minor optimization, emit `_super` helper to capture `super` access in an arrow.
                // This step isn't needed if we eventually transform this to ES5.
                var emitSuperHelpers = languageVersion >= 2 /* ScriptTarget.ES2015 */ && resolver.getNodeCheckFlags(node) & (4096 /* NodeCheckFlags.AsyncMethodWithSuperBinding */ | 2048 /* NodeCheckFlags.AsyncMethodWithSuper */);
                if (emitSuperHelpers) {
                    enableSubstitutionForAsyncMethodsWithSuper();
                    if (capturedSuperProperties.size) {
                        var variableStatement = createSuperAccessVariableStatement(factory, resolver, node, capturedSuperProperties);
                        substitutedSuperAccessors[ts.getNodeId(variableStatement)] = true;
                        ts.insertStatementsAfterStandardPrologue(statements, [variableStatement]);
                    }
                }
                var block = factory.createBlock(statements, /*multiLine*/ true);
                ts.setTextRange(block, node.body);
                if (emitSuperHelpers && hasSuperElementAccess) {
                    // Emit helpers for super element access expressions (`super[x]`).
                    if (resolver.getNodeCheckFlags(node) & 4096 /* NodeCheckFlags.AsyncMethodWithSuperBinding */) {
                        ts.addEmitHelper(block, ts.advancedAsyncSuperHelper);
                    }
                    else if (resolver.getNodeCheckFlags(node) & 2048 /* NodeCheckFlags.AsyncMethodWithSuper */) {
                        ts.addEmitHelper(block, ts.asyncSuperHelper);
                    }
                }
                result = block;
            }
            else {
                var expression = emitHelpers().createAwaiterHelper(inHasLexicalThisContext(), hasLexicalArguments, promiseConstructor, transformAsyncFunctionBodyWorker(node.body));
                var declarations = endLexicalEnvironment();
                if (ts.some(declarations)) {
                    var block = factory.converters.convertToFunctionBlock(expression);
                    result = factory.updateBlock(block, ts.setTextRange(factory.createNodeArray(ts.concatenate(declarations, block.statements)), block.statements));
                }
                else {
                    result = expression;
                }
            }
            enclosingFunctionParameterNames = savedEnclosingFunctionParameterNames;
            if (!isArrowFunction) {
                capturedSuperProperties = savedCapturedSuperProperties;
                hasSuperElementAccess = savedHasSuperElementAccess;
            }
            return result;
        }
        function transformAsyncFunctionBodyWorker(body, start) {
            if (ts.isBlock(body)) {
                return factory.updateBlock(body, ts.visitNodes(body.statements, asyncBodyVisitor, ts.isStatement, start));
            }
            else {
                return factory.converters.convertToFunctionBlock(ts.visitNode(body, asyncBodyVisitor, ts.isConciseBody));
            }
        }
        function getPromiseConstructor(type) {
            var typeName = type && ts.getEntityNameFromTypeNode(type);
            if (typeName && ts.isEntityName(typeName)) {
                var serializationKind = resolver.getTypeReferenceSerializationKind(typeName);
                if (serializationKind === ts.TypeReferenceSerializationKind.TypeWithConstructSignatureAndValue
                    || serializationKind === ts.TypeReferenceSerializationKind.Unknown) {
                    return typeName;
                }
            }
            return undefined;
        }
        function enableSubstitutionForAsyncMethodsWithSuper() {
            if ((enabledSubstitutions & 1 /* ES2017SubstitutionFlags.AsyncMethodsWithSuper */) === 0) {
                enabledSubstitutions |= 1 /* ES2017SubstitutionFlags.AsyncMethodsWithSuper */;
                // We need to enable substitutions for call, property access, and element access
                // if we need to rewrite super calls.
                context.enableSubstitution(208 /* SyntaxKind.CallExpression */);
                context.enableSubstitution(206 /* SyntaxKind.PropertyAccessExpression */);
                context.enableSubstitution(207 /* SyntaxKind.ElementAccessExpression */);
                // We need to be notified when entering and exiting declarations that bind super.
                context.enableEmitNotification(257 /* SyntaxKind.ClassDeclaration */);
                context.enableEmitNotification(169 /* SyntaxKind.MethodDeclaration */);
                context.enableEmitNotification(172 /* SyntaxKind.GetAccessor */);
                context.enableEmitNotification(173 /* SyntaxKind.SetAccessor */);
                context.enableEmitNotification(171 /* SyntaxKind.Constructor */);
                // We need to be notified when entering the generated accessor arrow functions.
                context.enableEmitNotification(237 /* SyntaxKind.VariableStatement */);
            }
        }
        /**
         * Hook for node emit.
         *
         * @param hint A hint as to the intended usage of the node.
         * @param node The node to emit.
         * @param emit A callback used to emit the node in the printer.
         */
        function onEmitNode(hint, node, emitCallback) {
            // If we need to support substitutions for `super` in an async method,
            // we should track it here.
            if (enabledSubstitutions & 1 /* ES2017SubstitutionFlags.AsyncMethodsWithSuper */ && isSuperContainer(node)) {
                var superContainerFlags = resolver.getNodeCheckFlags(node) & (2048 /* NodeCheckFlags.AsyncMethodWithSuper */ | 4096 /* NodeCheckFlags.AsyncMethodWithSuperBinding */);
                if (superContainerFlags !== enclosingSuperContainerFlags) {
                    var savedEnclosingSuperContainerFlags = enclosingSuperContainerFlags;
                    enclosingSuperContainerFlags = superContainerFlags;
                    previousOnEmitNode(hint, node, emitCallback);
                    enclosingSuperContainerFlags = savedEnclosingSuperContainerFlags;
                    return;
                }
            }
            // Disable substitution in the generated super accessor itself.
            else if (enabledSubstitutions && substitutedSuperAccessors[ts.getNodeId(node)]) {
                var savedEnclosingSuperContainerFlags = enclosingSuperContainerFlags;
                enclosingSuperContainerFlags = 0;
                previousOnEmitNode(hint, node, emitCallback);
                enclosingSuperContainerFlags = savedEnclosingSuperContainerFlags;
                return;
            }
            previousOnEmitNode(hint, node, emitCallback);
        }
        /**
         * Hooks node substitutions.
         *
         * @param hint A hint as to the intended usage of the node.
         * @param node The node to substitute.
         */
        function onSubstituteNode(hint, node) {
            node = previousOnSubstituteNode(hint, node);
            if (hint === 1 /* EmitHint.Expression */ && enclosingSuperContainerFlags) {
                return substituteExpression(node);
            }
            return node;
        }
        function substituteExpression(node) {
            switch (node.kind) {
                case 206 /* SyntaxKind.PropertyAccessExpression */:
                    return substitutePropertyAccessExpression(node);
                case 207 /* SyntaxKind.ElementAccessExpression */:
                    return substituteElementAccessExpression(node);
                case 208 /* SyntaxKind.CallExpression */:
                    return substituteCallExpression(node);
            }
            return node;
        }
        function substitutePropertyAccessExpression(node) {
            if (node.expression.kind === 106 /* SyntaxKind.SuperKeyword */) {
                return ts.setTextRange(factory.createPropertyAccessExpression(factory.createUniqueName("_super", 16 /* GeneratedIdentifierFlags.Optimistic */ | 32 /* GeneratedIdentifierFlags.FileLevel */), node.name), node);
            }
            return node;
        }
        function substituteElementAccessExpression(node) {
            if (node.expression.kind === 106 /* SyntaxKind.SuperKeyword */) {
                return createSuperElementAccessInAsyncMethod(node.argumentExpression, node);
            }
            return node;
        }
        function substituteCallExpression(node) {
            var expression = node.expression;
            if (ts.isSuperProperty(expression)) {
                var argumentExpression = ts.isPropertyAccessExpression(expression)
                    ? substitutePropertyAccessExpression(expression)
                    : substituteElementAccessExpression(expression);
                return factory.createCallExpression(factory.createPropertyAccessExpression(argumentExpression, "call"), 
                /*typeArguments*/ undefined, __spreadArray([
                    factory.createThis()
                ], node.arguments, true));
            }
            return node;
        }
        function isSuperContainer(node) {
            var kind = node.kind;
            return kind === 257 /* SyntaxKind.ClassDeclaration */
                || kind === 171 /* SyntaxKind.Constructor */
                || kind === 169 /* SyntaxKind.MethodDeclaration */
                || kind === 172 /* SyntaxKind.GetAccessor */
                || kind === 173 /* SyntaxKind.SetAccessor */;
        }
        function createSuperElementAccessInAsyncMethod(argumentExpression, location) {
            if (enclosingSuperContainerFlags & 4096 /* NodeCheckFlags.AsyncMethodWithSuperBinding */) {
                return ts.setTextRange(factory.createPropertyAccessExpression(factory.createCallExpression(factory.createUniqueName("_superIndex", 16 /* GeneratedIdentifierFlags.Optimistic */ | 32 /* GeneratedIdentifierFlags.FileLevel */), 
                /*typeArguments*/ undefined, [argumentExpression]), "value"), location);
            }
            else {
                return ts.setTextRange(factory.createCallExpression(factory.createUniqueName("_superIndex", 16 /* GeneratedIdentifierFlags.Optimistic */ | 32 /* GeneratedIdentifierFlags.FileLevel */), 
                /*typeArguments*/ undefined, [argumentExpression]), location);
            }
        }
    }
    ts.transformES2017 = transformES2017;
    /** Creates a variable named `_super` with accessor properties for the given property names. */
    function createSuperAccessVariableStatement(factory, resolver, node, names) {
        // Create a variable declaration with a getter/setter (if binding) definition for each name:
        //   const _super = Object.create(null, { x: { get: () => super.x, set: (v) => super.x = v }, ... });
        var hasBinding = (resolver.getNodeCheckFlags(node) & 4096 /* NodeCheckFlags.AsyncMethodWithSuperBinding */) !== 0;
        var accessors = [];
        names.forEach(function (_, key) {
            var name = ts.unescapeLeadingUnderscores(key);
            var getterAndSetter = [];
            getterAndSetter.push(factory.createPropertyAssignment("get", factory.createArrowFunction(
            /* modifiers */ undefined, 
            /* typeParameters */ undefined, 
            /* parameters */ [], 
            /* type */ undefined, 
            /* equalsGreaterThanToken */ undefined, ts.setEmitFlags(factory.createPropertyAccessExpression(ts.setEmitFlags(factory.createSuper(), 4 /* EmitFlags.NoSubstitution */), name), 4 /* EmitFlags.NoSubstitution */))));
            if (hasBinding) {
                getterAndSetter.push(factory.createPropertyAssignment("set", factory.createArrowFunction(
                /* modifiers */ undefined, 
                /* typeParameters */ undefined, 
                /* parameters */ [
                    factory.createParameterDeclaration(
                    /* decorators */ undefined, 
                    /* modifiers */ undefined, 
                    /* dotDotDotToken */ undefined, "v", 
                    /* questionToken */ undefined, 
                    /* type */ undefined, 
                    /* initializer */ undefined)
                ], 
                /* type */ undefined, 
                /* equalsGreaterThanToken */ undefined, factory.createAssignment(ts.setEmitFlags(factory.createPropertyAccessExpression(ts.setEmitFlags(factory.createSuper(), 4 /* EmitFlags.NoSubstitution */), name), 4 /* EmitFlags.NoSubstitution */), factory.createIdentifier("v")))));
            }
            accessors.push(factory.createPropertyAssignment(name, factory.createObjectLiteralExpression(getterAndSetter)));
        });
        return factory.createVariableStatement(
        /* modifiers */ undefined, factory.createVariableDeclarationList([
            factory.createVariableDeclaration(factory.createUniqueName("_super", 16 /* GeneratedIdentifierFlags.Optimistic */ | 32 /* GeneratedIdentifierFlags.FileLevel */), 
            /*exclamationToken*/ undefined, 
            /* type */ undefined, factory.createCallExpression(factory.createPropertyAccessExpression(factory.createIdentifier("Object"), "create"), 
            /* typeArguments */ undefined, [
                factory.createNull(),
                factory.createObjectLiteralExpression(accessors, /* multiline */ true)
            ]))
        ], 2 /* NodeFlags.Const */));
    }
    ts.createSuperAccessVariableStatement = createSuperAccessVariableStatement;
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    var ESNextSubstitutionFlags;
    (function (ESNextSubstitutionFlags) {
        /** Enables substitutions for async methods with `super` calls. */
        ESNextSubstitutionFlags[ESNextSubstitutionFlags["AsyncMethodsWithSuper"] = 1] = "AsyncMethodsWithSuper";
    })(ESNextSubstitutionFlags || (ESNextSubstitutionFlags = {}));
    // Facts we track as we traverse the tree
    var HierarchyFacts;
    (function (HierarchyFacts) {
        HierarchyFacts[HierarchyFacts["None"] = 0] = "None";
        //
        // Ancestor facts
        //
        HierarchyFacts[HierarchyFacts["HasLexicalThis"] = 1] = "HasLexicalThis";
        HierarchyFacts[HierarchyFacts["IterationContainer"] = 2] = "IterationContainer";
        // NOTE: do not add more ancestor flags without also updating AncestorFactsMask below.
        //
        // Ancestor masks
        //
        HierarchyFacts[HierarchyFacts["AncestorFactsMask"] = 3] = "AncestorFactsMask";
        HierarchyFacts[HierarchyFacts["SourceFileIncludes"] = 1] = "SourceFileIncludes";
        HierarchyFacts[HierarchyFacts["SourceFileExcludes"] = 2] = "SourceFileExcludes";
        HierarchyFacts[HierarchyFacts["StrictModeSourceFileIncludes"] = 0] = "StrictModeSourceFileIncludes";
        HierarchyFacts[HierarchyFacts["ClassOrFunctionIncludes"] = 1] = "ClassOrFunctionIncludes";
        HierarchyFacts[HierarchyFacts["ClassOrFunctionExcludes"] = 2] = "ClassOrFunctionExcludes";
        HierarchyFacts[HierarchyFacts["ArrowFunctionIncludes"] = 0] = "ArrowFunctionIncludes";
        HierarchyFacts[HierarchyFacts["ArrowFunctionExcludes"] = 2] = "ArrowFunctionExcludes";
        HierarchyFacts[HierarchyFacts["IterationStatementIncludes"] = 2] = "IterationStatementIncludes";
        HierarchyFacts[HierarchyFacts["IterationStatementExcludes"] = 0] = "IterationStatementExcludes";
    })(HierarchyFacts || (HierarchyFacts = {}));
    function transformES2018(context) {
        var factory = context.factory, emitHelpers = context.getEmitHelperFactory, resumeLexicalEnvironment = context.resumeLexicalEnvironment, endLexicalEnvironment = context.endLexicalEnvironment, hoistVariableDeclaration = context.hoistVariableDeclaration;
        var resolver = context.getEmitResolver();
        var compilerOptions = context.getCompilerOptions();
        var languageVersion = ts.getEmitScriptTarget(compilerOptions);
        var previousOnEmitNode = context.onEmitNode;
        context.onEmitNode = onEmitNode;
        var previousOnSubstituteNode = context.onSubstituteNode;
        context.onSubstituteNode = onSubstituteNode;
        var exportedVariableStatement = false;
        var enabledSubstitutions;
        var enclosingFunctionFlags;
        var parametersWithPrecedingObjectRestOrSpread;
        var enclosingSuperContainerFlags = 0;
        var hierarchyFacts = 0;
        var currentSourceFile;
        var taggedTemplateStringDeclarations;
        /** Keeps track of property names accessed on super (`super.x`) within async functions. */
        var capturedSuperProperties;
        /** Whether the async function contains an element access on super (`super[x]`). */
        var hasSuperElementAccess;
        /** A set of node IDs for generated super accessors. */
        var substitutedSuperAccessors = [];
        return ts.chainBundle(context, transformSourceFile);
        function affectsSubtree(excludeFacts, includeFacts) {
            return hierarchyFacts !== (hierarchyFacts & ~excludeFacts | includeFacts);
        }
        /**
         * Sets the `HierarchyFacts` for this node prior to visiting this node's subtree, returning the facts set prior to modification.
         * @param excludeFacts The existing `HierarchyFacts` to reset before visiting the subtree.
         * @param includeFacts The new `HierarchyFacts` to set before visiting the subtree.
         */
        function enterSubtree(excludeFacts, includeFacts) {
            var ancestorFacts = hierarchyFacts;
            hierarchyFacts = (hierarchyFacts & ~excludeFacts | includeFacts) & 3 /* HierarchyFacts.AncestorFactsMask */;
            return ancestorFacts;
        }
        /**
         * Restores the `HierarchyFacts` for this node's ancestor after visiting this node's
         * subtree.
         * @param ancestorFacts The `HierarchyFacts` of the ancestor to restore after visiting the subtree.
         */
        function exitSubtree(ancestorFacts) {
            hierarchyFacts = ancestorFacts;
        }
        function recordTaggedTemplateString(temp) {
            taggedTemplateStringDeclarations = ts.append(taggedTemplateStringDeclarations, factory.createVariableDeclaration(temp));
        }
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            currentSourceFile = node;
            var visited = visitSourceFile(node);
            ts.addEmitHelpers(visited, context.readEmitHelpers());
            currentSourceFile = undefined;
            taggedTemplateStringDeclarations = undefined;
            return visited;
        }
        function visitor(node) {
            return visitorWorker(node, /*expressionResultIsUnused*/ false);
        }
        function visitorWithUnusedExpressionResult(node) {
            return visitorWorker(node, /*expressionResultIsUnused*/ true);
        }
        function visitorNoAsyncModifier(node) {
            if (node.kind === 131 /* SyntaxKind.AsyncKeyword */) {
                return undefined;
            }
            return node;
        }
        function doWithHierarchyFacts(cb, value, excludeFacts, includeFacts) {
            if (affectsSubtree(excludeFacts, includeFacts)) {
                var ancestorFacts = enterSubtree(excludeFacts, includeFacts);
                var result = cb(value);
                exitSubtree(ancestorFacts);
                return result;
            }
            return cb(value);
        }
        function visitDefault(node) {
            return ts.visitEachChild(node, visitor, context);
        }
        /**
         * @param expressionResultIsUnused Indicates the result of an expression is unused by the parent node (i.e., the left side of a comma or the
         * expression of an `ExpressionStatement`).
         */
        function visitorWorker(node, expressionResultIsUnused) {
            if ((node.transformFlags & 128 /* TransformFlags.ContainsES2018 */) === 0) {
                return node;
            }
            switch (node.kind) {
                case 218 /* SyntaxKind.AwaitExpression */:
                    return visitAwaitExpression(node);
                case 224 /* SyntaxKind.YieldExpression */:
                    return visitYieldExpression(node);
                case 247 /* SyntaxKind.ReturnStatement */:
                    return visitReturnStatement(node);
                case 250 /* SyntaxKind.LabeledStatement */:
                    return visitLabeledStatement(node);
                case 205 /* SyntaxKind.ObjectLiteralExpression */:
                    return visitObjectLiteralExpression(node);
                case 221 /* SyntaxKind.BinaryExpression */:
                    return visitBinaryExpression(node, expressionResultIsUnused);
                case 351 /* SyntaxKind.CommaListExpression */:
                    return visitCommaListExpression(node, expressionResultIsUnused);
                case 292 /* SyntaxKind.CatchClause */:
                    return visitCatchClause(node);
                case 237 /* SyntaxKind.VariableStatement */:
                    return visitVariableStatement(node);
                case 254 /* SyntaxKind.VariableDeclaration */:
                    return visitVariableDeclaration(node);
                case 240 /* SyntaxKind.DoStatement */:
                case 241 /* SyntaxKind.WhileStatement */:
                case 243 /* SyntaxKind.ForInStatement */:
                    return doWithHierarchyFacts(visitDefault, node, 0 /* HierarchyFacts.IterationStatementExcludes */, 2 /* HierarchyFacts.IterationStatementIncludes */);
                case 244 /* SyntaxKind.ForOfStatement */:
                    return visitForOfStatement(node, /*outermostLabeledStatement*/ undefined);
                case 242 /* SyntaxKind.ForStatement */:
                    return doWithHierarchyFacts(visitForStatement, node, 0 /* HierarchyFacts.IterationStatementExcludes */, 2 /* HierarchyFacts.IterationStatementIncludes */);
                case 217 /* SyntaxKind.VoidExpression */:
                    return visitVoidExpression(node);
                case 171 /* SyntaxKind.Constructor */:
                    return doWithHierarchyFacts(visitConstructorDeclaration, node, 2 /* HierarchyFacts.ClassOrFunctionExcludes */, 1 /* HierarchyFacts.ClassOrFunctionIncludes */);
                case 169 /* SyntaxKind.MethodDeclaration */:
                    return doWithHierarchyFacts(visitMethodDeclaration, node, 2 /* HierarchyFacts.ClassOrFunctionExcludes */, 1 /* HierarchyFacts.ClassOrFunctionIncludes */);
                case 172 /* SyntaxKind.GetAccessor */:
                    return doWithHierarchyFacts(visitGetAccessorDeclaration, node, 2 /* HierarchyFacts.ClassOrFunctionExcludes */, 1 /* HierarchyFacts.ClassOrFunctionIncludes */);
                case 173 /* SyntaxKind.SetAccessor */:
                    return doWithHierarchyFacts(visitSetAccessorDeclaration, node, 2 /* HierarchyFacts.ClassOrFunctionExcludes */, 1 /* HierarchyFacts.ClassOrFunctionIncludes */);
                case 256 /* SyntaxKind.FunctionDeclaration */:
                    return doWithHierarchyFacts(visitFunctionDeclaration, node, 2 /* HierarchyFacts.ClassOrFunctionExcludes */, 1 /* HierarchyFacts.ClassOrFunctionIncludes */);
                case 213 /* SyntaxKind.FunctionExpression */:
                    return doWithHierarchyFacts(visitFunctionExpression, node, 2 /* HierarchyFacts.ClassOrFunctionExcludes */, 1 /* HierarchyFacts.ClassOrFunctionIncludes */);
                case 214 /* SyntaxKind.ArrowFunction */:
                    return doWithHierarchyFacts(visitArrowFunction, node, 2 /* HierarchyFacts.ArrowFunctionExcludes */, 0 /* HierarchyFacts.ArrowFunctionIncludes */);
                case 164 /* SyntaxKind.Parameter */:
                    return visitParameter(node);
                case 238 /* SyntaxKind.ExpressionStatement */:
                    return visitExpressionStatement(node);
                case 212 /* SyntaxKind.ParenthesizedExpression */:
                    return visitParenthesizedExpression(node, expressionResultIsUnused);
                case 210 /* SyntaxKind.TaggedTemplateExpression */:
                    return visitTaggedTemplateExpression(node);
                case 206 /* SyntaxKind.PropertyAccessExpression */:
                    if (capturedSuperProperties && ts.isPropertyAccessExpression(node) && node.expression.kind === 106 /* SyntaxKind.SuperKeyword */) {
                        capturedSuperProperties.add(node.name.escapedText);
                    }
                    return ts.visitEachChild(node, visitor, context);
                case 207 /* SyntaxKind.ElementAccessExpression */:
                    if (capturedSuperProperties && node.expression.kind === 106 /* SyntaxKind.SuperKeyword */) {
                        hasSuperElementAccess = true;
                    }
                    return ts.visitEachChild(node, visitor, context);
                case 257 /* SyntaxKind.ClassDeclaration */:
                case 226 /* SyntaxKind.ClassExpression */:
                    return doWithHierarchyFacts(visitDefault, node, 2 /* HierarchyFacts.ClassOrFunctionExcludes */, 1 /* HierarchyFacts.ClassOrFunctionIncludes */);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function visitAwaitExpression(node) {
            if (enclosingFunctionFlags & 2 /* FunctionFlags.Async */ && enclosingFunctionFlags & 1 /* FunctionFlags.Generator */) {
                return ts.setOriginalNode(ts.setTextRange(factory.createYieldExpression(/*asteriskToken*/ undefined, emitHelpers().createAwaitHelper(ts.visitNode(node.expression, visitor, ts.isExpression))), 
                /*location*/ node), node);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitYieldExpression(node) {
            if (enclosingFunctionFlags & 2 /* FunctionFlags.Async */ && enclosingFunctionFlags & 1 /* FunctionFlags.Generator */) {
                if (node.asteriskToken) {
                    var expression = ts.visitNode(ts.Debug.checkDefined(node.expression), visitor, ts.isExpression);
                    return ts.setOriginalNode(ts.setTextRange(factory.createYieldExpression(
                    /*asteriskToken*/ undefined, emitHelpers().createAwaitHelper(factory.updateYieldExpression(node, node.asteriskToken, ts.setTextRange(emitHelpers().createAsyncDelegatorHelper(ts.setTextRange(emitHelpers().createAsyncValuesHelper(expression), expression)), expression)))), node), node);
                }
                return ts.setOriginalNode(ts.setTextRange(factory.createYieldExpression(
                /*asteriskToken*/ undefined, createDownlevelAwait(node.expression
                    ? ts.visitNode(node.expression, visitor, ts.isExpression)
                    : factory.createVoidZero())), node), node);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitReturnStatement(node) {
            if (enclosingFunctionFlags & 2 /* FunctionFlags.Async */ && enclosingFunctionFlags & 1 /* FunctionFlags.Generator */) {
                return factory.updateReturnStatement(node, createDownlevelAwait(node.expression ? ts.visitNode(node.expression, visitor, ts.isExpression) : factory.createVoidZero()));
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitLabeledStatement(node) {
            if (enclosingFunctionFlags & 2 /* FunctionFlags.Async */) {
                var statement = ts.unwrapInnermostStatementOfLabel(node);
                if (statement.kind === 244 /* SyntaxKind.ForOfStatement */ && statement.awaitModifier) {
                    return visitForOfStatement(statement, node);
                }
                return factory.restoreEnclosingLabel(ts.visitNode(statement, visitor, ts.isStatement, factory.liftToBlock), node);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function chunkObjectLiteralElements(elements) {
            var chunkObject;
            var objects = [];
            for (var _i = 0, elements_5 = elements; _i < elements_5.length; _i++) {
                var e = elements_5[_i];
                if (e.kind === 298 /* SyntaxKind.SpreadAssignment */) {
                    if (chunkObject) {
                        objects.push(factory.createObjectLiteralExpression(chunkObject));
                        chunkObject = undefined;
                    }
                    var target = e.expression;
                    objects.push(ts.visitNode(target, visitor, ts.isExpression));
                }
                else {
                    chunkObject = ts.append(chunkObject, e.kind === 296 /* SyntaxKind.PropertyAssignment */
                        ? factory.createPropertyAssignment(e.name, ts.visitNode(e.initializer, visitor, ts.isExpression))
                        : ts.visitNode(e, visitor, ts.isObjectLiteralElementLike));
                }
            }
            if (chunkObject) {
                objects.push(factory.createObjectLiteralExpression(chunkObject));
            }
            return objects;
        }
        function visitObjectLiteralExpression(node) {
            if (node.transformFlags & 32768 /* TransformFlags.ContainsObjectRestOrSpread */) {
                // spread elements emit like so:
                // non-spread elements are chunked together into object literals, and then all are passed to __assign:
                //     { a, ...o, b } => __assign(__assign({a}, o), {b});
                // If the first element is a spread element, then the first argument to __assign is {}:
                //     { ...o, a, b, ...o2 } => __assign(__assign(__assign({}, o), {a, b}), o2)
                //
                // We cannot call __assign with more than two elements, since any element could cause side effects. For
                // example:
                //      var k = { a: 1, b: 2 };
                //      var o = { a: 3, ...k, b: k.a++ };
                //      // expected: { a: 1, b: 1 }
                // If we translate the above to `__assign({ a: 3 }, k, { b: k.a++ })`, the `k.a++` will evaluate before
                // `k` is spread and we end up with `{ a: 2, b: 1 }`.
                //
                // This also occurs for spread elements, not just property assignments:
                //      var k = { a: 1, get b() { l = { z: 9 }; return 2; } };
                //      var l = { c: 3 };
                //      var o = { ...k, ...l };
                //      // expected: { a: 1, b: 2, z: 9 }
                // If we translate the above to `__assign({}, k, l)`, the `l` will evaluate before `k` is spread and we
                // end up with `{ a: 1, b: 2, c: 3 }`
                var objects = chunkObjectLiteralElements(node.properties);
                if (objects.length && objects[0].kind !== 205 /* SyntaxKind.ObjectLiteralExpression */) {
                    objects.unshift(factory.createObjectLiteralExpression());
                }
                var expression = objects[0];
                if (objects.length > 1) {
                    for (var i = 1; i < objects.length; i++) {
                        expression = emitHelpers().createAssignHelper([expression, objects[i]]);
                    }
                    return expression;
                }
                else {
                    return emitHelpers().createAssignHelper(objects);
                }
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitExpressionStatement(node) {
            return ts.visitEachChild(node, visitorWithUnusedExpressionResult, context);
        }
        /**
         * @param expressionResultIsUnused Indicates the result of an expression is unused by the parent node (i.e., the left side of a comma or the
         * expression of an `ExpressionStatement`).
         */
        function visitParenthesizedExpression(node, expressionResultIsUnused) {
            return ts.visitEachChild(node, expressionResultIsUnused ? visitorWithUnusedExpressionResult : visitor, context);
        }
        function visitSourceFile(node) {
            var ancestorFacts = enterSubtree(2 /* HierarchyFacts.SourceFileExcludes */, ts.isEffectiveStrictModeSourceFile(node, compilerOptions) ?
                0 /* HierarchyFacts.StrictModeSourceFileIncludes */ :
                1 /* HierarchyFacts.SourceFileIncludes */);
            exportedVariableStatement = false;
            var visited = ts.visitEachChild(node, visitor, context);
            var statement = ts.concatenate(visited.statements, taggedTemplateStringDeclarations && [
                factory.createVariableStatement(/*modifiers*/ undefined, factory.createVariableDeclarationList(taggedTemplateStringDeclarations))
            ]);
            var result = factory.updateSourceFile(visited, ts.setTextRange(factory.createNodeArray(statement), node.statements));
            exitSubtree(ancestorFacts);
            return result;
        }
        function visitTaggedTemplateExpression(node) {
            return ts.processTaggedTemplateExpression(context, node, visitor, currentSourceFile, recordTaggedTemplateString, ts.ProcessLevel.LiftRestriction);
        }
        /**
         * Visits a BinaryExpression that contains a destructuring assignment.
         *
         * @param node A BinaryExpression node.
         * @param expressionResultIsUnused Indicates the result of an expression is unused by the parent node (i.e., the left side of a comma or the
         * expression of an `ExpressionStatement`).
         */
        function visitBinaryExpression(node, expressionResultIsUnused) {
            if (ts.isDestructuringAssignment(node) && node.left.transformFlags & 32768 /* TransformFlags.ContainsObjectRestOrSpread */) {
                return ts.flattenDestructuringAssignment(node, visitor, context, 1 /* FlattenLevel.ObjectRest */, !expressionResultIsUnused);
            }
            if (node.operatorToken.kind === 27 /* SyntaxKind.CommaToken */) {
                return factory.updateBinaryExpression(node, ts.visitNode(node.left, visitorWithUnusedExpressionResult, ts.isExpression), node.operatorToken, ts.visitNode(node.right, expressionResultIsUnused ? visitorWithUnusedExpressionResult : visitor, ts.isExpression));
            }
            return ts.visitEachChild(node, visitor, context);
        }
        /**
         * @param expressionResultIsUnused Indicates the result of an expression is unused by the parent node (i.e., the left side of a comma or the
         * expression of an `ExpressionStatement`).
         */
        function visitCommaListExpression(node, expressionResultIsUnused) {
            if (expressionResultIsUnused) {
                return ts.visitEachChild(node, visitorWithUnusedExpressionResult, context);
            }
            var result;
            for (var i = 0; i < node.elements.length; i++) {
                var element = node.elements[i];
                var visited = ts.visitNode(element, i < node.elements.length - 1 ? visitorWithUnusedExpressionResult : visitor, ts.isExpression);
                if (result || visited !== element) {
                    result || (result = node.elements.slice(0, i));
                    result.push(visited);
                }
            }
            var elements = result ? ts.setTextRange(factory.createNodeArray(result), node.elements) : node.elements;
            return factory.updateCommaListExpression(node, elements);
        }
        function visitCatchClause(node) {
            if (node.variableDeclaration &&
                ts.isBindingPattern(node.variableDeclaration.name) &&
                node.variableDeclaration.name.transformFlags & 32768 /* TransformFlags.ContainsObjectRestOrSpread */) {
                var name = factory.getGeneratedNameForNode(node.variableDeclaration.name);
                var updatedDecl = factory.updateVariableDeclaration(node.variableDeclaration, node.variableDeclaration.name, /*exclamationToken*/ undefined, /*type*/ undefined, name);
                var visitedBindings = ts.flattenDestructuringBinding(updatedDecl, visitor, context, 1 /* FlattenLevel.ObjectRest */);
                var block = ts.visitNode(node.block, visitor, ts.isBlock);
                if (ts.some(visitedBindings)) {
                    block = factory.updateBlock(block, __spreadArray([
                        factory.createVariableStatement(/*modifiers*/ undefined, visitedBindings)
                    ], block.statements, true));
                }
                return factory.updateCatchClause(node, factory.updateVariableDeclaration(node.variableDeclaration, name, /*exclamationToken*/ undefined, /*type*/ undefined, /*initializer*/ undefined), block);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitVariableStatement(node) {
            if (ts.hasSyntacticModifier(node, 1 /* ModifierFlags.Export */)) {
                var savedExportedVariableStatement = exportedVariableStatement;
                exportedVariableStatement = true;
                var visited = ts.visitEachChild(node, visitor, context);
                exportedVariableStatement = savedExportedVariableStatement;
                return visited;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        /**
         * Visits a VariableDeclaration node with a binding pattern.
         *
         * @param node A VariableDeclaration node.
         */
        function visitVariableDeclaration(node) {
            if (exportedVariableStatement) {
                var savedExportedVariableStatement = exportedVariableStatement;
                exportedVariableStatement = false;
                var visited = visitVariableDeclarationWorker(node, /*exportedVariableStatement*/ true);
                exportedVariableStatement = savedExportedVariableStatement;
                return visited;
            }
            return visitVariableDeclarationWorker(node, /*exportedVariableStatement*/ false);
        }
        function visitVariableDeclarationWorker(node, exportedVariableStatement) {
            // If we are here it is because the name contains a binding pattern with a rest somewhere in it.
            if (ts.isBindingPattern(node.name) && node.name.transformFlags & 32768 /* TransformFlags.ContainsObjectRestOrSpread */) {
                return ts.flattenDestructuringBinding(node, visitor, context, 1 /* FlattenLevel.ObjectRest */, 
                /*rval*/ undefined, exportedVariableStatement);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitForStatement(node) {
            return factory.updateForStatement(node, ts.visitNode(node.initializer, visitorWithUnusedExpressionResult, ts.isForInitializer), ts.visitNode(node.condition, visitor, ts.isExpression), ts.visitNode(node.incrementor, visitorWithUnusedExpressionResult, ts.isExpression), ts.visitIterationBody(node.statement, visitor, context));
        }
        function visitVoidExpression(node) {
            return ts.visitEachChild(node, visitorWithUnusedExpressionResult, context);
        }
        /**
         * Visits a ForOfStatement and converts it into a ES2015-compatible ForOfStatement.
         *
         * @param node A ForOfStatement.
         */
        function visitForOfStatement(node, outermostLabeledStatement) {
            var ancestorFacts = enterSubtree(0 /* HierarchyFacts.IterationStatementExcludes */, 2 /* HierarchyFacts.IterationStatementIncludes */);
            if (node.initializer.transformFlags & 32768 /* TransformFlags.ContainsObjectRestOrSpread */) {
                node = transformForOfStatementWithObjectRest(node);
            }
            var result = node.awaitModifier ?
                transformForAwaitOfStatement(node, outermostLabeledStatement, ancestorFacts) :
                factory.restoreEnclosingLabel(ts.visitEachChild(node, visitor, context), outermostLabeledStatement);
            exitSubtree(ancestorFacts);
            return result;
        }
        function transformForOfStatementWithObjectRest(node) {
            var initializerWithoutParens = ts.skipParentheses(node.initializer);
            if (ts.isVariableDeclarationList(initializerWithoutParens) || ts.isAssignmentPattern(initializerWithoutParens)) {
                var bodyLocation = void 0;
                var statementsLocation = void 0;
                var temp = factory.createTempVariable(/*recordTempVariable*/ undefined);
                var statements = [ts.createForOfBindingStatement(factory, initializerWithoutParens, temp)];
                if (ts.isBlock(node.statement)) {
                    ts.addRange(statements, node.statement.statements);
                    bodyLocation = node.statement;
                    statementsLocation = node.statement.statements;
                }
                else if (node.statement) {
                    ts.append(statements, node.statement);
                    bodyLocation = node.statement;
                    statementsLocation = node.statement;
                }
                return factory.updateForOfStatement(node, node.awaitModifier, ts.setTextRange(factory.createVariableDeclarationList([
                    ts.setTextRange(factory.createVariableDeclaration(temp), node.initializer)
                ], 1 /* NodeFlags.Let */), node.initializer), node.expression, ts.setTextRange(factory.createBlock(ts.setTextRange(factory.createNodeArray(statements), statementsLocation), 
                /*multiLine*/ true), bodyLocation));
            }
            return node;
        }
        function convertForOfStatementHead(node, boundValue) {
            var binding = ts.createForOfBindingStatement(factory, node.initializer, boundValue);
            var bodyLocation;
            var statementsLocation;
            var statements = [ts.visitNode(binding, visitor, ts.isStatement)];
            var statement = ts.visitIterationBody(node.statement, visitor, context);
            if (ts.isBlock(statement)) {
                ts.addRange(statements, statement.statements);
                bodyLocation = statement;
                statementsLocation = statement.statements;
            }
            else {
                statements.push(statement);
            }
            return ts.setEmitFlags(ts.setTextRange(factory.createBlock(ts.setTextRange(factory.createNodeArray(statements), statementsLocation), 
            /*multiLine*/ true), bodyLocation), 48 /* EmitFlags.NoSourceMap */ | 384 /* EmitFlags.NoTokenSourceMaps */);
        }
        function createDownlevelAwait(expression) {
            return enclosingFunctionFlags & 1 /* FunctionFlags.Generator */
                ? factory.createYieldExpression(/*asteriskToken*/ undefined, emitHelpers().createAwaitHelper(expression))
                : factory.createAwaitExpression(expression);
        }
        function transformForAwaitOfStatement(node, outermostLabeledStatement, ancestorFacts) {
            var expression = ts.visitNode(node.expression, visitor, ts.isExpression);
            var iterator = ts.isIdentifier(expression) ? factory.getGeneratedNameForNode(expression) : factory.createTempVariable(/*recordTempVariable*/ undefined);
            var result = ts.isIdentifier(expression) ? factory.getGeneratedNameForNode(iterator) : factory.createTempVariable(/*recordTempVariable*/ undefined);
            var errorRecord = factory.createUniqueName("e");
            var catchVariable = factory.getGeneratedNameForNode(errorRecord);
            var returnMethod = factory.createTempVariable(/*recordTempVariable*/ undefined);
            var callValues = ts.setTextRange(emitHelpers().createAsyncValuesHelper(expression), node.expression);
            var callNext = factory.createCallExpression(factory.createPropertyAccessExpression(iterator, "next"), /*typeArguments*/ undefined, []);
            var getDone = factory.createPropertyAccessExpression(result, "done");
            var getValue = factory.createPropertyAccessExpression(result, "value");
            var callReturn = factory.createFunctionCallCall(returnMethod, iterator, []);
            hoistVariableDeclaration(errorRecord);
            hoistVariableDeclaration(returnMethod);
            // if we are enclosed in an outer loop ensure we reset 'errorRecord' per each iteration
            var initializer = ancestorFacts & 2 /* HierarchyFacts.IterationContainer */ ?
                factory.inlineExpressions([factory.createAssignment(errorRecord, factory.createVoidZero()), callValues]) :
                callValues;
            var forStatement = ts.setEmitFlags(ts.setTextRange(factory.createForStatement(
            /*initializer*/ ts.setEmitFlags(ts.setTextRange(factory.createVariableDeclarationList([
                ts.setTextRange(factory.createVariableDeclaration(iterator, /*exclamationToken*/ undefined, /*type*/ undefined, initializer), node.expression),
                factory.createVariableDeclaration(result)
            ]), node.expression), 2097152 /* EmitFlags.NoHoisting */), 
            /*condition*/ factory.createComma(factory.createAssignment(result, createDownlevelAwait(callNext)), factory.createLogicalNot(getDone)), 
            /*incrementor*/ undefined, 
            /*statement*/ convertForOfStatementHead(node, getValue)), 
            /*location*/ node), 256 /* EmitFlags.NoTokenTrailingSourceMaps */);
            ts.setOriginalNode(forStatement, node);
            return factory.createTryStatement(factory.createBlock([
                factory.restoreEnclosingLabel(forStatement, outermostLabeledStatement)
            ]), factory.createCatchClause(factory.createVariableDeclaration(catchVariable), ts.setEmitFlags(factory.createBlock([
                factory.createExpressionStatement(factory.createAssignment(errorRecord, factory.createObjectLiteralExpression([
                    factory.createPropertyAssignment("error", catchVariable)
                ])))
            ]), 1 /* EmitFlags.SingleLine */)), factory.createBlock([
                factory.createTryStatement(
                /*tryBlock*/ factory.createBlock([
                    ts.setEmitFlags(factory.createIfStatement(factory.createLogicalAnd(factory.createLogicalAnd(result, factory.createLogicalNot(getDone)), factory.createAssignment(returnMethod, factory.createPropertyAccessExpression(iterator, "return"))), factory.createExpressionStatement(createDownlevelAwait(callReturn))), 1 /* EmitFlags.SingleLine */)
                ]), 
                /*catchClause*/ undefined, 
                /*finallyBlock*/ ts.setEmitFlags(factory.createBlock([
                    ts.setEmitFlags(factory.createIfStatement(errorRecord, factory.createThrowStatement(factory.createPropertyAccessExpression(errorRecord, "error"))), 1 /* EmitFlags.SingleLine */)
                ]), 1 /* EmitFlags.SingleLine */))
            ]));
        }
        function parameterVisitor(node) {
            ts.Debug.assertNode(node, ts.isParameter);
            return visitParameter(node);
        }
        function visitParameter(node) {
            if (parametersWithPrecedingObjectRestOrSpread === null || parametersWithPrecedingObjectRestOrSpread === void 0 ? void 0 : parametersWithPrecedingObjectRestOrSpread.has(node)) {
                return factory.updateParameterDeclaration(node, 
                /*decorators*/ undefined, 
                /*modifiers*/ undefined, node.dotDotDotToken, ts.isBindingPattern(node.name) ? factory.getGeneratedNameForNode(node) : node.name, 
                /*questionToken*/ undefined, 
                /*type*/ undefined, 
                /*initializer*/ undefined);
            }
            if (node.transformFlags & 32768 /* TransformFlags.ContainsObjectRestOrSpread */) {
                // Binding patterns are converted into a generated name and are
                // evaluated inside the function body.
                return factory.updateParameterDeclaration(node, 
                /*decorators*/ undefined, 
                /*modifiers*/ undefined, node.dotDotDotToken, factory.getGeneratedNameForNode(node), 
                /*questionToken*/ undefined, 
                /*type*/ undefined, ts.visitNode(node.initializer, visitor, ts.isExpression));
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function collectParametersWithPrecedingObjectRestOrSpread(node) {
            var parameters;
            for (var _i = 0, _a = node.parameters; _i < _a.length; _i++) {
                var parameter = _a[_i];
                if (parameters) {
                    parameters.add(parameter);
                }
                else if (parameter.transformFlags & 32768 /* TransformFlags.ContainsObjectRestOrSpread */) {
                    parameters = new ts.Set();
                }
            }
            return parameters;
        }
        function visitConstructorDeclaration(node) {
            var savedEnclosingFunctionFlags = enclosingFunctionFlags;
            var savedParametersWithPrecedingObjectRestOrSpread = parametersWithPrecedingObjectRestOrSpread;
            enclosingFunctionFlags = ts.getFunctionFlags(node);
            parametersWithPrecedingObjectRestOrSpread = collectParametersWithPrecedingObjectRestOrSpread(node);
            var updated = factory.updateConstructorDeclaration(node, 
            /*decorators*/ undefined, node.modifiers, ts.visitParameterList(node.parameters, parameterVisitor, context), transformFunctionBody(node));
            enclosingFunctionFlags = savedEnclosingFunctionFlags;
            parametersWithPrecedingObjectRestOrSpread = savedParametersWithPrecedingObjectRestOrSpread;
            return updated;
        }
        function visitGetAccessorDeclaration(node) {
            var savedEnclosingFunctionFlags = enclosingFunctionFlags;
            var savedParametersWithPrecedingObjectRestOrSpread = parametersWithPrecedingObjectRestOrSpread;
            enclosingFunctionFlags = ts.getFunctionFlags(node);
            parametersWithPrecedingObjectRestOrSpread = collectParametersWithPrecedingObjectRestOrSpread(node);
            var updated = factory.updateGetAccessorDeclaration(node, 
            /*decorators*/ undefined, node.modifiers, ts.visitNode(node.name, visitor, ts.isPropertyName), ts.visitParameterList(node.parameters, parameterVisitor, context), 
            /*type*/ undefined, transformFunctionBody(node));
            enclosingFunctionFlags = savedEnclosingFunctionFlags;
            parametersWithPrecedingObjectRestOrSpread = savedParametersWithPrecedingObjectRestOrSpread;
            return updated;
        }
        function visitSetAccessorDeclaration(node) {
            var savedEnclosingFunctionFlags = enclosingFunctionFlags;
            var savedParametersWithPrecedingObjectRestOrSpread = parametersWithPrecedingObjectRestOrSpread;
            enclosingFunctionFlags = ts.getFunctionFlags(node);
            parametersWithPrecedingObjectRestOrSpread = collectParametersWithPrecedingObjectRestOrSpread(node);
            var updated = factory.updateSetAccessorDeclaration(node, 
            /*decorators*/ undefined, node.modifiers, ts.visitNode(node.name, visitor, ts.isPropertyName), ts.visitParameterList(node.parameters, parameterVisitor, context), transformFunctionBody(node));
            enclosingFunctionFlags = savedEnclosingFunctionFlags;
            parametersWithPrecedingObjectRestOrSpread = savedParametersWithPrecedingObjectRestOrSpread;
            return updated;
        }
        function visitMethodDeclaration(node) {
            var savedEnclosingFunctionFlags = enclosingFunctionFlags;
            var savedParametersWithPrecedingObjectRestOrSpread = parametersWithPrecedingObjectRestOrSpread;
            enclosingFunctionFlags = ts.getFunctionFlags(node);
            parametersWithPrecedingObjectRestOrSpread = collectParametersWithPrecedingObjectRestOrSpread(node);
            var updated = factory.updateMethodDeclaration(node, 
            /*decorators*/ undefined, enclosingFunctionFlags & 1 /* FunctionFlags.Generator */
                ? ts.visitNodes(node.modifiers, visitorNoAsyncModifier, ts.isModifier)
                : node.modifiers, enclosingFunctionFlags & 2 /* FunctionFlags.Async */
                ? undefined
                : node.asteriskToken, ts.visitNode(node.name, visitor, ts.isPropertyName), ts.visitNode(/*questionToken*/ undefined, visitor, ts.isToken), 
            /*typeParameters*/ undefined, ts.visitParameterList(node.parameters, parameterVisitor, context), 
            /*type*/ undefined, enclosingFunctionFlags & 2 /* FunctionFlags.Async */ && enclosingFunctionFlags & 1 /* FunctionFlags.Generator */
                ? transformAsyncGeneratorFunctionBody(node)
                : transformFunctionBody(node));
            enclosingFunctionFlags = savedEnclosingFunctionFlags;
            parametersWithPrecedingObjectRestOrSpread = savedParametersWithPrecedingObjectRestOrSpread;
            return updated;
        }
        function visitFunctionDeclaration(node) {
            var savedEnclosingFunctionFlags = enclosingFunctionFlags;
            var savedParametersWithPrecedingObjectRestOrSpread = parametersWithPrecedingObjectRestOrSpread;
            enclosingFunctionFlags = ts.getFunctionFlags(node);
            parametersWithPrecedingObjectRestOrSpread = collectParametersWithPrecedingObjectRestOrSpread(node);
            var updated = factory.updateFunctionDeclaration(node, 
            /*decorators*/ undefined, enclosingFunctionFlags & 1 /* FunctionFlags.Generator */
                ? ts.visitNodes(node.modifiers, visitorNoAsyncModifier, ts.isModifier)
                : node.modifiers, enclosingFunctionFlags & 2 /* FunctionFlags.Async */
                ? undefined
                : node.asteriskToken, node.name, 
            /*typeParameters*/ undefined, ts.visitParameterList(node.parameters, parameterVisitor, context), 
            /*type*/ undefined, enclosingFunctionFlags & 2 /* FunctionFlags.Async */ && enclosingFunctionFlags & 1 /* FunctionFlags.Generator */
                ? transformAsyncGeneratorFunctionBody(node)
                : transformFunctionBody(node));
            enclosingFunctionFlags = savedEnclosingFunctionFlags;
            parametersWithPrecedingObjectRestOrSpread = savedParametersWithPrecedingObjectRestOrSpread;
            return updated;
        }
        function visitArrowFunction(node) {
            var savedEnclosingFunctionFlags = enclosingFunctionFlags;
            var savedParametersWithPrecedingObjectRestOrSpread = parametersWithPrecedingObjectRestOrSpread;
            enclosingFunctionFlags = ts.getFunctionFlags(node);
            parametersWithPrecedingObjectRestOrSpread = collectParametersWithPrecedingObjectRestOrSpread(node);
            var updated = factory.updateArrowFunction(node, node.modifiers, 
            /*typeParameters*/ undefined, ts.visitParameterList(node.parameters, parameterVisitor, context), 
            /*type*/ undefined, node.equalsGreaterThanToken, transformFunctionBody(node));
            enclosingFunctionFlags = savedEnclosingFunctionFlags;
            parametersWithPrecedingObjectRestOrSpread = savedParametersWithPrecedingObjectRestOrSpread;
            return updated;
        }
        function visitFunctionExpression(node) {
            var savedEnclosingFunctionFlags = enclosingFunctionFlags;
            var savedParametersWithPrecedingObjectRestOrSpread = parametersWithPrecedingObjectRestOrSpread;
            enclosingFunctionFlags = ts.getFunctionFlags(node);
            parametersWithPrecedingObjectRestOrSpread = collectParametersWithPrecedingObjectRestOrSpread(node);
            var updated = factory.updateFunctionExpression(node, enclosingFunctionFlags & 1 /* FunctionFlags.Generator */
                ? ts.visitNodes(node.modifiers, visitorNoAsyncModifier, ts.isModifier)
                : node.modifiers, enclosingFunctionFlags & 2 /* FunctionFlags.Async */
                ? undefined
                : node.asteriskToken, node.name, 
            /*typeParameters*/ undefined, ts.visitParameterList(node.parameters, parameterVisitor, context), 
            /*type*/ undefined, enclosingFunctionFlags & 2 /* FunctionFlags.Async */ && enclosingFunctionFlags & 1 /* FunctionFlags.Generator */
                ? transformAsyncGeneratorFunctionBody(node)
                : transformFunctionBody(node));
            enclosingFunctionFlags = savedEnclosingFunctionFlags;
            parametersWithPrecedingObjectRestOrSpread = savedParametersWithPrecedingObjectRestOrSpread;
            return updated;
        }
        function transformAsyncGeneratorFunctionBody(node) {
            resumeLexicalEnvironment();
            var statements = [];
            var statementOffset = factory.copyPrologue(node.body.statements, statements, /*ensureUseStrict*/ false, visitor);
            appendObjectRestAssignmentsIfNeeded(statements, node);
            var savedCapturedSuperProperties = capturedSuperProperties;
            var savedHasSuperElementAccess = hasSuperElementAccess;
            capturedSuperProperties = new ts.Set();
            hasSuperElementAccess = false;
            var returnStatement = factory.createReturnStatement(emitHelpers().createAsyncGeneratorHelper(factory.createFunctionExpression(
            /*modifiers*/ undefined, factory.createToken(41 /* SyntaxKind.AsteriskToken */), node.name && factory.getGeneratedNameForNode(node.name), 
            /*typeParameters*/ undefined, 
            /*parameters*/ [], 
            /*type*/ undefined, factory.updateBlock(node.body, ts.visitLexicalEnvironment(node.body.statements, visitor, context, statementOffset))), !!(hierarchyFacts & 1 /* HierarchyFacts.HasLexicalThis */)));
            // Minor optimization, emit `_super` helper to capture `super` access in an arrow.
            // This step isn't needed if we eventually transform this to ES5.
            var emitSuperHelpers = languageVersion >= 2 /* ScriptTarget.ES2015 */ && resolver.getNodeCheckFlags(node) & (4096 /* NodeCheckFlags.AsyncMethodWithSuperBinding */ | 2048 /* NodeCheckFlags.AsyncMethodWithSuper */);
            if (emitSuperHelpers) {
                enableSubstitutionForAsyncMethodsWithSuper();
                var variableStatement = ts.createSuperAccessVariableStatement(factory, resolver, node, capturedSuperProperties);
                substitutedSuperAccessors[ts.getNodeId(variableStatement)] = true;
                ts.insertStatementsAfterStandardPrologue(statements, [variableStatement]);
            }
            statements.push(returnStatement);
            ts.insertStatementsAfterStandardPrologue(statements, endLexicalEnvironment());
            var block = factory.updateBlock(node.body, statements);
            if (emitSuperHelpers && hasSuperElementAccess) {
                if (resolver.getNodeCheckFlags(node) & 4096 /* NodeCheckFlags.AsyncMethodWithSuperBinding */) {
                    ts.addEmitHelper(block, ts.advancedAsyncSuperHelper);
                }
                else if (resolver.getNodeCheckFlags(node) & 2048 /* NodeCheckFlags.AsyncMethodWithSuper */) {
                    ts.addEmitHelper(block, ts.asyncSuperHelper);
                }
            }
            capturedSuperProperties = savedCapturedSuperProperties;
            hasSuperElementAccess = savedHasSuperElementAccess;
            return block;
        }
        function transformFunctionBody(node) {
            var _a;
            resumeLexicalEnvironment();
            var statementOffset = 0;
            var statements = [];
            var body = (_a = ts.visitNode(node.body, visitor, ts.isConciseBody)) !== null && _a !== void 0 ? _a : factory.createBlock([]);
            if (ts.isBlock(body)) {
                statementOffset = factory.copyPrologue(body.statements, statements, /*ensureUseStrict*/ false, visitor);
            }
            ts.addRange(statements, appendObjectRestAssignmentsIfNeeded(/*statements*/ undefined, node));
            var leadingStatements = endLexicalEnvironment();
            if (statementOffset > 0 || ts.some(statements) || ts.some(leadingStatements)) {
                var block = factory.converters.convertToFunctionBlock(body, /*multiLine*/ true);
                ts.insertStatementsAfterStandardPrologue(statements, leadingStatements);
                ts.addRange(statements, block.statements.slice(statementOffset));
                return factory.updateBlock(block, ts.setTextRange(factory.createNodeArray(statements), block.statements));
            }
            return body;
        }
        function appendObjectRestAssignmentsIfNeeded(statements, node) {
            var containsPrecedingObjectRestOrSpread = false;
            for (var _i = 0, _a = node.parameters; _i < _a.length; _i++) {
                var parameter = _a[_i];
                if (containsPrecedingObjectRestOrSpread) {
                    if (ts.isBindingPattern(parameter.name)) {
                        // In cases where a binding pattern is simply '[]' or '{}',
                        // we usually don't want to emit a var declaration; however, in the presence
                        // of an initializer, we must emit that expression to preserve side effects.
                        //
                        // NOTE: see `insertDefaultValueAssignmentForBindingPattern` in es2015.ts
                        if (parameter.name.elements.length > 0) {
                            var declarations = ts.flattenDestructuringBinding(parameter, visitor, context, 0 /* FlattenLevel.All */, factory.getGeneratedNameForNode(parameter));
                            if (ts.some(declarations)) {
                                var declarationList = factory.createVariableDeclarationList(declarations);
                                var statement = factory.createVariableStatement(/*modifiers*/ undefined, declarationList);
                                ts.setEmitFlags(statement, 1048576 /* EmitFlags.CustomPrologue */);
                                statements = ts.append(statements, statement);
                            }
                        }
                        else if (parameter.initializer) {
                            var name = factory.getGeneratedNameForNode(parameter);
                            var initializer = ts.visitNode(parameter.initializer, visitor, ts.isExpression);
                            var assignment = factory.createAssignment(name, initializer);
                            var statement = factory.createExpressionStatement(assignment);
                            ts.setEmitFlags(statement, 1048576 /* EmitFlags.CustomPrologue */);
                            statements = ts.append(statements, statement);
                        }
                    }
                    else if (parameter.initializer) {
                        // Converts a parameter initializer into a function body statement, i.e.:
                        //
                        //  function f(x = 1) { }
                        //
                        // becomes
                        //
                        //  function f(x) {
                        //    if (typeof x === "undefined") { x = 1; }
                        //  }
                        var name = factory.cloneNode(parameter.name);
                        ts.setTextRange(name, parameter.name);
                        ts.setEmitFlags(name, 48 /* EmitFlags.NoSourceMap */);
                        var initializer = ts.visitNode(parameter.initializer, visitor, ts.isExpression);
                        ts.addEmitFlags(initializer, 48 /* EmitFlags.NoSourceMap */ | 1536 /* EmitFlags.NoComments */);
                        var assignment = factory.createAssignment(name, initializer);
                        ts.setTextRange(assignment, parameter);
                        ts.setEmitFlags(assignment, 1536 /* EmitFlags.NoComments */);
                        var block = factory.createBlock([factory.createExpressionStatement(assignment)]);
                        ts.setTextRange(block, parameter);
                        ts.setEmitFlags(block, 1 /* EmitFlags.SingleLine */ | 32 /* EmitFlags.NoTrailingSourceMap */ | 384 /* EmitFlags.NoTokenSourceMaps */ | 1536 /* EmitFlags.NoComments */);
                        var typeCheck = factory.createTypeCheck(factory.cloneNode(parameter.name), "undefined");
                        var statement = factory.createIfStatement(typeCheck, block);
                        ts.startOnNewLine(statement);
                        ts.setTextRange(statement, parameter);
                        ts.setEmitFlags(statement, 384 /* EmitFlags.NoTokenSourceMaps */ | 32 /* EmitFlags.NoTrailingSourceMap */ | 1048576 /* EmitFlags.CustomPrologue */ | 1536 /* EmitFlags.NoComments */);
                        statements = ts.append(statements, statement);
                    }
                }
                else if (parameter.transformFlags & 32768 /* TransformFlags.ContainsObjectRestOrSpread */) {
                    containsPrecedingObjectRestOrSpread = true;
                    var declarations = ts.flattenDestructuringBinding(parameter, visitor, context, 1 /* FlattenLevel.ObjectRest */, factory.getGeneratedNameForNode(parameter), 
                    /*doNotRecordTempVariablesInLine*/ false, 
                    /*skipInitializer*/ true);
                    if (ts.some(declarations)) {
                        var declarationList = factory.createVariableDeclarationList(declarations);
                        var statement = factory.createVariableStatement(/*modifiers*/ undefined, declarationList);
                        ts.setEmitFlags(statement, 1048576 /* EmitFlags.CustomPrologue */);
                        statements = ts.append(statements, statement);
                    }
                }
            }
            return statements;
        }
        function enableSubstitutionForAsyncMethodsWithSuper() {
            if ((enabledSubstitutions & 1 /* ESNextSubstitutionFlags.AsyncMethodsWithSuper */) === 0) {
                enabledSubstitutions |= 1 /* ESNextSubstitutionFlags.AsyncMethodsWithSuper */;
                // We need to enable substitutions for call, property access, and element access
                // if we need to rewrite super calls.
                context.enableSubstitution(208 /* SyntaxKind.CallExpression */);
                context.enableSubstitution(206 /* SyntaxKind.PropertyAccessExpression */);
                context.enableSubstitution(207 /* SyntaxKind.ElementAccessExpression */);
                // We need to be notified when entering and exiting declarations that bind super.
                context.enableEmitNotification(257 /* SyntaxKind.ClassDeclaration */);
                context.enableEmitNotification(169 /* SyntaxKind.MethodDeclaration */);
                context.enableEmitNotification(172 /* SyntaxKind.GetAccessor */);
                context.enableEmitNotification(173 /* SyntaxKind.SetAccessor */);
                context.enableEmitNotification(171 /* SyntaxKind.Constructor */);
                // We need to be notified when entering the generated accessor arrow functions.
                context.enableEmitNotification(237 /* SyntaxKind.VariableStatement */);
            }
        }
        /**
         * Called by the printer just before a node is printed.
         *
         * @param hint A hint as to the intended usage of the node.
         * @param node The node to be printed.
         * @param emitCallback The callback used to emit the node.
         */
        function onEmitNode(hint, node, emitCallback) {
            // If we need to support substitutions for `super` in an async method,
            // we should track it here.
            if (enabledSubstitutions & 1 /* ESNextSubstitutionFlags.AsyncMethodsWithSuper */ && isSuperContainer(node)) {
                var superContainerFlags = resolver.getNodeCheckFlags(node) & (2048 /* NodeCheckFlags.AsyncMethodWithSuper */ | 4096 /* NodeCheckFlags.AsyncMethodWithSuperBinding */);
                if (superContainerFlags !== enclosingSuperContainerFlags) {
                    var savedEnclosingSuperContainerFlags = enclosingSuperContainerFlags;
                    enclosingSuperContainerFlags = superContainerFlags;
                    previousOnEmitNode(hint, node, emitCallback);
                    enclosingSuperContainerFlags = savedEnclosingSuperContainerFlags;
                    return;
                }
            }
            // Disable substitution in the generated super accessor itself.
            else if (enabledSubstitutions && substitutedSuperAccessors[ts.getNodeId(node)]) {
                var savedEnclosingSuperContainerFlags = enclosingSuperContainerFlags;
                enclosingSuperContainerFlags = 0;
                previousOnEmitNode(hint, node, emitCallback);
                enclosingSuperContainerFlags = savedEnclosingSuperContainerFlags;
                return;
            }
            previousOnEmitNode(hint, node, emitCallback);
        }
        /**
         * Hooks node substitutions.
         *
         * @param hint The context for the emitter.
         * @param node The node to substitute.
         */
        function onSubstituteNode(hint, node) {
            node = previousOnSubstituteNode(hint, node);
            if (hint === 1 /* EmitHint.Expression */ && enclosingSuperContainerFlags) {
                return substituteExpression(node);
            }
            return node;
        }
        function substituteExpression(node) {
            switch (node.kind) {
                case 206 /* SyntaxKind.PropertyAccessExpression */:
                    return substitutePropertyAccessExpression(node);
                case 207 /* SyntaxKind.ElementAccessExpression */:
                    return substituteElementAccessExpression(node);
                case 208 /* SyntaxKind.CallExpression */:
                    return substituteCallExpression(node);
            }
            return node;
        }
        function substitutePropertyAccessExpression(node) {
            if (node.expression.kind === 106 /* SyntaxKind.SuperKeyword */) {
                return ts.setTextRange(factory.createPropertyAccessExpression(factory.createUniqueName("_super", 16 /* GeneratedIdentifierFlags.Optimistic */ | 32 /* GeneratedIdentifierFlags.FileLevel */), node.name), node);
            }
            return node;
        }
        function substituteElementAccessExpression(node) {
            if (node.expression.kind === 106 /* SyntaxKind.SuperKeyword */) {
                return createSuperElementAccessInAsyncMethod(node.argumentExpression, node);
            }
            return node;
        }
        function substituteCallExpression(node) {
            var expression = node.expression;
            if (ts.isSuperProperty(expression)) {
                var argumentExpression = ts.isPropertyAccessExpression(expression)
                    ? substitutePropertyAccessExpression(expression)
                    : substituteElementAccessExpression(expression);
                return factory.createCallExpression(factory.createPropertyAccessExpression(argumentExpression, "call"), 
                /*typeArguments*/ undefined, __spreadArray([
                    factory.createThis()
                ], node.arguments, true));
            }
            return node;
        }
        function isSuperContainer(node) {
            var kind = node.kind;
            return kind === 257 /* SyntaxKind.ClassDeclaration */
                || kind === 171 /* SyntaxKind.Constructor */
                || kind === 169 /* SyntaxKind.MethodDeclaration */
                || kind === 172 /* SyntaxKind.GetAccessor */
                || kind === 173 /* SyntaxKind.SetAccessor */;
        }
        function createSuperElementAccessInAsyncMethod(argumentExpression, location) {
            if (enclosingSuperContainerFlags & 4096 /* NodeCheckFlags.AsyncMethodWithSuperBinding */) {
                return ts.setTextRange(factory.createPropertyAccessExpression(factory.createCallExpression(factory.createIdentifier("_superIndex"), 
                /*typeArguments*/ undefined, [argumentExpression]), "value"), location);
            }
            else {
                return ts.setTextRange(factory.createCallExpression(factory.createIdentifier("_superIndex"), 
                /*typeArguments*/ undefined, [argumentExpression]), location);
            }
        }
    }
    ts.transformES2018 = transformES2018;
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    function transformES2019(context) {
        var factory = context.factory;
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitor(node) {
            if ((node.transformFlags & 64 /* TransformFlags.ContainsES2019 */) === 0) {
                return node;
            }
            switch (node.kind) {
                case 292 /* SyntaxKind.CatchClause */:
                    return visitCatchClause(node);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function visitCatchClause(node) {
            if (!node.variableDeclaration) {
                return factory.updateCatchClause(node, factory.createVariableDeclaration(factory.createTempVariable(/*recordTempVariable*/ undefined)), ts.visitNode(node.block, visitor, ts.isBlock));
            }
            return ts.visitEachChild(node, visitor, context);
        }
    }
    ts.transformES2019 = transformES2019;
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    function transformES2020(context) {
        var factory = context.factory, hoistVariableDeclaration = context.hoistVariableDeclaration;
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitor(node) {
            if ((node.transformFlags & 32 /* TransformFlags.ContainsES2020 */) === 0) {
                return node;
            }
            switch (node.kind) {
                case 208 /* SyntaxKind.CallExpression */: {
                    var updated = visitNonOptionalCallExpression(node, /*captureThisArg*/ false);
                    ts.Debug.assertNotNode(updated, ts.isSyntheticReference);
                    return updated;
                }
                case 206 /* SyntaxKind.PropertyAccessExpression */:
                case 207 /* SyntaxKind.ElementAccessExpression */:
                    if (ts.isOptionalChain(node)) {
                        var updated = visitOptionalExpression(node, /*captureThisArg*/ false, /*isDelete*/ false);
                        ts.Debug.assertNotNode(updated, ts.isSyntheticReference);
                        return updated;
                    }
                    return ts.visitEachChild(node, visitor, context);
                case 221 /* SyntaxKind.BinaryExpression */:
                    if (node.operatorToken.kind === 60 /* SyntaxKind.QuestionQuestionToken */) {
                        return transformNullishCoalescingExpression(node);
                    }
                    return ts.visitEachChild(node, visitor, context);
                case 215 /* SyntaxKind.DeleteExpression */:
                    return visitDeleteExpression(node);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function flattenChain(chain) {
            ts.Debug.assertNotNode(chain, ts.isNonNullChain);
            var links = [chain];
            while (!chain.questionDotToken && !ts.isTaggedTemplateExpression(chain)) {
                chain = ts.cast(ts.skipPartiallyEmittedExpressions(chain.expression), ts.isOptionalChain);
                ts.Debug.assertNotNode(chain, ts.isNonNullChain);
                links.unshift(chain);
            }
            return { expression: chain.expression, chain: links };
        }
        function visitNonOptionalParenthesizedExpression(node, captureThisArg, isDelete) {
            var expression = visitNonOptionalExpression(node.expression, captureThisArg, isDelete);
            if (ts.isSyntheticReference(expression)) {
                // `(a.b)` -> { expression `((_a = a).b)`, thisArg: `_a` }
                // `(a[b])` -> { expression `((_a = a)[b])`, thisArg: `_a` }
                return factory.createSyntheticReferenceExpression(factory.updateParenthesizedExpression(node, expression.expression), expression.thisArg);
            }
            return factory.updateParenthesizedExpression(node, expression);
        }
        function visitNonOptionalPropertyOrElementAccessExpression(node, captureThisArg, isDelete) {
            if (ts.isOptionalChain(node)) {
                // If `node` is an optional chain, then it is the outermost chain of an optional expression.
                return visitOptionalExpression(node, captureThisArg, isDelete);
            }
            var expression = ts.visitNode(node.expression, visitor, ts.isExpression);
            ts.Debug.assertNotNode(expression, ts.isSyntheticReference);
            var thisArg;
            if (captureThisArg) {
                if (!ts.isSimpleCopiableExpression(expression)) {
                    thisArg = factory.createTempVariable(hoistVariableDeclaration);
                    expression = factory.createAssignment(thisArg, expression);
                }
                else {
                    thisArg = expression;
                }
            }
            expression = node.kind === 206 /* SyntaxKind.PropertyAccessExpression */
                ? factory.updatePropertyAccessExpression(node, expression, ts.visitNode(node.name, visitor, ts.isIdentifier))
                : factory.updateElementAccessExpression(node, expression, ts.visitNode(node.argumentExpression, visitor, ts.isExpression));
            return thisArg ? factory.createSyntheticReferenceExpression(expression, thisArg) : expression;
        }
        function visitNonOptionalCallExpression(node, captureThisArg) {
            if (ts.isOptionalChain(node)) {
                // If `node` is an optional chain, then it is the outermost chain of an optional expression.
                return visitOptionalExpression(node, captureThisArg, /*isDelete*/ false);
            }
            if (ts.isParenthesizedExpression(node.expression) && ts.isOptionalChain(ts.skipParentheses(node.expression))) {
                // capture thisArg for calls of parenthesized optional chains like `(foo?.bar)()`
                var expression = visitNonOptionalParenthesizedExpression(node.expression, /*captureThisArg*/ true, /*isDelete*/ false);
                var args = ts.visitNodes(node.arguments, visitor, ts.isExpression);
                if (ts.isSyntheticReference(expression)) {
                    return ts.setTextRange(factory.createFunctionCallCall(expression.expression, expression.thisArg, args), node);
                }
                return factory.updateCallExpression(node, expression, /*typeArguments*/ undefined, args);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitNonOptionalExpression(node, captureThisArg, isDelete) {
            switch (node.kind) {
                case 212 /* SyntaxKind.ParenthesizedExpression */: return visitNonOptionalParenthesizedExpression(node, captureThisArg, isDelete);
                case 206 /* SyntaxKind.PropertyAccessExpression */:
                case 207 /* SyntaxKind.ElementAccessExpression */: return visitNonOptionalPropertyOrElementAccessExpression(node, captureThisArg, isDelete);
                case 208 /* SyntaxKind.CallExpression */: return visitNonOptionalCallExpression(node, captureThisArg);
                default: return ts.visitNode(node, visitor, ts.isExpression);
            }
        }
        function visitOptionalExpression(node, captureThisArg, isDelete) {
            var _a = flattenChain(node), expression = _a.expression, chain = _a.chain;
            var left = visitNonOptionalExpression(ts.skipPartiallyEmittedExpressions(expression), ts.isCallChain(chain[0]), /*isDelete*/ false);
            var leftThisArg = ts.isSyntheticReference(left) ? left.thisArg : undefined;
            var capturedLeft = ts.isSyntheticReference(left) ? left.expression : left;
            var leftExpression = factory.restoreOuterExpressions(expression, capturedLeft, 8 /* OuterExpressionKinds.PartiallyEmittedExpressions */);
            if (!ts.isSimpleCopiableExpression(capturedLeft)) {
                capturedLeft = factory.createTempVariable(hoistVariableDeclaration);
                leftExpression = factory.createAssignment(capturedLeft, leftExpression);
            }
            var rightExpression = capturedLeft;
            var thisArg;
            for (var i = 0; i < chain.length; i++) {
                var segment = chain[i];
                switch (segment.kind) {
                    case 206 /* SyntaxKind.PropertyAccessExpression */:
                    case 207 /* SyntaxKind.ElementAccessExpression */:
                        if (i === chain.length - 1 && captureThisArg) {
                            if (!ts.isSimpleCopiableExpression(rightExpression)) {
                                thisArg = factory.createTempVariable(hoistVariableDeclaration);
                                rightExpression = factory.createAssignment(thisArg, rightExpression);
                            }
                            else {
                                thisArg = rightExpression;
                            }
                        }
                        rightExpression = segment.kind === 206 /* SyntaxKind.PropertyAccessExpression */
                            ? factory.createPropertyAccessExpression(rightExpression, ts.visitNode(segment.name, visitor, ts.isIdentifier))
                            : factory.createElementAccessExpression(rightExpression, ts.visitNode(segment.argumentExpression, visitor, ts.isExpression));
                        break;
                    case 208 /* SyntaxKind.CallExpression */:
                        if (i === 0 && leftThisArg) {
                            if (!ts.isGeneratedIdentifier(leftThisArg)) {
                                leftThisArg = factory.cloneNode(leftThisArg);
                                ts.addEmitFlags(leftThisArg, 1536 /* EmitFlags.NoComments */);
                            }
                            rightExpression = factory.createFunctionCallCall(rightExpression, leftThisArg.kind === 106 /* SyntaxKind.SuperKeyword */ ? factory.createThis() : leftThisArg, ts.visitNodes(segment.arguments, visitor, ts.isExpression));
                        }
                        else {
                            rightExpression = factory.createCallExpression(rightExpression, 
                            /*typeArguments*/ undefined, ts.visitNodes(segment.arguments, visitor, ts.isExpression));
                        }
                        break;
                }
                ts.setOriginalNode(rightExpression, segment);
            }
            var target = isDelete
                ? factory.createConditionalExpression(createNotNullCondition(leftExpression, capturedLeft, /*invert*/ true), /*questionToken*/ undefined, factory.createTrue(), /*colonToken*/ undefined, factory.createDeleteExpression(rightExpression))
                : factory.createConditionalExpression(createNotNullCondition(leftExpression, capturedLeft, /*invert*/ true), /*questionToken*/ undefined, factory.createVoidZero(), /*colonToken*/ undefined, rightExpression);
            ts.setTextRange(target, node);
            return thisArg ? factory.createSyntheticReferenceExpression(target, thisArg) : target;
        }
        function createNotNullCondition(left, right, invert) {
            return factory.createBinaryExpression(factory.createBinaryExpression(left, factory.createToken(invert ? 36 /* SyntaxKind.EqualsEqualsEqualsToken */ : 37 /* SyntaxKind.ExclamationEqualsEqualsToken */), factory.createNull()), factory.createToken(invert ? 56 /* SyntaxKind.BarBarToken */ : 55 /* SyntaxKind.AmpersandAmpersandToken */), factory.createBinaryExpression(right, factory.createToken(invert ? 36 /* SyntaxKind.EqualsEqualsEqualsToken */ : 37 /* SyntaxKind.ExclamationEqualsEqualsToken */), factory.createVoidZero()));
        }
        function transformNullishCoalescingExpression(node) {
            var left = ts.visitNode(node.left, visitor, ts.isExpression);
            var right = left;
            if (!ts.isSimpleCopiableExpression(left)) {
                right = factory.createTempVariable(hoistVariableDeclaration);
                left = factory.createAssignment(right, left);
            }
            return ts.setTextRange(factory.createConditionalExpression(createNotNullCondition(left, right), 
            /*questionToken*/ undefined, right, 
            /*colonToken*/ undefined, ts.visitNode(node.right, visitor, ts.isExpression)), node);
        }
        function visitDeleteExpression(node) {
            return ts.isOptionalChain(ts.skipParentheses(node.expression))
                ? ts.setOriginalNode(visitNonOptionalExpression(node.expression, /*captureThisArg*/ false, /*isDelete*/ true), node)
                : factory.updateDeleteExpression(node, ts.visitNode(node.expression, visitor, ts.isExpression));
        }
    }
    ts.transformES2020 = transformES2020;
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    function transformES2021(context) {
        var hoistVariableDeclaration = context.hoistVariableDeclaration, factory = context.factory;
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitor(node) {
            if ((node.transformFlags & 16 /* TransformFlags.ContainsES2021 */) === 0) {
                return node;
            }
            switch (node.kind) {
                case 221 /* SyntaxKind.BinaryExpression */:
                    var binaryExpression = node;
                    if (ts.isLogicalOrCoalescingAssignmentExpression(binaryExpression)) {
                        return transformLogicalAssignment(binaryExpression);
                    }
                // falls through
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function transformLogicalAssignment(binaryExpression) {
            var operator = binaryExpression.operatorToken;
            var nonAssignmentOperator = ts.getNonAssignmentOperatorForCompoundAssignment(operator.kind);
            var left = ts.skipParentheses(ts.visitNode(binaryExpression.left, visitor, ts.isLeftHandSideExpression));
            var assignmentTarget = left;
            var right = ts.skipParentheses(ts.visitNode(binaryExpression.right, visitor, ts.isExpression));
            if (ts.isAccessExpression(left)) {
                var propertyAccessTargetSimpleCopiable = ts.isSimpleCopiableExpression(left.expression);
                var propertyAccessTarget = propertyAccessTargetSimpleCopiable ? left.expression :
                    factory.createTempVariable(hoistVariableDeclaration);
                var propertyAccessTargetAssignment = propertyAccessTargetSimpleCopiable ? left.expression : factory.createAssignment(propertyAccessTarget, left.expression);
                if (ts.isPropertyAccessExpression(left)) {
                    assignmentTarget = factory.createPropertyAccessExpression(propertyAccessTarget, left.name);
                    left = factory.createPropertyAccessExpression(propertyAccessTargetAssignment, left.name);
                }
                else {
                    var elementAccessArgumentSimpleCopiable = ts.isSimpleCopiableExpression(left.argumentExpression);
                    var elementAccessArgument = elementAccessArgumentSimpleCopiable ? left.argumentExpression :
                        factory.createTempVariable(hoistVariableDeclaration);
                    assignmentTarget = factory.createElementAccessExpression(propertyAccessTarget, elementAccessArgument);
                    left = factory.createElementAccessExpression(propertyAccessTargetAssignment, elementAccessArgumentSimpleCopiable ? left.argumentExpression : factory.createAssignment(elementAccessArgument, left.argumentExpression));
                }
            }
            return factory.createBinaryExpression(left, nonAssignmentOperator, factory.createParenthesizedExpression(factory.createAssignment(assignmentTarget, right)));
        }
    }
    ts.transformES2021 = transformES2021;
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    function transformESNext(context) {
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitor(node) {
            if ((node.transformFlags & 4 /* TransformFlags.ContainsESNext */) === 0) {
                return node;
            }
            switch (node.kind) {
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
    }
    ts.transformESNext = transformESNext;
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    function transformJsx(context) {
        var factory = context.factory, emitHelpers = context.getEmitHelperFactory;
        var compilerOptions = context.getCompilerOptions();
        var currentSourceFile;
        var currentFileState;
        return ts.chainBundle(context, transformSourceFile);
        function getCurrentFileNameExpression() {
            if (currentFileState.filenameDeclaration) {
                return currentFileState.filenameDeclaration.name;
            }
            var declaration = factory.createVariableDeclaration(factory.createUniqueName("_jsxFileName", 16 /* GeneratedIdentifierFlags.Optimistic */ | 32 /* GeneratedIdentifierFlags.FileLevel */), /*exclaimationToken*/ undefined, /*type*/ undefined, factory.createStringLiteral(currentSourceFile.fileName));
            currentFileState.filenameDeclaration = declaration;
            return currentFileState.filenameDeclaration.name;
        }
        function getJsxFactoryCalleePrimitive(isStaticChildren) {
            return compilerOptions.jsx === 5 /* JsxEmit.ReactJSXDev */ ? "jsxDEV" : isStaticChildren ? "jsxs" : "jsx";
        }
        function getJsxFactoryCallee(isStaticChildren) {
            var type = getJsxFactoryCalleePrimitive(isStaticChildren);
            return getImplicitImportForName(type);
        }
        function getImplicitJsxFragmentReference() {
            return getImplicitImportForName("Fragment");
        }
        function getImplicitImportForName(name) {
            var _a, _b;
            var importSource = name === "createElement"
                ? currentFileState.importSpecifier
                : ts.getJSXRuntimeImport(currentFileState.importSpecifier, compilerOptions);
            var existing = (_b = (_a = currentFileState.utilizedImplicitRuntimeImports) === null || _a === void 0 ? void 0 : _a.get(importSource)) === null || _b === void 0 ? void 0 : _b.get(name);
            if (existing) {
                return existing.name;
            }
            if (!currentFileState.utilizedImplicitRuntimeImports) {
                currentFileState.utilizedImplicitRuntimeImports = new ts.Map();
            }
            var specifierSourceImports = currentFileState.utilizedImplicitRuntimeImports.get(importSource);
            if (!specifierSourceImports) {
                specifierSourceImports = new ts.Map();
                currentFileState.utilizedImplicitRuntimeImports.set(importSource, specifierSourceImports);
            }
            var generatedName = factory.createUniqueName("_".concat(name), 16 /* GeneratedIdentifierFlags.Optimistic */ | 32 /* GeneratedIdentifierFlags.FileLevel */ | 64 /* GeneratedIdentifierFlags.AllowNameSubstitution */);
            var specifier = factory.createImportSpecifier(/*isTypeOnly*/ false, factory.createIdentifier(name), generatedName);
            generatedName.generatedImportReference = specifier;
            specifierSourceImports.set(name, specifier);
            return generatedName;
        }
        /**
         * Transform JSX-specific syntax in a SourceFile.
         *
         * @param node A SourceFile node.
         */
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            currentSourceFile = node;
            currentFileState = {};
            currentFileState.importSpecifier = ts.getJSXImplicitImportBase(compilerOptions, node);
            var visited = ts.visitEachChild(node, visitor, context);
            ts.addEmitHelpers(visited, context.readEmitHelpers());
            var statements = visited.statements;
            if (currentFileState.filenameDeclaration) {
                statements = ts.insertStatementAfterCustomPrologue(statements.slice(), factory.createVariableStatement(/*modifiers*/ undefined, factory.createVariableDeclarationList([currentFileState.filenameDeclaration], 2 /* NodeFlags.Const */)));
            }
            if (currentFileState.utilizedImplicitRuntimeImports) {
                for (var _i = 0, _a = ts.arrayFrom(currentFileState.utilizedImplicitRuntimeImports.entries()); _i < _a.length; _i++) {
                    var _b = _a[_i], importSource = _b[0], importSpecifiersMap = _b[1];
                    if (ts.isExternalModule(node)) {
                        // Add `import` statement
                        var importStatement = factory.createImportDeclaration(/*decorators*/ undefined, /*modifiers*/ undefined, factory.createImportClause(/*typeOnly*/ false, /*name*/ undefined, factory.createNamedImports(ts.arrayFrom(importSpecifiersMap.values()))), factory.createStringLiteral(importSource), /*assertClause*/ undefined);
                        ts.setParentRecursive(importStatement, /*incremental*/ false);
                        statements = ts.insertStatementAfterCustomPrologue(statements.slice(), importStatement);
                    }
                    else if (ts.isExternalOrCommonJsModule(node)) {
                        // Add `require` statement
                        var requireStatement = factory.createVariableStatement(/*modifiers*/ undefined, factory.createVariableDeclarationList([
                            factory.createVariableDeclaration(factory.createObjectBindingPattern(ts.map(ts.arrayFrom(importSpecifiersMap.values()), function (s) { return factory.createBindingElement(/*dotdotdot*/ undefined, s.propertyName, s.name); })), 
                            /*exclaimationToken*/ undefined, 
                            /*type*/ undefined, factory.createCallExpression(factory.createIdentifier("require"), /*typeArguments*/ undefined, [factory.createStringLiteral(importSource)]))
                        ], 2 /* NodeFlags.Const */));
                        ts.setParentRecursive(requireStatement, /*incremental*/ false);
                        statements = ts.insertStatementAfterCustomPrologue(statements.slice(), requireStatement);
                    }
                    else {
                        // Do nothing (script file) - consider an error in the checker?
                    }
                }
            }
            if (statements !== visited.statements) {
                visited = factory.updateSourceFile(visited, statements);
            }
            currentFileState = undefined;
            return vi