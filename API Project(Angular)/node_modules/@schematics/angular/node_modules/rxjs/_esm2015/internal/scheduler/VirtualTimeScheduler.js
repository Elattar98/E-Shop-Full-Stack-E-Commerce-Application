rop.quoted ? types2.stringLiteral(prop.propertyName) : types2.identifier(prop.propertyName);
      return types2.objectProperty(key, prop.value);
    }));
  }
  createPropertyAccess(expression, propertyName) {
    return types2.memberExpression(expression, types2.identifier(propertyName), false);
  }
  createTaggedTemplate(tag, template) {
    const elements = template.elements.map((element, i) => this.setSourceMapRange(types2.templateElement(element, i === template.elements.length - 1), element.range));
    return types2.taggedTemplateExpression(tag, types2.templateLiteral(elements, template.expressions));
  }
  createTypeOfExpression(expression) {
    return types2.unaryExpression("typeof", expression);
  }
  createVariableDeclaration(variableName, initializer, type) {
    return types2.variableDeclaration(type, [types2.variableDeclarator(types2.identifier(variableName), initializer)]);
  }
  setSourceMapRange(node, sourceMapRange) {
    if (sourceMapRange === null) {
      return node;
    }
    node.loc = {
      filename: sourceMapRange.url !== this.sourceUrl ? sourceMapRange.url : void 0,
      start: {
        line: sourceMapRange.start.line + 1,
        column: sourceMapRange.start.column
      },
      end: {
        line: sourceMapRange.end.line + 1,
        column: sourceMapRange.end.column
      }
    };
    node.start = sourceMapRange.start.offset;
    node.end = sourceMapRange.end.offset;
    return node;
  }
};
function isLExpression(expr) {
  return types2.isLVal(expr);
}

// bazel-out/k8-fastbuild/bin/packages/compiler-cli/linker/babel/src/ast/babel_ast_host.mjs
var BabelAstHost = class {
  constructor() {
    this.isStringLiteral = types2.isStringLiteral;
    this.isNumericLiteral = types2.isNumericLiteral;
    this.isArrayLiteral = types2.isArrayExpression;
    this.isObjectLiteral = types2.isObjectExpression;
    this.isCallExpression = types2.isCallExpression;
  }
  getSymbolName(node) {
    if (types2.isIdentifier(node)) {
      return node.name;
    } else if (types2.isMemberExpression(node) && types2.isIdentifier(node.property)) {
      return node.property.name;
    } else {
      return null;
    }
  }
  parseStringLiteral(str) {
    assert(str, types2.isStringLiteral, "a string literal");
    return str.value;
  }
  parseNumericLiteral(num) {
    assert(num, types2.isNumericLiteral, "a numeric literal");
    return num.value;
  }
  isBooleanLiteral(bool) {
    return types2.isBooleanLi