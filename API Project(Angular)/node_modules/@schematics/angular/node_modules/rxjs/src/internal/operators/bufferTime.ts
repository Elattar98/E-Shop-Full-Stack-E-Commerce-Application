
      import {createRequire as __cjsCompatRequire} from 'module';
      const require = __cjsCompatRequire(import.meta.url);
      const __ESM_IMPORT_META_URL__ = import.meta.url;
    
import {
  CycleAnalyzer,
  ImportGraph,
  isShim,
  readConfiguration
} from "./chunk-BCXYCOVM.js";
import {
  CompilationMode,
  ComponentDecoratorHandler,
  CompoundMetadataReader,
  CompoundMetadataRegistry,
  DirectiveDecoratorHandler,
  DtsMetadataReader,
  DtsTransformRegistry,
  HandlerFlags,
  InjectableClassRegistry,
  InjectableDecoratorHandler,
  LocalMetadataRegistry,
  LocalModuleScopeRegistry,
  MetadataDtsModuleScopeResolver,
  NgModuleDecoratorHandler,
  PartialEvaluator,
  PipeDecoratorHandler,
  ResourceRegistry,
  TraitCompiler,
  TraitState,
  TypeCheckScopeRegistry,
  forwardRefResolver,
  readBaseClass
} from "./chunk-KPEPSPYQ.js";
import {
  ClassMemberKind,
  KnownDeclaration,
  TypeScriptReflectionHost,
  isConcreteDeclaration,
  isDecoratorIdentifier,
  isNamedClassDeclaration,
  isNamedFunctionDeclaration,
  isNamedVariableDeclaration,
  reflectObjectLiteral
} from "./chunk-NFCN3OZI.js";
import {
  ConsoleLogger,
  LogLevel
} from "./chunk-E7NQQTT7.js";
import {
  ContentOrigin,
  SourceFileLoader
} from "./chunk-CYVTLM4Z.js";
import {
  AbsoluteModuleStrategy,
  ImportManager,
  LocalIdentifierStrategy,
  LogicalProjectStrategy,
  ModuleResolver,
  NoopImportRewriter,
  PrivateExportAliasingHost,
  R3SymbolsImportRewriter,
  Reference,
  ReferenceEmitter,
  isAssignment,
  isDtsPath,
  isFatalDiagnosticError,
  isFromDtsFile,
  isSymbolWithValueDeclaration,
  replaceTsWithNgInErrors,
  translateStatement,
  translateType,
  validateAndRewriteCoreSymbol
} from "./chunk-24DFPZCS.js";
import {
  LogicalFileSystem,
  NgtscCompilerHost,
  absoluteFrom,
  absoluteFromSourceFile,
  dirname,
  getFileSystem,
  isLocalRelativePath,
  isRooted,
  relative,
  toRelativeImport
} from "./chunk-TOKOIIBI.js";
import {
  NOOP_PERF_RECORDER
} from "./chunk-ACXPVP2W.js";

// bazel-out/k8-fastbuild/bin/packages/compiler-cli/ngcc/src/execution/create_compile_function.mjs
import ts23 from "typescript";

// bazel-out/k8-fastbuild/bin/packages/compiler-cli/ngcc/src/packages/entry_point.mjs
import ts7 from "typescript";

// bazel-out/k8-fastbuild/bin/packages/compiler-cli/ngcc/src/host/umd_host.mjs
import ts6 from "typescript";

// bazel-out/k8-fastbuild/bin/packages/compiler-cli/ngcc/src/utils.mjs
import ts from "typescript";
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function getNameText(name) {
  return ts.isIdentifier(name) || ts.isLiteralExpression(name) ? name.text : name.getText();
}
function hasNameIdentifier(declaration) {
  const namedDeclaration = declaration;
  return namedDeclaration.name !== void 0 && ts.isIdentifier(namedDeclaration.name);
}
function isRelativePath(path) {
  return isRooted(path) || /^\.\.?(\/|\\|$)/.test(path);
}
var FactoryMap = class {
  constructor(factory, entries) {
    this.factory = factory;
    this.internalMap = new Map(entries);
  }
  get(key) {
    if (!this.internalMap.has(key)) {
      this.internalMap.set(key, this.factory(key));
    }
    return this.internalMap.get(key);
  }
  set(key, value) {
    this.internalMap.set(key, value);
  }
};
function resolveFileWithPostfixes(fs, path, postFixes) {
  for (const postFix of postFixes) {
    const testPath = absoluteFrom(path + postFix);
    if (fs.exists(testPath) && fs.stat(testPath).isFile()) {
      return testPath;
    }
  }
  return null;
}
function getTsHelperFnFromDeclaration(decl) {
  if (!ts.isFunctionDeclaration(decl) && !ts.isVariableDeclaration(decl)) {
    return null;
  }
  if (decl.name === void 0 || !ts.isIdentifier(decl.name)) {
    return null;
  }
  return getTsHelperFnFromIdentifier(decl.name);
}
function getTsHelperFnFromIdentifier(id) {
  switch (stripDollarSuffix(id.text)) {
    case "__assign":
      return KnownDeclaration.TsHelperAssign;
    case "__spread":
      return KnownDeclaration.TsHelperSpread;
    case "__spreadArrays":
      return KnownDeclaration.TsHelperSpreadArrays;
    case "__spreadArray":
      return KnownDeclaration.TsHelperSpreadArray;
    case "__read":
      return KnownDeclaration.TsHelperRead;
    default:
      return null;
  }
}
function stripDollarSuffix(value) {
  return value.replace(/\$\d+$/, "");
}
function stripExtension(fileName) {
  return fileName.replace(/\..+$/, "");
}
function loadJson(fs, packageJsonPath) {
  try {
    return JSON.parse(fs.readFile(packageJsonPath));
  } catch {
    return null;
  }
}
function loadSecondaryEntryPointInfoForApfV14(fs, primaryPackageJson, packagePath, entryPointPath) {
  const exportMap = primaryPackageJson == null ? void 0 : primaryPackageJson.exports;
  if (!isExportObject(exportMap)) {
    return null;
  }
  const relativeEntryPointPath = fs.relative(packagePath, entryPointPath);
  const entryPointExportKey = `./${relativeEntryPointPath}`;
  const entryPointInfo = exportMap[entryPointExportKey];
  return isExportObject(entryPointInfo) ? entryPointInfo : null;
}
function isExportObject(thing) {
  return typeof thing === "object" && thing !== null && !Array.isArray(thing);
}

// bazel-out/k8-fastbuild/bin/packages/compiler-cli/ngcc/src/host/commonjs_umd_utils.mjs
import ts2 from "typescript";
function findNamespaceOfIdentifier(id) {
  return id.parent && ts2.isPropertyAccessExpression(id.parent) && id.parent.name === id && ts2.isIdentifier(id.parent.expression) ? id.parent.expression : null;
}
function findRequireCallReference(id, checker) {
  var _a, _b;
  const symbol = checker.getSymbolAtLocation(id) || null;
  const declaration = (_b = symbol == null ? void 0 : symbol.valueDeclaration) != null ? _b : (_a = symbol == null ? void 0 : symbol.declarations) == null ? void 0 : _a[0];
  const initializer = declaration && ts2.isVariableDeclaration(declaration) && declaration.initializer || null;
  return initializer && isRequireCall(initializer) ? initializer : null;
}
function isWildcardReexportStatement(stmt) {
  if (!ts2.isExpressionStatement(stmt) || !ts2.isCallExpression(stmt.expression)) {
    return false;
  }
  let fnName = null;
  if (ts2.isIdentifier(stmt.expression.expression)) {
    fnName = stmt.expression.expression.text;
  } else if (ts2.isPropertyAccessExpression(stmt.expression.expression) && ts2.isIdentifier(stmt.expression.expression.name)) {
    fnName = stmt.expression.expression.name.text;
  }
  if (fnName !== "__export" && fnName !== "__exportStar") {
    return false;
  }
  return stmt.expression.arguments.length > 0;
}
function isDefinePropertyReexportStatement(stmt) {
  if (!ts2.isExpressionStatement(stmt) || !ts2.isCallExpression(stmt.expression)) {
    return false;
  }
  if (!ts2.isPropertyAccessExpression(stmt.expression.expression) || !ts2.isIdentifier(stmt.expression.expression.expression) || stmt.expression.expression.expression.text !== "Object" || !ts2.isIdentifier(stmt.expression.expression.name) || stmt.expression.expression.name.text !== "defineProperty") {
    return false;
  }
  const args = stmt.expression.arguments;
  if (args.length !== 3) {
    return false;
  }
  const exportsObject = args[0];
  if (!ts2.isIdentifier(exportsObject) || exportsObject.text !== "exports") {
    return false;
  }
  const propertyKey = args[1];
  if (!ts2.isStringLiteral(propertyKey)) {
    return false;
  }
  const propertyDescriptor = args[2];
  if (!ts2.isObjectLiteralExpression(propertyDescriptor)) {
    return false;
  }
  return propertyDescriptor.properties.some((prop) => prop.name !== void 0 && ts2.isIdentifier(prop.name) && prop.name.text === "get");
}
function extractGetterFnExpression(statement) {
  const args = statement.expression.arguments;
  const getterFn = args[2].properties.find((prop) => prop.name !== void 0 && ts2.isIdentifier(prop.name) && prop.name.text === "get");
  if (getterFn === void 0 || !ts2.isPropertyAssignment(getterFn) || !ts2.isFunctionExpression(getterFn.initializer)) {
    return null;
  }
  const returnStatement = getterFn.initializer.body.statements[0];
  if (!ts2.isReturnStatement(returnStatement) || returnStatement.expression === void 0) {
    return null;
  }
  return returnStatement.expression;
}
function isRequireCall(node) {
  return ts2.isCallExpression(node) && ts2.isIdentifier(node.expression) && node.expression.text === "require" && node.arguments.length === 1 && ts2.isStringLiteral(node.arguments[0]);
}
function isExternalImport(path) {
  return !/^\.\.?(\/|$)/.test(path);
}
function isExportsDeclaration(expr) {
  return expr.parent && isExportsAssignment(expr.parent);
}
function isExportsAssignment(expr) {
  return isAssignment(expr) && ts2.isPropertyAccessExpression(expr.left) &