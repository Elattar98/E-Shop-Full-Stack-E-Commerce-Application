                       (ts.isSetAccessor(parent.parent) && !!((_d = parent.parent.decorators) === null || _d === void 0 ? void 0 : _d.length)) ||
                        (ts.isConstructorDeclaration(parent.parent) &&
                            !!((_e = parent.parent.parent.decorators) === null || _e === void 0 ? void 0 : _e.length)));
                    break;
            }
            if (isTypeReferenceForDecoratoredNode) {
                symbol = typeChecker.getSymbolAtLocation(node.typeName);
            }
        }
        else {
            switch (node.kind) {
                case ts.SyntaxKind.Identifier:
                    const parent = node.parent;
                    if (parent && ts.isShorthandPropertyAssignment(parent)) {
                        const shorthandSymbol = typeChecker.getShorthandAssignmentValueSymbol(parent);
                        if (shorthandSymbol) {
                            symbol = shorthandSymbol;
                        }
                    }
                    else {
                        symbol = typeChecker.getSymbolAtLocation(node);
                    }
                    break;
                case ts.SyntaxKind.ExportSpecifier:
                    symbol = typeChecker.getExportSpecifierLocalTargetSymbol(node);
                    break;
                case ts.SyntaxKind.ShorthandPropertyAssignment:
                    symbol = typeChecker.getShorthandAssignmentValueSymbol(node);
                    break;
            }
        }
        if (symbol) {
            usedSymbols.add(symbol);
        }
        ts.forEachChild(node, visit);
    });
    if (imports.length === 0) {
        return importNodeRemovals;
    }
    const isUnused = (node) => {
        // Do not remove JSX factory imports
        if (node.text === compilerOptions.jsxFactory) {
            return false;
        }
        const symbol = typeChecker.getSymbolAtLocation(node);
        return symbol && !usedSymbols.has(symbol);
    };
    for (const node of imports) {
        if (!node.importClause) {
            // "import 'abc';"
            continue;
        }
        const namedBindings = node.importClause.namedBindings;
        if (namedBindings && ts.isNamespaceImport(namedBindings)) {
            // "import * as XYZ from 'abc';"
            if (isUnused(namedBindings.name)) {
                importNodeRemovals.add(node);
            }
        }
        else {
            const specifierNodeRemovals = [];
            let clausesCount = 0;
            // "import { XYZ, ... } from 'abc';"
            if (namedBindings && ts.isNamedImports(namedBindings)) {