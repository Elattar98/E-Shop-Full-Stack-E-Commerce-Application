me you call enable() or disable()\n   * without passing along {emitEvent: false} as a function argument.\n   */\n  public readonly valueChanges!: Observable<TValue>;\n\n  /**\n   * A multicasting observable that emits an event every time the validation `status` of the control\n   * recalculates.\n   *\n   * @see `FormControlStatus`\n   * @see {@link AbstractControl.status}\n   *\n   */\n  public readonly statusChanges!: Observable<FormControlStatus>;\n\n  /**\n   * Reports the update strategy of the `AbstractControl` (meaning\n   * the event on which the control updates itself).\n   * Possible values: `'change'` | `'blur'` | `'submit'`\n   * Default value: `'change'`\n   */\n  get updateOn(): FormHooks {\n    return this._updateOn ? this._updateOn : (this.parent ? this.parent.updateOn : 'change');\n  }\n\n  /**\n   * Sets the synchronous validators that are active on this control.  Calling\n   * this overwrites any existing synchronous validators.\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   * If you want to add a new validator without affecting existing ones, consider\n   * using `addValidators()` method instead.\n   */\n  setValidators(validators: ValidatorFn|ValidatorFn[]|null): void {\n    this._rawValidators = validators;\n