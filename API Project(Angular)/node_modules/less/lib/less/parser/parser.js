           return packageJsonFilter
                            ? packageJsonFilter.allowsImportingAmbientModule(info.moduleSymbol, getModuleSpecifierResolutionHost(info.isFromPackageJson))
                            : true;
                    }
                    return ts.isImportableFile(info.isFromPackageJson ? packageJsonAutoImportProvider : program, sourceFile, moduleFile, preferences, packageJsonFilter, getModuleSpecifierResolutionHost(info.isFromPackageJson), moduleSpecifierCache);
                }
            }
            function pushAutoImportSymbol(symbol, origin) {
                var symbolId = ts.getSymbolId(symbol);
                if (symbolToSortTextMap[symbolId] === Completions.SortText.GlobalsOrKeywords) {
                    // If an auto-importable symbol is available as a global, don't add the auto import
                    return;
                }
                symbolToOriginInfoMap[symbols.length] = origin;
                symbolToSortTextMap[symbolId] = importCompletionNode ? Completions.SortText.LocationPriority : Completions.SortText.AutoImportSuggestions;
                symbols.push(symbol);
            }
            /* Mutates `symbols` and `symbolToOriginInfoMap`. */
            function collectObjectLiteralMethodSymbols(members, enclosingDeclaration) {
                // TODO: support JS files.
                if (ts.isInJSFile(location)) {
                    return;
                }
                members.forEach(function (member) {
                    if (!isObjectLiteralMethodSymbol(member)) {
                        return;
                    }
                    var displayName = getCompletionEntryDisplayNameForSymbol(member, ts.getEmitScriptTarget(compilerOptions), 
                    /*origin*/ undefined, 0 /* CompletionKind.ObjectPropertyDeclaration */, 
                    /*jsxIdentifierExpected*/ false);
                    if (!displayName) {
                        return;
                    }
                    var name = displayName.name;
                    var entryProps = getEntryForObjectLiteralMethodCompletion(member, name, enclosingDeclaration, program, host, compilerOptions, preferences, formatContext);
                    if (!entryProps) {
                        return;
                    }
                    var origin = __assign({ kind: 128 /* SymbolOriginInfoKind.ObjectLiteralMethod */ }, entryProps);
                    flags |= 32 /* CompletionInfoFlags.MayIncludeMethodSnippets */;
                    symbolToOriginInfoMap[symbols.length] = origin;
                    symbols.push(member);
                });
            }
            function isObjectLiteralMethodSymbol(symbol) {
                /*
                    For an object type
                    `type Foo = {
                        bar(x: number): void;
                        foo: (x: string) => string;
                    }`,
                    `bar` will have symbol flag `Method`,
                    `foo` will have symbol flag `Property`.
                */
                if (!(symbol.flags & (4 /* SymbolFlags.Property */ | 8192 /* SymbolFlags.Method */))) {
                    return false;
                }
                return true;
            }
            /**
             * Finds the first node that "embraces" the position, so that one may
             * accurately aggregate locals from the closest containing scope.
             */
            function getScopeNode(initialToken, position, sourceFile) {
                var scope = initialToken;
                while (scope && !ts.positionBelongsToNode(scope, position, sourceFile)) {
                    scope = scope.parent;
                }
                return scope;
            }
            function isCompletionListBlocker(contextToken) {
                var start = ts.timestamp();
                var result = isInStringOrRegularExpressionOrTemplateLiteral(contextToken) ||
                    isSolelyIdentifierDefinitionLocation(contextToken) ||
                    isDotOfNumericLiteral(contextToken) ||
                    isInJsxText(contextToken) ||
                    ts.isBigIntLiteral(contextToken);
                log("getCompletionsAtPosition: isCompletionListBlocker: " + (ts.timestamp() - start));
                return result;
            }
            function isInJsxText(contextToken) {
                if (contextToken.kind === 11 /* SyntaxKind.JsxText */) {
                    return true;
                }
                if (contextToken.kind === 31 /* SyntaxKind.GreaterThanToken */ && contextToken.parent) {
                    // <Component<string> /**/ />
                    // <Component<string> /**/ ><Component>
                    // - contextToken: GreaterThanToken (before cursor)
                    // - location: JsxSelfClosingElement or JsxOpeningElement
                    // - contextToken.parent === location
                    if (location === contextToken.parent && (location.kind === 280 /* SyntaxKind.JsxOpeningElement */ || location.kind === 279 /* SyntaxKind.JsxSelfClosingElement */)) {
                        return false;
                    }
                    if (contextToken.parent.kind === 280 /* SyntaxKind.JsxOpeningElement */) {
                        // <div>/**/
                        // - contextToken: GreaterThanToken (before cursor)
                        // - location: JSXElement
                        // - different parents (JSXOpeningElement, JSXElement)
                        return location.parent.kind !== 280 /* SyntaxKind.JsxOpeningElement */;
                    }
                    if (contextToken.parent.kind === 281 /* SyntaxKind.JsxClosingElement */ || contextToken.parent.kind === 279 /* SyntaxKind.JsxSelfClosingElement */) {
                        return !!contextToken.parent.parent && contextToken.parent.parent.kind === 278 /* SyntaxKind.JsxElement */;
                    }
                }
                return false;
            }
            function isNewIdentifierDefinitionLocation() {
                if (contextToken) {
                    var containingNodeKind = contextToken.parent.kind;
                    var tokenKind = keywordForNode(contextToken);
                    // Previous token may have been a keyword that was converted to an identifier.
                    switch (tokenKind) {
                        case 27 /* SyntaxKind.CommaToken */:
                            return containingNodeKind === 208 /* SyntaxKind.CallExpression */ // func( a, |
                                || containingNodeKind === 171 /* SyntaxKind.Constructor */ // constructor( a, |   /* public, protected, private keywords are allowed here, so show completion */
                                || containingNodeKind === 209 /* SyntaxKind.NewExpression */ // new C(a, |
                                || containingNodeKind === 204 /* SyntaxKind.ArrayLiteralExpression */ // [a, |
                                || containingNodeKind === 221 /* SyntaxKind.BinaryExpression */ // const x = (a, |
                                || containingNodeKind === 179 /* SyntaxKind.FunctionType */ // var x: (s: string, list|
                                || containingNodeKind === 205 /* SyntaxKind.ObjectLiteralExpression */; // const obj = { x, |
                        case 20 /* SyntaxKind.OpenParenToken */:
                            return containingNodeKind === 208 /* SyntaxKind.CallExpression */ // func( |
                                || containingNodeKind === 171 /* SyntaxKind.Constructor */ // constructor( |
                                || containingNodeKind === 209 /* SyntaxKind.NewExpression */ // new C(a|
                                || containingNodeKind === 212 /* SyntaxKind.ParenthesizedExpression */ // const x = (a|
                                || containingNodeKind === 191 /* SyntaxKind.ParenthesizedType */; // function F(pred: (a| /* this can become an arrow function, where 'a' is the argument */
                        case 22 /* SyntaxKind.OpenBracketToken */:
                            return containingNodeKind === 204 /* SyntaxKind.ArrayLiteralExpression */ // [ |
                                || containingNodeKind === 176 /* SyntaxKind.IndexSignature */ // [ | : string ]
                                || containingNodeKind === 162 /* SyntaxKind.ComputedPropertyName */; // [ |    /* this can become an index signature */
                        case 141 /* SyntaxKind.ModuleKeyword */: // module |
                        case 142 /* SyntaxKind.NamespaceKeyword */: // namespace |
                        case 100 /* SyntaxKind.ImportKeyword */: // import |
                            return true;
                        case 24 /* SyntaxKind.DotToken */:
                            return containingNodeKind === 261 /* SyntaxKind.ModuleDeclaration */; // module A.|
                        case 18 /* SyntaxKind.OpenBraceToken */:
                            return containingNodeKind === 257 /* SyntaxKind.ClassDeclaration */ // class A { |
                                || containingNodeKind === 205 /* SyntaxKind.ObjectLiteralExpression */; // const obj = { |
                        case 63 /* SyntaxKind.EqualsToken */:
                            return containingNodeKind === 254 /* SyntaxKind.VariableDeclaration */ // const x = a|
                                || containingNodeKind === 221 /* SyntaxKind.BinaryExpression */; // x = a|
                        case 15 /* SyntaxKind.TemplateHead */:
                            return containingNodeKind === 223 /* SyntaxKind.TemplateExpression */; // `aa ${|
                        case 16 /* SyntaxKind.TemplateMiddle */:
                            return containingNodeKind === 233 /* SyntaxKind.TemplateSpan */; // `aa ${10} dd ${|
                        case 131 /* SyntaxKind.AsyncKeyword */:
                            return containingNodeKind === 169 /* SyntaxKind.MethodDeclaration */ // const obj = { async c|()
                                || containingNodeKind === 297 /* SyntaxKind.ShorthandPropertyAssignment */; // const obj = { async c|
                        case 41 /* SyntaxKind.AsteriskToken */:
                            return containingNodeKind === 169 /* SyntaxKind.MethodDeclaration */; // const obj = { * c|
                    }
                    if (isClassMemberCompletionKeyword(tokenKind)) {
                        return true;
                    }
                }
                return false;
            }
            function isInStringOrRegularExpressionOrTemplateLiteral(contextToken) {
                // To be "in" one of these literals, the position has to be:
                //   1. entirely within the token text.
                //   2. at the end position of an unterminated token.
                //   3. at the end of a regular expression (due to trailing flags like '/foo/g').
                return (ts.isRegularExpressionLiteral(contextToken) || ts.isStringTextContainingNode(contextToken)) && (ts.rangeContainsPositionExclusive(ts.createTextRangeFromSpan(ts.createTextSpanFromNode(contextToken)), position) ||
                    position === contextToken.end && (!!contextToken.isUnterminated || ts.isRegularExpressionLiteral(contextToken)));
            }
            function tryGetObjectTypeLiteralInTypeArgumentCompletionSymbols() {
                var typeLiteralNode = tryGetTypeLiteralNode(contextToken);
                if (!typeLiteralNode)
                    return 0 /* GlobalsSearch.Continue */;
                var intersectionTypeNode = ts.isIntersectionTypeNode(typeLiteralNode.parent) ? typeLiteralNode.parent : undefined;
                var containerTypeNode = intersectionTypeNode || typeLiteralNode;
                var containerExpectedType = getConstraintOfTypeArgumentProperty(containerTypeNode, typeChecker);
                if (!containerExpectedType)
                    return 0 /* GlobalsSearch.Continue */;
                var containerActualType = typeChecker.getTypeFromTypeNode(containerTypeNode);
                var members = getPropertiesForCompletion(containerExpectedType, typeChecker);
                var existingMembers = getPropertiesForCompletion(containerActualType, typeChecker);
                var existingMemberEscapedNames = new ts.Set();
                existingMembers.forEach(function (s) { return existingMemberEscapedNames.add(s.escapedName); });
                symbols = ts.concatenate(symbols, ts.filter(members, function (s) { return !existingMemberEscapedNames.has(s.escapedName); }));
                completionKind = 0 /* CompletionKind.ObjectPropertyDeclaration */;
                isNewIdentifierLocation = true;
                return 1 /* GlobalsSearch.Success */;
            }
            /**
             * Aggregates relevant symbols for completion in object literals and object binding patterns.
             * Relevant symbols are stored in the captured 'symbols' variable.
             *
             * @returns true if 'symbols' was successfully populated; false otherwise.
             */
            function tryGetObjectLikeCompletionSymbols() {
                var symbolsStartIndex = symbols.length;
                var objectLikeContainer = tryGetObjectLikeCompletionContainer(contextToken);
                if (!objectLikeContainer)
                    return 0 /* GlobalsSearch.Continue */;
                // We're looking up possible property names from contextual/inferred/declared type.
                completionKind = 0 /* CompletionKind.ObjectPropertyDeclaration */;
                var typeMembers;
                var existingMembers;
                if (objectLikeContainer.kind === 205 /* SyntaxKind.ObjectLiteralExpression */) {
                    var instantiatedType = tryGetObjectLiteralContextualType(objectLikeContainer, typeChecker);
                    // Check completions for Object property value shorthand
                    if (instantiatedType === undefined) {
                        if (objectLikeContainer.flags & 33554432 /* NodeFlags.InWithStatement */) {
                            return 2 /* GlobalsSearch.Fail */;
                        }
                        isNonContextualObjectLiteral = true;
                        return 0 /* GlobalsSearch.Continue */;
                    }
                    var completionsType = typeChecker.getContextualType(objectLikeContainer, 4 /* ContextFlags.Completions */);
                    var hasStringIndexType = (completionsType || instantiatedType).getStringIndexType();
                    var hasNumberIndextype = (completionsType || instantiatedType).getNumberIndexType();
                    isNewIdentifierLocation = !!hasStringIndexType || !!hasNumberIndextype;
                    typeMembers = getPropertiesForObjectExpression(instantiatedType, completionsType, objectLikeContainer, typeChecker);
                    existingMembers = objectLikeContainer.properties;
                    if (typeMembers.length === 0) {
                        // Edge case: If NumberIndexType exists
                        if (!hasNumberIndextype) {
                            isNonContextualObjectLiteral = true;
                            return 0 /* GlobalsSearch.Continue */;
                        }
                    }
                }
                else {
                    ts.Debug.assert(objectLikeContainer.kind === 201 /* SyntaxKind.ObjectBindingPattern */);
                    // We are *only* completing on properties from the type being destructured.
                    isNewIdentifierLocation = false;
                    var rootDeclaration = ts.getRootDeclaration(objectLikeContainer.parent);
                    if (!ts.isVariableLike(rootDeclaration))
                        return ts.Debug.fail("Root declaration is not variable-like.");
                    // We don't want to complete using the type acquired by the shape
                    // of the binding pattern; we are only interested in types acquired
                    // through type declaration or inference.
                    // Also proceed if rootDeclaration is a parameter and if its containing function expression/arrow function is contextually typed -
                    // type of parameter will flow in from the contextual type of the function
                    var canGetType = ts.hasInitializer(rootDeclaration) || !!ts.getEffectiveTypeAnnotationNode(rootDeclaration) || rootDeclaration.parent.parent.kind === 244 /* SyntaxKind.ForOfStatement */;
                    if (!canGetType && rootDeclaration.kind === 164 /* SyntaxKind.Parameter */) {
                        if (ts.isExpression(rootDeclaration.parent)) {
                            canGetType = !!typeChecker.getContextualType(rootDeclaration.parent);
                        }
                        else if (rootDeclaration.parent.kind === 169 /* SyntaxKind.MethodDeclaration */ || rootDeclaration.parent.kind === 173 /* SyntaxKind.SetAccessor */) {
                            canGetType = ts.isExpression(rootDeclaration.parent.parent) && !!typeChecker.getContextualType(rootDeclaration.parent.parent);
                        }
                    }
                    if (canGetType) {
                        var typeForObject_1 = typeChecker.getTypeAtLocation(objectLikeContainer);
                        if (!typeForObject_1)
                            return 2 /* GlobalsSearch.Fail */;
                        typeMembers = typeChecker.getPropertiesOfType(typeForObject_1).filter(function (propertySymbol) {
                            return typeChecker.isPropertyAccessible(objectLikeContainer, /*isSuper*/ false, /*writing*/ false, typeForObject_1, propertySymbol);
                        });
                        existingMembers = objectLikeContainer.elements;
                    }
                }
                if (typeMembers && typeMembers.length > 0) {
                    // Add filtered items to the completion list
                    var filteredMembers = filterObjectMembersList(typeMembers, ts.Debug.checkDefined(existingMembers));
                    symbols = ts.concatenate(symbols, filteredMembers);
                    setSortTextToOptionalMember();
                    if (objectLikeContainer.kind === 205 /* SyntaxKind.ObjectLiteralExpression */
                        && preferences.includeCompletionsWithObjectLiteralMethodSnippets
                        && preferences.includeCompletionsWithInsertText) {
                        transformObjectLiteralMembersSortText(symbolsStartIndex);
                        collectObjectLiteralMethodSymbols(filteredMembers, objectLikeContainer);
                    }
                }
                return 1 /* GlobalsSearch.Success */;
            }
            /**
             * Aggregates relevant symbols for completion in import clauses and export clauses
             * whose declarations have a module specifier; for instance, symbols will be aggregated for
             *
             *      import { | } from "moduleName";
             *      export { a as foo, | } from "moduleName";
             *
             * but not for
             *
             *      export { | };
             *
             * Relevant symbols are stored in the captured 'symbols' variable.
             */
            function tryGetImportOrExportClauseCompletionSymbols() {
                if (!contextToken)
                    return 0 /* GlobalsSearch.Continue */;
                // `import { |` or `import { a as 0, | }` or `import { type | }`
                var namedImportsOrExports = contextToken.kind === 18 /* SyntaxKind.OpenBraceToken */ || contextToken.kind === 27 /* SyntaxKind.CommaToken */ ? ts.tryCast(contextToken.parent, ts.isNamedImportsOrExports) :
                    ts.isTypeKeywordTokenOrIdentifier(contextToken) ? ts.tryCast(contextToken.parent.parent, ts.isNamedImportsOrExports) : undefined;
                if (!namedImportsOrExports)
                    return 0 /* GlobalsSearch.Continue */;
                // We can at least offer `type` at `import { |`
                if (!ts.isTypeKeywordTokenOrIdentifier(contextToken)) {
                    keywordFilters = 8 /* KeywordCompletionFilters.TypeKeyword */;
                }
                // try to show exported member for imported/re-exported module
                var moduleSpecifier = (namedImportsOrExports.kind === 269 /* SyntaxKind.NamedImports */ ? namedImportsOrExports.parent.parent : namedImportsOrExports.parent).moduleSpecifier;
                if (!moduleSpecifier) {
                    isNewIdentifierLocation = true;
                    return namedImportsOrExports.kind === 269 /* SyntaxKind.NamedImports */ ? 2 /* GlobalsSearch.Fail */ : 0 /* GlobalsSearch.Continue */;
                }
                var moduleSpecifierSymbol = typeChecker.getSymbolAtLocation(moduleSpecifier); // TODO: GH#18217
                if (!moduleSpecifierSymbol) {
                    isNewIdentifierLocation = true;
                    return 2 /* GlobalsSearch.Fail */;
                }
                completionKind = 3 /* CompletionKind.MemberLike */;
                isNewIdentifierLocation = false;
                var exports = typeChecker.getExportsAndPropertiesOfModule(moduleSpecifierSymbol);
                var existing = new ts.Set(namedImportsOrExports.elements.filter(function (n) { return !isCurrentlyEditingNode(n); }).map(function (n) { return (n.propertyName || n.name).escapedText; }));
                var uniques = exports.filter(function (e) { return e.escapedName !== "default" /* InternalSymbolName.Default */ && !existing.has(e.escapedName); });
                symbols = ts.concatenate(symbols, uniques);
                if (!uniques.length) {
                    // If there's nothing else to import, don't offer `type` either
                    keywordFilters = 0 /* KeywordCompletionFilters.None */;
                }
                return 1 /* GlobalsSearch.Success */;
            }
            /**
             * Adds local declarations for completions in named exports:
             *
             *   export { | };
             *
             * Does not check for the absence of a module specifier (`export {} from "./other"`)
             * because `tryGetImportOrExportClauseCompletionSymbols` runs first and handles that,
             * preventing this function from running.
             */
            function tryGetLocalNamedExportCompletionSymbols() {
                var _a;
                var namedExports = contextToken && (contextToken.kind === 18 /* SyntaxKind.OpenBraceToken */ || contextToken.kind === 27 /* SyntaxKind.CommaToken */)
                    ? ts.tryCast(contextToken.parent, ts.isNamedExports)
                    : undefined;
                if (!namedExports) {
                    return 0 /* GlobalsSearch.Continue */;
                }
                var localsContainer = ts.findAncestor(namedExports, ts.or(ts.isSourceFile, ts.isModuleDeclaration));
                completionKind = 5 /* CompletionKind.None */;
                isNewIdentifierLocation = false;
                (_a = localsContainer.locals) === null || _a === void 0 ? void 0 : _a.forEach(function (symbol, name) {
                    var _a, _b;
                    symbols.push(symbol);
                    if ((_b = (_a = localsContainer.symbol) === null || _a === void 0 ? void 0 : _a.exports) === null || _b === void 0 ? void 0 : _b.has(name)) {
                        symbolToSortTextMap[ts.getSymbolId(symbol)] = Completions.SortText.OptionalMember;
                    }
                });
                return 1 /* GlobalsSearch.Success */;
            }
            /**
             * Aggregates relevant symbols for completion in class declaration
             * Relevant symbols are stored in the captured 'symbols' variable.
             */
            function tryGetClassLikeCompletionSymbols() {
                var decl = tryGetObjectTypeDeclarationCompletionContainer(sourceFile, contextToken, location, position);
                if (!decl)
                    return 0 /* GlobalsSearch.Continue */;
                // We're looking up possible property names from parent type.
                completionKind = 3 /* CompletionKind.MemberLike */;
                // Declaring new property/method/accessor
                isNewIdentifierLocation = true;
                keywordFilters = contextToken.kind === 41 /* SyntaxKind.AsteriskToken */ ? 0 /* KeywordCompletionFilters.None */ :
                    ts.isClassLike(decl) ? 2 /* KeywordCompletionFilters.ClassElementKeywords */ : 3 /* KeywordCompletionFilters.InterfaceElementKeywords */;
                // If you're in an interface you don't want to repeat things from super-interface. So just stop here.
                if (!ts.isClassLike(decl))
                    return 1 /* GlobalsSearch.Success */;
                var classElement = contextToken.kind === 26 /* SyntaxKind.SemicolonToken */ ? contextToken.parent.parent : contextToken.parent;
                var classElementModifierFlags = ts.isClassElement(classElement) ? ts.getEffectiveModifierFlags(classElement) : 0 /* ModifierFlags.None */;
                // If this is context token is not something we are editing now, consider if this would lead to be modifier
                if (contextToken.kind === 79 /* SyntaxKind.Identifier */ && !isCurrentlyEditingNode(contextToken)) {
                    switch (contextToken.getText()) {
                        case "private":
                            classElementModifierFlags = classElementModifierFlags | 8 /* ModifierFlags.Private */;
                            break;
                        case "static":
                            classElementModifierFlags = classElementModifierFlags | 32 /* ModifierFlags.Static */;
                            break;
                        case "override":
                            classElementModifierFlags = classElementModifierFlags | 16384 /* ModifierFlags.Override */;
                            break;
                    }
                }
                if (ts.isClassStaticBlockDeclaration(classElement)) {
                    classElementModifierFlags |= 32 /* ModifierFlags.Static */;
                }
                // No member list for private methods
                if (!(classElementModifierFlags & 8 /* ModifierFlags.Private */)) {
                    // List of property symbols of base type that are not private and already implemented
                    var baseTypeNodes = ts.isClassLike(decl) && classElementModifierFlags & 16384 /* ModifierFlags.Override */ ? ts.singleElementArray(ts.getEffectiveBaseTypeNode(decl)) : ts.getAllSuperTypeNodes(decl);
                    var baseSymbols = ts.flatMap(baseTypeNodes, function (baseTypeNode) {
                        var type = typeChecker.getTypeAtLocation(baseTypeNode);
                        return classElementModifierFlags & 32 /* ModifierFlags.Static */ ?
                            (type === null || type === void 0 ? void 0 : type.symbol) && typeChecker.getPropertiesOfType(typeChecker.getTypeOfSymbolAtLocation(type.symbol, decl)) :
                            type && typeChecker.getPropertiesOfType(type);
                    });
                    symbols = ts.concatenate(symbols, filterClassMembersList(baseSymbols, decl.members, classElementModifierFlags));
                }
                return 1 /* GlobalsSearch.Success */;
            }
            function isConstructorParameterCompletion(node) {
                return !!node.parent && ts.isParameter(node.parent) && ts.isConstructorDeclaration(node.parent.parent)
                    && (ts.isParameterPropertyModifier(node.kind) || ts.isDeclarationName(node));
            }
            /**
             * Returns the immediate owning class declaration of a context token,
             * on the condition that one exists and that the context implies completion should be given.
             */
            function tryGetConstructorLikeCompletionContainer(contextToken) {
                if (contextToken) {
                    var parent = contextToken.parent;
                    switch (contextToken.kind) {
                        case 20 /* SyntaxKind.OpenParenToken */:
                        case 27 /* SyntaxKind.CommaToken */:
                            return ts.isConstructorDeclaration(contextToken.parent) ? contextToken.parent : undefined;
                        default:
                            if (isConstructorParameterCompletion(contextToken)) {
                                return parent.parent;
                            }
                    }
                }
                return undefined;
            }
            function tryGetFunctionLikeBodyCompletionContainer(contextToken) {
                if (contextToken) {
                    var prev_1;
                    var container = ts.findAncestor(contextToken.parent, function (node) {
                        if (ts.isClassLike(node)) {
                            return "quit";
                        }
                        if (ts.isFunctionLikeDeclaration(node) && prev_1 === node.body) {
                            return true;
                        }
                        prev_1 = node;
                        return false;
                    });
                    return container && container;
                }
            }
            function tryGetContainingJsxElement(contextToken) {
                if (contextToken) {
                    var parent = contextToken.parent;
                    switch (contextToken.kind) {
                        case 31 /* SyntaxKind.GreaterThanToken */: // End of a type argument list
                        case 30 /* SyntaxKind.LessThanSlashToken */:
                        case 43 /* SyntaxKind.SlashToken */:
                        case 79 /* SyntaxKind.Identifier */:
                        case 206 /* SyntaxKind.PropertyAccessExpression */:
                        case 286 /* SyntaxKind.JsxAttributes */:
                        case 285 /* SyntaxKind.JsxAttribute */:
                        case 287 /* SyntaxKind.JsxSpreadAttribute */:
                            if (parent && (parent.kind === 279 /* SyntaxKind.JsxSelfClosingElement */ || parent.kind === 280 /* SyntaxKind.JsxOpeningElement */)) {
                                if (contextToken.kind === 31 /* SyntaxKind.GreaterThanToken */) {
                                    var precedingToken = ts.findPrecedingToken(contextToken.pos, sourceFile, /*startNode*/ undefined);
                                    if (!parent.typeArguments || (precedingToken && precedingToken.kind === 43 /* SyntaxKind.SlashToken */))
                                        break;
                                }
                                return parent;
                            }
                            else if (parent.kind === 285 /* SyntaxKind.JsxAttribute */) {
                                // Currently we parse JsxOpeningLikeElement as:
                                //      JsxOpeningLikeElement
                                //          attributes: JsxAttributes
                                //             properties: NodeArray<JsxAttributeLike>
                                return parent.parent.parent;
                            }
                            break;
                        // The context token is the closing } or " of an attribute, which means
                        // its parent is a JsxExpression, whose parent is a JsxAttribute,
                        // whose parent is a JsxOpeningLikeElement
                        case 10 /* SyntaxKind.StringLiteral */:
                            if (parent && ((parent.kind === 285 /* SyntaxKind.JsxAttribute */) || (parent.kind === 287 /* SyntaxKind.JsxSpreadAttribute */))) {
                                // Currently we parse JsxOpeningLikeElement as:
                                //      JsxOpeningLikeElement
                                //          attributes: JsxAttributes
                                //             properties: NodeArray<JsxAttributeLike>
                                return parent.parent.parent;
                            }
                            break;
                        case 19 /* SyntaxKind.CloseBraceToken */:
                            if (parent &&
                                parent.kind === 288 /* SyntaxKind.JsxExpression */ &&
                                parent.parent && parent.parent.kind === 285 /* SyntaxKind.JsxAttribute */) {
                                // Currently we parse JsxOpeningLikeElement as:
                                //      JsxOpeningLikeElement
                                //          attributes: JsxAttributes
                                //             properties: NodeArray<JsxAttributeLike>
                                //                  each JsxAttribute can have initializer as JsxExpression
                                return parent.parent.parent.parent;
                            }
                            if (parent && parent.kind === 287 /* SyntaxKind.JsxSpreadAttribute */) {
                                // Currently we parse JsxOpeningLikeElement as:
                                //      JsxOpeningLikeElement
                                //          attributes: JsxAttributes
                                //             properties: NodeArray<JsxAttributeLike>
                                return parent.parent.parent;
                            }
                            break;
                    }
                }
                return undefined;
            }
            /**
             * @returns true if we are certain that the currently edited location must define a new location; false otherwise.
             */
            function isSolelyIdentifierDefinitionLocation(contextToken) {
                var parent = contextToken.parent;
                var containingNodeKind = parent.kind;
                switch (contextToken.kind) {
                    case 27 /* SyntaxKind.CommaToken */:
                        return containingNodeKind === 254 /* SyntaxKind.VariableDeclaration */ ||
                            isVariableDeclarationListButNotTypeArgument(contextToken) ||
                            containingNodeKind === 237 /* SyntaxKind.VariableStatement */ ||
                            containingNodeKind === 260 /* SyntaxKind.EnumDeclaration */ || // enum a { foo, |
                            isFunctionLikeButNotConstructor(containingNodeKind) ||
                            containingNodeKind === 258 /* SyntaxKind.InterfaceDeclaration */ || // interface A<T, |
                            containingNodeKind === 202 /* SyntaxKind.ArrayBindingPattern */ || // var [x, y|
                            containingNodeKind === 259 /* SyntaxKind.TypeAliasDeclaration */ || // type Map, K, |
                            // class A<T, |
                            // var C = class D<T, |
                            (ts.isClassLike(parent) &&
                                !!parent.typeParameters &&
                                parent.typeParameters.end >= contextToken.pos);
                    case 24 /* SyntaxKind.DotToken */:
                        return containingNodeKind === 202 /* SyntaxKind.ArrayBindingPattern */; // var [.|
                    case 58 /* SyntaxKind.ColonToken */:
                        return containingNodeKind === 203 /* SyntaxKind.BindingElement */; // var {x :html|
                    case 22 /* SyntaxKind.OpenBracketToken */:
                        return containingNodeKind === 202 /* SyntaxKind.ArrayBindingPattern */; // var [x|
                    case 20 /* SyntaxKind.OpenParenToken */:
                        return containingNodeKind === 292 /* SyntaxKind.CatchClause */ ||
                            isFunctionLikeButNotConstructor(containingNodeKind);
                    case 18 /* SyntaxKind.OpenBraceToken */:
                        return containingNodeKind === 260 /* SyntaxKind.EnumDeclaration */; // enum a { |
                    case 29 /* SyntaxKind.LessThanToken */:
                        return containingNodeKind === 257 /* SyntaxKind.ClassDeclaration */ || // class A< |
                            containingNodeKind === 226 /* SyntaxKind.ClassExpression */ || // var C = class D< |
                            containingNodeKind === 258 /* SyntaxKind.InterfaceDeclaration */ || // interface A< |
                            containingNodeKind === 259 /* SyntaxKind.TypeAliasDeclaration */ || // type List< |
                            ts.isFunctionLikeKind(containingNodeKind);
                    case 124 /* SyntaxKind.StaticKeyword */:
                        return containingNodeKind === 167 /* SyntaxKind.PropertyDeclaration */ && !ts.isClassLike(parent.parent);
                    case 25 /* SyntaxKind.DotDotDotToken */:
                        return containingNodeKind === 164 /* SyntaxKind.Parameter */ ||
                            (!!parent.parent && parent.parent.kind === 202 /* SyntaxKind.ArrayBindingPattern */); // var [...z|
                    case 123 /* SyntaxKind.PublicKeyword */:
                    case 121 /* SyntaxKind.PrivateKeyword */:
                    case 122 /* SyntaxKind.ProtectedKeyword */:
                        return containingNodeKind === 164 /* SyntaxKind.Parameter */ && !ts.isConstructorDeclaration(parent.parent);
                    case 127 /* SyntaxKind.AsKeyword */:
                        return containingNodeKind === 270 /* SyntaxKind.ImportSpecifier */ ||
                            containingNodeKind === 275 /* SyntaxKind.ExportSpecifier */ ||
                            containingNodeKind === 268 /* SyntaxKind.NamespaceImport */;
                    case 136 /* SyntaxKind.GetKeyword */:
                    case 149 /* SyntaxKind.SetKeyword */:
                        return !isFromObjectTypeDeclaration(contextToken);
                    case 79 /* SyntaxKind.Identifier */:
                        if (containingNodeKind === 270 /* SyntaxKind.ImportSpecifier */ &&
                            contextToken === parent.name &&
                            contextToken.text === "type") {
                            // import { type | }
                            return false;
                        }
                        break;
                    case 84 /* SyntaxKind.ClassKeyword */:
                    case 92 /* SyntaxKind.EnumKeyword */:
                    case 118 /* SyntaxKind.InterfaceKeyword */:
                    case 98 /* SyntaxKind.FunctionKeyword */:
                    case 113 /* SyntaxKind.VarKeyword */:
                    case 100 /* SyntaxKind.ImportKeyword */:
                    case 119 /* SyntaxKind.LetKeyword */:
                    case 85 /* SyntaxKind.ConstKeyword */:
                    case 137 /* SyntaxKind.InferKeyword */:
                        return true;
                    case 152 /* SyntaxKind.TypeKeyword */:
                        // import { type foo| }
                        return containingNodeKind !== 270 /* SyntaxKind.ImportSpecifier */;
                    case 41 /* SyntaxKind.AsteriskToken */:
                        return ts.isFunctionLike(contextToken.parent) && !ts.isMethodDeclaration(contextToken.parent);
                }
                // If the previous token is keyword corresponding to class member completion keyword
                // there will be completion available here
                if (isClassMemberCompletionKeyword(keywordForNode(contextToken)) && isFromObjectTypeDeclaration(contextToken)) {
                    return false;
                }
                if (isConstructorParameterCompletion(contextToken)) {
                    // constructor parameter completion is available only if
                    // - its modifier of the constructor parameter or
                    // - its name of the parameter and not being edited
                    // eg. constructor(a |<- this shouldnt show completion
                    if (!ts.isIdentifier(contextToken) ||
                        ts.isParameterPropertyModifier(keywordForNode(contextToken)) ||
                        isCurrentlyEditingNode(contextToken)) {
                        return false;
                    }
                }
                // Previous token may have been a keyword that was converted to an identifier.
                switch (keywordForNode(contextToken)) {
                    case 126 /* SyntaxKind.AbstractKeyword */:
                    case 84 /* SyntaxKind.ClassKeyword */:
                    case 85 /* SyntaxKind.ConstKeyword */:
                    case 135 /* SyntaxKind.DeclareKeyword */:
                    case 92 /* SyntaxKind.EnumKeyword */:
                    case 98 /* SyntaxKind.FunctionKeyword */:
                    case 118 /* SyntaxKind.InterfaceKeyword */:
                    case 119 /* SyntaxKind.LetKeyword */:
                    case 121 /* SyntaxKind.PrivateKeyword */:
                    case 122 /* SyntaxKind.ProtectedKeyword */:
                    case 123 /* SyntaxKind.PublicKeyword */:
                    case 124 /* SyntaxKind.StaticKeyword */:
                    case 113 /* SyntaxKind.VarKeyword */:
                        return true;
                    case 131 /* SyntaxKind.AsyncKeyword */:
                        return ts.isPropertyDeclaration(contextToken.parent);
                }
                // If we are inside a class declaration, and `constructor` is totally not present,
                // but we request a completion manually at a whitespace...
                var ancestorClassLike = ts.findAncestor(contextToken.parent, ts.isClassLike);
                if (ancestorClassLike && contextToken === previousToken && isPreviousPropertyDeclarationTerminated(contextToken, position)) {
                    return false; // Don't block completions.
                }
                var ancestorPropertyDeclaraion = ts.getAncestor(contextToken.parent, 167 /* SyntaxKind.PropertyDeclaration */);
                // If we are inside a class declaration and typing `constructor` after property declaration...
                if (ancestorPropertyDeclaraion
                    && contextToken !== previousToken
                    && ts.isClassLike(previousToken.parent.parent)
                    // And the cursor is at the token...
                    && position <= previousToken.end) {
                    // If we are sure that the previous property declaration is terminated according to newline or semicolon...
                    if (isPreviousPropertyDeclarationTerminated(contextToken, previousToken.end)) {
                        return false; // Don't block completions.
                    }
                    else if (contextToken.kind !== 63 /* SyntaxKind.EqualsToken */
                        // Should not block: `class C { blah = c/**/ }`
                        // But should block: `class C { blah = somewhat c/**/ }` and `class C { blah: SomeType c/**/ }`
                        && (ts.isInitializedProperty(ancestorPropertyDeclaraion)
                            || ts.hasType(ancestorPropertyDeclaraion))) {
                        return true;
                    }
                }
                return ts.isDeclarationName(contextToken)
                    && !ts.isShorthandPropertyAssignment(contextToken.parent)
                    && !ts.isJsxAttribute(contextToken.parent)
                    // Don't block completions if we're in `class C /**/`, because we're *past* the end of the identifier and might want to complete `extends`.
                    // If `contextToken !== previousToken`, this is `class C ex/**/`.
                    && !(ts.isClassLike(contextToken.parent) && (contextToken !== previousToken || position > previousToken.end));
            }
            function isPreviousPropertyDeclarationTerminated(contextToken, position) {
                return contextToken.kind !== 63 /* SyntaxKind.EqualsToken */ &&
                    (contextToken.kind === 26 /* SyntaxKind.SemicolonToken */
                        || !ts.positionsAreOnSameLine(contextToken.end, position, sourceFile));
            }
            function isFunctionLikeButNotConstructor(kind) {
                return ts.isFunctionLikeKind(kind) && kind !== 171 /* SyntaxKind.Constructor */;
            }
            function isDotOfNumericLiteral(contextToken) {
                if (contextToken.kind === 8 /* SyntaxKind.NumericLiteral */) {
                    var text = contextToken.getFullText();
                    return text.charAt(text.length - 1) === ".";
                }
                return false;
            }
            function isVariableDeclarationListButNotTypeArgument(node) {
                return node.parent.kind === 255 /* SyntaxKind.VariableDeclarationList */
                    && !ts.isPossiblyTypeArgumentPosition(node, sourceFile, typeChecker);
            }
            /**
             * Filters out completion suggestions for named imports or exports.
             *
             * @returns Symbols to be suggested in an object binding pattern or object literal expression, barring those whose declarations
             *          do not occur at the current position and have not otherwise been typed.
             */
            function filterObjectMembersList(contextualMemberSymbols, existingMembers) {
                if (existingMembers.length === 0) {
                    return contextualMemberSymbols;
                }
                var membersDeclaredBySpreadAssignment = new ts.Set();
                var existingMemberNames = new ts.Set();
                for (var _i = 0, existingMembers_1 = existingMembers; _i < existingMembers_1.length; _i++) {
                    var m = existingMembers_1[_i];
                    // Ignore omitted expressions for missing members
                    if (m.kind !== 296 /* SyntaxKind.PropertyAssignment */ &&
                        m.kind !== 297 /* SyntaxKind.ShorthandPropertyAssignment */ &&
                        m.kind !== 203 /* SyntaxKind.BindingElement */ &&
                        m.kind !== 169 /* SyntaxKind.MethodDeclaration */ &&
                        m.kind !== 172 /* SyntaxKind.GetAccessor */ &&
                        m.kind !== 173 /* SyntaxKind.SetAccessor */ &&
                        m.kind !== 298 /* SyntaxKind.SpreadAssignment */) {
                        continue;
                    }
                    // If this is the current item we are editing right now, do not filter it out
                    if (isCurrentlyEditingNode(m)) {
                        continue;
                    }
                    var existingName = void 0;
                    if (ts.isSpreadAssignment(m)) {
                        setMembersDeclaredBySpreadAssignment(m, membersDeclaredBySpreadAssignment);
                    }
                    else if (ts.isBindingElement(m) && m.propertyName) {
                        // include only identifiers in completion list
                        if (m.propertyName.kind === 79 /* SyntaxKind.Identifier */) {
                            existingName = m.propertyName.escapedText;
                        }
                    }
                    else {
                        // TODO: Account for computed property name
                        // NOTE: if one only performs this step when m.name is an identifier,
                        // things like '__proto__' are not filtered out.
                        var name = ts.getNameOfDeclaration(m);
                        existingName = name && ts.isPropertyNameLiteral(name) ? ts.getEscapedTextOfIdentifierOrLiteral(name) : undefined;
                    }
                    if (existingName !== undefined) {
                        existingMemberNames.add(existingName);
                    }
                }
                var filteredSymbols = contextualMemberSymbols.filter(function (m) { return !existingMemberNames.has(m.escapedName); });
                setSortTextToMemberDeclaredBySpreadAssignment(membersDeclaredBySpreadAssignment, filteredSymbols);
                return filteredSymbols;
            }
            function setMembersDeclaredBySpreadAssignment(declaration, membersDeclaredBySpreadAssignment) {
                var expression = declaration.expression;
                var symbol = typeChecker.getSymbolAtLocation(expression);
                var type = symbol && typeChecker.getTypeOfSymbolAtLocation(symbol, expression);
                var properties = type && type.properties;
                if (properties) {
                    properties.forEach(function (property) {
                        membersDeclaredBySpreadAssignment.add(property.name);
                    });
                }
            }
            // Set SortText to OptionalMember if it is an optional member
            function setSortTextToOptionalMember() {
                symbols.forEach(function (m) {
                    var _a;
                    if (m.flags & 16777216 /* SymbolFlags.Optional */) {
                        var symbolId = ts.getSymbolId(m);
                        symbolToSortTextMap[symbolId] = (_a = symbolToSortTextMap[symbolId]) !== null && _a !== void 0 ? _a : Completions.SortText.OptionalMember;
                    }
                });
            }
            // Set SortText to MemberDeclaredBySpreadAssignment if it is fulfilled by spread assignment
            function setSortTextToMemberDeclaredBySpreadAssignment(membersDeclaredBySpreadAssignment, contextualMemberSymbols) {
                if (membersDeclaredBySpreadAssignment.size === 0) {
                    return;
                }
                for (var _i = 0, contextualMemberSymbols_1 = contextualMemberSymbols; _i < contextualMemberSymbols_1.length; _i++) {
                    var contextualMemberSymbol = contextualMemberSymbols_1[_i];
                    if (membersDeclaredBySpreadAssignment.has(contextualMemberSymbol.name)) {
                        symbolToSortTextMap[ts.getSymbolId(contextualMemberSymbol)] = Completions.SortText.MemberDeclaredBySpreadAssignment;
                    }
                }
            }
            function transformObjectLiteralMembersSortText(start) {
                var _a;
                for (var i = start; i < symbols.length; i++) {
                    var symbol = symbols[i];
                    var symbolId = ts.getSymbolId(symbol);
                    var origin = symbolToOriginInfoMap === null || symbolToOriginInfoMap === void 0 ? void 0 : symbolToOriginInfoMap[i];
                    var target = ts.getEmitScriptTarget(compilerOptions);
                    var displayName = getCompletionEntryDisplayNameForSymbol(symbol, target, origin, 0 /* CompletionKind.ObjectPropertyDeclaration */, 
                    /*jsxIdentifierExpected*/ false);
                    if (displayName) {
                        var originalSortText = (_a = symbolToSortTextMap[symbolId]) !== null && _a !== void 0 ? _a : Completions.SortText.LocationPriority;
                        var name = displayName.name;
                        symbolToSortTextMap[symbolId] = Completions.SortText.ObjectLiteralProperty(originalSortText, name);
                    }
                }
            }
            /**
             * Filters out completion suggestions for class elements.
             *
             * @returns Symbols to be suggested in an class element depending on existing memebers and symbol flags
             */
            function filterClassMembersList(baseSymbols, existingMembers, currentClassElementModifierFlags) {
                var existingMemberNames = new ts.Set();
                for (var _i = 0, existingMembers_2 = existingMembers; _i < existingMembers_2.length; _i++) {
                    var m = existingMembers_2[_i];
                    // Ignore omitted expressions for missing members
                    if (m.kind !== 167 /* SyntaxKind.PropertyDeclaration */ &&
                        m.kind !== 169 /* SyntaxKind.MethodDeclaration */ &&
                        m.kind !== 172 /* SyntaxKind.GetAccessor */ &&
                        m.kind !== 173 /* SyntaxKind.SetAccessor */) {
                        continue;
                    }
                    // If this is the current item we are editing right now, do not filter it out
                    if (isCurrentlyEditingNode(m)) {
                        continue;
                    }
                    // Dont filter member even if the name matches if it is declared private in the list
                    if (ts.hasEffectiveModifier(m, 8 /* ModifierFlags.Private */)) {
                        continue;
                    }
                    // do not filter it out if the static presence doesnt match
                    if (ts.isStatic(m) !== !!(currentClassElementModifierFlags & 32 /* ModifierFlags.Static */)) {
                        continue;
                    }
                    var existingName = ts.getPropertyNameForPropertyNameNode(m.name);
                    if (existingName) {
                        existingMemberNames.add(existingName);
                    }
                }
                return baseSymbols.filter(function (propertySymbol) {
                    return !existingMemberNames.has(propertySymbol.escapedName) &&
                        !!propertySymbol.declarations &&
                        !(ts.getDeclarationModifierFlagsFromSymbol(propertySymbol) & 8 /* ModifierFlags.Private */) &&
                        !(propertySymbol.valueDeclaration && ts.isPrivateIdentifierClassElementDeclaration(propertySymbol.valueDeclaration));
                });
            }
            /**
             * Filters out completion suggestions from 'symbols' according to existing JSX attributes.
             *
             * @returns Symbols to be suggested in a JSX element, barring those whose attributes
             *          do not occur at the current position and have not otherwise been typed.
             */
            function filterJsxAttributes(symbols, attributes) {
                var seenNames = new ts.Set();
                var membersDeclaredBySpreadAssignment = new ts.Set();
                for (var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++) {
                    var attr = attributes_1[_i];
                    // If this is the current item we are editing right now, do not filter it out
                    if (isCurrentlyEditingNode(attr)) {
                        continue;
                    }
                    if (attr.kind === 285 /* SyntaxKind.JsxAttribute */) {
                        seenNames.add(attr.name.escapedText);
                    }
                    else if (ts.isJsxSpreadAttribute(attr)) {
                        setMembersDeclaredBySpreadAssignment(attr, membersDeclaredBySpreadAssignment);
                    }
                }
                var filteredSymbols = symbols.filter(function (a) { return !seenNames.has(a.escapedName); });
                setSortTextToMemberDeclaredBySpreadAssignment(membersDeclaredBySpreadAssignment, filteredSymbols);
                return filteredSymbols;
            }
            function isCurrentlyEditingNode(node) {
                return node.getStart(sourceFile) <= position && position <= node.getEnd();
            }
        }
        /**
         * Returns the immediate owning object literal or binding pattern of a context token,
         * on the condition that one exists and that the context implies completion should be given.
         */
        function tryGetObjectLikeCompletionContainer(contextToken) {
            if (contextToken) {
                var parent = contextToken.parent;
                switch (contextToken.kind) {
                    case 18 /* SyntaxKind.OpenBraceToken */: // const x = { |
                    case 27 /* SyntaxKind.CommaToken */: // const x = { a: 0, |
                        if (ts.isObjectLiteralExpression(parent) || ts.isObjectBindingPattern(parent)) {
                            return parent;
                        }
                        break;
                    case 41 /* SyntaxKind.AsteriskToken */:
                        return ts.isMethodDeclaration(parent) ? ts.tryCast(parent.parent, ts.isObjectLiteralExpression) : undefined;
                    case 79 /* SyntaxKind.Identifier */:
                        return contextToken.text === "async" && ts.isShorthandPropertyAssignment(contextToken.parent)
                            ? contextToken.parent.parent : undefined;
                }
            }
            return undefined;
        }
        function getRelevantTokens(position, sourceFile) {
            var previousToken = ts.findPrecedingToken(position, sourceFile);
            if (previousToken && position <= previousToken.end && (ts.isMemberName(previousToken) || ts.isKeyword(previousToken.kind))) {
                var contextToken = ts.findPrecedingToken(previousToken.getFullStart(), sourceFile, /*startNode*/ undefined); // TODO: GH#18217
                return { contextToken: contextToken, previousToken: previousToken };
            }
            return { contextToken: previousToken, previousToken: previousToken };
        }
        function getAutoImportSymbolFromCompletionEntryData(name, data, program, host) {
            var containingProgram = data.isPackageJsonImport ? host.getPackageJsonAutoImportProvider() : program;
            var checker = containingProgram.getTypeChecker();
            var moduleSymbol = data.ambientModuleName ? checker.tryFindAmbientModule(data.ambientModuleName) :
                data.fileName ? checker.getMergedSymbol(ts.Debug.checkDefined(containingProgram.getSourceFile(data.fileName)).symbol) :
                    undefined;
            if (!moduleSymbol)
                return undefined;
            var symbol = data.exportName === "export=" /* InternalSymbolName.ExportEquals */
                ? checker.resolveExternalModuleSymbol(moduleSymbol)
                : checker.tryGetMemberInModuleExportsAndProperties(data.exportName, moduleSymbol);
            if (!symbol)
                return undefined;
            var isDefaultExport = data.exportName === "default" /* InternalSymbolName.Default */;
            symbol = isDefaultExport && ts.getLocalSymbolForExportDefault(symbol) || symbol;
            return { symbol: symbol, origin: completionEntryDataToSymbolOriginInfo(data, name, moduleSymbol) };
        }
        function getCompletionEntryDisplayNameForSymbol(symbol, target, origin, kind, jsxIdentifierExpected) {
            var name = originIncludesSymbolName(origin) ? origin.symbolName : symbol.name;
            if (name === undefined
                // If the symbol is external module, don't show it in the completion list
                // (i.e declare module "http" { const x; } | // <= request completion here, "http" should not be there)
                || symbol.flags & 1536 /* SymbolFlags.Module */ && ts.isSingleOrDoubleQuote(name.charCodeAt(0))
                // If the symbol is the internal name of an ES symbol, it is not a valid entry. Internal names for ES symbols start with "__@"
                || ts.isKnownSymbol(symbol)) {
                return undefined;
            }
            var validNameResult = { name: name, needsConvertPropertyAccess: false };
            if (ts.isIdentifierText(name, target, jsxIdentifierExpected ? 1 /* LanguageVariant.JSX */ : 0 /* LanguageVariant.Standard */) || symbol.valueDeclaration && ts.isPrivateIdentifierClassElementDeclaration(symbol.valueDeclaration)) {
                return validNameResult;
            }
            switch (kind) {
                case 3 /* CompletionKind.MemberLike */:
                    return undefined;
                case 0 /* CompletionKind.ObjectPropertyDeclaration */:
                    // TODO: GH#18169
                    return { name: JSON.stringify(name), needsConvertPropertyAccess: false };
                case 2 /* CompletionKind.PropertyAccess */:
                case 1 /* CompletionKind.Global */: // For a 'this.' completion it will be in a global context, but may have a non-identifier name.
                    // Don't add a completion for a name starting with a space. See https://github.com/Microsoft/TypeScript/pull/20547
                    return name.charCodeAt(0) === 32 /* CharacterCodes.space */ ? undefined : { name: name, needsConvertPropertyAccess: true };
                case 5 /* CompletionKind.None */:
                case 4 /* CompletionKind.String */:
                    return validNameResult;
                default:
                    ts.Debug.assertNever(kind);
            }
        }
        // A cache of completion entries for keywords, these do not change between sessions
        var _keywordCompletions = [];
        var allKeywordsCompletions = ts.memoize(function () {
            var res = [];
            for (var i = 81 /* SyntaxKind.FirstKeyword */; i <= 160 /* SyntaxKind.LastKeyword */; i++) {
                res.push({
                    name: ts.tokenToString(i),
                    kind: "keyword" /* ScriptElementKind.keyword */,
                    kindModifiers: "" /* ScriptElementKindModifier.none */,
                    sortText: Completions.SortText.GlobalsOrKeywords
                });
            }
            return res;
        });
        function getKeywordCompletions(keywordFilter, filterOutTsOnlyKeywords) {
            if (!filterOutTsOnlyKeywords)
                return getTypescriptKeywordCompletions(keywordFilter);
            var index = keywordFilter + 8 /* KeywordCompletionFilters.Last */ + 1;
            return _keywordCompletions[index] ||
                (_keywordCompletions[index] = getTypescriptKeywordCompletions(keywordFilter)
                    .filter(function (entry) { return !isTypeScriptOnlyKeyword(ts.stringToToken(entry.name)); }));
        }
        function getTypescriptKeywordCompletions(keywordFilter) {
            return _keywordCompletions[keywordFilter] || (_keywordCompletions[keywordFilter] = allKeywordsCompletions().filter(function (entry) {
                var kind = ts.stringToToken(entry.name);
                switch (keywordFilter) {
                    case 0 /* KeywordCompletionFilters.None */:
                        return false;
                    case 1 /* KeywordCompletionFilters.All */:
                        return isFunctionLikeBodyKeyword(kind)
                            || kind === 135 /* SyntaxKind.DeclareKeyword */
                            || kind === 141 /* SyntaxKind.ModuleKeyword */
                            || kind === 152 /* SyntaxKind.TypeKeyword */
                            || kind === 142 /* SyntaxKind.NamespaceKeyword */
                            || kind === 126 /* SyntaxKind.AbstractKeyword */
                            || ts.isTypeKeyword(kind) && kind !== 153 /* SyntaxKind.UndefinedKeyword */;
                    case 5 /* KeywordCompletionFilters.FunctionLikeBodyKeywords */:
                        return isFunctionLikeBodyKeyword(kind);
                    case 2 /* KeywordCompletionFilters.ClassElementKeywords */:
                        return isClassMemberCompletionKeyword(kind);
                    case 3 /* KeywordCompletionFilters.InterfaceElementKeywords */:
                        return isInterfaceOrTypeLiteralCompletionKeyword(kind);
                    case 4 /* KeywordCompletionFilters.ConstructorParameterKeywords */:
                        return ts.isParameterPropertyModifier(kind);
                    case 6 /* KeywordCompletionFilters.TypeAssertionKeywords */:
                        return ts.isTypeKeyword(kind) || kind === 85 /* SyntaxKind.ConstKeyword */;
                    case 7 /* KeywordCompletionFilters.TypeKeywords */:
                        return ts.isTypeKeyword(kind);
                    case 8 /* KeywordCompletionFilters.TypeKeyword */:
                        return kind === 152 /* SyntaxKind.TypeKeyword */;
                    default:
                        return ts.Debug.assertNever(keywordFilter);
                }
            }));
        }
        function isTypeScriptOnlyKeyword(kind) {
            switch (kind) {
                case 126 /* SyntaxKind.AbstractKeyword */:
                case 130 /* SyntaxKind.AnyKeyword */:
                case 158 /* SyntaxKind.BigIntKeyword */:
                case 133 /* SyntaxKind.BooleanKeyword */:
                case 135 /* SyntaxKind.DeclareKeyword */:
                case 92 /* SyntaxKind.EnumKeyword */:
                case 157 /* SyntaxKind.GlobalKeyword */:
                case 117 /* SyntaxKind.ImplementsKeyword */:
                case 137 /* SyntaxKind.InferKeyword */:
                case 118 /* SyntaxKind.InterfaceKeyword */:
                case 139 /* SyntaxKind.IsKeyword */:
                case 140 /* SyntaxKind.KeyOfKeyword */:
                case 141 /* SyntaxKind.ModuleKeyword */:
                case 142 /* SyntaxKind.NamespaceKeyword */:
                case 143 /* SyntaxKind.NeverKeyword */:
                case 147 /* SyntaxKind.NumberKeyword */:
                case 148 /* SyntaxKind.ObjectKeyword */:
                case 159 /* SyntaxKind.OverrideKeyword */:
                case 121 /* SyntaxKind.PrivateKeyword */:
                case 122 /* SyntaxKind.ProtectedKeyword */:
                case 123 /* SyntaxKind.PublicKeyword */:
                case 145 /* SyntaxKind.ReadonlyKeyword */:
                case 150 /* SyntaxKind.StringKeyword */:
                case 151 /* SyntaxKind.SymbolKeyword */:
                case 152 /* SyntaxKind.TypeKeyword */:
                case 154 /* SyntaxKind.UniqueKeyword */:
                case 155 /* SyntaxKind.UnknownKeyword */:
                    return true;
                default:
                    return false;
            }
        }
        function isInterfaceOrTypeLiteralCompletionKeyword(kind) {
            return kind === 145 /* SyntaxKind.ReadonlyKeyword */;
        }
        function isClassMemberCompletionKeyword(kind) {
            switch (kind) {
                case 126 /* SyntaxKind.AbstractKeyword */:
                case 134 /* SyntaxKind.ConstructorKeyword */:
                case 136 /* SyntaxKind.GetKeyword */:
                case 149 /* SyntaxKind.SetKeyword */:
                case 131 /* SyntaxKind.AsyncKeyword */:
                case 135 /* SyntaxKind.DeclareKeyword */:
                case 159 /* SyntaxKind.OverrideKeyword */:
                    return true;
                default:
                    return ts.isClassMemberModifier(kind);
            }
        }
        function isFunctionLikeBodyKeyword(kind) {
            return kind === 131 /* SyntaxKind.AsyncKeyword */
                || kind === 132 /* SyntaxKind.AwaitKeyword */
                || kind === 127 /* SyntaxKind.AsKeyword */
                || !ts.isContextualKeyword(kind) && !isClassMemberCompletionKeyword(kind);
        }
        function keywordForNode(node) {
            return ts.isIdentifier(node) ? node.originalKeywordKind || 0 /* SyntaxKind.Unknown */ : node.kind;
        }
        function getContextualKeywords(contextToken, position) {
            var entries = [];
            /**
             * An `AssertClause` can come after an import declaration:
             *  import * from "foo" |
             *  import "foo" |
             * or after a re-export declaration that has a module specifier:
             *  export { foo } from "foo" |
             * Source: https://tc39.es/proposal-import-assertions/
             */
            if (contextToken) {
                var file = contextToken.getSourceFile();
                var parent = contextToken.parent;
                var tokenLine = file.getLineAndCharacterOfPosition(contextToken.end).line;
                var currentLine = file.getLineAndCharacterOfPosition(position).line;
                if ((ts.isImportDeclaration(parent) || ts.isExportDeclaration(parent) && parent.moduleSpecifier)
                    && contextToken === parent.moduleSpecifier
                    && tokenLine === currentLine) {
                    entries.push({
                        name: ts.tokenToString(129 /* SyntaxKind.AssertKeyword */),
                        kind: "keyword" /* ScriptElementKind.keyword */,
                        kindModifiers: "" /* ScriptElementKindModifier.none */,
                        sortText: Completions.SortText.GlobalsOrKeywords,
                    });
                }
            }
            return entries;
        }
        /** Get the corresponding JSDocTag node if the position is in a jsDoc comment */
        function getJsDocTagAtPosition(node, position) {
            return ts.findAncestor(node, function (n) {
                return ts.isJSDocTag(n) && ts.rangeContainsPosition(n, position) ? true :
                    ts.isJSDoc(n) ? "quit" : false;
            });
        }
        function getPropertiesForObjectExpression(contextualType, completionsType, obj, checker) {
            var hasCompletionsType = completionsType && completionsType !== contextualType;
            var type = hasCompletionsType && !(completionsType.flags & 3 /* TypeFlags.AnyOrUnknown */)
                ? checker.getUnionType([contextualType, completionsType])
                : contextualType;
            var properties = getApparentProperties(type, obj, checker);
            return type.isClass() && containsNonPublicProperties(properties) ? [] :
                hasCompletionsType ? ts.filter(properties, hasDeclarationOtherThanSelf) : properties;
            // Filter out members whose only declaration is the object literal itself to avoid
            // self-fulfilling completions like:
            //
            // function f<T>(x: T) {}
            // f({ abc/**/: "" }) // `abc` is a member of `T` but only because it declares itself
            function hasDeclarationOtherThanSelf(member) {
                if (!ts.length(member.declarations))
                    return true;
                return ts.some(member.declarations, function (decl) { return decl.parent !== obj; });
            }
        }
        Completions.getPropertiesForObjectExpression = getPropertiesForObjectExpression;
        function getApparentProperties(type, node, checker) {
            if (!type.isUnion())
                return type.getApparentProperties();
            return checker.getAllPossiblePropertiesOfTypes(ts.filter(type.types, function (memberType) {
                return !(memberType.flags & 131068 /* TypeFlags.Primitive */
                    || checker.isArrayLikeType(memberType)
                    || checker.isTypeInvalidDueToUnionDiscriminant(memberType, node)
                    || ts.typeHasCallOrConstructSignatures(memberType, checker)
                    || memberType.isClass() && containsNonPublicProperties(memberType.getApparentProperties()));
            }));
        }
        function containsNonPublicProperties(props) {
            return ts.some(props, function (p) { return !!(ts.getDeclarationModifierFlagsFromSymbol(p) & 24 /* ModifierFlags.NonPublicAccessibilityModifier */); });
        }
        /**
         * Gets all properties on a type, but if that type is a union of several types,
         * excludes array-like types or callable/constructable types.
         */
        function getPropertiesForCompletion(type, checker) {
            return type.isUnion()
                ? ts.Debug.checkEachDefined(checker.getAllPossiblePropertiesOfTypes(type.types), "getAllPossiblePropertiesOfTypes() should all be defined")
                : ts.Debug.checkEachDefined(type.getApparentProperties(), "getApparentProperties() should all be defined");
        }
        /**
         * Returns the immediate owning class declaration of a context token,
         * on the condition that one exists and that the context implies completion should be given.
         */
        function tryGetObjectTypeDeclarationCompletionContainer(sourceFile, contextToken, location, position) {
            // class c { method() { } | method2() { } }
            switch (location.kind) {
                case 348 /* SyntaxKind.SyntaxList */:
                    return ts.tryCast(location.parent, ts.isObjectTypeDeclaration);
                case 1 /* SyntaxKind.EndOfFileToken */:
                    var cls = ts.tryCast(ts.lastOrUndefined(ts.cast(location.parent, ts.isSourceFile).statements), ts.isObjectTypeDeclaration);
                    if (cls && !ts.findChildOfKind(cls, 19 /* SyntaxKind.CloseBraceToken */, sourceFile)) {
                        return cls;
                    }
                    break;
                case 79 /* SyntaxKind.Identifier */: {
                    // class c { public prop = c| }
                    if (ts.isPropertyDeclaration(location.parent) && location.parent.initializer === location) {
                        return undefined;
                    }
                    // class c extends React.Component { a: () => 1\n compon| }
                    if (isFromObjectTypeDeclaration(location)) {
                        return ts.findAncestor(location, ts.isObjectTypeDeclaration);
                    }
                }
            }
            if (!contextToken)
                return undefined;
            // class C { blah; constructor/**/ } and so on
            if (location.kind === 134 /* SyntaxKind.ConstructorKeyword */
                // class C { blah \n constructor/**/ }
                || (ts.isIdentifier(contextToken) && ts.isPropertyDeclaration(contextToken.parent) && ts.isClassLike(location))) {
                return ts.findAncestor(contextToken, ts.isClassLike);
            }
            switch (contextToken.kind) {
                case 63 /* SyntaxKind.EqualsToken */: // class c { public prop = | /* global completions */ }
                    return undefined;
                case 26 /* SyntaxKind.SemicolonToken */: // class c {getValue(): number; | }
                case 19 /* SyntaxKind.CloseBraceToken */: // class c { method() { } | }
                    // class c { method() { } b| }
                    return isFromObjectTypeDeclaration(location) && location.parent.name === location
                        ? location.parent.parent
                        : ts.tryCast(location, ts.isObjectTypeDeclaration);
                case 18 /* SyntaxKind.OpenBraceToken */: // class c { |
                case 27 /* SyntaxKind.CommaToken */: // class c {getValue(): number, | }
                    return ts.tryCast(contextToken.parent, ts.isObjectTypeDeclaration);
                default:
                    if (!isFromObjectTypeDeclaration(contextToken)) {
                        // class c extends React.Component { a: () => 1\n| }
                        if (ts.getLineAndCharacterOfPosition(sourceFile, contextToken.getEnd()).line !== ts.getLineAndCharacterOfPosition(sourceFile, position).line && ts.isObjectTypeDeclaration(location)) {
                            return location;
                        }
                        return undefined;
                    }
                    var isValidKeyword = ts.isClassLike(contextToken.parent.parent) ? isClassMemberCompletionKeyword : isInterfaceOrTypeLiteralCompletionKeyword;
                    return (isValidKeyword(contextToken.kind) || contextToken.kind === 41 /* SyntaxKind.AsteriskToken */ || ts.isIdentifier(contextToken) && isValidKeyword(ts.stringToToken(contextToken.text))) // TODO: GH#18217
                        ? contextToken.parent.parent : undefined;
            }
        }
        function tryGetTypeLiteralNode(node) {
            if (!node)
                return undefined;
            var parent = node.parent;
            switch (node.kind) {
                case 18 /* SyntaxKind.OpenBraceToken */:
                    if (ts.isTypeLiteralNode(parent)) {
                        return parent;
                    }
                    break;
                case 26 /* SyntaxKind.SemicolonToken */:
                case 27 /* SyntaxKind.CommaToken */:
                case 79 /* SyntaxKind.Identifier */:
                    if (parent.kind === 166 /* SyntaxKind.PropertySignature */ && ts.isTypeLiteralNode(parent.parent)) {
                        return parent.parent;
                    }
                    break;
            }
            return undefined;
        }
        function getConstraintOfTypeArgumentProperty(node, checker) {
            if (!node)
                return undefined;
            if (ts.isTypeNode(node) && ts.isTypeReferenceType(node.parent)) {
                return checker.getTypeArgumentConstraint(node);
            }
            var t = getConstraintOfTypeArgumentProperty(node.parent, checker);
            if (!t)
                return undefined;
            switch (node.kind) {
                case 166 /* SyntaxKind.PropertySignature */:
                    return checker.getTypeOfPropertyOfContextualType(t, node.symbol.escapedName);
                case 188 /* SyntaxKind.IntersectionType */:
                case 182 /* SyntaxKind.TypeLiteral */:
                case 187 /* SyntaxKind.UnionType */:
                    return t;
            }
        }
        // TODO: GH#19856 Would like to return `node is Node & { parent: (ClassElement | TypeElement) & { parent: ObjectTypeDeclaration } }` but then compilation takes > 10 minutes
        function isFromObjectTypeDeclaration(node) {
            return node.parent && ts.isClassOrTypeElement(node.parent) && ts.isObjectTypeDeclaration(node.parent.parent);
        }
        function isValidTrigger(sourceFile, triggerCharacter, contextToken, position) {
            switch (triggerCharacter) {
                case ".":
                case "@":
                    return true;
                case '"':
                case "'":
                case "`":
                    // Only automatically bring up completions if this is an opening quote.
                    return !!contextToken && ts.isStringLiteralOrTemplate(contextToken) && position === contextToken.getStart(sourceFile) + 1;
                case "#":
                    return !!contextToken && ts.isPrivateIdentifier(contextToken) && !!ts.getContainingClass(contextToken);
                case "<":
                    // Opening JSX tag
                    return !!contextToken && contextToken.kind === 29 /* SyntaxKind.LessThanToken */ && (!ts.isBinaryExpression(contextToken.parent) || binaryExpressionMayBeOpenTag(contextToken.parent));
                case "/":
                    return !!contextToken && (ts.isStringLiteralLike(contextToken)
                        ? !!ts.tryGetImportFromModuleSpecifier(contextToken)
                        : contextToken.kind === 43 /* SyntaxKind.SlashToken */ && ts.isJsxClosingElement(contextToken.parent));
                case " ":
                    return !!contextToken && ts.isImportKeyword(contextToken) && contextToken.parent.kind === 305 /* SyntaxKind.SourceFile */;
                default:
                    return ts.Debug.assertNever(triggerCharacter);
            }
        }
        function binaryExpressionMayBeOpenTag(_a) {
            var left = _a.left;
            return ts.nodeIsMissing(left);
        }
        /** Determines if a type is exactly the same type resolved by the global 'self', 'global', or 'globalThis'. */
        function isProbablyGlobalType(type, sourceFile, checker) {
            // The type of `self` and `window` is the same in lib.dom.d.ts, but `window` does not exist in
            // lib.webworker.d.ts, so checking against `self` is also a check against `window` when it exists.
            var selfSymbol = checker.resolveName("self", /*location*/ undefined, 111551 /* SymbolFlags.Value */, /*excludeGlobals*/ false);
            if (selfSymbol && checker.getTypeOfSymbolAtLocation(selfSymbol, sourceFile) === type) {
                return true;
            }
            var globalSymbol = checker.resolveName("global", /*location*/ undefined, 111551 /* SymbolFlags.Value */, /*excludeGlobals*/ false);
            if (globalSymbol && checker.getTypeOfSymbolAtLocation(globalSymbol, sourceFile) === type) {
                return true;
            }
            var globalThisSymbol = checker.resolveName("globalThis", /*location*/ undefined, 111551 /* SymbolFlags.Value */, /*excludeGlobals*/ false);
            if (globalThisSymbol && checker.getTypeOfSymbolAtLocation(globalThisSymbol, sourceFile) === type) {
                return true;
            }
            return false;
        }
        function isStaticProperty(symbol) {
            return !!(symbol.valueDeclaration && ts.getEffectiveModifierFlags(symbol.valueDeclaration) & 32 /* ModifierFlags.Static */ && ts.isClassLike(symbol.valueDeclaration.parent));
        }
        function tryGetObjectLiteralContextualType(node, typeChecker) {
            var type = typeChecker.getContextualType(node);
            if (type) {
                return type;
            }
            var parent = ts.walkUpParenthesizedExpressions(node.parent);
            if (ts.isBinaryExpression(parent) && parent.operatorToken.kind === 63 /* SyntaxKind.EqualsToken */ && node === parent.left) {
                // Object literal is assignment pattern: ({ | } = x)
                return typeChecker.getTypeAtLocation(parent);
            }
            if (ts.isExpression(parent)) {
                // f(() => (({ | })));
                return typeChecker.getContextualType(parent);
            }
            return undefined;
        }
        function getImportStatementCompletionInfo(contextToken) {
            var keywordCompletion;
            var isKeywordOnlyCompletion = false;
            var candidate = getCandidate();
            return {
                isKeywordOnlyCompletion: isKeywordOnlyCompletion,
                keywordCompletion: keywordCompletion,
                isNewIdentifierLocation: !!(candidate || keywordCompletion === 152 /* SyntaxKind.TypeKeyword */),
                replacementNode: candidate && ts.rangeIsOnSingleLine(candidate, candidate.getSourceFile())
                    ? candidate
                    : undefined
            };
            function getCandidate() {
                var parent = contextToken.parent;
                if (ts.isImportEqualsDeclaration(parent)) {
                    keywordCompletion = contextToken.kind === 152 /* SyntaxKind.TypeKeyword */ ? undefined : 152 /* SyntaxKind.TypeKeyword */;
                    return isModuleSpecifierMissingOrEmpty(parent.moduleReference) ? parent : undefined;
                }
                if (couldBeTypeOnlyImportSpecifier(parent, contextToken) && canCompleteFromNamedBindings(parent.parent)) {
                    return parent;
                }
                if (ts.isNamedImports(parent) || ts.isNamespaceImport(parent)) {
                    if (!parent.parent.isTypeOnly && (contextToken.kind === 18 /* SyntaxKind.OpenBraceToken */ ||
                        contextToken.kind === 100 /* SyntaxKind.ImportKeyword */ ||
                        contextToken.kind === 27 /* SyntaxKind.CommaToken */)) {
                        keywordCompletion = 152 /* SyntaxKind.TypeKeyword */;
                    }
                    if (canCompleteFromNamedBindings(parent)) {
                        // At `import { ... } |` or `import * as Foo |`, the only possible completion is `from`
                        if (contextToken.kind === 19 /* SyntaxKind.CloseBraceToken */ || contextToken.kind === 79 /* SyntaxKind.Identifier */) {
                            isKeywordOnlyCompletion = true;
                            keywordCompletion = 156 /* SyntaxKind.FromKeyword */;
                        }
                        else {
                            return parent.parent.parent;
                        }
                    }
                    return undefined;
                }
                if (ts.isImportKeyword(contextToken) && ts.isSourceFile(parent)) {
                    // A lone import keyword with nothing following it does not parse as a statement at all
                    keywordCompletion = 152 /* SyntaxKind.TypeKeyword */;
                    return contextToken;
                }
                if (ts.isImportKeyword(contextToken) && ts.isImportDeclaration(parent)) {
                    // `import s| from`
                    keywordCompletion = 152 /* SyntaxKind.TypeKeyword */;
                    return isModuleSpecifierMissingOrEmpty(parent.moduleSpecifier) ? parent : undefined;
                }
                return undefined;
            }
        }
        function couldBeTypeOnlyImportSpecifier(importSpecifier, contextToken) {
            return ts.isImportSpecifier(importSpecifier)
                && (importSpecifier.isTypeOnly || contextToken === importSpecifier.name && ts.isTypeKeywordTokenOrIdentifier(contextToken));
        }
        function canCompleteFromNamedBindings(namedBindings) {
            return isModuleSpecifierMissingOrEmpty(namedBindings.parent.parent.moduleSpecifier)
                && (ts.isNamespaceImport(namedBindings) || namedBindings.elements.length < 2)
                && !namedBindings.parent.name;
        }
        function isModuleSpecifierMissingOrEmpty(specifier) {
            var _a;
            if (ts.nodeIsMissing(specifier))
                return true;
            return !((_a = ts.tryCast(ts.isExternalModuleReference(specifier) ? specifier.expression : specifier, ts.isStringLiteralLike)) === null || _a === void 0 ? void 0 : _a.text);
        }
        function getVariableDeclaration(property) {
            var variableDeclaration = ts.findAncestor(property, function (node) {
                return ts.isFunctionBlock(node) || isArrowFunctionBody(node) || ts.isBindingPattern(node)
                    ? "quit"
                    : ts.isVariableDeclaration(node);
            });
            return variableDeclaration;
        }
        function isArrowFunctionBody(node) {
            return node.parent && ts.isArrowFunction(node.parent) && node.parent.body === node;
        }
        ;
        /** True if symbol is a type or a module containing at least one type. */
        function symbolCanBeReferencedAtTypeLocation(symbol, checker, seenModules) {
            if (seenModules === void 0) { seenModules = new ts.Map(); }
            // Since an alias can be merged with a local declaration, we need to test both the alias and its target.
            // This code used to just test the result of `skipAlias`, but that would ignore any locally introduced meanings.
            return nonAliasCanBeReferencedAtTypeLocation(symbol) || nonAliasCanBeReferencedAtTypeLocation(ts.skipAlias(symbol.exportSymbol || symbol, checker));
            function nonAliasCanBeReferencedAtTypeLocation(symbol) {
                return !!(symbol.flags & 788968 /* SymbolFlags.Type */) || checker.isUnknownSymbol(symbol) ||
                    !!(symbol.flags & 1536 /* SymbolFlags.Module */) && ts.addToSeen(seenModules, ts.getSymbolId(symbol)) &&
                        checker.getExportsOfModule(symbol).some(function (e) { return symbolCanBeReferencedAtTypeLocation(e, checker, seenModules); });
            }
        }
        function isDeprecated(symbol, checker) {
            var declarations = ts.skipAlias(symbol, checker).declarations;
            return !!ts.length(declarations) && ts.every(declarations, ts.isDeprecatedDeclaration);
        }
        /**
         * True if the first character of `lowercaseCharacters` is the first character
         * of some "word" in `identiferString` (where the string is split into "words"
         * by camelCase and snake_case segments), then if the remaining characters of
         * `lowercaseCharacters` appear, in order, in the rest of `identifierString`.
         *
         * True:
         * 'state' in 'useState'
         * 'sae' in 'useState'
         * 'viable' in 'ENVIRONMENT_VARIABLE'
         *
         * False:
         * 'staet' in 'useState'
         * 'tate' in 'useState'
         * 'ment' in 'ENVIRONMENT_VARIABLE'
         */
        function charactersFuzzyMatchInString(identifierString, lowercaseCharacters) {
            if (lowercaseCharacters.length === 0) {
                return true;
            }
            var matchedFirstCharacter = false;
            var prevChar;
            var characterIndex = 0;
            var len = identifierString.length;
            for (var strIndex = 0; strIndex < len; strIndex++) {
                var strChar = identifierString.charCodeAt(strIndex);
                var testChar = lowercaseCharacters.charCodeAt(characterIndex);
                if (strChar === testChar || strChar === toUpperCharCode(testChar)) {
                    matchedFirstCharacter || (matchedFirstCharacter = prevChar === undefined || // Beginning of word
                        97 /* CharacterCodes.a */ <= prevChar && prevChar <= 122 /* CharacterCodes.z */ && 65 /* CharacterCodes.A */ <= strChar && strChar <= 90 /* CharacterCodes.Z */ || // camelCase transition
                        prevChar === 95 /* CharacterCodes._ */ && strChar !== 95 /* CharacterCodes._ */); // snake_case transition
                    if (matchedFirstCharacter) {
                        characterIndex++;
                    }
                    if (characterIndex === lowercaseCharacters.length) {
                        return true;
                    }
                }
                prevChar = strChar;
            }
            // Did not find all characters
            return false;
        }
        function toUpperCharCode(charCode) {
            if (97 /* CharacterCodes.a */ <= charCode && charCode <= 122 /* CharacterCodes.z */) {
                return charCode - 32;
            }
            return charCode;
        }
    })(Completions = ts.Completions || (ts.Completions = {}));
})(ts || (ts = {}));
var ts;
(function (ts) {
    /* @internal */
    var DocumentHighlights;
    (function (DocumentHighlights) {
        function getDocumentHighlights(program, cancellationToken, sourceFile, position, sourceFilesToSearch) {
            var node = ts.getTouchingPropertyName(sourceFile, position);
            if (node.parent && (ts.isJsxOpeningElement(node.parent) && node.parent.tagName === node || ts.isJsxClosingElement(node.parent))) {
                // For a JSX element, just highlight the matching tag, not all references.
                var _a = node.parent.parent, openingElement = _a.openingElement, closingElement = _a.closingElement;
                var highlightSpans = [openingElement, closingElement].map(function (_a) {
                    var tagName = _a.tagName;
                    return getHighlightSpanForNode(tagName, sourceFile);
                });
                return [{ fileName: sourceFile.fileName, highlightSpans: highlightSpans }];
            }
            return getSemanticDocumentHighlights(position, node, program, cancellationToken, sourceFilesToSearch) || getSyntacticDocumentHighlights(node, sourceFile);
        }
        DocumentHighlights.getDocumentHighlights = getDocumentHighlights;
        function getHighlightSpanForNode(node, sourceFile) {
            return {
                fileName: sourceFile.fileName,
                textSpan: ts.createTextSpanFromNode(node, sourceFile),
                kind: "none" /* HighlightSpanKind.none */
            };
        }
        function getSemanticDocumentHighlights(position, node, program, cancellationToken, sourceFilesToSearch) {
            var sourceFilesSet = new ts.Set(sourceFilesToSearch.map(function (f) { return f.fileName; }));
            var referenceEntries = ts.FindAllReferences.getReferenceEntriesForNode(position, node, program, sourceFilesToSearch, cancellationToken, /*options*/ undefined, sourceFilesSet);
            if (!referenceEntries)
                return undefined;
            var map = ts.arrayToMultiMap(referenceEntries.map(ts.FindAllReferences.toHighlightSpan), function (e) { return e.fileName; }, function (e) { return e.span; });
            var getCanonicalFileName = ts.createGetCanonicalFileName(program.useCaseSensitiveFileNames());
            return ts.mapDefined(ts.arrayFrom(map.entries()), function (_a) {
                var fileName = _a[0], highlightSpans = _a[1];
                if (!sourceFilesSet.has(fileName)) {
                    if (!program.redirectTargetsMap.has(ts.toPath(fileName, program.getCurrentDirectory(), getCanonicalFileName))) {
                        return undefined;
                    }
                    var redirectTarget_1 = program.getSourceFile(fileName);
                    var redirect = ts.find(sourceFilesToSearch, function (f) { return !!f.redirectInfo && f.redirectInfo.redirectTarget === redirectTarget_1; });
                    fileName = redirect.fileName;
                    ts.Debug.assert(sourceFilesSet.has(fileName));
                }
                return { fileName: fileName, highlightSpans: highlightSpans };
            });
        }
        function getSyntacticDocumentHighlights(node, sourceFile) {
            var highlightSpans = getHighlightSpans(node, sourceFile);
            return highlightSpans && [{ fileName: sourceFile.fileName, highlightSpans: highlightSpans }];
        }
        function getHighlightSpans(node, sourceFile) {
            switch (node.kind) {
                case 99 /* SyntaxKind.IfKeyword */:
                case 91 /* SyntaxKind.ElseKeyword */:
                    return ts.isIfStatement(node.parent) ? getIfElseOccurrences(node.parent, sourceFile) : undefined;
                case 105 /* SyntaxKind.ReturnKeyword */:
                    return useParent(node.parent, ts.isReturnStatement, getReturnOccurrences);
                case 109 /* SyntaxKind.ThrowKeyword */:
                    return useParent(node.parent, ts.isThrowStatement, getThrowOccurrences);
                case 111 /* SyntaxKind.TryKeyword */:
                case 83 /* SyntaxKind.CatchKeyword */:
                case 96 /* SyntaxKind.FinallyKeyword */:
                    var tryStatement = node.kind === 83 /* SyntaxKind.CatchKeyword */ ? node.parent.parent : node.parent;
          