ass to the builder. Note that messages will stop being forwarded, and if you want
     * to log a builder scheduled from your builder you should forward log events yourself.
     */
    logger?: logging.Logger;
    /**
     * Target to pass to the builder.
     */
    target?: Target;
}
/**
 * The context received as a second argument in your builder.
 */
export interface BuilderContext {
    /**
     * Unique amongst contexts. Contexts instances are not guaranteed to be the same (but it could
     * be the same context), and all the fields in a context could be the same, yet the builder's
     * context could be different. This is the same ID as the corresponding run.
     */
    id: number;
    /**
     * The builder info that called your function. Since the builder info is from the builder.json
     * (or the host), it could contain information that is different than expected.
     */
    builder: BuilderInfo;
    /**
     * A logger that appends messages to a log. This could be a separate interface or completely
     * ignored. `console.log` could also be completely ignored.
     */
    logger: logging.LoggerApi;
    /**
     * The absolute workspace root of this run. This is a system path and will not be normalized;
     * ie. on Windows it will starts with `C:\\` (or whatever drive).
     */
    workspaceRoot: string;
    /**
     * The current directory the user is in. This could be outside the workspace root. This is a
     * system path and will not be normalized; ie. on Windows it will starts with `C:\\` (or
     * whatever drive).
     */
    currentDirectory: string;
    /**
     * The target that was used to run this builder.
     * Target is optional if a builder was ran using `scheduleBuilder()`.
     */
    target?: Target;
    /**
     * Schedule a target in the same workspace. This can be the same target that is being executed
     * right now, but targets of the same name are serialized.
     * Running the same target and waiting for it to end will result in a deadlocking scenario.
     * Targets are considered the same if the project, the target AND the configuration are the same.
     * @param target The target to schedule.
     * @param overrides A set of options to override the workspace set of options.
     * @param scheduleOptions Additional optional scheduling options.
     * @return A promise of a run. It will resolve when all the members of the run are available.
     */
    scheduleTarget(target: Target, overrides?: json.JsonObject, scheduleOptions?: ScheduleOptions): Promise<BuilderRun>;
    /**
     * Schedule a builder by its name. This can be the same builder that is being executed.
     * @param builderName The name of the builder, ie. its `packageName:builderName` tuple.
     * @param options All options to use for the builder (by default empty object). There is no
     *     additional options added, e.g. from the workspace.
     * @param scheduleOptions Additional optional scheduling options.
     * @return A promise of a run. It will resolve when all the members of the run are available.
     */
    scheduleBuilder(builderName: string, options?: json.JsonObject, scheduleOptions?: ScheduleOptions): Promise<BuilderRun>;
    /**
     * Resolve and return options for a specified target. If the target isn't defined in the
     * workspace this will reject the promise. This object will be read directly from the workspace
     * but not validated against the builder of the target.
     * @param target The target to resolve the options of.
     * @return A non-validated object resolved from the workspace.
     */
    getTargetOptions(target: Target): Promise<json.JsonObject>;
    getProjectMetadata(projectName: string): Promise<json.JsonObject>;
    getProjectMetadata(target: Target): Promise<json.JsonObject>;
    /**
     * Resolves and return a builder name. The exact format of the name is up to the host,
     * so it should not be parsed to gather information (it's free form). This string can be
     * used to validate options or schedule a builder directly.
     * @param target The target to resolve the builder name.
     */
    getBuilderNameForTarget(target: Target): Promise<string>;
    /**
     * Validates the options against a builder schema. This uses the same methods as the
     * scheduleTarget and scheduleBrowser methods to validate and apply defaults to the options.
     * It can be generically typed, if you know which interf