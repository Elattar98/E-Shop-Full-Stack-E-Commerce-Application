'use strict';
/**
 * @license Angular v14.2.0-next.0
 * (c) 2010-2022 Google LLC. https://angular.io/
 * License: MIT
 */
(function (factory) {
    typeof define === 'function' && define.amd ? define(factory) :
        factory();
})((function () {
    'use strict';
    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    (function (_global) {
        var AsyncTestZoneSpec = /** @class */ (function () {
            function AsyncTestZoneSpec(finishCallback, failCallback, namePrefix) {
                this.finishCallback = finishCallback;
                this.failCallback = failCallback;
                this._pendingMicroTasks = false;
                this._pendingMacroTasks = false;
                this._alreadyErrored = false;
                this._isSync = false;
                this._existingFinishTimer = null;
                this.entryFunction = null;
                this.runZone = Zone.current;
                this.unresolvedChainedPromiseCount = 0;
                this.supportWaitUnresolvedChainedPromise = false;
                this.name = 'asyncTestZone for ' + namePrefix;
                this.properties = { 'AsyncTestZoneSpec': this };
                this.supportWaitUnresolvedChainedPromise =
                    _global[Zone.__symbol__('supportWaitUnResolvedChainedPromise')] === true;
            }
            AsyncTestZoneSpec.prototype.isUnresolvedChainedPromisePending = function () {
                return this.unresolvedChainedPromiseCount > 0;
            };
            AsyncTestZoneSpec.prototype._finishCallbackIfDone = function () {
                var _this = this;
                // NOTE: Technically the `onHasTask` could fire together with the initial synchronous
                // completion in `onInvoke`. `onHasTask` might call this method when it captured e.g.
                // microtasks in the proxy zone that now complete as part of this async zone run.
                // Consider the following scenario:
                //    1. A test `beforeEach` schedules a microtask in the ProxyZone.
                //    2. An actual empty `it` spec executes in the AsyncTestZone` (using e.g. `waitForAsync`).
                //    3. The `onInvoke` invokes `_finishCallbackIfDone` because the spec runs synchronously.
                //    4. We wait the scheduled timeout (see below) to account for unhandled promises.
                //    5. The microtask from (1) finishes and `onHasTask` is invoked.
                //    --> We register a second `_finishCallbackIfDone` even though we have scheduled a timeout.
                // If the finish timeout from below is already scheduled, terminate the existing scheduled
                // finish invocation, avoiding calling `jasmine` `done` multiple times. *Note* that we would
                // want to schedule a new finish callback in case the task state changes again.
                if (this._existingFinishTimer !== null) {
                    clearTimeout(this._existingFinishTimer);
                    this._existingFinishTimer = null;
                }
                if (!(this._pendingMicroTasks || this._pendingMacroTasks ||
                    (this.supportWaitUnresolvedChainedPromise && this.isUnresolvedChainedPromisePending()))) {
                    // We wait until the next tick because we would like to catch unhandled promises which could
                    // cause test logic to be executed. In such cases we cannot finish with tasks pending then.
                    this.runZone.run(function () {
                        _this._existingFinishTimer = setTimeout(function () {
                            if (!_this._alreadyErrored && !(_this._pendingMicroTasks || _this._pendingMacroTasks)) {
                                _this.finishCallback();
                            }
                        }, 0);
                    });
                }
            };
            AsyncTestZoneSpec.prototype.patchPromiseForTest = function () {
                if (!this.supportWaitUnresolvedChainedPromise) {
                    return;
                }
                var patchPromiseForTest = Promise[Zone.__symbol__('patchPromiseForTest')];
                if (patchPromiseForTest) {
                    patchPromiseForTest();
                }
            };
            AsyncTestZoneSpec.prototype.unPatchPromiseForTest = function () {
                if (!this.supportWaitUnresolvedChainedPromise) {
                    return;
                }
                var unPatchPromiseForTest = Promise[Zone.__symbol__('unPatchPromiseForTest')];
                if (unPatchProm