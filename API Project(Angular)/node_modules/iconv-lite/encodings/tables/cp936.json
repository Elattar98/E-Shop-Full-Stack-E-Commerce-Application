ype for which the metadata is captured.\n   */\n  type: o.Expression;\n\n  /**\n   * An expression representing the Angular decorators that were applied on the class.\n   */\n  decorators: o.Expression;\n\n  /**\n   * An expression representing the Angular decorators applied to constructor parameters, or `null`\n   * if there is no constructor.\n   */\n  ctorParameters: o.Expression|null;\n\n  /**\n   * An expression representing the Angular decorators that were applied on the properties of the\n   * class, or `null` if no properties have decorators.\n   */\n  propDecorators: o.Expression|null;\n}\n\nexport function compileClassMetadata(metadata: R3ClassMetadata): o.Expression {\n  // Generate an ngDevMode guarded call to setClassMetadata with the class identifier and its\n  // metadata.\n  const fnCall = o.importExpr(R3.setClassMetadata).callFn([\n    metadata.type,\n    metadata.decorators,\n    metadata.ctorParameters ?? o.literal(null),\n    metadata.propDecorators ?? o.literal(null),\n  ]);\n  const iife = o.fn([], [devOnlyGuardedExpression(fnCall).toStmt()]);\n  return iife.callFn([]);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as o from '../../output/output_ast';\nimport {R3ClassMetadata} from '../r3_class_metadata_compiler';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {DefinitionMap} from '../view/util';\n\nimport {R3DeclareClassMetadata} from './api';\n\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION = '12.0.0';\n\nexport function compileDeclareClassMetadata(metadata: R3ClassMetadata): o.Expression {\n  const definitionMap = new DefinitionMap<R3DeclareClassMetadata>();\n  definitionMap.set('minVersion', o.literal(MINIMUM_PARTIAL_LINKER_VERSION));\n  definitionMap.set('version', o.literal('14.1.0'));\n  definitionMap.set('ngImport', o.importExpr(R3.core));\n  definitionMap.set('type', metadata.type);\n  definitionMap.set('decorators', metadata.decorators);\n  definitionMap.set('ctorParameters', metadata.ctorParameters);\n  definitionMap.set('propDecorators', metadata.propDecorators);\n\n  return o.importExpr(R3.declareClassMetadata).callFn([definitionMap.toLiteralMap()]);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as o from '../../output/output_ast';\nimport {R3DependencyMetadata} from '../r3_factory';\nimport {DefinitionMap} from '../view/util';\n\nimport {R3DeclareDependencyMetadata} from './api';\n\n/**\n * Creates an array literal expression from the given array, mapping all values to an expression\n * using the provided mapping function. If the array is empty or null, then null is returned.\n *\n * @param values The array to transfer into literal array expression.\n * @param mapper The logic to use for creating an expression for the array's values.\n * @returns An array literal expression representing `values`, or null if `values` is empty or\n * is itself null.\n */\nexport function toOptionalLiteralArray<T>(\n    values: T[]|null, mapper: (value: T) => o.Expression): o.LiteralArrayExpr|null {\n  if (values === null || values.length === 0) {\n    return null;\n  }\n  return o.literalArr(values.map(value => mapper(value)));\n}\n\n/**\n * Creates an object literal expression from the given object, mapping all values to an expression\n * using the provided mapping function. If the object has no keys, then null is returned.\n *\n * @param object The object to transfer into an object literal expression.\n * @param mapper The logic to use for creating an expression for the object's values.\n * @returns An object literal expression representing `object`, or null if `object` does not have\n * any keys.\n */\nexport function toOptionalLiteralMap<T>(\n    object: {[key: string]: T}, mapper: (value: T) => o.Expression): o.LiteralMapExpr|null {\n  const entries = Object.keys(object).map(key => {\n    const value = object[key];\n    return {key, value: mapper(value), quoted: true};\n  });\n\n  if (entries.length > 0) {\n    return o.literalMap(entries);\n  } else {\n    return null;\n  }\n}\n\nexport function compileDependencies(deps: R3DependencyMetadata[]|'invalid'|null): o.LiteralExpr|\n    o.LiteralArrayExpr {\n  if (deps === 'invalid') {\n    // The `deps` can be set to the string \"invalid\"  by the `unwrapConstructorDependencies()`\n    // function, which tries to convert `ConstructorDeps` into `R3DependencyMetadata[]`.\n    return o.literal('invalid');\n  } else if (deps === null) {\n    return o.literal(null);\n  } else {\n    return o.literalArr(deps.map(compileDependency));\n  }\n}\n\nexport function compileDependency(dep: R3DependencyMetadata): o.LiteralMapExpr {\n  const depMeta = new DefinitionMap<R3DeclareDependencyMetadata>();\n  depMeta.set('token', dep.token);\n  if (dep.attributeNameType !== null) {\n    depMeta.set('attribute', o.literal(true));\n  }\n  if (dep.host) {\n    depMeta.set('host', o.literal(true));\n  }\n  if (dep.optional) {\n    depMeta.set('optional', o.literal(true));\n  }\n  if (dep.self) {\n    depMeta.set('self', o.literal(true));\n  }\n  if (dep.skipSelf) {\n    depMeta.set('skipSelf', o.literal(true));\n  }\n  return depMeta.toLiteralMap();\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as o from '../../output/output_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {convertFromMaybeForwardRefExpression, R3CompiledExpression} from '../util';\nimport {R3DirectiveMetadata, R3HostMetadata, R3QueryMetadata} from '../view/api';\nimport {createDirectiveType} from '../view/compiler';\nimport {asLiteral, conditionallyCreateMapObjectLiteral, DefinitionMap} from '../view/util';\n\nimport {R3DeclareDirectiveMetadata, R3DeclareQueryMetadata} from './api';\nimport {toOptionalLiteralMap} from './util';\n\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION = '14.0.0';\n\n/**\n * Compile a directive declaration defined by the `R3DirectiveMetadata`.\n */\nexport function compileDeclareDirectiveFromMetadata(meta: R3DirectiveMetadata):\n    R3CompiledExpression {\n  const definitionMap = createDirectiveDefinitionMap(meta);\n\n  const expression = o.importExpr(R3.declareDirective).callFn([definitionMap.toLiteralMap()]);\n  const type = createDirectiveType(meta);\n\n  return {expression, type, statements: []};\n}\n\n/**\n * Gathers the declaration fields for a directive into a `DefinitionMap`. This allows for reusing\n * this logic for components, as they extend the directive metadata.\n */\nexport function createDirectiveDefinitionMap(meta: R3DirectiveMetadata):\n    DefinitionMap<R3DeclareDirectiveMetadata> {\n  const definitionMap = new DefinitionMap<R3DeclareDirectiveMetadata>();\n\n  definitionMap.set('minVersion', o.literal(MINIMUM_PARTIAL_LINKER_VERSION));\n  definitionMap.set('version', o.literal('14.1.0'));\n\n  // e.g. `type: MyDirective`\n  definitionMap.set('type', meta.internalType);\n\n  if (meta.isStandalone) {\n    definitionMap.set('isStandalone', o.literal(meta.isStandalone));\n  }\n\n  // e.g. `selector: 'some-dir'`\n  if (meta.selector !== null) {\n    definitionMap.set('selector', o.literal(meta.selector));\n  }\n\n  definitionMap.set('inputs', conditionallyCreateMapObjectLiteral(meta.inputs, true));\n  definitionMap.set('outputs', conditionallyCreateMapObjectLiteral(meta.outputs));\n\n  definitionMap.set('host', compileHostMetadata(meta.host));\n\n  definitionMap.set('providers', meta.providers);\n\n  if (meta.queries.length > 0) {\n    definitionMap.set('queries', o.literalArr(meta.queries.map(compileQuery)));\n  }\n  if (meta.viewQueries.length > 0) {\n    definitionMap.set('viewQueries', o.literalArr(meta.viewQueries.map(compileQuery)));\n  }\n\n  if (meta.exportAs !== null) {\n    definitionMap.set('exportAs', asLiteral(meta.exportAs));\n  }\n\n  if (meta.usesInheritance) {\n    definitionMap.set('usesInheritance', o.literal(true));\n  }\n  if (meta.lifecycle.usesOnChanges) {\n    definitionMap.set('usesOnChanges', o.literal(true));\n  }\n\n  definitionMap.set('ngImport', o.importExpr(R3.core));\n\n  return definitionMap;\n}\n\n/**\n * Compiles the metadata of a single query into its partial declaration form as declared\n * by `R3DeclareQueryMetadata`.\n */\nfunction compileQuery(query: R3QueryMetadata): o.LiteralMapExpr {\n  const meta = new DefinitionMap<R3DeclareQueryMetadata>();\n  meta.set('propertyName', o.literal(query.propertyName));\n  if (query.first) {\n    meta.set('first', o.literal(true));\n  }\n  meta.set(\n      'predicate',\n      Array.isArray(query.predicate) ? asLiteral(query.predicate) :\n                                       convertFromMaybeForwardRefExpression(query.predicate));\n  if (!query.emitDistinctChangesOnly) {\n    // `emitDistinctChangesOnly` is special because we expect it to be `true`.\n    // Therefore we explicitly emit the field, and explicitly place it only when it's `false`.\n    meta.set('emitDistinctChangesOnly', o.literal(false));\n  } else {\n    // The linker will assume that an absent `emitDistinctChangesOnly` flag is by default `true`.\n  }\n  if (query.descendants) {\n    meta.set('descendants', o.literal(true));\n  }\n  meta.set('read', query.read);\n  if (query.static) {\n    meta.set('static', o.literal(true));\n  }\n  return meta.toLiteralMap();\n}\n\n/**\n * Compiles the host metadata into its partial declaration form as declared\n * in `R3DeclareDirectiveMetadata['host']`\n */\nfunction compileHostMetadata(meta: R3HostMetadata): o.LiteralMapExpr|null {\n  const hostMetadata = new DefinitionMap<NonNullable<R3DeclareDirectiveMetadata['host']>>();\n  hostMetadata.set('attributes', toOptionalLiteralMap(meta.attributes, expression => expression));\n  hostMetadata.set('listeners', toOptionalLiteralMap(meta.listeners, o.literal));\n  hostMetadata.set('properties', toOptionalLiteralMap(meta.properties, o.literal));\n\n  if (meta.specialAttributes.styleAttr) {\n    hostMetadata.set('styleAttribute', o.literal(meta.specialAttributes.styleAttr));\n  }\n  if (meta.specialAttributes.classAttr) {\n    hostMetadata.set('classAttribute', o.literal(meta.specialAttributes.classAttr));\n  }\n\n  if (hostMetadata.values.length > 0) {\n    return hostMetadata.toLiteralMap();\n  } else {\n    return null;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as core from '../../core';\nimport {DEFAULT_INTERPOLATION_CONFIG} from '../../ml_parser/interpolation_config';\nimport * as o from '../../output/output_ast';\nimport {ParseLocation, ParseSourceFile, ParseSourceSpan} from '../../parse_util';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {generateForwardRef, R3CompiledExpression} from '../util';\nimport {DeclarationListEmitMode, R3ComponentMetadata, R3TemplateDependencyKind, R3TemplateDependencyMetadata} from '../view/api';\nimport {createComponentType} from '../view/compiler';\nimport {ParsedTemplate} from '../view/template';\nimport {DefinitionMap} from '../view/util';\n\nimport {R3DeclareComponentMetadata, R3DeclareDirectiveDependencyMetadata, R3DeclareNgModuleDependencyMetadata, R3DeclarePipeDependencyMetadata} from './api';\nimport {createDirectiveDefinitionMap} from './directive';\nimport {toOptionalLiteralArray} from './util';\n\nexport interface DeclareComponentTemplateInfo {\n  /**\n   * The string contents of the template.\n   *\n   * This is the \"logical\" template string, after expansion of any escaped characters (for inline\n   * templates). This may differ from the actual template bytes as they appear in the .ts file.\n   */\n  content: string;\n\n  /**\n   * A full path to the file which contains the template.\n   *\n   * This can be either the original .ts file if the template is inline, or the .html file if an\n   * external file was used.\n   */\n  sourceUrl: string;\n\n  /**\n   * Whether the template was inline (using `template`) or external (using `templateUrl`).\n   */\n  isInline: boolean;\n\n  /**\n   * If the template was defined inline by a direct string literal, then this is that literal\n   * expression. Otherwise `null`, if the template was not defined inline or was not a literal.\n   */\n  inlineTemplateLiteralExpression: o.Expression|null;\n}\n\n/**\n * Compile a component declaration defined by the `R3ComponentMetadata`.\n */\nexport function compileDeclareComponentFromMetadata(\n    meta: R3ComponentMetadata<R3TemplateDependencyMetadata>, template: ParsedTemplate,\n    additionalTemplateInfo: DeclareComponentTemplateInfo): R3CompiledExpression {\n  const definitionMap = createComponentDefinitionMap(meta, template, additionalTemplateInfo);\n\n  const expression = o.importExpr(R3.declareComponent).callFn([definitionMap.toLiteralMap()]);\n  const type = createComponentType(meta);\n\n  return {expression, type, statements: []};\n}\n\n/**\n * Gathers the declaration fields for a component into a `DefinitionMap`.\n */\nexport function createComponentDefinitionMap(\n    meta: R3ComponentMetadata<R3TemplateDependencyMetadata>, template: ParsedTemplate,\n    templateInfo: DeclareComponentTemplateInfo): DefinitionMap<R3DeclareComponentMetadata> {\n  const definitionMap: DefinitionMap<R3DeclareComponentMetadata> =\n      createDirectiveDefinitionMap(meta);\n\n  definitionMap.set('template', getTemplateExpression(template, templateInfo));\n  if (templateInfo.isInline) {\n    definitionMap.set('isInline', o.literal(true));\n  }\n\n  definitionMap.set('styles', toOptionalLiteralArray(meta.styles, o.literal));\n  definitionMap.set('dependencies', compileUsedDependenciesMetadata(meta));\n  definitionMap.set('viewProviders', meta.viewProviders);\n  definitionMap.set('animations', meta.animations);\n\n  if (meta.changeDetection !== undefined) {\n    definitionMap.set(\n        'changeDetection',\n        o.importExpr(R3.ChangeDetectionStrategy)\n            .prop(core.ChangeDetectionStrategy[meta.changeDetection]));\n  }\n  if (meta.encapsulation !== core.ViewEncapsulation.Emulated) {\n    definitionMap.set(\n        'encapsulation',\n        o.importExpr(R3.ViewEncapsulation).prop(core.ViewEncapsulation[meta.encapsulation]));\n  }\n  if (meta.interpolation !== DEFAULT_INTERPOLATION_CONFIG) {\n    definitionMap.set(\n        'interpolation',\n        o.literalArr([o.literal(meta.interpolation.start), o.literal(meta.interpolation.end)]));\n  }\n\n  if (template.preserveWhitespaces === true) {\n    definitionMap.set('preserveWhitespaces', o.literal(true));\n  }\n\n  return definitionMap;\n}\n\nfunction getTemplateExpression(\n    template: ParsedTemplate, templateInfo: DeclareComponentTemplateInfo): o.Expression {\n  // If the template has been defined using a direct literal, we use that expression directly\n  // without any modifications. This is ensures proper source mapping from the partially\n  // compiled code to the source file declaring the template. Note that this does not capture\n  // template literals referenced indirectly through an identifier.\n  if (templateInfo.inlineTemplateLiteralExpression !== null) {\n    return templateInfo.inlineTemplateLiteralExpression;\n  }\n\n  // If the template is defined inline but not through a literal, the template has been resolved\n  // through static interpretation. We create a literal but cannot provide any source span. Note\n  // that we cannot use the expression defining the template because the linker expects the template\n  // to be defined as a literal in the declaration.\n  if (templateInfo.isInline) {\n    return o.literal(templateInfo.content, null, null);\n  }\n\n  // The template is external so we must synthesize an expression node with\n  // the appropriate source-span.\n  const contents = templateInfo.content;\n  const file = new ParseSourceFile(contents, templateInfo.sourceUrl);\n  const start = new ParseLocation(file, 0, 0, 0);\n  const end = computeEndLocation(file, contents);\n  const span = new ParseSourceSpan(start, end);\n  return o.literal(contents, null, span);\n}\n\nfunction computeEndLocation(file: ParseSourceFile, contents: string): ParseLocation {\n  const length = contents.length;\n  let lineStart = 0;\n  let lastLineStart = 0;\n  let line = 0;\n  do {\n    lineStart = contents.indexOf('\\n', lastLineStart);\n    if (lineStart !== -1) {\n      lastLineStart = lineStart + 1;\n      line++;\n    }\n  } while (lineStart !== -1);\n\n  return new ParseLocation(file, length, line, length - lastLineStart);\n}\n\nfunction compileUsedDependenciesMetadata(meta: R3ComponentMetadata<R3TemplateDependencyMetadata>):\n    o.LiteralArrayExpr|null {\n  const wrapType = meta.declarationListEmitMode !== DeclarationListEmitMode.Direct ?\n      generateForwardRef :\n      (expr: o.Expression) => expr;\n\n  return toOptionalLiteralArray(meta.declarations, decl => {\n    switch (decl.kind) {\n      case R3TemplateDependencyKind.Directive:\n        const dirMeta = new DefinitionMap<R3DeclareDirectiveDependencyMetadata>();\n        dirMeta.set('kind', o.literal(decl.isComponent ? 'component' : 'directive'));\n        dirMeta.set('type', wrapType(decl.type));\n        dirMeta.set('selector', o.literal(decl.selector));\n        dirMeta.set('inputs', toOptionalLiteralArray(decl.inputs, o.literal));\n        dirMeta.set('outputs', toOptionalLiteralArray(decl.outputs, o.literal));\n        dirMeta.set('exportAs', toOptionalLiteralArray(decl.exportAs, o.literal));\n        return dirMeta.toLiteralMap();\n      case R3TemplateDependencyKind.Pipe:\n        const pipeMeta = new DefinitionMap<R3DeclarePipeDependencyMetadata>();\n        pipeMeta.set('kind', o.literal('pipe'));\n        pipeMeta.set('type', wrapType(decl.type));\n        pipeMeta.set('name', o.literal(decl.name));\n        return pipeMeta.toLiteralMap();\n      case R3TemplateDependencyKind.NgModule:\n        const ngModuleMeta = new DefinitionMap<R3DeclareNgModuleDependencyMetadata>();\n        ngModuleMeta.set('kind', o.literal('ngmodule'));\n        ngModuleMeta.set('type', wrapType(decl.type));\n        return ngModuleMeta.toLiteralMap();\n    }\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as o from '../../output/output_ast';\nimport {createFactoryType, FactoryTarget, R3FactoryMetadata} from '../r3_factory';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {R3CompiledExpression} from '../util';\nimport {DefinitionMap} from '../view/util';\n\nimport {R3DeclareFactoryMetadata} from './api';\nimport {compileDependencies} from './util';\n\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION = '12.0.0';\n\nexport function compileDeclareFactoryFunction(meta: R3FactoryMetadata): R3CompiledExpression {\n  const definitionMap = new DefinitionMap<R3DeclareFactoryMetadata>();\n  definitionMap.set('minVersion', o.literal(MINIMUM_PARTIAL_LINKER_VERSION));\n  definitionMap.set('version', o.literal('14.1.0'));\n  definitionMap.set('ngImport', o.importExpr(R3.core));\n  definitionMap.set('type', meta.internalType);\n  definitionMap.set('deps', compileDependencies(meta.deps));\n  definitionMap.set('target', o.importExpr(R3.FactoryTarget).prop(FactoryTarget[meta.target]));\n\n  return {\n    expression: o.importExpr(R3.declareFactory).callFn([definitionMap.toLiteralMap()]),\n    statements: [],\n    type: createFactoryType(meta),\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {createInjectableType, R3InjectableMetadata} from '../../injectable_compiler_2';\nimport * as o from '../../output/output_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {convertFromMaybeForwardRefExpression, R3CompiledExpression} from '../util';\nimport {DefinitionMap} from '../view/util';\n\nimport {R3DeclareInjectableMetadata} from './api';\nimport {compileDependency} from './util';\n\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION = '12.0.0';\n\n/**\n * Compile a Injectable declaration defined by the `R3InjectableMetadata`.\n */\nexport function compileDeclareInjectableFromMetadata(meta: R3InjectableMetadata):\n    R3CompiledExpression {\n  const definitionMap = createInjectableDefinitionMap(meta);\n\n  const expression = o.importExpr(R3.declareInjectable).callFn([definitionMap.toLiteralMap()]);\n  const type = createInjectableType(meta);\n\n  return {expression, type, statements: []};\n}\n\n/**\n * Gathers the declaration fields for a Injectable into a `DefinitionMap`.\n */\nexport function createInjectableDefinitionMap(meta: R3InjectableMetadata):\n    DefinitionMap<R3DeclareInjectableMetadata> {\n  const definitionMap = new DefinitionMap<R3DeclareInjectableMetadata>();\n\n  definitionMap.set('minVersion', o.literal(MINIMUM_PARTIAL_LINKER_VERSION));\n  definitionMap.set('version', o.literal('14.1.0'));\n  definitionMap.set('ngImport', o.importExpr(R3.core));\n  definitionMap.set('type', meta.internalType);\n\n  // Only generate providedIn property if it has a non-null value\n  if (meta.providedIn !== undefined) {\n    const providedIn = convertFromMaybeForwardRefExpression(meta.providedIn);\n    if ((providedIn as o.LiteralExpr).value !== null) {\n      definitionMap.set('providedIn', providedIn);\n    }\n  }\n\n  if (meta.useClass !== undefined) {\n    definitionMap.set('useClass', convertFromMaybeForwardRefExpression(meta.useClass));\n  }\n  if (meta.useExisting !== undefined) {\n    definitionMap.set('useExisting', convertFromMaybeForwardRefExpression(meta.useExisting));\n  }\n  if (meta.useValue !== undefined) {\n    definitionMap.set('useValue', convertFromMaybeForwardRefExpression(meta.useValue));\n  }\n  // Factories do not contain `ForwardRef`s since any types are already wrapped in a function call\n  // so the types will not be eagerly evaluated. Therefore we do not need to process this expression\n  // with `convertFromProviderExpression()`.\n  if (meta.useFactory !== undefined) {\n    definitionMap.set('useFactory', meta.useFactory);\n  }\n\n  if (meta.deps !== undefined) {\n    definitionMap.set('deps', o.literalArr(meta.deps.map(compileDependency)));\n  }\n\n  return definitionMap;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as o from '../../output/output_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {createInjectorType, R3InjectorMetadata} from '../r3_injector_compiler';\nimport {R3CompiledExpression} from '../util';\nimport {DefinitionMap} from '../view/util';\nimport {R3DeclareInjectorMetadata} from './api';\n\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION = '12.0.0';\n\nexport function compileDeclareInjectorFromMetadata(meta: R3InjectorMetadata): R3CompiledExpression {\n  const definitionMap = createInjectorDefinitionMap(meta);\n\n  const expression = o.importExpr(R3.declareInjector).callFn([definitionMap.toLiteralMap()]);\n  const type = createInjectorType(meta);\n\n  return {expression, type, statements: []};\n}\n\n/**\n * Gathers the declaration fields for an Injector into a `DefinitionMap`.\n */\nfunction createInjectorDefinitionMap(meta: R3InjectorMetadata):\n    DefinitionMap<R3DeclareInjectorMetadata> {\n  const definitionMap = new DefinitionMap<R3DeclareInjectorMetadata>();\n\n  definitionMap.set('minVersion', o.literal(MINIMUM_PARTIAL_LINKER_VERSION));\n  definitionMap.set('version', o.literal('14.1.0'));\n  definitionMap.set('ngImport', o.importExpr(R3.core));\n\n  definitionMap.set('type', meta.internalType);\n  definitionMap.set('providers', meta.providers);\n  if (meta.imports.length > 0) {\n    definitionMap.set('imports', o.literalArr(meta.imports));\n  }\n\n  return definitionMap;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as o from '../../output/output_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {createNgModuleType, R3NgModuleMetadata} from '../r3_module_compiler';\nimport {R3CompiledExpression, refsToArray} from '../util';\nimport {DefinitionMap} from '../view/util';\n\nimport {R3DeclareNgModuleMetadata} from './api';\n\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION = '14.0.0';\n\nexport function compileDeclareNgModuleFromMetadata(meta: R3NgModuleMetadata): R3CompiledExpression {\n  const definitionMap = createNgModuleDefinitionMap(meta);\n\n  const expression = o.importExpr(R3.declareNgModule).callFn([definitionMap.toLiteralMap()]);\n  const type = createNgModuleType(meta);\n\n  return {expression, type, statements: []};\n}\n\n/**\n * Gathers the declaration fields for an NgModule into a `DefinitionMap`.\n */\nfunction createNgModuleDefinitionMap(meta: R3NgModuleMetadata):\n    DefinitionMap<R3DeclareNgModuleMetadata> {\n  const definitionMap = new DefinitionMap<R3DeclareNgModuleMetadata>();\n\n  definitionMap.set('minVersion', o.literal(MINIMUM_PARTIAL_LINKER_VERSION));\n  definitionMap.set('version', o.literal('14.1.0'));\n  definitionMap.set('ngImport', o.importExpr(R3.core));\n  definitionMap.set('type', meta.internalType);\n\n  // We only generate the keys in the metadata if the arrays contain values.\n\n  // We must wrap the arrays inside a function if any of the values are a forward reference to a\n  // not-yet-declared class. This is to support JIT execution of the `ɵɵngDeclareNgModule()` call.\n  // In the linker these wrappers are stripped and then reapplied for the `ɵɵdefineNgModule()` call.\n\n  if (meta.bootstrap.length > 0) {\n    definitionMap.set('bootstrap', refsToArray(meta.bootstrap, meta.containsForwardDecls));\n  }\n\n  if (meta.declarations.length > 0) {\n    definitionMap.set('declarations', refsToArray(meta.declarations, meta.containsForwardDecls));\n  }\n\n  if (meta.imports.length > 0) {\n    definitionMap.set('imports', refsToArray(meta.imports, meta.containsForwardDecls));\n  }\n\n  if (meta.exports.length > 0) {\n    definitionMap.set('exports', refsToArray(meta.exports, meta.containsForwardDecls));\n  }\n\n  if (meta.schemas !== null && meta.schemas.length > 0) {\n    definitionMap.set('schemas', o.literalArr(meta.schemas.map(ref => ref.value)));\n  }\n\n  if (meta.id !== null) {\n    definitionMap.set('id', meta.id);\n  }\n\n  return definitionMap;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as o from '../../output/output_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {createPipeType, R3PipeMetadata} from '../r3_pipe_compiler';\nimport {R3CompiledExpression} from '../util';\nimport {DefinitionMap} from '../view/util';\n\nimport {R3DeclarePipeMetadata} from './api';\n\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION = '14.0.0';\n\n/**\n * Compile a Pipe declaration defined by the `R3PipeMetadata`.\n */\nexport function compileDeclarePipeFromMetadata(meta: R3PipeMetadata): R3CompiledExpression {\n  const definitionMap = createPipeDefinitionMap(meta);\n\n  const expression = o.importExpr(R3.declarePipe).callFn([definitionMap.toLiteralMap()]);\n  const type = createPipeType(meta);\n\n  return {expression, type, statements: []};\n}\n\n/**\n * Gathers the declaration fields for a Pipe into a `DefinitionMap`.\n */\nexport function createPipeDefinitionMap(meta: R3PipeMetadata):\n    DefinitionMap<R3DeclarePipeMetadata> {\n  const definitionMap = new DefinitionMap<R3DeclarePipeMetadata>();\n\n  definitionMap.set('minVersion', o.literal(MINIMUM_PARTIAL_LINKER_VERSION));\n  definitionMap.set('version', o.literal('14.1.0'));\n  definitionMap.set('ngImport', o.importExpr(R3.core));\n\n  // e.g. `type: MyPipe`\n  definitionMap.set('type', meta.internalType);\n\n  if (meta.isStandalone) {\n    definitionMap.set('isStandalone', o.literal(meta.isStandalone));\n  }\n\n  // e.g. `name: \"myPipe\"`\n  definitionMap.set('name', o.literal(meta.pipeName));\n\n  if (meta.pure === false) {\n    // e.g. `pure: false`\n    definitionMap.set('pure', o.literal(meta.pure));\n  }\n\n  return definitionMap;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n//////////////////////////////////////\n// THIS FILE HAS GLOBAL SIDE EFFECT //\n//       (see bottom of file)       //\n//////////////////////////////////////\n\n/**\n * @module\n * @description\n * Entry point for all APIs of the compiler package.\n *\n * <div class=\"callout is-critical\">\n *   <header>Unstable APIs</header>\n *   <p>\n *     All compiler apis are currently considered experimental and private!\n *   </p>\n *   <p>\n *     We expect the APIs in this package to keep on changing. Do not rely on them.\n *   </p>\n * </div>\n */\n\nimport * as core from './core';\nimport {publishFacade} from './jit_compiler_facade';\nimport {global} from './util';\n\nexport {CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA, SchemaMetadata} from './core';\nexport {core};\n\nexport * from './version';\nexport {CompilerConfig, preserveWhitespacesDefault} from './config';\nexport * from './resource_loader';\nexport {ConstantPool} from './constant_pool';\nexport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from './ml_parser/interpolation_config';\nexport * from './schema/element_schema_registry';\nexport * from './i18n/index';\nexport * from './expression_parser/ast';\nexport * from './expression_parser/lexer';\nexport * from './expression_parser/parser';\nexport * from './ml_parser/ast';\nexport * from './ml_parser/html_parser';\nexport * from './ml_parser/html_tags';\nexport * from './ml_parser/interpolation_config';\nexport * from './ml_parser/tags';\nexport {ParseTreeResult, TreeError} from './ml_parser/parser';\nexport {LexerRange} from './ml_parser/lexer';\nexport * from './ml_parser/xml_parser';\nexport {ArrayType, DYNAMIC_TYPE, BinaryOperator, BinaryOperatorExpr, BuiltinType, BuiltinTypeName, CommaExpr, ConditionalExpr, DeclareFunctionStmt, DeclareVarStmt, Expression, ExpressionStatement, ExpressionType, ExpressionVisitor, ExternalExpr, ExternalReference, literalMap, FunctionExpr, IfStmt, InstantiateExpr, InvokeFunctionExpr, LiteralArrayExpr, LiteralExpr, LiteralMapExpr, MapType, NotExpr, NONE_TYPE, ReadKeyExpr, ReadPropExpr, ReadVarExpr, ReturnStatement, StatementVisitor, TaggedTemplateExpr, TemplateLiteral, TemplateLiteralElement, Type, TypeModifier, TypeVisitor, WrappedNodeExpr, WriteKeyExpr, WritePropExpr, WriteVarExpr, StmtModifier, Statement, STRING_TYPE, TypeofExpr, jsDocComment, leadingComment, LeadingComment, JSDocComment, UnaryOperator, UnaryOperatorExpr, LocalizedString} from './output/output_ast';\nexport {EmitterVisitorContext} from './output/abstract_emitter';\nexport {JitEvaluator} from './output/output_jit';\nexport * from './parse_util';\nexport * from './schema/dom_element_schema_registry';\nexport * from './selector';\nexport {Version} from './util';\nexport {SourceMap} from './output/source_map';\nexport * from './injectable_compiler_2';\nexport * from './render3/partial/api';\nexport * from './render3/view/api';\nexport {BoundAttribute as TmplAstBoundAttribute, BoundEvent as TmplAstBoundEvent, BoundText as TmplAstBoundText, Content as TmplAstContent, Element as TmplAstElement, Icu as TmplAstIcu, Node as TmplAstNode, RecursiveVisitor as TmplAstRecursiveVisitor, Reference as TmplAstReference, Template as TmplAstTemplate, Text as TmplAstText, TextAttribute as TmplAstTextAttribute, Variable as TmplAstVariable} from './render3/r3_ast';\nexport * from './render3/view/t2_api';\nexport * from './render3/view/t2_binder';\nexport {Identifiers as R3Identifiers} from './render3/r3_identifiers';\nexport {R3ClassMetadata, CompileClassMetadataFn, compileClassMetadata} from './render3/r3_class_metadata_compiler';\nexport {compileFactoryFunction, R3DependencyMetadata, R3FactoryMetadata, FactoryTarget} from './render3/r3_factory';\nexport {compileNgModule, R3NgModuleMetadata, R3SelectorScopeMode} from './render3/r3_module_compiler';\nexport {compileInjector, R3InjectorMetadata} from './render3/r3_injector_compiler';\nexport {compilePipeFromMetadata, R3PipeMetadata} from './render3/r3_pipe_compiler';\nexport {makeBindingParser, ParsedTemplate, parseTemplate, ParseTemplateOptions} from './render3/view/template';\nexport {ForwardRefHandling, MaybeForwardRefExpression, R3CompiledExpression, R3Reference, createMayBeForwardRefExpression, devOnlyGuardedExpression, getSafePropertyAccessString} from './render3/util';\nexport {compileComponentFromMetadata, compileDirectiveFromMetadata, parseHostBindings, ParsedHostBindings, verifyHostBindings} from './render3/view/compiler';\nexport {compileDeclareClassMetadata} from './render3/partial/class_metadata';\nexport {compileDeclareComponentFromMetadata, DeclareComponentTemplateInfo} from './render3/partial/component';\nexport {compileDeclareDirectiveFromMetadata} from './render3/partial/directive';\nexport {compileDeclareFactoryFunction} from './render3/partial/factory';\nexport {compileDeclareInjectableFromMetadata} from './render3/partial/injectable';\nexport {compileDeclareInjectorFromMetadata} from './render3/partial/injector';\nexport {compileDeclareNgModuleFromMetadata} from './render3/partial/ng_module';\nexport {compileDeclarePipeFromMetadata} from './render3/partial/pipe';\nexport {publishFacade} from './jit_compiler_facade';\nexport {emitDistinctChangesOnlyDefaultValue, ChangeDetectionStrategy, ViewEncapsulation} from './core';\nimport * as outputAst from './output/output_ast';\nexport {outputAst};\n// This file only reexports content of the `src` folder. Keep it that way.\n\n// This function call has a global side effects and publishes the compiler into global namespace for\n// the late binding of the Compiler to the @angular/core for jit compilation.\npublishFacade(global);\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of this package.\n */\nexport * from './src/compiler';\n\n// This file only reexports content of the `src` folder. Keep it that way.\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// This file is not used to build this module. It is only used during editing\n// by the TypeScript language service and during build for verification. `ngc`\n// replaces this file with production index.ts when it rewrites private symbol\n// names.\n\nexport * from './public_api';\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// This file is not used to build this module. It is only used during editing\n// by the TypeScript language service and during build for verification. `ngc`\n// replaces this file with production index.ts when it rewrites private symbol\n// names.\n\nexport * from './compiler';\n"],"names":["Type","digest","serializerVisitor","MEANING_SEPARATOR","ID_SEPARATOR","RecursiveAstVisitor","o.variable","o.Expression","o.LiteralExpr","o.FunctionExpr","o.ReturnStatement","o.INFERRED_TYPE","o.StmtModifier","o.LiteralArrayExpr","o.literalArr","o.literalMap","o.FnParam","o.DYNAMIC_TYPE","o.fn","invalid","o.ReadVarExpr","VERSION","o.JSDocComment","o.UnaryOperator","o.BinaryOperator","o.expressionType","o.ExternalExpr","o.BinaryOperatorExpr","o.TypeofExpr","o.literal","o.WrappedNodeExpr","o.importExpr","FactoryTarget","o.InstantiateExpr","o.NULL_EXPR","R3","o.ifStmt","o.InvokeFunctionExpr","o.DeclareVarStmt","o.NONE_TYPE","Comment","Text","Element","Icu","RecursiveVisitor","visitAll","i18n.RecurseVisitor","_Visitor","_PLACEHOLDER_TAG","_SOURCE_TAG","xml.Tag","xml.Text","xml.CR","xml.serialize","xml.Declaration","xml.Doctype","i18n.Message","i18n.Icu","i18n.Container","i18n.Placeholder","o.isNull","t.Template","o.ExpressionType","chars.$LF","global","o.LiteralMapExpr","o.LiteralMapEntry","o.typeofExpr","o.ExpressionStatement","cdAst.AstTransformer","o.UnaryOperatorExpr","cdAst.ThisReceiver","o.not","o.ReadPropExpr","cdAst.PropertyRead","cdAst.ImplicitReceiver","cdAst.SafeCall","cdAst.Call","cdAst.SafeKeyedRead","cdAst.KeyedRead","cdAst.EmptyExpr","parseStyle","chars.$EOF","chars.$SPACE","chars.isDigit","chars.$PERIOD","chars.$LPAREN","chars.$RPAREN","chars.$LBRACE","chars.$RBRACE","chars.$LBRACKET","chars.$RBRACKET","chars.$COMMA","chars.$COLON","chars.$SEMICOLON","chars.$SQ","chars.$DQ","chars.$HASH","chars.$PLUS","chars.$MINUS","chars.$STAR","chars.$SLASH","chars.$PERCENT","chars.$CARET","chars.$QUESTION","chars.$LT","chars.$GT","chars.$EQ","chars.$BANG","chars.$AMPERSAND","chars.$BAR","chars.$NBSP","chars.isWhitespace","chars.$_","chars.$BACKSLASH","chars.$u","chars.$a","chars.$z","chars.$A","chars.$Z","chars.$$","chars.isAsciiLetter","chars.$e","chars.$E","chars.$n","chars.$f","chars.$FF","chars.$r","chars.$CR","chars.$t","chars.$TAB","chars.$v","chars.$VTAB","Parser","chars.isQuote","chars.$x","chars.$X","chars.$0","chars.$9","chars.isAsciiHexDigit","chars.isNewLine","chars.$b","chars.$BSPACE","chars.isOctalDigit","html.Comment","html.Expansion","html.ExpansionCase","html.Text","html.Element","html.Attribute","html.visitAll","TEMPLATE_ATTR_PREFIX","NG_CONTENT_SELECT_ATTR","t.Variable","t.Content","t.Element","t.TextAttribute","t.BoundText","t.Icu","t.Comment","t.BoundAttribute","t.Text","t.Reference","t.BoundEvent","ExpressionParser","ExpressionLexer","i18n.TagPlaceholder","i18n.Text","i18n.IcuPlaceholder","html.NodeWithI18n","o.jsDocComment","variable","localizedString","o.localizedString","o.LiteralPiece","o.PlaceholderPiece","t.visitAll","core.parseSelectorToR3Selector","o.NUMBER_TYPE","isNgContainer","checkIsNgContainer","o.TYPED_NULL_EXPR","literal","core.SecurityContext","o.taggedTemplate","o.TemplateLiteral","o.TemplateLiteralElement","o.STRING_TYPE","core.ViewEncapsulation","core.ChangeDetectionStrategy","_VERSION","_XMLNS","_DEFAULT_SOURCE_LANG","_MARKER_TAG","_TARGET_TAG","_UNIT_TAG","_WriteVisitor","XmlToI18n","ml.visitAll","i18n.CloneVisitor","MINIMUM_PARTIAL_LINKER_VERSION"],"mappings":"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