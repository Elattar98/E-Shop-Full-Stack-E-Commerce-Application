is.space();
    }

    let val;
    let maybeNewline = false;

    if (isBlockComment) {
      val = `/*${comment.value}*/`;

      if (this.format.indent.adjustMultilineComment) {
        var _comment$loc;

        const offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;

        if (offset) {
          const newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
          val = val.replace(newlineRegex, "\n");
        }

        const indentSize = Math.max(this._getIndent(), this.format.retainLines ? 0 : this._buf.getCurrentColumn());
        val = val.replace(/\n(?!$)/g, `\n${" ".repeat(indentSize)}`);
        maybeNewline = true;
      }
    } else if (!this._noLineTerminator) {
      val = `//${comment.value}\n`;
      maybeNewline = true;
    }

    if (this.endsWith(47)) this._space();
    this.withSource("start", comment.loc, this._append.bind(this, val, maybeNewline));
    if (printNewLines) this.newline(1);
  }

  _printComments(comments, inlinePureAnnotation) {
    if (!(comments != null && comments.length)) retu