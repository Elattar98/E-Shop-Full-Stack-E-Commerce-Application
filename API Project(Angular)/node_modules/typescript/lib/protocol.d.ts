ction printBundle(bundle) {
            writeBundle(bundle, beginPrint(), /*sourceMapEmitter*/ undefined);
            return endPrint();
        }
        function printFile(sourceFile) {
            writeFile(sourceFile, beginPrint(), /*sourceMapEmitter*/ undefined);
            return endPrint();
        }
        function printUnparsedSource(unparsed) {
            writeUnparsedSource(unparsed, beginPrint());
            return endPrint();
        }
        function writeNode(hint, node, sourceFile, output) {
            var previousWriter = writer;
            setWriter(output, /*_sourceMapGenerator*/ undefined);
            print(hint, node, sourceFile);
            reset();
            writer = previousWriter;
        }
        function writeList(format, nodes, sourceFile, output) {
            var previousWriter = writer;
            setWriter(output, /*_sourceMapGenerator*/ undefined);
            if (sourceFile) {
                setSourceFile(sourceFile);
            }
            emitList(/*parentNode*/ undefined, nodes, format);
            reset();
            writer = previousWriter;
        }
        function getTextPosWithWriteLine() {
            return writer.getTextPosWithWriteLine ? writer.getTextPosWithWriteLine() : writer.getTextPos();
        }
        function updateOrPushBundleFileTextLike(pos, end, kind) {
            var last = ts.lastOrUndefined(bundleFileInfo.sections);
            if (last && last.kind === kind) {
                last.end = end;
            }
            else {
                bundleFileInfo.sections.push({ pos: pos, end: end, kind: kind });
            }
        }
        function recordBundleFileInternalSectionStart(node) {
            if (recordInternalSection &&
                bundleFileInfo &&
                currentSourceFile &&
                (ts.isDeclaration(node) || ts.isVariableStatement(node)) &&
                ts.isInternalDeclaration(node, currentSourceFile) &&
                sourceFileTextKind !== "internal" /* BundleFileSectionKind.Internal */) {
                var prevSourceFileTextKind = sourceFileTextKind;
                recordBundleFileTextLikeSection(writer.getTextPos());
                sourceFileTextPos = getTextPosWithWriteLine();
                sourceFileTextKind = "internal" /* BundleFileSectionKind.Internal */;
                return prevSourceFileTextKind;
            }
            return undefined;
        }
        function recordBundleFileInternalSectionEnd(prevSourceFileTextKind) {
            if (prevSourceFileTextKind) {
                recordBundleFileTextLikeSection(writer.getTextPos());
                sourceFileTextPos = getTextPosWithWriteLine();
                sourceFileTextKind = prevSourceFileTextKind;
            }
        }
        function recordBundleFileTextLikeSection(end) {
            if (sourceFileTextPos < end) {
                updateOrPushBundleFileTextLike(sourceFileTextPos, end, sourceFileTextKind);
                return true;
            }
            return false;
        }
        function writeBundle(bundle, output, sourceMapGenerator) {
            var _a;
            isOwnFileEmit = false;
            var previousWriter = writer;
            setWriter(output, sourceMapGenerator);
            emitShebangIfNeeded(bundle);
            emitPrologueDirectivesIfNeeded(bundle);
            emitHelpers(bundle);
            emitSyntheticTripleSlashReferencesIfNeeded(bundle);
            for (var _b = 0, _c = bundle.prepends; _b < _c.length; _b++) {
                var prepend = _c[_b];
                writeLine();
                var pos = writer.getTextPos();
                var savedSections = bundleFileInfo && bundleFileInfo.sections;
                if (savedSections)
                    bundleFileInfo.sections = [];
                print(4 /* EmitHint.Unspecified */, prepend, /*sourceFile*/ undefined);
                if (bundleFileInfo) {
                    var newSections = bundleFileInfo.sections;
                    bundleFileInfo.sections = savedSections;
                    if (prepend.oldFileOfCurrentEmit)
                        (_a = bundleFileInfo.sections).push.apply(_a, newSections);
                    else {
                        newSections.forEach(function (section) { return ts.Debug.assert(ts.isBundleFileTextLike(section)); });
                        bundleFileInfo.sections.push({
                            pos: pos,
                            end: writer.getTextPos(),
                            kind: "prepend" /* BundleFileSectionKind.Prepend */,
                            data: relativeToBuildInfo(prepend.fileName),
                            texts: newSections
                        });
                    }
                }
            }
            sourceFileTextPos = getTextPosWithWriteLine();
            for (var _d = 0, _e = bundle.sourceFiles; _d < _e.length; _d++) {
                var sourceFile = _e[_d];
                print(0 /* EmitHint.SourceFile */, sourceFile, sourceFile);
            }
            if (bundleFileInfo && bundle.sourceFiles.length) {
                var end = writer.getTextPos();
                if (recordBundleFileTextLikeSection(end)) {
                    // Store prologues
                    var prologues = getPrologueDirectivesFromBundledSourceFiles(bundle);
                    if (prologues) {
                        if (!bundleFileInfo.sources)
                            bundleFileInfo.sources = {};
                        bundleFileInfo.sources.prologues = prologues;
                    }
                    // Store helpes
                    var helpers = getHelpersFromBundledSourceFiles(bundle);
                    if (helpers) {
                        if (!bundleFileInfo.sources)
                            bundleFileInfo.sources = {};
                        bundleFileInfo.sources.helpers = helpers;
                    }
                }
            }
            reset();
            writer = previousWriter;
        }
        function writeUnparsedSource(unparsed, output) {
            var previousWriter = writer;
            setWriter(output, /*_sourceMapGenerator*/ undefined);
            print(4 /* EmitHint.Unspecified */, unparsed, /*sourceFile*/ undefined);
            reset();
            writer = previousWriter;
        }
        function writeFile(sourceFile, output, sourceMapGenerator) {
            isOwnFileEmit = true;
            var previousWriter = writer;
            setWriter(output, sourceMapGenerator);
            emitShebangIfNeeded(sourceFile);
            emitPrologueDirectivesIfNeeded(sourceFile);
            print(0 /* EmitHint.SourceFile */, sourceFile, sourceFile);
            reset();
            writer = previousWriter;
        }
        function beginPrint() {
            return ownWriter || (ownWriter = ts.createTextWriter(newLine));
        }
        function endPrint() {
            var text = ownWriter.getText();
            ownWriter.clear();
            return text;
        }
        function print(hint, node, sourceFile) {
            if (sourceFile) {
                setSourceFile(sourceFile);
            }
            pipelineEmit(hint, node, /*parenthesizerRule*/ undefined);
        }
        function setSourceFile(sourceFile) {
            currentSourceFile = sourceFile;
            currentLineMap = undefined;
            detachedCommentsInfo = undefined;
            if (sourceFile) {
                setSourceMapSource(sourceFile);
            }
        }
        function setWriter(_writer, _sourceMapGenerator) {
            if (_writer && printerOptions.omitTrailingSemicolon) {
                _writer = ts.getTrailingSemicolonDeferringWriter(_writer);
            }
            writer = _writer; // TODO: GH#18217
            sourceMapGenerator = _sourceMapGenerator;
            sourceMapsDisabled = !writer || !sourceMapGenerator;
        }
        function reset() {
            nodeIdToGeneratedName = [];
            autoGeneratedIdToGeneratedName = [];
            generatedNames = new ts.Set();
            tempFlagsStack = [];
            tempFlags = 0 /* TempFlags.Auto */;
            reservedNamesStack = [];
            currentSourceFile = undefined;
            currentLineMap = undefined;
            detachedCommentsInfo = undefined;
            setWriter(/*output*/ undefined, /*_sourceMapGenerator*/ undefined);
        }
        function getCurrentLineMap() {
            return currentLineMap || (currentLineMap = ts.getLineStarts(ts.Debug.checkDefined(currentSourceFile)));
        }
        function emit(node, parenthesizerRule) {
            if (node === undefined)
                return;
            var prevSourceFileTextKind = recordBundleFileInternalSectionStart(node);
            pipelineEmit(4 /* EmitHint.Unspecified */, node, parenthesizerRule);
            recordBundleFileInternalSectionEnd(prevSourceFileTextKind);
        }
        function emitIdentifierName(node) {
            if (node === undefined)
                return;
            pipelineEmit(2 /* EmitHint.IdentifierName */, node, /*parenthesizerRule*/ undefined);
        }
        function emitExpression(node, parenthesizerRule) {
            if (node === undefined)
                return;
            pipelineEmit(1 /* EmitHint.Expression */, node, parenthesizerRule);
        }
        function emitJsxAttributeValue(node) {
            pipelineEmit(ts.isStringLiteral(node) ? 6 /* EmitHint.JsxAttributeValue */ : 4 /* EmitHint.Unspecified */, node);
        }
        function beforeEmitNode(node) {
            if (preserveSourceNewlines && (ts.getEmitFlags(node) & 134217728 /* EmitFlags.IgnoreSourceNewlines */)) {
                preserveSourceNewlines = false;
            }
        }
        function afterEmitNode(savedPreserveSourceNewlines) {
            preserveSourceNewlines = savedPreserveSourceNewlines;
        }
        function pipelineEmit(emitHint, node, parenthesizerRule) {
            currentParenthesizerRule = parenthesizerRule;
            var pipelinePhase = getPipelinePhase(0 /* PipelinePhase.Notification */, emitHint, node);
            pipelinePhase(emitHint, node);
            currentParenthesizerRule = undefined;
        }
        function shouldEmitComments(node) {
            return !commentsDisabled && !ts.isSourceFile(node);
        }
        function shouldEmitSourceMaps(node) {
            return !sourceMapsDisabled &&
                !ts.isSourceFile(node) &&
                !ts.isInJsonFile(node) &&
                !ts.isUnparsedSource(node) &&
                !ts.isUnparsedPrepend(node);
        }
        function getPipelinePhase(phase, emitHint, node) {
            switch (phase) {
                case 0 /* PipelinePhase.Notification */:
                    if (onEmitNode !== ts.noEmitNotification && (!isEmitNotificationEnabled || isEmitNotificationEnabled(node))) {
                        return pipelineEmitWithNotification;
                    }
                // falls through
                case 1 /* PipelinePhase.Substitution */:
                    if (substituteNode !== ts.noEmitSubstitution && (lastSubstitution = substituteNode(emitHint, node) || node) !== node) {
                        if (currentParenthesizerRule) {
                            lastSubstitution = currentParenthesizerRule(lastSubstitution);
                        }
                        return pipelineEmitWithSubstitution;
                    }
                // falls through
                case 2 /* PipelinePhase.Comments */:
                    if (shouldEmitComments(node)) {
                        return pipelineEmitWithComments;
                    }
                // falls through
                case 3 /* PipelinePhase.SourceMaps */:
                    if (shouldEmitSourceMaps(node)) {
                        return pipelineEmitWithSourceMaps;
                    }
                // falls through
                case 4 /* PipelinePhase.Emit */:
                    return pipelineEmitWithHint;
                default:
                    return ts.Debug.assertNever(phase);
            }
        }
        function getNextPipelinePhase(currentPhase, emitHint, node) {
            return getPipelinePhase(currentPhase + 1, emitHint, node);
        }
        function pipelineEmitWithNotification(hint, node) {
            var pipelinePhase = getNextPipelinePhase(0 /* PipelinePhase.Notification */, hint, node);
            onEmitNode(hint, node, pipelinePhase);
        }
        function pipelineEmitWithHint(hint, node) {
            onBeforeEmitNode === null || onBeforeEmitNode === void 0 ? void 0 : onBeforeEmitNode(node);
            if (preserveSourceNewlines) {
                var savedPreserveSourceNewlines = preserveSourceNewlines;
                beforeEmitNode(node);
                pipelineEmitWithHintWorker(hint, node);
                afterEmitNode(savedPreserveSourceNewlines);
            }
            else {
                pipelineEmitWithHintWorker(hint, node);
            }
            onAfterEmitNode === null || onAfterEmitNode === void 0 ? void 0 : onAfterEmitNode(node);
            // clear the parenthesizer rule as we ascend
            currentParenthesizerRule = undefined;
        }
        function pipelineEmitWithHintWorker(hint, node, allowSnippets) {
            if (allowSnippets === void 0) { allowSnippets = true; }
            if (allowSnippets) {
                var snippet = ts.getSnippetElement(node);
                if (snippet) {
                    return emitSnippetNode(hint, node, snippet);
                }
            }
            if (hint === 0 /* EmitHint.SourceFile */)
                return emitSourceFile(ts.cast(node, ts.isSourceFile));
            if (hint === 2 /* EmitHint.IdentifierName */)
                return emitIdentifier(ts.cast(node, ts.isIdentifier));
            if (hint === 6 /* EmitHint.JsxAttributeValue */)
                return emitLiteral(ts.cast(node, ts.isStringLiteral), /*jsxAttributeEscape*/ true);
            if (hint === 3 /* EmitHint.MappedTypeParameter */)
                return emitMappedTypeParameter(ts.cast(node, ts.isTypeParameterDeclaration));
            if (hint === 5 /* EmitHint.EmbeddedStatement */) {
                ts.Debug.assertNode(node, ts.isEmptyStatement);
                return emitEmptyStatement(/*isEmbeddedStatement*/ true);
            }
            if (hint === 4 /* EmitHint.Unspecified */) {
                switch (node.kind) {
                    // Pseudo-literals
                    case 15 /* SyntaxKind.TemplateHead */:
                    case 16 /* SyntaxKind.TemplateMiddle */:
                    case 17 /* SyntaxKind.TemplateTail */:
                        return emitLiteral(node, /*jsxAttributeEscape*/ false);
                    // Identifiers
                    case 79 /* SyntaxKind.Identifier */:
                        return emitIdentifier(node);
                    // PrivateIdentifiers
                    case 80 /* SyntaxKind.PrivateIdentifier */:
                        return emitPrivateIdentifier(node);
                    // Parse tree nodes
                    // Names
                    case 161 /* SyntaxKind.QualifiedName */:
                        return emitQualifiedName(node);
                    case 162 /* SyntaxKind.ComputedPropertyName */:
                        return emitComputedPropertyName(node);
                    // Signature elements
                    case 163 /* SyntaxKind.TypeParameter */:
                        return emitTypeParameter(node);
                    case 164 /* SyntaxKind.Parameter */:
                        return emitParameter(node);
                    case 165 /* SyntaxKind.Decorator */:
                        return emitDecorator(node);
                    // Type members
                    case 166 /* SyntaxKind.PropertySignature */:
                        return emitPropertySignature(node);
                    case 167 /* SyntaxKind.PropertyDeclaration */:
                        return emitPropertyDeclaration(node);
                    case 168 /* SyntaxKind.MethodSignature */:
                        return emitMethodSignature(node);
                    case 169 /* SyntaxKind.MethodDeclaration */:
                        return emitMethodDeclaration(node);
                    case 170 /* SyntaxKind.ClassStaticBlockDeclaration */:
                        return emitClassStaticBlockDeclaration(node);
                    case 171 /* SyntaxKind.Constructor */:
                        return emitConstructor(node);
                    case 172 /* SyntaxKind.GetAccessor */:
                    case 173 /* SyntaxKind.SetAccessor */:
                        return emitAccessorDeclaration(node);
                    case 174 /* SyntaxKind.CallSignature */:
                        return emitCallSignature(node);
                    case 175 /* SyntaxKind.ConstructSignature */:
                        return emitConstructSignature(node);
                    case 176 /* SyntaxKind.IndexSignature */:
                        return emitIndexSignature(node);
                    // Types
                    case 177 /* SyntaxKind.TypePredicate */:
                        return emitTypePredicate(node);
                    case 178 /* SyntaxKind.TypeReference */:
                        return emitTypeReference(node);
                    case 179 /* SyntaxKind.FunctionType */:
                        return emitFunctionType(node);
                    case 180 /* SyntaxKind.ConstructorType */:
                        return emitConstructorType(node);
                    case 181 /* SyntaxKind.TypeQuery */:
                        return emitTypeQuery(node);
                    case 182 /* SyntaxKind.TypeLiteral */:
                        return emitTypeLiteral(node);
                    case 183 /* SyntaxKind.ArrayType */:
                        return emitArrayType(node);
                    case 184 /* SyntaxKind.TupleType */:
                        return emitTupleType(node);
                    case 185 /* SyntaxKind.OptionalType */:
                        return emitOptionalType(node);
                    // SyntaxKind.RestType is handled below
                    case 187 /* SyntaxKind.UnionType */:
                        return emitUnionType(node);
                    case 188 /* SyntaxKind.IntersectionType */:
                        return emitIntersectionType(node);
                    case 189 /* SyntaxKind.ConditionalType */:
                        return emitConditionalType(node);
                    case 190 /* SyntaxKind.InferType */:
                        return emitInferType(node);
                    case 191 /* SyntaxKind.ParenthesizedType */:
                        return emitParenthesizedType(node);
                    case 228 /* SyntaxKind.ExpressionWithTypeArguments */:
                        return emitExpressionWithTypeArguments(node);
                    case 192 /* SyntaxKind.ThisType */:
                        return emitThisType();
                    case 193 /* SyntaxKind.TypeOperator */:
                        return emitTypeOperator(node);
                    case 194 /* SyntaxKind.IndexedAccessType */:
                        return emitIndexedAccessType(node);
                    case 195 /* SyntaxKind.MappedType */:
                        return emitMappedType(node);
                    case 196 /* SyntaxKind.LiteralType */:
                        return emitLiteralType(node);
                    case 197 /* SyntaxKind.NamedTupleMember */:
                        return emitNamedTupleMember(node);
                    case 198 /* SyntaxKind.TemplateLiteralType */:
                        return emitTemplateType(node);
                    case 199 /* SyntaxKind.TemplateLiteralTypeSpan */:
                        return emitTemplateTypeSpan(node);
                    case 200 /* SyntaxKind.ImportType */:
                        return emitImportTypeNode(node);
                    // Binding patterns
                    case 201 /* SyntaxKind.ObjectBindingPattern */:
                        return emitObjectBindingPattern(node);
                    case 202 /* SyntaxKind.ArrayBindingPattern */:
                        return emitArrayBindingPattern(node);
                    case 203 /* SyntaxKind.BindingElement */:
                        return emitBindingElement(node);
                    // Misc
                    case 233 /* SyntaxKind.TemplateSpan */:
                        return emitTemplateSpan(node);
                    case 234 /* SyntaxKind.SemicolonClassElement */:
                        return emitSemicolonClassElement();
                    // Statements
                    case 235 /* SyntaxKind.Block */:
                        return emitBlock(node);
                    case 237 /* SyntaxKind.VariableStatement */:
                        return emitVariableStatement(node);
                    case 236 /* SyntaxKind.EmptyStatement */:
                        return emitEmptyStatement(/*isEmbeddedStatement*/ false);
                    case 238 /* SyntaxKind.ExpressionStatement */:
                        return emitExpressionStatement(node);
                    case 239 /* SyntaxKind.IfStatement */:
                        return emitIfStatement(node);
                    case 240 /* SyntaxKind.DoStatement */:
                        return emitDoStatement(node);
                    case 241 /* SyntaxKind.WhileStatement */:
                        return emitWhileStatement(node);
                    case 242 /* SyntaxKind.ForStatement */:
                        return emitForStatement(node);
                    case 243 /* SyntaxKind.ForInStatement */:
                        return emitForInStatement(node);
                    case 244 /* SyntaxKind.ForOfStatement */:
                        return emitForOfStatement(node);
                    case 245 /* SyntaxKind.ContinueStatement */:
                        return emitContinueStatement(node);
                    case 246 /* SyntaxKind.BreakStatement */:
                        return emitBreakStatement(node);
                    case 247 /* SyntaxKind.ReturnStatement */:
                        return emitReturnStatement(node);
                    case 248 /* SyntaxKind.WithStatement */:
                        return emitWithStatement(node);
                    case 249 /* SyntaxKind.SwitchStatement */:
                        return emitSwitchStatement(node);
                    case 250 /* SyntaxKind.LabeledStatement */:
                        return emitLabeledStatement(node);
                    case 251 /* SyntaxKind.ThrowStatement */:
                        return emitThrowStatement(node);
                    case 252 /* SyntaxKind.TryStatement */:
                        return emitTryStatement(node);
                    case 253 /* SyntaxKind.DebuggerStatement */:
                        return emitDebuggerStatement(node);
                    // Declarations
                    case 254 /* SyntaxKind.VariableDeclaration */:
                        return emitVariableDeclaration(node);
                    case 255 /* SyntaxKind.VariableDeclarationList */:
                        return emitVariableDeclarationList(node);
                    case 256 /* SyntaxKind.FunctionDeclaration */:
                        return emitFunctionDeclaration(node);
                    case 257 /* SyntaxKind.ClassDeclaration */:
                        return emitClassDeclaration(node);
                    case 258 /* SyntaxKind.InterfaceDeclaration */:
                        return emitInterfaceDeclaration(node);
                    case 259 /* SyntaxKind.TypeAliasDeclaration */:
                        return emitTypeAliasDeclaration(node);
                    case 260 /* SyntaxKind.EnumDeclaration */:
                        return emitEnumDeclaration(node);
                    case 261 /* SyntaxKind.ModuleDeclaration */:
                        return emitModuleDeclaration(node);
                    case 262 /* SyntaxKind.ModuleBlock */:
                        return emitModuleBlock(node);
                    case 263 /* SyntaxKind.CaseBlock */:
                        return emitCaseBlock(node);
                    case 264 /* SyntaxKind.NamespaceExportDeclaration */:
                        return emitNamespaceExportDeclaration(node);
                    case 265 /* SyntaxKind.ImportEqualsDeclaration */:
                        return emitImportEqualsDeclaration(node);
                    case 266 /* SyntaxKind.ImportDeclaration */:
                        return emitImportDeclaration(node);
                    case 267 /* SyntaxKind.ImportClause */:
                        return emitImportClause(node);
                    case 268 /* SyntaxKind.NamespaceImport */:
                        return emitNamespaceImport(node);
                    case 274 /* SyntaxKind.NamespaceExport */:
                        return emitNamespaceExport(node);
                    case 269 /* SyntaxKind.NamedImports */:
                        return emitNamedImports(node);
                    case 270 /* SyntaxKind.ImportSpecifier */:
                        return emitImportSpecifier(node);
                    case 271 /* SyntaxKind.ExportAssignment */:
                        return emitExportAssignment(node);
                    case 272 /* SyntaxKind.ExportDeclaration */:
                        return emitExportDeclaration(node);
                    case 273 /* SyntaxKind.NamedExports */:
                        return emitNamedExports(node);
                    case 275 /* SyntaxKind.ExportSpecifier */:
                        return emitExportSpecifier(node);
                    case 293 /* SyntaxKind.AssertClause */:
                        return emitAssertClause(node);
                    case 294 /* SyntaxKind.AssertEntry */:
                        return emitAssertEntry(node);
                    case 276 /* SyntaxKind.MissingDeclaration */:
                        return;
                    // Module references
                    case 277 /* SyntaxKind.ExternalModuleReference */:
                        return emitExternalModuleReference(node);
                    // JSX (non-expression)
                    case 11 /* SyntaxKind.JsxText */:
                        return emitJsxText(node);
                    case 280 /* SyntaxKind.JsxOpeningElement */:
                    case 283 /* SyntaxKind.JsxOpeningFragment */:
                        return emitJsxOpeningElementOrFragment(node);
                    case 281 /* SyntaxKind.JsxClosingElement */:
                    case 284 /* SyntaxKind.JsxClosingFragment */:
                        return emitJsxClosingElementOrFragment(node);
                    case 285 /* SyntaxKind.JsxAttribute */:
                        return emitJsxAttribute(node);
                    case 286 /* SyntaxKind.JsxAttributes */:
                        return emitJsxAttributes(node);
                    case 287 /* SyntaxKind.JsxSpreadAttribute */:
                        return emitJsxSpreadAttribute(node);
                    case 288 /* SyntaxKind.JsxExpression */:
                        return emitJsxExpression(node);
                    // Clauses
                    case 289 /* SyntaxKind.CaseClause */:
                        return emitCaseClause(node);
                    case 290 /* SyntaxKind.DefaultClause */:
                        return emitDefaultClause(node);
                    case 291 /* SyntaxKind.HeritageClause */:
                        return emitHeritageClause(node);
                    case 292 /* SyntaxKind.CatchClause */:
                        return emitCatchClause(node);
                    // Property assignments
                    case 296 /* SyntaxKind.PropertyAssignment */:
                        return emitPropertyAssignment(node);
                    case 297 /* SyntaxKind.ShorthandPropertyAssignment */:
                        return emitShorthandPropertyAssignment(node);
                    case 298 /* SyntaxKind.SpreadAssignment */:
                        return emitSpreadAssignment(node);
                    // Enum
                    case 299 /* SyntaxKind.EnumMember */:
                        return emitEnumMember(node);
                    // Unparsed
                    case 300 /* SyntaxKind.UnparsedPrologue */:
                        return writeUnparsedNode(node);
                    case 307 /* SyntaxKind.UnparsedSource */:
                    case 301 /* SyntaxKind.UnparsedPrepend */:
                        return emitUnparsedSourceOrPrepend(node);
                    case 302 /* SyntaxKind.UnparsedText */:
                    case 303 /* SyntaxKind.UnparsedInternalText */:
                        return emitUnparsedTextLike(node);
                    case 304 /* SyntaxKind.UnparsedSyntheticReference */:
                        return emitUnparsedSyntheticReference(node);
                    // Top-level nodes
                    case 305 /* SyntaxKind.SourceFile */:
                        return emitSourceFile(node);
                    case 306 /* SyntaxKind.Bundle */:
                        return ts.Debug.fail("Bundles should be printed using printBundle");
                    // SyntaxKind.UnparsedSource (handled above)
                    case 308 /* SyntaxKind.InputFiles */:
                        return ts.Debug.fail("InputFiles should not be printed");
                    // JSDoc nodes (only used in codefixes currently)
                    case 309 /* SyntaxKind.JSDocTypeExpression */:
                        return emitJSDocTypeExpression(node);
                    case 310 /* SyntaxKind.JSDocNameReference */:
                        return emitJSDocNameReference(node);
                    case 312 /* SyntaxKind.JSDocAllType */:
                        return writePunctuation("*");
                    case 313 /* SyntaxKind.JSDocUnknownType */:
                        return writePunctuation("?");
                    case 314 /* SyntaxKind.JSDocNullableType */:
                        return emitJSDocNullableType(node);
                    case 315 /* SyntaxKind.JSDocNonNullableType */:
                        return emitJSDocNonNullableType(node);
                    case 316 /* SyntaxKind.JSDocOptionalType */:
                        return emitJSDocOptionalType(node);
                    case 317 /* SyntaxKind.JSDocFunctionType */:
                        return emitJSDocFunctionType(node);
                    case 186 /* SyntaxKind.RestType */:
                    case 318 /* SyntaxKind.JSDocVariadicType */:
                        return emitRestOrJSDocVariadicType(node);
                    case 319 /* SyntaxKind.JSDocNamepathType */:
                        return;
                    case 320 /* SyntaxKind.JSDoc */:
                        return emitJSDoc(node);
                    case 322 /* SyntaxKind.JSDocTypeLiteral */:
                        return emitJSDocTypeLiteral(node);
                    case 323 /* SyntaxKind.JSDocSignature */:
                        return emitJSDocSignature(node);
                    case 327 /* SyntaxKind.JSDocTag */:
                    case 332 /* SyntaxKind.JSDocClassTag */:
                    case 337 /* SyntaxKind.JSDocOverrideTag */:
                        return emitJSDocSimpleTag(node);
                    case 328 /* SyntaxKind.JSDocAugmentsTag */:
                    case 329 /* SyntaxKind.JSDocImplementsTag */:
                        return emitJSDocHeritageTag(node);
                    case 330 /* SyntaxKind.JSDocAuthorTag */:
                    case 331 /* SyntaxKind.JSDocDeprecatedTag */:
                        return;
                    // SyntaxKind.JSDocClassTag (see JSDocTag, above)
                    case 333 /* SyntaxKind.JSDocPublicTag */:
                    case 334 /* SyntaxKind.JSDocPrivateTag */:
                    case 335 /* SyntaxKind.JSDocProtectedTag */:
                    case 336 /* SyntaxKind.JSDocReadonlyTag */:
                        return;
                    case 338 /* SyntaxKind.JSDocCallbackTag */:
                        return emitJSDocCallbackTag(node);
                    // SyntaxKind.JSDocEnumTag (see below)
                    case 340 /* SyntaxKind.JSDocParameterTag */:
                    case 347 /* SyntaxKind.JSDocPropertyTag */:
                        return emitJSDocPropertyLikeTag(node);
                    case 339 /* SyntaxKind.JSDocEnumTag */:
                    case 341 /* SyntaxKind.JSDocReturnTag */:
                    case 342 /* SyntaxKind.JSDocThisTag */:
                    case 343 /* SyntaxKind.JSDocTypeTag */:
                        return emitJSDocSimpleTypedTag(node);
                    case 344 /* SyntaxKind.JSDocTemplateTag */:
                        return emitJSDocTemplateTag(node);
                    case 345 /* SyntaxKind.JSDocTypedefTag */:
                        return emitJSDocTypedefTag(node);
                    case 346 /* SyntaxKind.JSDocSeeTag */:
                        return emitJSDocSeeTag(node);
                    // SyntaxKind.JSDocPropertyTag (see JSDocParameterTag, above)
                    // Transformation nodes
                    case 349 /* SyntaxKind.NotEmittedStatement */:
                    case 353 /* SyntaxKind.EndOfDeclarationMarker */:
                    case 352 /* SyntaxKind.MergeDeclarationMarker */:
                        return;
                }
                if (ts.isExpression(node)) {
                    hint = 1 /* EmitHint.Expression */;
                    if (substituteNode !== ts.noEmitSubstitution) {
                        var substitute = substituteNode(hint, node) || node;
                        if (substitute !== node) {
                            node = substitute;
                            if (currentParenthesizerRule) {
                                node = currentParenthesizerRule(node);
                            }
                        }
                    }
                }
            }
            if (hint === 1 /* EmitHint.Expression */) {
                switch (node.kind) {
                    // Literals
                    case 8 /* SyntaxKind.NumericLiteral */:
                    case 9 /* SyntaxKind.BigIntLiteral */:
                        return emitNumericOrBigIntLiteral(node);
                    case 10 /* SyntaxKind.StringLiteral */:
                    case 13 /* SyntaxKind.RegularExpressionLiteral */:
                    case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
                        return emitLiteral(node, /*jsxAttributeEscape*/ false);
                    // Identifiers
                    case 79 /* SyntaxKind.Identifier */:
                        return emitIdentifier(node);
                    case 80 /* SyntaxKind.PrivateIdentifier */:
                        return emitPrivateIdentifier(node);
                    // Expressions
                    case 204 /* SyntaxKind.ArrayLiteralExpression */:
                        return emitArrayLiteralExpression(node);
                    case 205 /* SyntaxKind.ObjectLiteralExpression */:
                        return emitObjectLiteralExpression(node);
                    case 206 /* SyntaxKind.PropertyAccessExpression */:
                        return emitPropertyAccessExpression(node);
                    case 207 /* SyntaxKind.ElementAccessExpression */:
                        return emitElementAccessExpression(node);
                    case 208 /* SyntaxKind.CallExpression */:
                        return emitCallExpression(node);
                    case 209 /* SyntaxKind.NewExpression */:
                        return emitNewExpression(node);
                    case 210 /* SyntaxKind.TaggedTemplateExpression */:
                        return emitTaggedTemplateExpression(node);
                    case 211 /* SyntaxKind.TypeAssertionExpression */:
                        return emitTypeAssertionExpression(node);
                    case 212 /* SyntaxKind.ParenthesizedExpression */:
                        return emitParenthesizedExpression(node);
                    case 213 /* SyntaxKind.FunctionExpression */:
                        return emitFunctionExpression(node);
                    case 214 /* SyntaxKind.ArrowFunction */:
                        return emitArrowFunction(node);
                    case 215 /* SyntaxKind.DeleteExpression */:
                        return emitDeleteExpression(node);
                    case 216 /* SyntaxKind.TypeOfExpression */:
                        return emitTypeOfExpression(node);
                    case 217 /* SyntaxKind.VoidExpression */:
                        return emitVoidExpression(node);
                    case 218 /* SyntaxKind.AwaitExpression */:
                        return emitAwaitExpression(node);
                    case 219 /* SyntaxKind.PrefixUnaryExpression */:
                        return emitPrefixUnaryExpression(node);
                    case 220 /* SyntaxKind.PostfixUnaryExpression */:
                        return emitPostfixUnaryExpression(node);
                    case 221 /* SyntaxKind.BinaryExpression */:
                        return emitBinaryExpression(node);
                    case 222 /* SyntaxKind.ConditionalExpression */:
                        return emitConditionalExpression(node);
                    case 223 /* SyntaxKind.TemplateExpression */:
                        return emitTemplateExpression(node);
                    case 224 /* SyntaxKind.YieldExpression */:
                        return emitYieldExpression(node);
                    case 225 /* SyntaxKind.SpreadElement */:
                        return emitSpreadElement(node);
                    case 226 /* SyntaxKind.ClassExpression */:
                        return emitClassExpression(node);
                    case 227 /* SyntaxKind.OmittedExpression */:
                        return;
                    case 229 /* SyntaxKind.AsExpression */:
                        return emitAsExpression(node);
                    case 230 /* SyntaxKind.NonNullExpression */:
                        return emitNonNullExpression(node);
                    case 228 /* SyntaxKind.ExpressionWithTypeArguments */:
                        return emitExpressionWithTypeArguments(node);
                    case 231 /* SyntaxKind.MetaProperty */:
                        return emitMetaProperty(node);
                    case 232 /* SyntaxKind.SyntheticExpression */:
                        return ts.Debug.fail("SyntheticExpression should never be printed.");
                    // JSX
                    case 278 /* SyntaxKind.JsxElement */:
                        return emitJsxElement(node);
                    case 279 /* SyntaxKind.JsxSelfClosingElement */:
                        return emitJsxSelfClosingElement(node);
                    case 282 /* SyntaxKind.JsxFragment */:
                        return emitJsxFragment(node);
                    // Synthesized list
                    case 348 /* SyntaxKind.SyntaxList */:
                        return ts.Debug.fail("SyntaxList should not be printed");
                    // Transformation nodes
                    case 349 /* SyntaxKind.NotEmittedStatement */:
                        return;
                    case 350 /* SyntaxKind.PartiallyEmittedExpression */:
                        return emitPartiallyEmittedExpression(node);
                    case 351 /* SyntaxKind.CommaListExpression */:
                        return emitCommaList(node);
                    case 352 /* SyntaxKind.MergeDeclarationMarker */:
                    case 353 /* SyntaxKind.EndOfDeclarationMarker */:
                        return;
                    case 354 /* SyntaxKind.SyntheticReferenceExpression */:
                        return ts.Debug.fail("SyntheticReferenceExpression should not be printed");
                }
            }
            if (ts.isKeyword(node.kind))
                return writeTokenNode(node, writeKeyword);
            if (ts.isTokenKind(node.kind))
                return writeTokenNode(node, writePunctuation);
            ts.Debug.fail("Unhandled SyntaxKind: ".concat(ts.Debug.formatSyntaxKind(node.kind), "."));
        }
        function emitMappedTypeParameter(node) {
            emit(node.name);
            writeSpace();
            writeKeyword("in");
            writeSpace();
            emit(node.constraint);
        }
        function pipelineEmitWithSubstitution(hint, node) {
            var pipelinePhase = getNextPipelinePhase(1 /* PipelinePhase.Substitution */, hint, node);
            ts.Debug.assertIsDefined(lastSubstitution);
            node = lastSubstitution;
            lastSubstitution = undefined;
            pipelinePhase(hint, node);
        }
        function getHelpersFromBundledSourceFiles(bundle) {
            var result;
            if (moduleKind === ts.ModuleKind.None || printerOptions.noEmitHelpers) {
                return undefined;
            }
            var bundledHelpers = new ts.Map();
            for (var _a = 0, _b = bundle.sourceFiles; _a < _b.length; _a++) {
                var sourceFile = _b[_a];
                var shouldSkip = ts.getExternalHelpersModuleName(sourceFile) !== undefined;
                var helpers = getSortedEmitHelpers(sourceFile);
                if (!helpers)
                    continue;
                for (var _c = 0, helpers_5 = helpers; _c < helpers_5.length; _c++) {
                    var helper = helpers_5[_c];
                    if (!helper.scoped && !shouldSkip && !bundledHelpers.get(helper.name)) {
                        bundledHelpers.set(helper.name, true);
                        (result || (result = [])).push(helper.name);
                    }
                }
            }
            return result;
        }
        function emitHelpers(node) {
            var helpersEmitted = false;
            var bundle = node.kind === 306 /* SyntaxKind.Bundle */ ? node : undefined;
            if (bundle && moduleKind === ts.ModuleKind.None) {
                return;
            }
            var numPrepends = bundle ? bundle.prepends.length : 0;
            var numNodes = bundle ? bundle.sourceFiles.length + numPrepends : 1;
            for (var i = 0; i < numNodes; i++) {
                var currentNode = bundle ? i < numPrepends ? bundle.prepends[i] : bundle.sourceFiles[i - numPrepends] : node;
                var sourceFile = ts.isSourceFile(currentNode) ? currentNode : ts.isUnparsedSource(currentNode) ? undefined : currentSourceFile;
                var shouldSkip = printerOptions.noEmitHelpers || (!!sourceFile && ts.hasRecordedExternalHelpers(sourceFile));
                var shouldBundle = (ts.isSourceFile(currentNode) || ts.isUnparsedSource(currentNode)) && !isOwnFileEmit;
                var helpers = ts.isUnparsedSource(currentNode) ? currentNode.helpers : getSortedEmitHelpers(currentNode);
                if (helpers) {
                    for (var _a = 0, helpers_6 = helpers; _a < helpers_6.length; _a++) {
                        var helper = helpers_6[_a];
                        if (!helper.scoped) {
                            // Skip the helper if it can be skipped and the noEmitHelpers compiler
                            // option is set, or if it can be imported and the importHelpers compiler
                            // option is set.
                            if (shouldSkip)
                                continue;
                            // Skip the helper if it can be bundled but hasn't already been emitted and we
                            // are emitting a bundled module.
                            if (shouldBundle) {
                                if (bundledHelpers.get(helper.name)) {
                                    continue;
                                }
                                bundledHelpers.set(helper.name, true);
                            }
                        }
                        else if (bundle) {
                            // Skip the helper if it is scoped and we are emitting bundled helpers
                            continue;
                        }
                        var pos = getTextPosWithWriteLine();
                        if (typeof helper.text === "string") {
                            writeLines(helper.text);
                        }
                        else {
                            writeLines(helper.text(makeFileLevelOptimisticUniqueName));
                        }
                        if (bundleFileInfo)
                            bundleFileInfo.sections.push({ pos: pos, end: writer.getTextPos(), kind: "emitHelpers" /* BundleFileSectionKind.EmitHelpers */, data: helper.name });
                        helpersEmitted = true;
                    }
                }
            }
            return helpersEmitted;
        }
        function getSortedEmitHelpers(node) {
            var helpers = ts.getEmitHelpers(node);
            return helpers && ts.stableSort(helpers, ts.compareEmitHelpers);
        }
        //
        // Literals/Pseudo-literals
        //
        // SyntaxKind.NumericLiteral
        // SyntaxKind.BigIntLiteral
        function emitNumericOrBigIntLiteral(node) {
            emitLiteral(node, /*jsxAttributeEscape*/ false);
        }
        // SyntaxKind.StringLiteral
        // SyntaxKind.RegularExpressionLiteral
        // SyntaxKind.NoSubstitutionTemplateLiteral
        // SyntaxKind.TemplateHead
        // SyntaxKind.TemplateMiddle
        // SyntaxKind.TemplateTail
        function emitLiteral(node, jsxAttributeEscape) {
            var text = getLiteralTextOfNode(node, printerOptions.neverAsciiEscape, jsxAttributeEscape);
            if ((printerOptions.sourceMap || printerOptions.inlineSourceMap)
                && (node.kind === 10 /* SyntaxKind.StringLiteral */ || ts.isTemplateLiteralKind(node.kind))) {
                writeLiteral(text);
            }
            else {
                // Quick info expects all literals to be called with writeStringLiteral, as there's no specific type for numberLiterals
                writeStringLiteral(text);
            }
        }
        // SyntaxKind.UnparsedSource
        // SyntaxKind.UnparsedPrepend
        function emitUnparsedSourceOrPrepend(unparsed) {
            for (var _a = 0, _b = unparsed.texts; _a < _b.length; _a++) {
                var text = _b[_a];
                writeLine();
                emit(text);
            }
        }
        // SyntaxKind.UnparsedPrologue
        // SyntaxKind.UnparsedText
        // SyntaxKind.UnparsedInternal
        // SyntaxKind.UnparsedSyntheticReference
        function writeUnparsedNode(unparsed) {
            writer.rawWrite(unparsed.parent.text.substring(unparsed.pos, unparsed.end));
        }
        // SyntaxKind.UnparsedText
        // SyntaxKind.UnparsedInternal
        function emitUnparsedTextLike(unparsed) {
            var pos = getTextPosWithWriteLine();
            writeUnparsedNode(unparsed);
            if (bundleFileInfo) {
                updateOrPushBundleFileTextLike(pos, writer.getTextPos(), unparsed.kind === 302 /* SyntaxKind.UnparsedText */ ?
                    "text" /* BundleFileSectionKind.Text */ :
                    "internal" /* BundleFileSectionKind.Internal */);
            }
        }
        // SyntaxKind.UnparsedSyntheticReference
        function emitUnparsedSyntheticReference(unparsed) {
            var pos = getTextPosWithWriteLine();
            writeUnparsedNode(unparsed);
            if (bundleFileInfo) {
                var section = ts.clone(unparsed.section);
                section.pos = pos;
                section.end = writer.getTextPos();
                bundleFileInfo.sections.push(section);
            }
        }
        //
        // Snippet Elements
        //
        function emitSnippetNode(hint, node, snippet) {
            switch (snippet.kind) {
                case 1 /* SnippetKind.Placeholder */:
                    emitPlaceholder(hint, node, snippet);
                    break;
                case 0 /* SnippetKind.TabStop */:
                    emitTabStop(hint, node, snippet);
                    break;
            }
        }
        function emitPlaceholder(hint, node, snippet) {
            nonEscapingWrite("${".concat(snippet.order, ":")); // `${2:`
            pipelineEmitWithHintWorker(hint, node, /*allowSnippets*/ false); // `...`
            nonEscapingWrite("}"); // `}`
            // `${2:...}`
        }
        function emitTabStop(hint, node, snippet) {
            // A tab stop should only be attached to an empty node, i.e. a node that doesn't emit any text.
            ts.Debug.assert(node.kind === 236 /* SyntaxKind.EmptyStatement */, "A tab stop cannot be attached to a node of kind ".concat(ts.Debug.formatSyntaxKind(node.kind), "."));
            ts.Debug.assert(hint !== 5 /* EmitHint.EmbeddedStatement */, "A tab stop cannot be attached to an embedded statement.");
            nonEscapingWrite("$".concat(snippet.order));
        }
        //
        // Identifiers
        //
        function emitIdentifier(node) {
            var writeText = node.symbol ? writeSymbol : write;
            writeText(getTextOfNode(node, /*includeTrivia*/ false), node.symbol);
            emitList(node, node.typeArguments, 53776 /* ListFormat.TypeParameters */); // Call emitList directly since it could be an array of TypeParameterDeclarations _or_ type arguments
        }
        //
        // Names
        //
        function emitPrivateIdentifier(node) {
            var writeText = node.symbol ? writeSymbol : write;
            writeText(getTextOfNode(node, /*includeTrivia*/ false), node.symbol);
        }
        function emitQualifiedName(node) {
            emitEntityName(node.left);
            writePunctuation(".");
            emit(node.right);
        }
        function emitEntityName(node) {
            if (node.kind === 79 /* SyntaxKind.Identifier */) {
                emitExpression(node);
            }
            else {
                emit(node);
            }
        }
        function emitComputedPropertyName(node) {
            writePunctuation("[");
            emitExpression(node.expression, parenthesizer.parenthesizeExpressionOfComputedPropertyName);
            writePunctuation("]");
        }
        //
        // Signature elements
        //
        function emitTypeParameter(node) {
            emitModifiers(node, node.modifiers);
            emit(node.name);
            if (node.constraint) {
                writeSpace();
                writeKeyword("extends");
                writeSpace();
                emit(node.constraint);
            }
            if (node.default) {
                writeSpace();
                writeOperator("=");
                writeSpace();
                emit(node.default);
            }
        }
        function emitParameter(node) {
            emitDecorators(node, node.decorators);
            emitModifiers(node, node.modifiers);
            emit(node.dotDotDotToken);
            emitNodeWithWriter(node.name, writeParameter);
            emit(node.questionToken);
            if (node.parent && node.parent.kind === 317 /* SyntaxKind.JSDocFunctionType */ && !node.name) {
                emit(node.type);
            }
            else {
                emitTypeAnnotation(node.type);
            }
            // The comment position has to fallback to any present node within the parameterdeclaration because as it turns out, the parser can make parameter declarations with _just_ an initializer.
            emitInitializer(node.initializer, node.type ? node.type.end : node.questionToken ? node.questionToken.end : node.name ? node.name.end : node.modifiers ? node.modifiers.end : node.decorators ? node.decorators.end : node.pos, node, parenthesizer.parenthesizeExpressionForDisallowedComma);
        }
        function emitDecorator(decorator) {
            writePunctuation("@");
            emitExpression(decorator.expression, parenthesizer.parenthesizeLeftSideOfAccess);
        }
        //
        // Type members
        //
        function emitPropertySignature(node) {
            emitDecorators(node, node.decorators);
            emitModifiers(node, node.modifiers);
            emitNodeWithWriter(node.name, writeProperty);
            emit(node.questionToken);
            emitTypeAnnotation(node.type);
            writeTrailingSemicolon();
        }
        function emitPropertyDeclaration(node) {
            emitDecorators(node, node.decorators);
            emitModifiers(node, node.modifiers);
            emit(node.name);
            emit(node.questionToken);
            emit(node.exclamationToken);
            emitTypeAnnotation(node.type);
            emitInitializer(node.initializer, node.type ? node.type.end : node.questionToken ? node.questionToken.end : node.name.end, node);
            writeTrailingSemicolon();
        }
        function emitMethodSignature(node) {
            pushNameGenerationScope(node);
            emitDecorators(node, node.decorators);
            emitModifiers(node, node.modifiers);
            emit(node.name);
            emit(node.questionToken);
            emitTypeParameters(node, node.typeParameters);
            emitParameters(node, node.parameters);
            emitTypeAnnotation(node.type);
            writeTrailingSemicolon();
            popNameGenerationScope(node);
        }
        function emitMethodDeclaration(node) {
            emitDecorators(node, node.decorators);
            emitModifiers(node, node.modifiers);
            emit(node.asteriskToken);
            emit(node.name);
            emit(node.questionToken);
            emitSignatureAndBody(node, emitSignatureHead);
        }
        function emitClassStaticBlockDeclaration(node) {
            emitDecorators(node, node.decorators);
            emitModifiers(node, node.modifiers);
            writeKeyword("static");
            emitBlockFunctionBody(node.body);
        }
        function emitConstructor(node) {
            emitModifiers(node, node.modifiers);
            writeKeyword("constructor");
            emitSignatureAndBody(node, emitSignatureHead);
        }
        function emitAccessorDeclaration(node) {
            emitDecorators(node, node.decorators);
            emitModifiers(node, node.modifiers);
            writeKeyword(node.kind === 172 /* SyntaxKind.GetAccessor */ ? "get" : "set");
            writeSpace();
            emit(node.name);
            emitSignatureAndBody(node, emitSignatureHead);
        }
        function emitCallSignature(node) {
            pushNameGenerationScope(node);
            emitDecorators(node, node.decorators);
            emitModifiers(node, node.modifiers);
            emitTypeParameters(node, node.typeParameters);
            emitParameters(node, node.parameters);
            emitTypeAnnotation(node.type);
            writeTrailingSemicolon();
            popNameGenerationScope(node);
        }
        function emitConstructSignature(node) {
            pushNameGenerationScope(node);
            emitDecorators(node, node.decorators);
            emitModifiers(node, node.modifiers);
            writeKeyword("new");
            writeSpace();
            emitTypeParameters(node, node.typeParameters);
            emitParameters(node, node.parameters);
            emitTypeAnnotation(node.type);
            writeTrailingSemicolon();
            popNameGenerationScope(node);
        }
        function emitIndexSignature(node) {
            emitDecorators(node, node.decorators);
            emitModifiers(node, node.modifiers);
            emitParametersForIndexSignature(node, node.parameters);
            emitTypeAnnotation(node.type);
            writeTrailingSemicolon();
        }
        function emitTemplateTypeSpan(node) {
            emit(node.type);
            emit(node.literal);
        }
        function emitSemicolonClassElement() {
            writeTrailingSemicolon();
        }
        //
        // Types
        //
        function emitTypePredicate(node) {
            if (node.assertsModifier) {
                emit(node.assertsModifier);
                writeSpace();
            }
            emit(node.parameterName);
            if (node.type) {
                writeSpace();
                writeKeyword("is");
                writeSpace();
                emit(node.type);
            }
        }
        function emitTypeReference(node) {
            emit(node.typeName);
            emitTypeArguments(node, node.typeArguments);
        }
        function emitFunctionType(node) {
            pushNameGenerationScope(node);
            emitTypeParameters(node, node.typeParameters);
            emitParametersForArrow(node, node.parameters);
            writeSpace();
            writePunctuation("=>");
            writeSpace();
            emit(node.type);
            popNameGenerationScope(node);
        }
        function emitJSDocFunctionType(node) {
            writeKeyword("function");
            emitParameters(node, node.parameters);
            writePunctuation(":");
            emit(node.type);
        }
        function emitJSDocNullableType(node) {
            writePunctuation("?");
            emit(node.type);
        }
        function emitJSDocNonNullableType(node) {
            writePunctuation("!");
            emit(node.type);
        }
        function emitJSDocOptionalType(node) {
            emit(node.type);
            writePunctuation("=");
        }
        function emitConstructorType(node) {
            pushNameGenerationScope(node);
            emitModifiers(node, node.modifiers);
            writeKeyword("new");
            writeSpace();
            emitTypeParameters(node, node.typeParameters);
            emitParameters(node, node.parameters);
            writeSpace();
            writePunctuation("=>");
            writeSpace();
            emit(node.type);
            popNameGenerationScope(node);
        }
        function emitTypeQuery(node) {
            writeKeyword("typeof");
            writeSpace();
            emit(node.exprName);
            emitTypeArguments(node, node.typeArguments);
        }
        function emitTypeLiteral(node) {
            writePunctuation("{");
            var flags = ts.getEmitFlags(node) & 1 /* EmitFlags.SingleLine */ ? 768 /* ListFormat.SingleLineTypeLiteralMembers */ : 32897 /* ListFormat.MultiLineTypeLiteralMembers */;
            emitList(node, node.members, flags | 524288 /* ListFormat.NoSpaceIfEmpty */);
            writePunctuation("}");
        }
        function emitArrayType(node) {
            emit(node.elementType, parenthesizer.parenthesizeNonArrayTypeOfPostfixType);
            writePunctuation("[");
            writePunctuation("]");
        }
        function emitRestOrJSDocVariadicType(node) {
            writePunctuation("...");
            emit(node.type);
        }
        function emitTupleType(node) {
            emitTokenWithComment(22 /* SyntaxKind.OpenBracketToken */, node.pos, writePunctuation, node);
            var flags = ts.getEmitFlags(node) & 1 /* EmitFlags.SingleLine */ ? 528 /* ListFormat.SingleLineTupleTypeElements */ : 657 /* ListFormat.MultiLineTupleTypeElements */;
            emitList(node, node.elements, flags | 524288 /* ListFormat.NoSpaceIfEmpty */, parenthesizer.parenthesizeElementTypeOfTupleType);
            emitTokenWithComment(23 /* SyntaxKind.CloseBracketToken */, node.elements.end, writePunctuation, node);
        }
        function emitNamedTupleMember(node) {
            emit(node.dotDotDotToken);
            emit(node.name);
            emit(node.questionToken);
            emitTokenWithComment(58 /* SyntaxKind.ColonToken */, node.name.end, writePunctuation, node);
            writeSpace();
            emit(node.type);
        }
        function emitOptionalType(node) {
            emit(node.type, parenthesizer.parenthesizeTypeOfOptionalType);
            writePunctuation("?");
        }
        function emitUnionType(node) {
            emitList(node, node.types, 516 /* ListFormat.UnionTypeConstituents */, parenthesizer.parenthesizeConstituentTypeOfUnionType);
        }
        function emitIntersectionType(node) {
            emitList(node, node.types, 520 /* ListFormat.IntersectionTypeConstituents */, parenthesizer.parenthesizeConstituentTypeOfIntersectionType);
        }
        function emitConditionalType(node) {
            emit(node.checkType, parenthesizer.parenthesizeCheckTypeOfConditionalType);
            writeSpace();
            writeKeyword("extends");
            writeSpace();
            emit(node.extendsType, parenthesizer.parenthesizeExtendsTypeOfConditionalType);
            writeSpace();
            writePunctuation("?");
            writeSpace();
            emit(node.trueType);
            writeSpace();
            writePunctuation(":");
            writeSpace();
            emit(node.falseType);
        }
        function emitInferType(node) {
            writeKeyword("infer");
            writeSpace();
            emit(node.typeParameter);
        }
        function emitParenthesizedType(node) {
            writePunctuation("(");
            emit(node.type);
            writePunctuation(")");
        }
        function emitThisType() {
            writeKeyword("this");
        }
        function emitTypeOperator(node) {
            writeTokenText(node.operator, writeKeyword);
            writeSpace();
            var parenthesizerRule = node.operator === 145 /* SyntaxKind.ReadonlyKeyword */ ?
                parenthesizer.parenthesizeOperandOfReadonlyTypeOperator :
                parenthesizer.parenthesizeOperandOfTypeOperator;
            emit(node.type, parenthesizerRule);
        }
        function emitIndexedAccessType(node) {
            emit(node.objectType, parenthesizer.parenthesizeNonArrayTypeOfPostfixType);
            writePunctuation("[");
            emit(node.indexType);
            writePunctuation("]");
        }
        function emitMappedType(node) {
            var emitFlags = ts.getEmitFlags(node);
            writePunctuation("{");
            if (emitFlags & 1 /* EmitFlags.SingleLine */) {
                writeSpace();
            }
            else {
                writeLine();
                increaseIndent();
            }
            if (node.readonlyToken) {
                emit(node.readonlyToken);
                if (node.readonlyToken.kind !== 145 /* SyntaxKind.ReadonlyKeyword */) {
                    writeKeyword("readonly");
                }
                writeSpace();
            }
            writePunctuation("[");
            pipelineEmit(3 /* EmitHint.MappedTypeParameter */, node.typeParameter);
            if (node.nameType) {
                writeSpace();
                writeKeyword("as");
                writeSpace();
                emit(node.nameType);
            }
            writePunctuation("]");
            if (node.questionToken) {
                emit(node.questionToken);
                if (node.questionToken.kind !== 57 /* SyntaxKind.QuestionToken */) {
                    writePunctuation("?");
                }
            }
            writePunctuation(":");
            writeSpace();
            emit(node.type);
            writeTrailingSemicolon();
            if (emitFlags & 1 /* EmitFlags.SingleLine */) {
                writeSpace();
            }
            else {
                writeLine();
                decreaseIndent();
            }
            emitList(node, node.members, 2 /* ListFormat.PreserveLines */);
            writePunctuation("}");
        }
        function emitLiteralType(node) {
            emitExpression(node.literal);
        }
        function emitTemplateType(node) {
            emit(node.head);
            emitList(node, node.templateSpans, 262144 /* ListFormat.TemplateExpressionSpans */);
        }
        function emitImportTypeNode(node) {
            if (node.isTypeOf) {
                writeKeyword("typeof");
                writeSpace();
            }
            writeKeyword("import");
            writePunctuation("(");
            emit(node.argument);
            if (node.assertions) {
                writePunctuation(",");
                writeSpace();
                writePunctuation("{");
                writeSpace();
                writeKeyword("assert");
                writePunctuation(":");
                writeSpace();
                var elements = node.assertions.assertClause.elements;
                emitList(node.assertions.assertClause, elements, 526226 /* ListFormat.ImportClauseEntries */);
                writeSpace();
                writePunctuation("}");
            }
            writePunctuation(")");
            if (node.qualifier) {
                writePunctuation(".");
                emit(node.qualifier);
            }
            emitTypeArguments(node, node.typeArguments);
        }
        //
        // Binding patterns
        //
        function emitObjectBindingPattern(node) {
            writePunctuation("{");
            emitList(node, node.elements, 525136 /* ListFormat.ObjectBindingPatternElements */);
            writePunctuation("}");
        }
        function emitArrayBindingPattern(node) {
            writePunctuation("[");
            emitList(node, node.elements, 524880 /* ListFormat.ArrayBindingPatternElements */);
            writePunctuation("]");
        }
        function emitBindingElement(node) {
            emit(node.dotDotDotToken);
            if (node.propertyName) {
                emit(node.propertyName);
                writePunctuation(":");
                writeSpace();
            }
            emit(node.name);
            emitInitializer(node.initializer, node.name.end, node, parenthesizer.parenthesizeExpressionForDisallowedComma);
        }
        //
        // Expressions
        //
        function emitArrayLiteralExpression(node) {
            var elements = node.elements;
            var preferNewLine = node.multiLine ? 65536 /* ListFormat.PreferNewLine */ : 0 /* ListFormat.None */;
            emitExpressionList(node, elements, 8914 /* ListFormat.ArrayLiteralExpressionElements */ | preferNewLine, parenthesizer.parenthesizeExpressionForDisallowedComma);
        }
        function emitObjectLiteralExpression(node) {
            ts.forEach(node.properties, generateMemberNames);
            var indentedFlag = ts.getEmitFlags(node) & 65536 /* EmitFlags.Indented */;
            if (indentedFlag) {
                increaseIndent();
            }
            var preferNewLine = node.multiLine ? 65536 /* ListFormat.PreferNewLine */ : 0 /* ListFormat.None */;
            var allowTrailingComma = currentSourceFile && currentSourceFile.languageVersion >= 1 /* ScriptTarget.ES5 */ && !ts.isJsonSourceFile(currentSourceFile) ? 64 /* ListFormat.AllowTrailingComma */ : 0 /* ListFormat.None */;
            emitList(node, node.properties, 526226 /* ListFormat.ObjectLiteralExpressionProperties */ | allowTrailingComma | preferNewLine);
            if (indentedFlag) {
                decreaseIndent();
            }
        }
        function emitPropertyAccessExpression(node) {
            emitExpression(node.expression, parenthesizer.parenthesizeLeftSideOfAccess);
            var token = node.questionDotToken || ts.setTextRangePosEnd(ts.factory.createToken(24 /* SyntaxKind.DotToken */), node.expression.end, node.name.pos);
            var linesBeforeDot = getLinesBetweenNodes(node, node.expression, token);
            var linesAfterDot = getLinesBetweenNodes(node, token, node.name);
            writeLinesAndIndent(linesBeforeDot, /*writeSpaceIfNotIndenting*/ false);
            var shouldEmitDotDot = token.kind !== 28 /* SyntaxKind.QuestionDotToken */ &&
                mayNeedDotDotForPropertyAccess(node.expression) &&
                !writer.hasTrailingComment() &&
                !writer.hasTrailingWhitespace();
            if (shouldEmitDotDot) {
                writePunctuation(".");
            }
            if (node.questionDotToken) {
                emit(token);
            }
            else {
                emitTokenWithComment(token.kind, node.expression.end, writePunctuation, node);
            }
            writeLinesAndIndent(linesAfterDot, /*writeSpaceIfNotIndenting*/ false);
            emit(node.name);
            decreaseIndentIf(linesBeforeDot, linesAfterDot);
        }
        // 1..toString is a valid property access, emit a dot after the literal
        // Also emit a dot if expression is a integer const enum value - it will appear in generated code as numeric literal
        function mayNeedDotDotForPropertyAccess(expression) {
            expression = ts.skipPartiallyEmittedExpressions(expression);
            if (ts.isNumericLiteral(expression)) {
                // check if numeric literal is a decimal literal that was originally written with a dot
                var text = getLiteralTextOfNode(expression, /*neverAsciiEscape*/ true, /*jsxAttributeEscape*/ false);
                // If he number will be printed verbatim and it doesn't already contain a dot, add one
                // if the expression doesn't have any comments that will be emitted.
                return !expression.numericLiteralFlags && !ts.stringContains(text, ts.tokenToString(24 /* SyntaxKind.DotToken */));
            }
            else if (ts.isAccessExpression(expression)) {
                // check if constant enum value is integer
                var constantValue = ts.getConstantValue(expression);
                // isFinite handles cases when constantValue is undefined
                return typeof constantValue === "number" && isFinite(constantValue)
                    && Math.floor(constantValue) === constantValue;
            }
        }
        function emitElementAccessExpression(node) {
            emitExpression(node.expression, parenthesizer.parenthesizeLeftSideOfAccess);
            emit(node.questionDotToken);
            emitTokenWithComment(22 /* SyntaxKind.OpenBracketToken */, node.expression.end, writePunctuation, node);
            emitExpression(node.argumentExpression);
            emitTokenWithComment(23 /* SyntaxKind.CloseBracketToken */, node.argumentExpression.end, writePunctuation, node);
        }
        function emitCallExpression(node) {
            var indirectCall = ts.getEmitFlags(node) & 536870912 /* EmitFlags.IndirectCall */;
            if (indirectCall) {
                writePunctuation("(");
                writeLiteral("0");
                writePunctuation(",");
                writeSpace();
            }
            emitExpression(node.expression, parenthesizer.parenthesizeLeftSideOfAccess);
            if (indirectCall) {
                writePunctuation(")");
            }
            emit(node.questionDotToken);
            emitTypeArguments(node, node.typeArguments);
            emitExpressionList(node, node.arguments, 2576 /* ListFormat.CallExpressionArguments */, parenthesizer.parenthesizeExpressionForDisallowedComma);
        }
        function emitNewExpression(node) {
            emitTokenWithComment(103 /* SyntaxKind.NewKeyword */, node.pos, writeKeyword, node);
            writeSpace();
            emitExpression(node.expression, parenthesizer.parenthesizeExpressionOfNew);
            emitTypeArguments(node, node.typeArguments);
            emitExpressionList(node, node.arguments, 18960 /* ListFormat.NewExpressionArguments */, parenthesizer.parenthesizeExpressionForDisallowedComma);
        }
        function emitTaggedTemplateExpression(node) {
            var indirectCall = ts.getEmitFlags(node) & 536870912 /* EmitFlags.IndirectCall */;
            if (indirectCall) {
                writePunctuation("(");
                writeLiteral("0");
                writePunctuation(",");
                writeSpace();
            }
            emitExpression(node.tag, parenthesizer.parenthesizeLeftSideOfAccess);
            if (indirectCall) {
                writePunctuation(")");
            }
            emitTypeArguments(node, node.typeArguments);
            writeSpace();
            emitExpression(node.template);
        }
        function emitTypeAssertionExpression(node) {
            writePunctuation("<");
            emit(node.type);
            writePunctuation(">");
            emitExpression(node.expression, parenthesizer.parenthesizeOperandOfPrefixUnary);
        }
        function emitParenthesizedExpression(node) {
            var openParenPos = emitTokenWithComment(20 /* SyntaxKind.OpenParenToken */, node.pos, writePunctuation, node);
            var indented = writeLineSeparatorsAndIndentBefore(node.expression, node);
            emitExpression(node.expression, /*parenthesizerRules*/ undefined);
            writeLineSeparatorsAfter(node.expression, node);
            decreaseIndentIf(indented);
            emitTokenWithComment(21 /* SyntaxKind.CloseParenToken */, node.expression ? node.expression.end : openParenPos, writePunctuation, node);
        }
        function emitFunctionExpression(node) {
            generateNameIfNeeded(node.name);
            emitFunctionDeclarationOrExpression(node);
        }
        function emitArrowFunction(node) {
            emitDecorators(node, node.decorators);
            emitModifiers(node, node.modifiers);
            emitSignatureAndBody(node, emitArrowFunctionHead);
        }
        function emitArrowFunctionHead(node) {
            emitTypeParameters(node, node.typeParameters);
            emitParametersForArrow(node, node.parameters);
            emitTypeAnnotation(node.type);
            writeSpace();
            emit(node.equalsGreaterThanToken);
        }
        function emitDeleteExpression(node) {
            emitTokenWithComment(89 /* SyntaxKind.DeleteKeyword */, node.pos, writeKeyword, node);
            writeSpace();
            emitExpression(node.expression, parenthesizer.parenthesizeOperandOfPrefixUnary);
        }
        function emitTypeOfExpression(node) {
            emitTokenWithComment(112 /* SyntaxKind.TypeOfKeyword */, node.pos, writeKeyword, node);
            writeSpace();
            emitExpression(node.expression, parenthesizer.parenthesizeOperandOfPrefixUnary);
        }
        function emitVoidExpression(node) {
            emitTokenWithComment(114 /* SyntaxKind.VoidKeyword */, node.pos, writeKeyword, node);
            writeSpace();
            emitExpression(node.expression, parenthesizer.parenthesizeOperandOfPrefixUnary);
        }
        function emitAwaitExpression(node) {
            emitTokenWithComment(132 /* SyntaxKind.AwaitKeyword */, node.pos, writeKeyword, node);
            writeSpace();
            emitExpression(node.expression, parenthesizer.parenthesizeOperandOfPrefixUnary);
        }
        function emitPrefixUnaryExpression(node) {
            writeTokenText(node.operator, writeOperator);
            if (shouldEmitWhitespaceBeforeOperand(node)) {
                writeSpace();
            }
            emitExpression(node.operand, parenthesizer.parenthesizeOperandOfPrefixUnary);
        }
        function shouldEmitWhitespaceBeforeOperand(node) {
            // In some cases, we need to emit a space between the operator and the operand. One obvious case
            // is when the operator is an identifier, like delete or typeof. We also need to do this for plus
            // and minus expressions in certain cases. Specifically, consider the following two cases (parens
            // are just for clarity of exposition, and not part of the source code):
            //
            //  (+(+1))
            //  (+(++1))
            //
            // We need to emit a space in both cases. In the first case, the absence of a space will make
            // the resulting expression a prefix increment operation. And in the second, it will make the resulting
            // expression a prefix increment whose operand is a plus expression - (++(+x))
            // The same is true of minus of course.
            var operand = node.operand;
            return operand.kind === 219 /* SyntaxKind.PrefixUnaryExpression */
                && ((node.operator === 39 /* SyntaxKind.PlusToken */ && (operand.operator === 39 /* SyntaxKind.PlusToken */ || operand.operator === 45 /* SyntaxKind.PlusPlusToken */))
                    || (node.operator === 40 /* SyntaxKind.MinusToken */ && (operand.operator === 40 /* SyntaxKind.MinusToken */ || operand.operator === 46 /* SyntaxKind.MinusMinusToken */)));
        }
        function emitPostfixUnaryExpression(node) {
            emitExpression(node.operand, parenthesizer.parenthesizeOperandOfPostfixUnary);
            writeTokenText(node.operator, writeOperator);
        }
        function createEmitBinaryExpression() {
            return ts.createBinaryExpressionTrampoline(onEnter, onLeft, onOperator, onRight, onExit, /*foldState*/ undefined);
            function onEnter(node, state) {
                if (state) {
                    state.stackIndex++;
                    state.preserveSourceNewlinesStack[state.stackIndex] = preserveSourceNewlines;
                    state.containerPosStack[state.stackIndex] = containerPos;
                    state.containerEndStack[state.stackIndex] = containerEnd;
                    state.declarationListContainerEndStack[state.stackIndex] = declarationListContainerEnd;
                    var emitComments_1 = state.shouldEmitCommentsStack[state.stackIndex] = shouldEmitComments(node);
                    var emitSourceMaps = state.shouldEmitSourceMapsStack[state.stackIndex] = shouldEmitSourceMaps(node);
                    onBeforeEmitNode === null || onBeforeEmitNode === void 0 ? void 0 : onBeforeEmitNode(node);
                    if (emitComments_1)
                        emitCommentsBeforeNode(node);
                    if (emitSourceMaps)
                        emitSourceMapsBeforeNode(node);
                    beforeEmitNode(node);
                }
                else {
                    state = {
                        stackIndex: 0,
                        preserveSourceNewlinesStack: [undefined],
                        containerPosStack: [-1],
                        containerEndStack: [-1],
                        declarationListContainerEndStack: [-1],
                        shouldEmitCommentsStack: [false],
                        shouldEmitSourceMapsStack: [false],
                    };
                }
                return state;
            }
            function onLeft(next, _workArea, parent) {
                return maybeEmitExpression(next, parent, "left");
            }
            function onOperator(operatorToken, _state, node) {
                var isCommaOperator = operatorToken.kind !== 27 /* SyntaxKind.CommaToken */;
                var linesBeforeOperator = getLinesBetweenNodes(node, node.left, operatorToken);
                var linesAfterOperator = getLinesBetweenNodes(node, operatorToken, node.right);
                writeLinesAndIndent(linesBeforeOperator, isCommaOperator);
                emitLeadingCommentsOfPosition(operatorToken.pos);
                writeTokenNode(operatorToken, operatorToken.kind === 101 /* SyntaxKind.InKeyword */ ? writeKeyword : writeOperator);
                emitTrailingCommentsOfPosition(operatorToken.end, /*prefixSpace*/ true); // Binary operators should have a space before the comment starts
                writeLinesAndIndent(linesAfterOperator, /*writeSpaceIfNotIndenting*/ true);
            }
            function onRight(next, _workArea, parent) {
                return maybeEmitExpression(next, parent, "right");
            }
            function onExit(node, state) {
                var linesBeforeOperator = getLinesBetweenNodes(node, node.left, node.operatorToken);
                var linesAfterOperator = getLinesBetweenNodes(node, node.operatorToken, node.right);
                decreaseIndentIf(linesBeforeOperator, linesAfterOperator);
                if (state.stackIndex > 0) {
                    var savedPreserveSourceNewlines = state.preserveSourceNewlinesStack[state.stackIndex];
                    var savedContainerPos = state.containerPosStack[state.stackIndex];
                    var savedContainerEnd = state.containerEndStack[state.stackIndex];
                    var savedDeclarationListContainerEnd = state.declarationListContainerEndStack[state.stackIndex];
                    var shouldEmitComments_1 = state.shouldEmitCommentsStack[state.stackIndex];
                    var shouldEmitSourceMaps_1 = state.shouldEmitSourceMapsStack[state.stackIndex];
                    afterEmitNode(savedPreserveSourceNewlines);
                    if (shouldEmitSourceMaps_1)
                        emitSourceMapsAfterNode(node);
                    if (shouldEmitComments_1)
                        emitCommentsAfterNode(node, savedContainerPos, savedContainerEnd, savedDeclarationListContainerEnd);
                    onAfterEmitNode === null || onAfterEmitNode === void 0 ? void 0 : onAfterEmitNode(node);
                    state.stackIndex--;
                }
            }
            function maybeEmitExpression(next, parent, side) {
                var parenthesizerRule = side === "left" ?
                    parenthesizer.getParenthesizeLeftSideOfBinaryForOperator(parent.operatorToken.kind) :
                    parenthesizer.getParenthesizeRightSideOfBinaryForOperator(parent.operatorToken.kind);
                var pipelinePhase = getPipelinePhase(0 /* PipelinePhase.Notification */, 1 /* EmitHint.Expression */, next);
                if (pipelinePhase === pipelineEmitWithSubstitution) {
                    ts.Debug.assertIsDefined(lastSubstitution);
                    next = parenthesizerRule(ts.cast(lastSubstitution, ts.isExpression));
                    pipelinePhase = getNextPipelinePhase(1 /* PipelinePhase.Substitution */, 1 /* EmitHint.Expression */, next);
                    lastSubstitution = undefined;
                }
                if (pipelinePhase === pipelineEmitWithComments ||
                    pipelinePhase === pipelineEmitWithSourceMaps ||
                    pipelinePhase === pipelineEmitWithHint) {
                    if (ts.isBinaryExpression(next)) {
                        return next;
                    }
                }
                currentParenthesizerRule = parenthesizerRule;
                pipelinePhase(1 /* EmitHint.Expression */, next);
            }
        }
        function emitConditionalExpression(node) {
            var linesBeforeQuestion = getLinesBetweenNodes(node, node.condition, node.questionToken);
            var linesAfterQuestion = getLinesBetweenNodes(node, node.questionToken, node.whenTrue);
            var linesBeforeColon = getLinesBetweenNodes(node, node.whenTrue, node.colonToken);
            var linesAfterColon = getLinesBetweenNodes(node, node.colonToken, node.whenFalse);
            emitExpression(node.condition, parenthesizer.parenthesizeConditionOfConditionalExpression);
            writeLinesAndIndent(linesBeforeQuestion, /*writeSpaceIfNotIndenting*/ true);
            emit(node.questionToken);
            writeLinesAndIndent(linesAfterQuestion, /*writeSpaceIfNotIndenting*/ true);
            emitExpression(node.whenTrue, parenthesizer.parenthesizeBranchOfConditionalExpression);
            decreaseIndentIf(linesBeforeQuestion, linesAfterQuestion);
            writeLinesAndIndent(linesBeforeColon, /*writeSpaceIfNotIndenting*/ true);
            emit(node.colonToken);
            writeLinesAndIndent(linesAfterColon, /*writeSpaceIfNotIndenting*/ true);
            emitExpression(node.whenFalse, parenthesizer.parenthesizeBranchOfConditionalExpression);
            decreaseIndentIf(linesBeforeColon, linesAfterColon);
        }
        function emitTemplateExpression(node) {
            emit(node.head);
            emitList(node, node.templateSpans, 262144 /* ListFormat.TemplateExpressionSpans */);
        }
        function emitYieldExpression(node) {
            emitTokenWithComment(125 /* SyntaxKind.YieldKeyword */, node.pos, writeKeyword, node);
            emit(node.asteriskToken);
            emitExpressionWithLeadingSpace(node.expression && parenthesizeExpressionForNoAsi(node.expression), parenthesizeExpressionForNoAsiAndDisallowedComma);
        }
        function emitSpreadElement(node) {
            emitTokenWithComment(25 /* SyntaxKind.DotDotDotToken */, node.pos, writePunctuation, node);
            emitExpression(node.expression, parenthesizer.parenthesizeExpressionForDisallowedComma);
        }
        function emitClassExpression(node) {
            generateNameIfNeeded(node.name);
            emitClassDeclarationOrExpression(node);
        }
        function emitExpressionWithTypeArguments(node) {
            emitExpression(node.expression, parenthesizer.parenthesizeLeftSideOfAccess);
            emitTypeArguments(node, node.typeArguments);
        }
        function emitAsExpression(node) {
            emitExpression(node.expression, /*parenthesizerRules*/ undefined);
            if (node.type) {
                writeSpace();
                writeKeyword("as");
                writeSpace();
                emit(node.type);
            }
        }
        function emitNonNullExpression(node) {
            emitExpression(node.expression, parenthesizer.parenthesizeLeftSideOfAccess);
            writeOperator("!");
        }
        function emitMetaProperty(node) {
            writeToken(node.keywordToken, node.pos, writePunctuation);
            writePunctuation(".");
            emit(node.name);
        }
        //
        // Misc
        //
        function emitTemplateSpan(node) {
            emitExpression(node.expression);
            emit(node.literal);
        }
        //
        // Statements
        //
        function emitBlock(node) {
            emitBlockStatements(node, /*forceSingleLine*/ !node.multiLine && isEmptyBlock(node));
        }
        function emitBlockStatements(node, forceSingleLine) {
            emitTokenWithComment(18 /* SyntaxKind.OpenBraceToken */, node.pos, writePunctuation, /*contextNode*/ node);
            var format = forceSingleLine || ts.getEmitFlags(node) & 1 /* EmitFlags.SingleLine */ ? 768 /* ListFormat.SingleLineBlockStatements */ : 129 /* ListFormat.MultiLineBlockStatements */;
            emitList(node, node.statements, format);
            emitTokenWithComment(19 /* SyntaxKind.CloseBraceToken */, node.statements.end, writePunctuation, /*contextNode*/ node, /*indentLeading*/ !!(format & 1 /* ListFormat.MultiLine */));
        }
        function emitVariableStatement(node) {
            emitModifiers(node, node.modifiers);
            emit(node.declarationList);
            writeTrailingSemicolon();
        }
        function emitEmptyStatement(isEmbeddedStatement) {
            // While most trailing semicolons are possibly insignificant, an embedded "empty"
            // statement is significant and cannot be elided by a trailing-semicolon-omitting writer.
            if (isEmbeddedStatement) {
                writePunctuation(";");
            }
            else {
                writeTrailingSemicolon();
            }
        }
        function emitExpressionStatement(node) {
            emitExpression(node.expression, parenthesizer.parenthesizeExpressionOfExpressionStatement);
            // Emit semicolon in non json files
            // or if json file that created synthesized expression(eg.define expression statement when --out and amd code generation)
            if (!currentSourceFile || !ts.isJsonSourceFile(currentSourceFile) || ts.nodeIsSynthesized(node.expression)) {
                writeTrailingSemicolon();
            }
        }
        function emitIfStatement(node) {
            var openParenPos = emitTokenWithComment(99 /* SyntaxKind.IfKeyword */, node.pos, writeKeyword, node);
            writeSpace();
            emitTokenWithComment(20 /* SyntaxKind.OpenParenToken */, openParenPos, writePunctuation, node);
            emitExpression(node.expression);
            emitTokenWithComment(21 /* SyntaxKind.CloseParenToken */, node.expression.end, writePunctuation, node);
            emitEmbeddedStatement(node, node.thenStatement);
            if (node.elseStatement) {
                writeLineOrSpace(node, node.thenStatement, node.elseStatement);
                emitTokenWithComment(91 /* SyntaxKind.ElseKeyword */, node.thenStatement.end, writeKeyword, node);
                if (node.elseStatement.kind === 239 /* SyntaxKind.IfStatement */) {
                    writeSpace();
                    emit(node.elseStatement);
                }
                else {
                    emitEmbeddedStatement(node, node.elseStatement);
                }
            }
        }
        function emitWhileClause(node, startPos) {
            var openParenPos = emitTokenWithComment(115 /* SyntaxKind.WhileKeyword */, startPos, writeKeyword, node);
            writeSpace();
            emitTokenWithComment(20 /* SyntaxKind.OpenParenToken */, openParenPos, writePunctuation, node);
            emitExpression(node.expression);
            emitTokenWithComment(21 /* SyntaxKind.CloseParenToken */, node.expression.end, writePunctuation, node);
        }
        function emitDoStatement(node) {
            emitTokenWithComment(90 /* SyntaxKind.DoKeyword */, node.pos, writeKeyword, node);
            emitEmbeddedStatement(node, node.statement);
            if (ts.isBlock(node.statement) && !preserveSourceNewlines) {
                writeSpace();
            }
            else {
                writeLineOrSpace(node, node.statement, node.expression);
            }
            emitWhileClause(node, node.statement.end);
            writeTrailingSemicolon();
        }
        function emitWhileStatement(node) {
            emitWhileClause(node, node.pos);
            emitEmbeddedStatement(node, node.statement);
        }
        function emitForStatement(node) {
            var openParenPos = emitTokenWithComment(97 /* SyntaxKind.ForKeyword */, node.pos, writeKeyword, node);
            writeSpace();
            var pos = emitTokenWithComment(20 /* SyntaxKind.OpenParenToken */, openParenPos, writePunctuation, /*contextNode*/ node);
            emitForBinding(node.initializer);
            pos = emitTokenWithComment(26 /* SyntaxKind.SemicolonToken */, node.initializer ? node.initializer.end : pos, writePunctuation, node);
            emitExpressionWithLeadingSpace(node.condition);
            pos = emitTokenWithComment(26 /* SyntaxKind.SemicolonToken */, node.condition ? node.condition.end : pos, writePunctuation, node);
            emitExpressionWithLeadingSpace(node.incrementor);
            emitTokenWithComment(21 /* SyntaxKind.CloseParenToken */, node.incrementor ? node.incrementor.end : pos, writePunctuation, node);
            emitEmbeddedStatement(node, node.statement);
        }
        function emitForInStatement(node) {
            var openParenPos = emitTokenWithComment(97 /* SyntaxKind.ForKeyword */, node.pos, writeKeyword, node);
            writeSpace();
            emitTokenWithComment(20 /* SyntaxKind.OpenParenToken */, openParenPos, writePunctuation, node);
            emitForBinding(node.initializer);
            writeSpace();
            emitTokenWithComment(101 /* SyntaxKind.InKeyword */, node.initializer.end, writeKeyword, node);
            writeSpace();
            emitExpression(node.expression);
            emitTokenWithComment(21 /* SyntaxKind.CloseParenToken */, node.expression.end, writePunctuation, node);
            emitEmbeddedStatement(node, node.statement);
        }
        function emitForOfStatement(node) {
            var openParenPos = emitTokenWithComment(97 /* SyntaxKind.ForKeyword */, node.pos, writeKeyword, node);
            writeSpace();
            emitWithTrailingSpace(node.awaitModifier);
            emitTokenWithComment(20 /* SyntaxKind.OpenParenToken */, openParenPos, writePunctuation, node);
            emitForBinding(node.initializer);
            writeSpace();
            emitTokenWithComment(160 /* SyntaxKind.OfKeyword */, node.initializer.end, writeKeyword, node);
            writeSpace();
            emitExpression(node.expression);
            emitTokenWithComment(21 /* SyntaxKind.CloseParenToken */, node.expression.end, writePunctuation, node);
            emitEmbeddedStatement(node, node.statement);
        }
        function emitForBinding(node) {
            if (node !== undefined) {
                if (node.kind === 255 /* SyntaxKind.VariableDeclarationList */) {
                    emit(node);
                }
                else {
                    emitExpression(node);
                }
            }
        }
        function emitContinueStatement(node) {
            emitTokenWithComment(86 /* SyntaxKind.ContinueKeyword */, node.pos, writeKeyword, node);
            emitWithLeadingSpace(node.label);
            writeTrailingSemicolon();
        }
        function emitBreakStatement(node) {
            emitTokenWithComment(81 /* SyntaxKind.BreakKeyword */, node.pos, writeKeyword, node);
            emitWithLeadingSpace(node.label);
            writeTrailingSemicolon();
        }
        function emitTokenWithComment(token, pos, writer, contextNode, indentLeading) {
            var node = ts.getParseTreeNode(contextNode);
            var isSimilarNode = node && node.kind === contextNode.kind;
            var startPos = pos;
            if (isSimilarNode && currentSourceFile) {
                pos = ts.skipTrivia(currentSourceFile.text, pos);
            }
            if (isSimilarNode && contextNode.pos !== startPos) {
                var needsIndent = indentLeading && currentSourceFile && !ts.positionsAreOnSameLine(startPos, pos, currentSourceFile);
                if (needsIndent) {
                    increaseIndent();
                }
                emitLeadingCommentsOfPosition(startPos);
                if (needsIndent) {
                    decreaseIndent();
                }
            }
            pos = writeTokenText(token, writer, pos);
            if (isSimilarNode && contextNode.end !== pos) {
                var isJsxExprContext = contextNode.kind === 288 /* SyntaxKind.JsxExpression */;
                emitTrailingCommentsOfPosition(pos, /*prefixSpace*/ !isJsxExprContext, /*forceNoNewline*/ isJsxExprContext);
            }
            return pos;
        }
        function commentWillEmitNewLine(node) {
            return node.kind === 2 /* SyntaxKind.SingleLineCommentTrivia */ || !!node.hasTrailingNewLine;
        }
        function willEmitLeadingNewLine(node) {
            if (!currentSourceFile)
                return false;
            if (ts.some(ts.getLeadingCommentRanges(currentSourceFile.text, node.pos), commentWillEmitNewLine))
                return true;
            if (ts.some(ts.getSyntheticLeadingComments(node), commentWillEmitNewLine))
                return true;
            if (ts.isPartiallyEmittedExpression(node)) {
                if (node.pos !== node.expression.pos) {
                    if (ts.some(ts.getTrailingCommentRanges(currentSourceFile.text, node.expression.pos), commentWillEmitNewLine))
                        return true;
                }
                return willEmitLeadingNewLine(node.expression);
            }
            return false;
        }
        /**
         * Wraps an expression in parens if we would emit a leading comment that would introduce a line separator
         * between the node and its parent.
         */
        function parenthesizeExpressionForNoAsi(node) {
            if (!commentsDisabled && ts.isPartiallyEmittedExpression(node) && willEmitLeadingNewLine(node)) {
                var parseNode = ts.getParseTreeNode(node);
                if (parseNode && ts.isParenthesizedExpression(parseNode)) {
                    // If the original node was a parenthesized expression, restore it to preserve comment and source map emit
                    var parens = ts.factory.createParenthesizedExpression(node.expression);
                    ts.setOriginalNode(parens, node);
                    ts.setTextRange(parens, parseNode);
                    return parens;
                }
                return ts.factory.createParenthesizedExpression(node);
            }
            return node;
        }
        function parenthesizeExpressionForNoAsiAndDisallowedComma(node) {
            return parenthesizeExpressionForNoAsi(parenthesizer.parenthesizeExpressionForDisallowedComma(node));
        }
        function emitReturnStatement(node) {
            emitTokenWithComment(105 /* SyntaxKind.ReturnKeyword */, node.pos, writeKeyword, /*contextNode*/ node);
            emitExpressionWithLeadingSpace(node.expression && parenthesizeExpressionForNoAsi(node.expression), parenthesizeExpressionForNoAsi);
            writeTrailingSemicolon();
        }
        function emitWithStatement(node) {
            var openParenPos = emitTokenWithComment(116 /* SyntaxKind.WithKeyword */, node.pos, writeKeyword, node);
            writeSpace();
            emitTokenWithComment(20 /* SyntaxKind.OpenParenToken */, openParenPos, writePunctuation, node);
            emitExpression(node.expression);
            emitTokenWithComment(21 /* SyntaxKind.CloseParenToken */, node.expression.end, writePunctuation, node);
            emitEmbeddedStatement(node, node.statement);
        }
        function emitSwitchStatement(node) {
            var openParenPos = emitTokenWithComment(107 /* SyntaxKind.SwitchKeyword */, node.pos, writeKeyword, node);
            writeSpace();
            emitTokenWithComment(20 /* SyntaxKind.OpenParenToken */, openParenPos, writePunctuation, node);
            emitExpression(node.expression);
            emitTokenWithComment(21 /* SyntaxKind.CloseParenToken */, node.expression.end, writePunctuation, node);
            writeSpace();
            emit(node.caseBlock);
        }
        function emitLabeledStatement(node) {
            emit(node.label);
            emitTokenWithComment(58 /* SyntaxKind.ColonToken */, node.label.end, writePunctuation, node);
            writeSpace();
            emit(node.statement);
        }
        function emitThrowStatement(node) {
            emitTokenWithComment(109 /* SyntaxKind.ThrowKeyword */, node.pos, writeKeyword, node);
            emitExpressionWithLeadingSpace(parenthesizeExpressionForNoAsi(node.expression), parenthesizeExpressionForNoAsi);
            writeTrailingSemicolon();
        }
        function emitTryStatement(node) {
            emitTokenWithComment(111 /* SyntaxKind.TryKeyword */, node.pos, writeKeyword, node);
            writeSpace();
            emit(node.tryBlock);
            if (node.catchClause) {
                writeLineOrSpace(node, node.tryBlock, node.catchClause);
                emit(node.catchClause);
            }
            if (node.finallyBlock) {
                writeLineOrSpace(node, node.catchClause || node.tryBlock, node.finallyBlock);
                emitTokenWithComment(96 /* SyntaxKind.FinallyKeyword */, (node.catchClause || node.tryBlock).end, writeKeyword, node);
                writeSpace();
                emit(node.finallyBlock);
            }
        }
        function emitDebuggerStatement(node) {
            writeToken(87 /* SyntaxKind.DebuggerKeyword */, node.pos, writeKeyword);
            writeTrailingSemicolon();
        }
        //
        // Declarations
        //
        function emitVariableDeclaration(node) {
            var _a, _b, _c, _d, _e;
            emit(node.name);
            emit(node.exclamationToken);
            emitTypeAnnotation(node.type);
            emitInitializer(node.initializer, (_e = (_b = (_a = node.type) === null || _a === void 0 ? void 0 : _a.end) !== null && _b !== void 0 ? _b : (_d = (_c = node.name.emitNode) === null || _c === void 0 ? void 0 : _c.typeNode) === null || _d === void 0 ? void 0 : _d.end) !== null && _e !== void 0 ? _e : node.name.end, node, parenthesizer.parenthesizeExpressionForDisallowedComma);
        }
        function emitVariableDeclarationList(node) {
            writeKeyword(ts.isLet(node) ? "let" : ts.isVarConst(node) ? "const" : "var");
            writeSpace();
            emitList(node, node.declarations, 528 /* ListFormat.VariableDeclarationList */);
        }
        function emitFunctionDeclaration(node) {
            emitFunctionDeclarationOrExpression(node);
        }
        function emitFunctionDeclarationOrExpression(node) {
            emitDecorators(node, node.decorators);
            emitModifiers(node, node.modifiers);
            writeKeyword("function");
            emit(node.asteriskToken);
            writeSpace();
            emitIdentifierName(node.name);
            emitSignatureAndBody(node, emitSignatureHead);
        }
        function emitSignatureAndBody(node, emitSignatureHead) {
            var body = node.body;
            if (body) {
                if (ts.isBlock(body)) {
                    var indentedFlag = ts.getEmitFlags(node) & 65536 /* EmitFlags.Indented */;
                    if (indentedFlag) {
                        increaseIndent();
                    }
                    pushNameGenerationScope(node);
                    ts.forEach(node.parameters, generateNames);
                    generateNames(node.body);
                    emitSignatureHead(node);
                    emitBlockFunctionBody(body);
                    popNameGenerationScope(node);
                    if (indentedFlag) {
                        decreaseIndent();
                    }
                }
                else {
                    emitSignatureHead(node);
                    writeSpace();
                    emitExpression(body, parenthesizer.parenthesizeConciseBodyOfArrowFunction);
                }
            }
            else {
                emitSignatureHead(node);
                writeTrailingSemicolon();
            }
        }
        function emitSignatureHead(node) {
            emitTypeParameters(node, node.typeParameters);
            emitParameters(node, node.parameters);
            emitTypeAnnotation(node.type);
        }
        function shouldEmitBlockFunctionBodyOnSingleLine(body) {
            // We must emit a function body as a single-line body in the following case:
            // * The body has NodeEmitFlags.SingleLine specified.
            // We must emit a function body as a multi-line body in the following cases:
            // * The body is explicitly marked as multi-line.
            // * A non-synthesized body's start and end position are on different lines.
            // * Any statement in the body starts on a new line.
            if (ts.getEmitFlags(body) & 1 /* EmitFlags.SingleLine */) {
                return true;
            }
            if (body.multiLine) {
                return false;
            }
            if (!ts.nodeIsSynthesized(body) && currentSourceFile && !ts.rangeIsOnSingleLine(body, currentSourceFile)) {
                return false;
            }
            if (getLeadingLineTerminatorCount(body, body.statements, 2 /* ListFormat.PreserveLines */)
                || getClosingLineTerminatorCount(body, body.statements, 2 /* ListFormat.PreserveLines */)) {
                return false;
            }
            var previousStatement;
            for (var _a = 0, _b = body.statements; _a < _b.length; _a++) {
                var statement = _b[_a];
                if (getSeparatingLineTerminatorCount(previousStatement, statement, 2 /* ListFormat.PreserveLines */) > 0) {
                    return false;
                }
                previousStatement = statement;
            }
            return true;
        }
        function emitBlockFunctionBody(body) {
            onBeforeEmitNode === null || onBeforeEmitNode === void 0 ? void 0 : onBeforeEmitNode(body);
            writeSpace();
            writePunctuation("{");
            increaseIndent();
            var emitBlockFunctionBody = shouldEmitBlockFunctionBodyOnSingleLine(body)
                ? emitBlockFunctionBodyOnSingleLine
                : emitBlockFunctionBodyWorker;
            emitBodyWithDetachedComments(body, body.statements, emitBlockFunctionBody);
            decreaseIndent();
            writeToken(19 /* SyntaxKind.CloseBraceToken */, body.statements.end, writePunctuation, body);
            onAfterEmitNode === null || onAfterEmitNode === void 0 ? void 0 : onAfterEmitNode(body);
        }
        function emitBlockFunctionBodyOnSingleLine(body) {
            emitBlockFunctionBodyWorker(body, /*emitBlockFunctionBodyOnSingleLine*/ true);
        }
        function emitBlockFunctionBodyWorker(body, emitBlockFunctionBodyOnSingleLine) {
            // Emit all the prologue directives (like "use strict").
            var statementOffset = emitPrologueDirectives(body.statements);
            var pos = writer.getTextPos();
            emitHelpers(body);
  