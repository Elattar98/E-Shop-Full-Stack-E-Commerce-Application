*\n * NOTE:\n * - This uses binary search algorithm for fast removals.\n *\n * @param array A sorted array to binary search.\n * @param value The value to look for.\n * @param shift grouping shift.\n *   - `0` means look at every location\n *   - `1` means only look at every other (even) location (the odd locations are to be ignored as\n *         they are values.)\n * @returns index of the value.\n *   - positive index if value found.\n *   - negative index if value not found. (`~index` to get the value where it should have been\n * inserted)\n */\nfunction _arrayIndexOfSorted(array: string[], value: string, shift: number): number {\n  ngDevMode && assertEqual(Array.isArray(array), true, 'Expecting an array');\n  let start = 0;\n  let end = array.length >> shift;\n  while (end !== start) {\n    const middle = start + ((end - start) >> 1);  // find the middle.\n    const current = array[middle << shift];\n    if (value === current) {\n      return (middle << shift);\n    } else if (current > value) {\n      end = middle;\n    } else {\n      start = middle + 1;  // We already searched middle so make it non-inclusive by adding 1\n    }\n  }\n  return ~(end << shift);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Convince closure compiler that the wrapped function has no side-effects.\n *\n * Closure compiler always assumes that `toString` has no side-effects. We use this quirk to\n * allow us to execute a function but have closure compiler mark the call as no-side-effects.\n * It is important that the return value for the `noSideEffects` function be assigned\n * to something which is retained otherwise the call to `noSideEffects` will be removed by closure\n * compiler.\n */\nexport function noSideEffects<T>(fn: () => T): T {\n  return {toString: fn}.toString() as unknown as T;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../interface/type';\n\nimport {noSideEffects} from './closure';\n\n\n\n/**\n * An interface implemented by all Angular type decorators, which allows them to be used as\n * decorators as well as Angular syntax.\n *\n * ```\n * @ng.Component({...})\n * class MyClass {...}\n * ```\n *\n * @publicApi\n */\nexport interface TypeDecorator {\n  /**\n   * Invoke as decorator.\n   */\n  <T extends Type<any>>(type: T): T;\n\n  // Make TypeDecorator assignable to built-in ParameterDecorator type.\n  // ParameterDecorator is declared in lib.d.ts as a `declare type`\n  // so we cannot declare this interface as a subtype.\n  // see https://github.com/angular/angular/issues/3379#issuecomment-126169417\n  (target: Object, propertyKey?: string|symbol, parameterIndex?: number): void;\n}\n\nexport const ANNOTATIONS = '__annotations__';\nexport const PARAMETERS = '__parameters__';\nexport const PROP_METADATA = '__prop__metadata__';\n\n/**\n * @suppress {globalThis}\n */\nexport function makeDecorator<T>(\n    name: string, props?: (...args: any[]) => any, parentClass?: any,\n    additionalProcessing?: (type: Type<T>) => void,\n    typeFn?: (type: Type<T>, ...args: any[]) => void):\n    {new (...args: any[]): any; (...args: any[]): any; (...args: any[]): (cls: any) => any;} {\n  return noSideEffects(() => {\n    const metaCtor = makeMetadataCtor(props);\n\n    function DecoratorFactory(\n        this: unknown|typeof DecoratorFactory, ...args: any[]): (cls: Type<T>) => any {\n      if (this instanceof DecoratorFactory) {\n        metaCtor.call(this, ...args);\n        return this as typeof DecoratorFactory;\n      }\n\n      const annotationInstance = new (DecoratorFactory as any)(...args);\n      return function TypeDecorator(cls: Type<T>) {\n        if (typeFn) typeFn(cls, ...args);\n        // Use of Object.defineProperty is important since it creates non-enumerable property which\n        // prevents the property is copied during subclassing.\n        const annotations = cls.hasOwnProperty(ANNOTATIONS) ?\n            (cls as any)[ANNOTATIONS] :\n            (Object.defineProperty(cls, ANNOTATIONS, {value: []}) as any)[ANNOTATIONS];\n        annotations.push(annotationInstance);\n\n\n        if (additionalProcessing) additionalProcessing(cls);\n\n        return cls;\n      };\n    }\n\n    if (parentClass) {\n      DecoratorFactory.prototype = Object.create(parentClass.prototype);\n    }\n\n    DecoratorFactory.prototype.ngMetadataName = name;\n    (DecoratorFactory as any).annotationCls = DecoratorFactory;\n    return DecoratorFactory as any;\n  });\n}\n\nfunction makeMetadataCtor(props?: (...args: any[]) => any): any {\n  return function ctor(this: any, ...args: any[]) {\n    if (props) {\n      const values = props(...args);\n      for (const propName in values) {\n        this[propName] = values[propName];\n      }\n    }\n  };\n}\n\nexport function makeParamDecorator(\n    name: string, props?: (...args: any[]) => any, parentClass?: any): any {\n  return noSideEffects(() => {\n    const metaCtor = makeMetadataCtor(props);\n    function ParamDecoratorFactory(\n        this: unknown|typeof ParamDecoratorFactory, ...args: any[]): any {\n      if (this instanceof ParamDecoratorFactory) {\n        metaCtor.apply(this, args);\n        return this;\n      }\n      const annotationInstance = new (<any>ParamDecoratorFactory)(...args);\n\n      (<any>ParamDecorator).annotation = annotationInstance;\n      return ParamDecorator;\n\n      function ParamDecorator(cls: any, unusedKey: any, index: number): any {\n        // Use of Object.defineProperty is important since it creates non-enumerable property which\n        // prevents the property is copied during subclassing.\n        const parameters = cls.hasOwnProperty(PARAMETERS) ?\n            (cls as any)[PARAMETERS] :\n            Object.defineProperty(cls, PARAMETERS, {value: []})[PARAMETERS];\n\n        // there might be gaps if some in between parameters do not have annotations.\n        // we pad with nulls.\n        while (parameters.length <= index) {\n          parameters.push(null);\n        }\n\n        (parameters[index] = parameters[index] || []).push(annotationInstance);\n        return cls;\n      }\n    }\n    if (parentClass) {\n      ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);\n    }\n    ParamDecoratorFactory.prototype.ngMetadataName = name;\n    (<any>ParamDecoratorFactory).annotationCls = ParamDecoratorFactory;\n    return ParamDecoratorFactory;\n  });\n}\n\nexport function makePropDecorator(\n    name: string, props?: (...args: any[]) => any, parentClass?: any,\n    additionalProcessing?: (target: any, name: string, ...args: any[]) => void): any {\n  return noSideEffects(() => {\n    const metaCtor = makeMetadataCtor(props);\n\n    function PropDecoratorFactory(this: unknown|typeof PropDecoratorFactory, ...args: any[]): any {\n      if (this instanceof PropDecoratorFactory) {\n        metaCtor.apply(this, args);\n        return this;\n      }\n\n      const decoratorInstance = new (<any>PropDecoratorFactory)(...args);\n\n      function PropDecorator(target: any, name: string) {\n        const constructor = target.constructor;\n        // Use of Object.defineProperty is important because it creates a non-enumerable property\n        // which prevents the property from being copied during subclassing.\n        const meta = constructor.hasOwnProperty(PROP_METADATA) ?\n            (constructor as any)[PROP_METADATA] :\n            Object.defineProperty(constructor, PROP_METADATA, {value: {}})[PROP_METADATA];\n        meta[name] = meta.hasOwnProperty(name) && meta[name] || [];\n        meta[name].unshift(decoratorInstance);\n\n        if (additionalProcessing) additionalProcessing(target, name, ...args);\n      }\n\n      return PropDecorator;\n    }\n\n    if (parentClass) {\n      PropDecoratorFactory.prototype = Object.create(parentClass.prototype);\n    }\n\n    PropDecoratorFactory.prototype.ngMetadataName = name;\n    (<any>PropDecoratorFactory).annotationCls = PropDecoratorFactory;\n    return PropDecoratorFactory;\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {isType, Type} from '../interface/type';\nimport {newArray} from '../util/array_utils';\nimport {ANNOTATIONS, PARAMETERS, PROP_METADATA} from '../util/decorators';\nimport {global} from '../util/global';\n\nimport {PlatformReflectionCapabilities} from './platform_reflection_capabilities';\n\n\n\n/*\n * #########################\n * Attention: These Regular expressions have to hold even if the code is minified!\n * ##########################\n */\n\n/**\n * Regular expression that detects pass-through constructors for ES5 output. This Regex\n * intends to capture the common delegation pattern emitted by TypeScript and Babel. Also\n * it intends to capture the pattern where existing constructors have been downleveled from\n * ES2015 to ES5 using TypeScript w/ downlevel iteration. e.g.\n *\n * ```\n *   function MyClass() {\n *     var _this = _super.apply(this, arguments) || this;\n * ```\n *\n * downleveled to ES5 with `downlevelIteration` for TypeScript < 4.2:\n * ```\n *   function MyClass() {\n *     var _this = _super.apply(this, __spread(arguments)) || this;\n * ```\n *\n * or downleveled to ES5 with `downlevelIteration` for TypeScript >= 4.2:\n * ```\n *   function MyClass() {\n *     var _this = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;\n * ```\n *\n * More details can be found in: https://github.com/angular/angular/issues/38453.\n */\nexport const ES5_DELEGATE_CTOR =\n    /^function\\s+\\S+\\(\\)\\s*{[\\s\\S]+\\.apply\\(this,\\s*(arguments|(?:[^()]+\\(\\[\\],)?[^()]+\\(arguments\\).*)\\)/;\n/** Regular expression that detects ES2015 classes which extend from other classes. */\nexport const ES2015_INHERITED_CLASS = /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{/;\n/**\n * Regular expression that detects ES2015 classes which extend from other classes and\n * have an explicit constructor defined.\n */\nexport const ES2015_INHERITED_CLASS_WITH_CTOR =\n    /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{[\\s\\S]*constructor\\s*\\(/;\n/**\n * Regular expression that detects ES2015 classes which extend from other classes\n * and inherit a constructor.\n */\nexport const ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR =\n    /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{[\\s\\S]*constructor\\s*\\(\\)\\s*{[^}]*super\\(\\.\\.\\.arguments\\)/;\n\n/**\n * Determine whether a stringified type is a class which delegates its constructor\n * to its parent.\n *\n * This is not trivial since compiled code can actually contain a constructor function\n * even if the original source code did not. For instance, when the child class contains\n * an initialized instance property.\n */\nexport function isDelegateCtor(typeStr: string): boolean {\n  return ES5_DELEGATE_CTOR.test(typeStr) ||\n      ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr) ||\n      (ES2015_INHERITED_CLASS.test(typeStr) && !ES2015_INHERITED_CLASS_WITH_CTOR.test(typeStr));\n}\n\nexport class ReflectionCapabilities implements PlatformReflectionCapabilities {\n  private _reflect: any;\n\n  constructor(reflect?: any) {\n    this._reflect = reflect || global['Reflect'];\n  }\n\n  factory<T>(t: Type<T>): (args: any[]) => T {\n    return (...args: any[]) => new t(...args);\n  }\n\n  /** @internal */\n  _zipTypesAndAnnotations(paramTypes: any[], paramAnnotations: any[]): any[][] {\n    let result: any[][];\n\n    if (typeof paramTypes === 'undefined') {\n      result = newArray(paramAnnotations.length);\n    } else {\n      result = newArray(paramTypes.length);\n    }\n\n    for (let i = 0; i < result.length; i++) {\n      // TS outputs Object for parameters without types, while Traceur omits\n      // the annotations. For now we preserve the Traceur behavior to aid\n      // migration, but this can be revisited.\n      if (typeof paramTypes === 'undefined') {\n        result[i] = [];\n      } else if (paramTypes[i] && paramTypes[i] != Object) {\n        result[i] = [paramTypes[i]];\n      } else {\n        result[i] = [];\n      }\n      if (paramAnnotations && paramAnnotations[i] != null) {\n        result[i] = result[i].concat(paramAnnotations[i]);\n      }\n    }\n    return result;\n  }\n\n  private _ownParameters(type: Type<any>, parentCtor: any): any[][]|null {\n    const typeStr = type.toString();\n    // If we have no decorators, we only have function.length as metadata.\n    // In that case, to detect whether a child class declared an own constructor or not,\n    // we need to look inside of that constructor to check whether it is\n    // just calling the parent.\n    // This also helps to work around for https://github.com/Microsoft/TypeScript/issues/12439\n    // that sets 'design:paramtypes' to []\n    // if a class inherits from another class but has no ctor declared itself.\n    if (isDelegateCtor(typeStr)) {\n      return null;\n    }\n\n    // Prefer the direct API.\n    if ((<any>type).parameters && (<any>type).parameters !== parentCtor.parameters) {\n      return (<any>type).parameters;\n    }\n\n    // API of tsickle for lowering decorators to properties on the class.\n    const tsickleCtorParams = (<any>type).ctorParameters;\n    if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {\n      // Newer tsickle uses a function closure\n      // Retain the non-function case for compatibility with older tsickle\n      const ctorParameters =\n          typeof tsickleCtorParams === 'function' ? tsickleCtorParams() : tsickleCtorParams;\n      const paramTypes = ctorParameters.map((ctorParam: any) => ctorParam && ctorParam.type);\n      const paramAnnotations = ctorParameters.map(\n          (ctorParam: any) =>\n              ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));\n      return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n    }\n\n    // API for metadata created by invoking the decorators.\n    const paramAnnotations = type.hasOwnProperty(PARAMETERS) && (type as any)[PARAMETERS];\n    const paramTypes = this._reflect && this._reflect.getOwnMetadata &&\n        this._reflect.getOwnMetadata('design:paramtypes', type);\n    if (paramTypes || paramAnnotations) {\n      return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n    }\n\n    // If a class has no decorators, at least create metadata\n    // based on function.length.\n    // Note: We know that this is a real constructor as we checked\n    // the content of the constructor above.\n    return newArray<any[]>(type.length);\n  }\n\n  parameters(type: Type<any>): any[][] {\n    // Note: only report metadata if we have at least one class decorator\n    // to stay in sync with the static reflector.\n    if (!isType(type)) {\n      return [];\n    }\n    const parentCtor = getParentCtor(type);\n    let parameters = this._ownParameters(type, parentCtor);\n    if (!parameters && parentCtor !== Object) {\n      parameters = this.parameters(parentCtor);\n    }\n    return parameters || [];\n  }\n\n  private _ownAnnotations(typeOrFunc: Type<any>, parentCtor: any): any[]|null {\n    // Prefer the direct API.\n    if ((<any>typeOrFunc).annotations && (<any>typeOrFunc).annotations !== parentCtor.annotations) {\n      let annotations = (<any>typeOrFunc).annotations;\n      if (typeof annotations === 'function' && annotations.annotations) {\n        annotations = annotations.annotations;\n      }\n      return annotations;\n    }\n\n    // API of tsickle for lowering decorators to properties on the class.\n    if ((<any>typeOrFunc).decorators && (<any>typeOrFunc).decorators !== parentCtor.decorators) {\n      return convertTsickleDecoratorIntoMetadata((<any>typeOrFunc).decorators);\n    }\n\n    // API for metadata created by invoking the decorators.\n    if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {\n      return (typeOrFunc as any)[ANNOTATIONS];\n    }\n    return null;\n  }\n\n  annotations(typeOrFunc: Type<any>): any[] {\n    if (!isType(typeOrFunc)) {\n      return [];\n    }\n    const parentCtor = getParentCtor(typeOrFunc);\n    const ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];\n    const parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];\n    return parentAnnotations.concat(ownAnnotations);\n  }\n\n  private _ownPropMetadata(typeOrFunc: any, parentCtor: any): {[key: string]: any[]}|null {\n    // Prefer the direct API.\n    if ((<any>typeOrFunc).propMetadata &&\n        (<any>typeOrFunc).propMetadata !== parentCtor.propMetadata) {\n      let propMetadata = (<any>typeOrFunc).propMetadata;\n      if (typeof propMetadata === 'function' && propMetadata.propMetadata) {\n        propMetadata = propMetadata.propMetadata;\n      }\n      return propMetadata;\n    }\n\n    // API of tsickle for lowering decorators to properties on the class.\n    if ((<any>typeOrFunc).propDecorators &&\n        (<any>typeOrFunc).propDecorators !== parentCtor.propDecorators) {\n      const propDecorators = (<any>typeOrFunc).propDecorators;\n      const propMetadata = <{[key: string]: any[]}>{};\n      Object.keys(propDecorators).forEach(prop => {\n        propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);\n      });\n      return propMetadata;\n    }\n\n    // API for metadata created by invoking the decorators.\n    if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {\n      return (typeOrFunc as any)[PROP_METADATA];\n    }\n    return null;\n  }\n\n  propMetadata(typeOrFunc: any): {[key: string]: any[]} {\n    if (!isType(typeOrFunc)) {\n      return {};\n    }\n    const parentCtor = getParentCtor(typeOrFunc);\n    const propMetadata: {[key: string]: any[]} = {};\n    if (parentCtor !== Object) {\n      const parentPropMetadata = this.propMetadata(parentCtor);\n      Object.keys(parentPropMetadata).forEach((propName) => {\n        propMetadata[propName] = parentPropMetadata[propName];\n      });\n    }\n    const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);\n    if (ownPropMetadata) {\n      Object.keys(ownPropMetadata).forEach((propName) => {\n        const decorators: any[] = [];\n        if (propMetadata.hasOwnProperty(propName)) {\n          decorators.push(...propMetadata[propName]);\n        }\n        decorators.push(...ownPropMetadata[propName]);\n        propMetadata[propName] = decorators;\n      });\n    }\n    return propMetadata;\n  }\n\n  ownPropMetadata(typeOrFunc: any): {[key: string]: any[]} {\n    if (!isType(typeOrFunc)) {\n      return {};\n    }\n    return this._ownPropMetadata(typeOrFunc, getParentCtor(typeOrFunc)) || {};\n  }\n\n  hasLifecycleHook(type: any, lcProperty: string): boolean {\n    return type instanceof Type && lcProperty in type.prototype;\n  }\n}\n\nfunction convertTsickleDecoratorIntoMetadata(decoratorInvocations: any[]): any[] {\n  if (!decoratorInvocations) {\n    return [];\n  }\n  return decoratorInvocations.map(decoratorInvocation => {\n    const decoratorType = decoratorInvocation.type;\n    const annotationCls = decoratorType.annotationCls;\n    const annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];\n    return new annotationCls(...annotationArgs);\n  });\n}\n\nfunction getParentCtor(ctor: Function): Type<any> {\n  const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;\n  const parentCtor = parentProto ? parentProto.constructor : null;\n  // Note: We always use `Object` as the null value\n  // to simplify checking later on.\n  return parentCtor || Object;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {global} from './global';\n\ndeclare global {\n  /**\n   * Values of ngDevMode\n   * Depending on the current state of the application, ngDevMode may have one of several values.\n   *\n   * For convenience, the “truthy” value which enables dev mode is also an object which contains\n   * Angular’s performance counters. This is not necessary, but cuts down on boilerplate for the\n   * perf counters.\n   *\n   * ngDevMode may also be set to false. This can happen in one of a few ways:\n   * - The user explicitly sets `window.ngDevMode = false` somewhere in their app.\n   * - The user calls `enableProdMode()`.\n   * - The URL contains a `ngDevMode=false` text.\n   * Finally, ngDevMode may not have been defined at all.\n   */\n  const ngDevMode: null|NgDevModePerfCounters;\n  interface NgDevModePerfCounters {\n    namedConstructors: boolean;\n    firstCreatePass: number;\n    tNode: number;\n    tView: number;\n    rendererCreateTextNode: number;\n    rendererSetText: number;\n    rendererCreateElement: number;\n    rendererAddEventListener: number;\n    rendererSetAttribute: number;\n    rendererRemoveAttribute: number;\n    rendererSetProperty: number;\n    rendererSetClassName: number;\n    rendererAddClass: number;\n    rendererRemoveClass: number;\n    rendererSetStyle: number;\n    rendererRemoveStyle: number;\n    rendererDestroy: number;\n    rendererDestroyNode: number;\n    rendererMoveNode: number;\n    rendererRemoveNode: number;\n    rendererAppendChild: number;\n    rendererInsertBefore: number;\n    rendererCreateComment: number;\n  }\n}\n\nexport function ngDevModeResetPerfCounters(): NgDevModePerfCounters {\n  const locationString = typeof location !== 'undefined' ? location.toString() : '';\n  const newCounters: NgDevModePerfCounters = {\n    namedConstructors: locationString.indexOf('ngDevMode=namedConstructors') != -1,\n    firstCreatePass: 0,\n    tNode: 0,\n    tView: 0,\n    rendererCreateTextNode: 0,\n    rendererSetText: 0,\n    rendererCreateElement: 0,\n    rendererAddEventListener: 0,\n    rendererSetAttribute: 0,\n    rendererRemoveAttribute: 0,\n    rendererSetProperty: 0,\n    rendererSetClassName: 0,\n    rendererAddClass: 0,\n    rendererRemoveClass: 0,\n    rendererSetStyle: 0,\n    rendererRemoveStyle: 0,\n    rendererDestroy: 0,\n    rendererDestroyNode: 0,\n    rendererMoveNode: 0,\n    rendererRemoveNode: 0,\n    rendererAppendChild: 0,\n    rendererInsertBefore: 0,\n    rendererCreateComment: 0,\n  };\n\n  // Make sure to refer to ngDevMode as ['ngDevMode'] for closure.\n  const allowNgDevModeTrue = locationString.indexOf('ngDevMode=false') === -1;\n  global['ngDevMode'] = allowNgDevModeTrue && newCounters;\n  return newCounters;\n}\n\n/**\n * This function checks to see if the `ngDevMode` has been set. If yes,\n * then we honor it, otherwise we default to dev mode with additional checks.\n *\n * The idea is that unless we are doing production build where we explicitly\n * set `ngDevMode == false` we should be helping the developer by providing\n * as much early warning and errors as possible.\n *\n * `ɵɵdefineComponent` is guaranteed to have been called before any component template functions\n * (and thus Ivy instructions), so a single initialization there is sufficient to ensure ngDevMode\n * is defined for the entire instruction set.\n *\n * When checking `ngDevMode` on toplevel, always init it before referencing it\n * (e.g. `((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode())`), otherwise you can\n *  get a `ReferenceError` like in https://github.com/angular/angular/issues/31595.\n *\n * Details on possible values for `ngDevMode` can be found on its docstring.\n *\n * NOTE:\n * - changes to the `ngDevMode` name must be synced with `compiler-cli/src/tooling.ts`.\n */\nexport function initNgDevMode(): boolean {\n  // The below checks are to ensure that calling `initNgDevMode` multiple times does not\n  // reset the counters.\n  // If the `ngDevMode` is not an object, then it means we have not created the perf counters\n  // yet.\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    if (typeof ngDevMode !== 'object') {\n      ngDevModeResetPerfCounters();\n    }\n    return typeof ngDevMode !== 'undefined' && !!ngDevMode;\n  }\n  return false;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Used for stringify render output in Ivy.\n * Important! This function is very performance-sensitive and we should\n * be extra careful not to introduce megamorphic reads in it.\n * Check `core/test/render3/perf/render_stringify` for benchmarks and alternate implementations.\n */\nexport function renderStringify(value: any): string {\n  if (typeof value === 'string') return value;\n  if (value == null) return '';\n  // Use `String` so that it invokes the `toString` method of the value. Note that this\n  // appears to be faster than calling `value.toString` (see `render_stringify` benchmark).\n  return String(value);\n}\n\n\n/**\n * Used to stringify a value so that it can be displayed in an error message.\n * Important! This function contains a megamorphic read and should only be\n * used for error messages.\n */\nexport function stringifyForError(value: any): string {\n  if (typeof value === 'function') return value.name || value.toString();\n  if (typeof value === 'object' && value != null && typeof value.type === 'function') {\n    return value.type.name || value.type.toString();\n  }\n\n  return renderStringify(value);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ImportedNgModuleProviders} from '../di/interface/provider';\nimport {RuntimeError, RuntimeErrorCode} from '../errors';\nimport {Type} from '../interface/type';\nimport {stringify} from '../util/stringify';\n\nimport {stringifyForError} from './util/stringify_utils';\n\n\n/** Called when directives inject each other (creating a circular dependency) */\nexport function throwCyclicDependencyError(token: string, path?: string[]): never {\n  const depPath = path ? `. Dependency path: ${path.join(' > ')} > ${token}` : '';\n  throw new RuntimeError(\n      RuntimeErrorCode.CYCLIC_DI_DEPENDENCY,\n      `Circular dependency in DI detected for ${token}${depPath}`);\n}\n\nexport function throwMixedMultiProviderError() {\n  throw new Error(`Cannot mix multi providers and regular providers`);\n}\n\nexport function throwInvalidProviderError(\n    ngModuleType?: Type<unknown>, providers?: any[], provider?: any): never {\n  if (ngModuleType && providers) {\n    const providerDetail = providers.map(v => v == provider ? '?' + provider + '?' : '...');\n    throw new Error(`Invalid provider for the NgModule '${\n        stringify(ngModuleType)}' - only instances of Provider and Type are allowed, got: [${\n        providerDetail.join(', ')}]`);\n  } else if ((provider as ImportedNgModuleProviders).ɵproviders) {\n    throw new RuntimeError(\n        RuntimeErrorCode.PROVIDER_IN_WRONG_CONTEXT,\n        `Invalid providers from 'importProvidersFrom' present in a non-environment injector. 'importProvidersFrom' can't be used for component providers.`);\n  } else {\n    throw new Error('Invalid provider');\n  }\n}\n\n\n/** Throws an error when a token is not found in DI. */\nexport function throwProviderNotFoundError(token: any, injectorName?: string): never {\n  const injectorDetails = injectorName ? ` in ${injectorName}` : '';\n  throw new RuntimeError(\n      RuntimeErrorCode.PROVIDER_NOT_FOUND,\n      ngDevMode && `No provider for ${stringifyForError(token)} found${injectorDetails}`);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n/**\n * Special flag indicating that a decorator is of type `Inject`. It's used to make `Inject`\n * decorator tree-shakable (so we don't have to rely on the `instanceof` checks).\n * Note: this flag is not included into the `InjectFlags` since it's an internal-only API.\n */\nexport const enum DecoratorFlags {\n  Inject = -1\n}\n\n/**\n * Injection flags for DI.\n *\n * @publicApi\n * @deprecated use an options object for `inject` instead.\n */\nexport enum InjectFlags {\n  // TODO(alxhub): make this 'const' (and remove `InternalInjectFlags` enum) when ngc no longer\n  // writes exports of it into ngfactory files.\n\n  /** Check self and check parent injector if needed */\n  Default = 0b0000,\n\n  /**\n   * Specifies that an injector should retrieve a dependency from any injector until reaching the\n   * host element of the current component. (Only used with Element Injector)\n   */\n  Host = 0b0001,\n\n  /** Don't ascend to ancestors of the node requesting injection. */\n  Self = 0b0010,\n\n  /** Skip the node that is requesting injection. */\n  SkipSelf = 0b0100,\n\n  /** Inject `defaultValue` instead if token not found. */\n  Optional = 0b1000,\n}\n\n/**\n * This enum is an exact copy of the `InjectFlags` enum above, but the difference is that this is a\n * const enum, so actual enum values would be inlined in generated code. The `InjectFlags` enum can\n * be turned into a const enum when ViewEngine is removed (see TODO at the `InjectFlags` enum\n * above). The benefit of inlining is that we can use these flags at the top level without affecting\n * tree-shaking (see \"no-toplevel-property-access\" tslint rule for more info).\n * Keep this enum in sync with `InjectFlags` enum above.\n */\nexport const enum InternalInjectFlags {\n  /** Check self and check parent injector if needed */\n  Default = 0b0000,\n\n  /**\n   * Specifies that an injector should retrieve a dependency from any injector until reaching the\n   * host element of the current component. (Only used with Element Injector)\n   */\n  Host = 0b0001,\n\n  /** Don't ascend to ancestors of the node requesting injection. */\n  Self = 0b0010,\n\n  /** Skip the node that is requesting injection. */\n  SkipSelf = 0b0100,\n\n  /** Inject `defaultValue` instead if token not found. */\n  Optional = 0b1000,\n\n  /**\n   * This token is being injected into a pipe.\n   *\n   * This flag is intentionally not in the public facing `InjectFlags` because it is only added by\n   * the compiler and is not a developer applicable flag.\n   */\n  ForPipe = 0b10000,\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {throwProviderNotFoundError} from '../render3/errors_di';\nimport {assertNotEqual} from '../util/assert';\nimport {stringify} from '../util/stringify';\n\nimport {getInjectableDef, ɵɵInjectableDeclaration} from './interface/defs';\nimport {InjectFlags} from './interface/injector';\nimport {ProviderToken} from './provider_token';\n\n\n/**\n * Current implementation of inject.\n *\n * By default, it is `injectInjectorOnly`, which makes it `Injector`-only aware. It can be changed\n * to `directiveInject`, which brings in the `NodeInjector` system of ivy. It is designed this\n * way for two reasons:\n *  1. `Injector` should not depend on ivy logic.\n *  2. To maintain tree shake-ability we don't want to bring in unnecessary code.\n */\nlet _injectImplementation: (<T>(token: ProviderToken<T>, flags?: InjectFlags) => T | null)|\n    undefined;\nexport function getInjectImplementation() {\n  return _injectImplementation;\n}\n\n\n/**\n * Sets the current inject implementation.\n */\nexport function setInjectImplementation(\n    impl: (<T>(token: ProviderToken<T>, flags?: InjectFlags) => T | null)|\n    undefined): (<T>(token: ProviderToken<T>, flags?: InjectFlags) => T | null)|undefined {\n  const previous = _injectImplementation;\n  _injectImplementation = impl;\n  return previous;\n}\n\n\n/**\n * Injects `root` tokens in limp mode.\n *\n * If no injector exists, we can still inject tree-shakable providers which have `providedIn` set to\n * `\"root\"`. This is known as the limp mode injection. In such case the value is stored in the\n * injectable definition.\n */\nexport function injectRootLimpMode<T>(\n    token: ProviderToken<T>, notFoundValue: T|undefined, flags: InjectFlags): T|null {\n  const injectableDef: ɵɵInjectableDeclaration<T>|null = getInjectableDef(token);\n  if (injectableDef && injectableDef.providedIn == 'root') {\n    return injectableDef.value === undefined ? injectableDef.value = injectableDef.factory() :\n                                               injectableDef.value;\n  }\n  if (flags & InjectFlags.Optional) return null;\n  if (notFoundValue !== undefined) return notFoundValue;\n  throwProviderNotFoundError(stringify(token), 'Injector');\n}\n\n\n/**\n * Assert that `_injectImplementation` is not `fn`.\n *\n * This is useful, to prevent infinite recursion.\n *\n * @param fn Function which it should not equal to\n */\nexport function assertInjectImplementationNotEqual(\n    fn: (<T>(token: ProviderToken<T>, flags?: InjectFlags) => T | null)) {\n  ngDevMode &&\n      assertNotEqual(_injectImplementation, fn, 'Calling ɵɵinject would cause infinite recursion');\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport '../util/ng_dev_mode';\n\nimport {RuntimeError, RuntimeErrorCode} from '../errors';\nimport {Type} from '../interface/type';\nimport {stringify} from '../util/stringify';\n\nimport {resolveForwardRef} from './forward_ref';\nimport {getInjectImplementation, injectRootLimpMode} from './inject_switch';\nimport {Injector} from './injector';\nimport {DecoratorFlags, InjectFlags, InternalInjectFlags} from './interface/injector';\nimport {ProviderToken} from './provider_token';\n\n\nconst _THROW_IF_NOT_FOUND = {};\nexport const THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\n\n/*\n * Name of a property (that we patch onto DI decorator), which is used as an annotation of which\n * InjectFlag this decorator represents. This allows to avoid direct references to the DI decorators\n * in the code, thus making them tree-shakable.\n */\nconst DI_DECORATOR_FLAG = '__NG_DI_FLAG__';\n\nexport const NG_TEMP_TOKEN_PATH = 'ngTempTokenPath';\nconst NG_TOKEN_PATH = 'ngTokenPath';\nconst NEW_LINE = /\\n/gm;\nconst NO_NEW_LINE = 'ɵ';\nexport const SOURCE = '__source';\n\n/**\n * Current injector value used by `inject`.\n * - `undefined`: it is an error to call `inject`\n * - `null`: `inject` can be called but there is no injector (limp-mode).\n * - Injector instance: Use the injector for resolution.\n */\nlet _currentInjector: Injector|undefined|null = undefined;\n\nexport function setCurrentInjector(injector: Injector|null|undefined): Injector|undefined|null {\n  const former = _currentInjector;\n  _currentInjector = injector;\n  return former;\n}\n\nexport function injectInjectorOnly<T>(token: ProviderToken<T>): T;\nexport function injectInjectorOnly<T>(token: ProviderToken<T>, flags?: InjectFlags): T|null;\nexport function injectInjectorOnly<T>(token: ProviderToken<T>, flags = InjectFlags.Default): T|\n    null {\n  if (_currentInjector === undefined) {\n    throw new RuntimeError(\n        RuntimeErrorCode.MISSING_INJECTION_CONTEXT,\n        ngDevMode &&\n            `inject() must be called from an injection context (a constructor, a factory function or a field initializer)`);\n  } else if (_currentInjector === null) {\n    return injectRootLimpMode(token, undefined, flags);\n  } else {\n    return _currentInjector.get(token, flags & InjectFlags.Optional ? null : undefined, flags);\n  }\n}\n\n/**\n * Generated instruction: injects a token from the currently active injector.\n *\n * (Additional documentation moved to `inject`, as it is the public API, and an alias for this\n * instruction)\n *\n * @see inject\n * @codeGenApi\n * @publicApi This instruction has been emitted by ViewEngine for some time and is deployed to npm.\n */\nexport function ɵɵinject<T>(token: ProviderToken<T>): T;\nexport function ɵɵinject<T>(token: ProviderToken<T>, flags?: InjectFlags): T|null;\nexport function ɵɵinject<T>(token: ProviderToken<T>, flags = InjectFlags.Default): T|null {\n  return (getInjectImplementation() || injectInjectorOnly)(resolveForwardRef(token), flags);\n}\n\n/**\n * Throws an error indicating that a factory function could not be generated by the compiler for a\n * particular class.\n *\n * The name of the class is not mentioned here, but will be in the generated factory function name\n * and thus in the stack trace.\n *\n * @codeGenApi\n */\nexport function ɵɵinvalidFactoryDep(index: number): never {\n  throw new RuntimeError(\n      RuntimeErrorCode.INVALID_FACTORY_DEPENDENCY,\n      ngDevMode &&\n          `This constructor is not compatible with Angular Dependency Injection because its dependency at index ${\n              index} of the parameter list is invalid.\nThis can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.\n\nPlease check that 1) the type for the parameter at index ${\n              index} is correct and 2) the correct Angular decorators are defined for this class and its ancestors.`);\n}\n\n/**\n * Type of the options argument to `inject`.\n *\n * @publicApi\n */\nexport interface InjectOptions {\n  /**\n   * Use optional injection, and return `null` if the requested token is not found.\n   */\n  optional?: boolean;\n\n  /**\n   * Start injection at the parent of the current injector.\n   */\n  skipSelf?: boolean;\n\n  /**\n   * Only query the current injector for the token, and don't fall back to the parent injector if\n   * it's not found.\n   */\n  self?: boolean;\n\n  /**\n   * Stop injection at the host component's injector. Only relevant when injecting from an element\n   * injector, and a no-op for environment injectors.\n   */\n  host?: boolean;\n}\n\n/**\n * @param token A token that represents a dependency that should be injected.\n * @returns the injected value if operation is successful, `null` otherwise.\n * @throws if called outside of a supported context.\n *\n * @publicApi\n */\nexport function inject<T>(token: ProviderToken<T>): T;\n/**\n * @param token A token that represents a dependency that should be injected.\n * @param flags Control how injection is executed. The flags correspond to injection strategies that\n *     can be specified with parameter decorators `@Host`, `@Self`, `@SkipSelf`, and `@Optional`.\n * @returns the injected value if operation is successful, `null` otherwise.\n * @throws if called outside of a supported context.\n *\n * @publicApi\n * @deprecated prefer an options object instead of `InjectFlags`\n */\nexport function inject<T>(token: ProviderToken<T>, flags?: InjectFlags): T|null;\n/**\n * @param token A token that represents a dependency that should be injected.\n * @param options Control how injection is executed. Options correspond to injection strategies\n *     that can be specified with parameter decorators `@Host`, `@Self`, `@SkipSelf`, and\n *     `@Optional`.\n * @returns the injected value if operation is successful.\n * @throws if called outside of a supported context, or if the token is not found.\n *\n * @publicApi\n */\nexport function inject<T>(token: ProviderToken<T>, options: InjectOptions&{optional?: false}): T;\n/**\n * @param token A token that represents a dependency that should be injected.\n * @param options Control how injection is executed. Options correspond to injection strategies\n *     that can be specified with parameter decorators `@Host`, `@Self`, `@SkipSelf`, and\n *     `@Optional`.\n * @returns the injected value if operation is successful,  `null` if the token is not\n *     found and optional injection has been requested.\n * @throws if called outside of a supported context, or if the token is not found and optional\n *     injection was not requested.\n *\n * @publicApi\n */\nexport function inject<T>(token: ProviderToken<T>, options: InjectOptions): T|null;\n/**\n * Injects a token from the currently active injector.\n * `inject` is only supported during instantiation of a dependency by the DI system. It can be used\n * during:\n * - Construction (via the `constructor`) of a class being instantiated by the DI system, such\n * as an `@Injectable` or `@Component`.\n * - In the initializer for fields of such classes.\n * - In the factory function specified for `useFactory` of a `Provider` or an `@Injectable`.\n * - In the `factory` function specified for an `InjectionToken`.\n *\n * @param token A token that represents a dependency that should be injected.\n * @param flags Optional flags that control how injection is executed.\n * The flags correspond to injection strategies that can be specified with\n * parameter decorators `@Host`, `@Self`, `@SkipSef`, and `@Optional`.\n * @returns the injected value if operation is successful, `null` otherwise.\n * @throws if called outside of a supported context.\n *\n * @usageNotes\n * In practice the `inject()` calls are allowed in a constructor, a constructor parameter and a\n * field initializer:\n *\n * ```typescript\n * @Injectable({providedIn: 'root'})\n * export class Car {\n *   radio: Radio|undefined;\n *   // OK: field initializer\n *   spareTyre = inject(Tyre);\n *\n *   constructor() {\n *     // OK: constructor body\n *     this.radio = inject(Radio);\n *   }\n * }\n * ```\n *\n * It is also legal to call `inject` from a provider's factory:\n *\n * ```typescript\n * providers: [\n *   {provide: Car, useFactory: () => {\n *     // OK: a class factory\n *     const engine = inject(Engine);\n *     return new Car(engine);\n *   }}\n * ]\n * ```\n *\n * Calls to the `inject()` function outside of the class creation context will result in error. Most\n * notably, calls to `inject()` are disallowed after a class instance was created, in methods\n * (including lifecycle hooks):\n *\n * ```typescript\n * @Component({ ... })\n * export class CarComponent {\n *   ngOnInit() {\n *     // ERROR: too late, the component instance was already created\n *     const engine = inject(Engine);\n *     engine.start();\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport function inject<T>(\n    token: ProviderToken<T>, flags: InjectFlags|InjectOptions = InjectFlags.Default): T|null {\n  if (typeof flags !== 'number') {\n    // While TypeScript doesn't accept it without a cast, bitwise OR with false-y values in\n    // JavaScript is a no-op. We can use that for a very codesize-efficient conversion from\n    // `InjectOptions` to `InjectFlags`.\n    flags = (InternalInjectFlags.Default |  // comment to force a line break in the formatter\n             ((flags.optional && InternalInjectFlags.Optional) as number) |\n             ((flags.host && InternalInjectFlags.Host) as number) |\n             ((flags.self && InternalInjectFlags.Self) as number) |\n             ((flags.skipSelf && InternalInjectFlags.SkipSelf) as number)) as InjectFlags;\n  }\n  return ɵɵinject(token, flags);\n}\n\nexport function injectArgs(types: (ProviderToken<any>|any[])[]): any[] {\n  const args: any[] = [];\n  for (let i = 0; i < types.length; i++) {\n    const arg = resolveForwardRef(types[i]);\n    if (Array.isArray(arg)) {\n      if (arg.length === 0) {\n        throw new RuntimeError(\n            RuntimeErrorCode.INVALID_DIFFER_INPUT,\n            ngDevMode && 'Arguments array must have arguments.');\n      }\n      let type: Type<any>|undefined = undefined;\n      let flags: InjectFlags = InjectFlags.Default;\n\n      for (let j = 0; j < arg.length; j++) {\n        const meta = arg[j];\n        const flag = getInjectFlag(meta);\n        if (typeof flag === 'number') {\n          // Special case when we handle @Inject decorator.\n          if (flag === DecoratorFlags.Inject) {\n            type = meta.token;\n          } else {\n            flags |= flag;\n          }\n        } else {\n          type = meta;\n        }\n      }\n\n      args.push(ɵɵinject(type!, flags));\n    } else {\n      args.push(ɵɵinject(arg));\n    }\n  }\n  return args;\n}\n\n/**\n * Attaches a given InjectFlag to a given decorator using monkey-patching.\n * Since DI decorators can be used in providers `deps` array (when provider is configured using\n * `useFactory`) without initialization (e.g. `Host`) and as an instance (e.g. `new Host()`), we\n * attach the flag to make it available both as a static property and as a field on decorator\n * instance.\n *\n * @param decorator Provided DI decorator.\n * @param flag InjectFlag that should be applied.\n */\nexport function attachInjectFlag(decorator: any, flag: InternalInjectFlags|DecoratorFlags): any {\n  decorator[DI_DECORATOR_FLAG] = flag;\n  decorator.prototype[DI_DECORATOR_FLAG] = flag;\n  return decorator;\n}\n\n/**\n * Reads monkey-patched property that contains InjectFlag attached to a decorator.\n *\n * @param token Token that may contain monkey-patched DI flags property.\n */\nexport function getInjectFlag(token: any): number|undefined {\n  return token[DI_DECORATOR_FLAG];\n}\n\nexport function catchInjectorError(\n    e: any, token: any, injectorErrorName: string, source: string|null): never {\n  const tokenPath: any[] = e[NG_TEMP_TOKEN_PATH];\n  if (token[SOURCE]) {\n    tokenPath.unshift(token[SOURCE]);\n  }\n  e.message = formatError('\\n' + e.message, tokenPath, injectorErrorName, source);\n  e[NG_TOKEN_PATH] = tokenPath;\n  e[NG_TEMP_TOKEN_PATH] = null;\n  throw e;\n}\n\nexport function formatError(\n    text: string, obj: any, injectorErrorName: string, source: string|null = null): string {\n  text = text && text.charAt(0) === '\\n' && text.charAt(1) == NO_NEW_LINE ? text.slice(2) : text;\n  let context = stringify(obj);\n  if (Array.isArray(obj)) {\n    context = obj.map(stringify).join(' -> ');\n  } else if (typeof obj === 'object') {\n    let parts = <string[]>[];\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        let value = obj[key];\n        parts.push(\n            key + ':' + (typeof value === 'string' ? JSON.stringify(value) : stringify(value)));\n      }\n    }\n    context = `{${parts.join(', ')}}`;\n  }\n  return `${injectorErrorName}${source ? '(' + source + ')' : ''}[${context}]: ${\n      text.replace(NEW_LINE, '\\n  ')}`;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {makeParamDecorator} from '../util/decorators';\n\nimport {attachInjectFlag} from './injector_compatibility';\nimport {DecoratorFlags, InternalInjectFlags} from './interface/injector';\n\n\n/**\n * Type of the Inject decorator / constructor function.\n *\n * @publicApi\n */\nexport interface InjectDecorator {\n  /**\n   * Parameter decorator on a dependency parameter of a class constructor\n   * that specifies a custom provider of the dependency.\n   *\n   * @usageNotes\n   * The following example shows a class constructor that specifies a\n   * custom provider of a dependency using the parameter decorator.\n   *\n   * When `@Inject()` is not present, the injector uses the type annotation of the\n   * parameter as the provider.\n   *\n   * <code-example path=\"core/di/ts/metadata_spec.ts\" region=\"InjectWithoutDecorator\">\n   * </code-example>\n   *\n   * @see [\"Dependency Injection Guide\"](guide/dependency-injection)\n   *\n   */\n  (token: any): any;\n  new(token: any): Inject;\n}\n\n/**\n * Type of the Inject metadata.\n *\n * @publicApi\n */\nexport interface Inject {\n  /**\n   * A [DI token](guide/glossary#di-token) that maps to the dependency to be injected.\n   */\n  token: any;\n}\n\n/**\n * Inject decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Inject: InjectDecorator = attachInjectFlag(\n    // Disable tslint because `DecoratorFlags` is a const enum which gets inlined.\n    // tslint:disable-next-line: no-toplevel-property-access\n    makeParamDecorator('Inject', (token: any) => ({token})), DecoratorFlags.Inject);\n\n/**\n * Type of the Optional decorator / constructor function.\n *\n * @publicApi\n */\nexport interface OptionalDecorator {\n  /**\n   * Parameter decorator to be used on constructor parameters,\n   * which marks the parameter as being an optional dependency.\n   * The DI framework provides `null` if the dependency is not found.\n   *\n   * Can be used together with other parameter decorators\n   * that modify how dependency injection operates.\n   *\n   * @usageNotes\n   *\n   * The following code allows the possibility of a `null` result:\n   *\n   * <code-example path=\"core/di/ts/metadata_spec.ts\" region=\"Optional\">\n   * </code-example>\n   *\n   * @see [\"Dependency Injection Guide\"](guide/dependency-injection).\n   */\n  (): any;\n  new(): Optional;\n}\n\n/**\n * Type of the Optional metadata.\n *\n * @publicApi\n */\nexport interface Optional {}\n\n/**\n * Optional decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Optional: OptionalDecorator =\n    // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n    // tslint:disable-next-line: no-toplevel-property-access\n    attachInjectFlag(makeParamDecorator('Optional'), InternalInjectFlags.Optional);\n\n/**\n * Type of the Self decorator / constructor function.\n *\n * @publicApi\n */\nexport interface SelfDecorator {\n  /**\n   * Parameter decorator to be used on constructor parameters,\n   * which tells the DI framework to start dependency resolution from the local injector.\n   *\n   * Resolution works upward through the injector hierarchy, so the children\n   * of this class must configure their own providers or be prepared for a `null` result.\n   *\n   * @usageNotes\n   *\n   * In the following example, the dependency can be resolved\n   * by the local injector when instantiating the class itself, but not\n   * when instantiating a child.\n   *\n   * <code-example path=\"core/di/ts/metadata_spec.ts\" region=\"Self\">\n   * </code-example>\n   *\n   * @see `SkipSelf`\n   * @see `Optional`\n   *\n   */\n  (): any;\n  new(): Self;\n}\n\n/**\n * Type of the Self metadata.\n *\n * @publicApi\n */\nexport interface Self {}\n\n/**\n * Self decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Self: SelfDecorator =\n    // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n    // tslint:disable-next-line: no-toplevel-property-access\n    attachInjectFlag(makeParamDecorator('Self'), InternalInjectFlags.Self);\n\n\n/**\n * Type of the `SkipSelf` decorator / constructor function.\n *\n * @publicApi\n */\nexport interface SkipSelfDecorator {\n  /**\n   * Parameter decorator to be used on constructor parameters,\n   * which tells the DI framework to start dependency resolution from the parent injector.\n   * Resolution works upward through the injector hierarchy, so the local injector\n   * is not checked for a provider.\n   *\n   * @usageNotes\n   *\n   * In the following example, the dependency can be resolved when\n   * instantiating a child, but not when instantiating the class itself.\n   *\n   * <code-example path=\"core/di/ts/metadata_spec.ts\" region=\"SkipSelf\">\n   * </code-example>\n   *\n   * @see [Dependency Injection guide](guide/dependency-injection-in-action#skip).\n   * @see `Self`\n   * @see `Optional`\n   *\n   */\n  (): any;\n  new(): SkipSelf;\n}\n\n/**\n * Type of the `SkipSelf` metadata.\n *\n * @publicApi\n */\nexport interface SkipSelf {}\n\n/**\n * `SkipSelf` decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const SkipSelf: SkipSelfDecorator =\n    // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n    // tslint:disable-next-line: no-toplevel-property-access\n    attachInjectFlag(makeParamDecorator('SkipSelf'), InternalInjectFlags.SkipSelf);\n\n/**\n * Type of the `Host` decorator / constructor function.\n *\n * @publicApi\n */\nexport interface HostDecorator {\n  /**\n   * Parameter decorator on a view-provider parameter of a class constructor\n   * that tells the DI framework to resolve the view by checking injectors of child\n   * elements, and stop when reaching the host element of the current component.\n   *\n   * @usageNotes\n   *\n   * The following shows use with the `@Optional` decorator, and allows for a `null` result.\n   *\n   * <code-example path=\"core/di/ts/metadata_spec.ts\" region=\"Host\">\n   * </code-example>\n   *\n   * For an extended example, see [\"Dependency Injection\n   * Guide\"](guide/dependency-injection-in-action#optional).\n   */\n  (): any;\n  new(): Host;\n}\n\n/**\n * Type of the Host metadata.\n *\n * @publicApi\n */\nexport interface Host {}\n\n/**\n * Host decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Host: HostDecorator =\n    // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n    // tslint:disable-next-line: no-toplevel-property-access\n    attachInjectFlag(makeParamDecorator('Host'), InternalInjectFlags.Host);\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n/**\n * The strategy that the default change detector uses to detect changes.\n * When set, takes effect the next time change detection is triggered.\n *\n * @see {@link ChangeDetectorRef#usage-notes Change detection usage}\n *\n * @publicApi\n */\nexport enum ChangeDetectionStrategy {\n  /**\n   * Use the `CheckOnce` strategy, meaning that automatic change detection is deactivated\n   * until reactivated by setting the strategy to `Default` (`CheckAlways`).\n   * Change detection can still be explicitly invoked.\n   * This strategy applies to all child directives and cannot be overridden.\n   */\n  OnPush = 0,\n\n  /**\n   * Use the default `CheckAlways` strategy, in which change detection is automatic until\n   * explicitly deactivated.\n   */\n  Default = 1,\n}\n\n/**\n * Defines the possible states of the default change detector.\n * @see `ChangeDetectorRef`\n */\nexport enum ChangeDetectorStatus {\n  /**\n   * A state in which, after calling `detectChanges()`, the change detector\n   * state becomes `Checked`, and must be explicitly invoked or reactivated.\n   */\n  CheckOnce,\n\n  /**\n   * A state in which change detection is skipped until the change detector mode\n   * becomes `CheckOnce`.\n   */\n  Checked,\n\n  /**\n   * A state in which change detection continues automatically until explicitly\n   * deactivated.\n   */\n  CheckAlways,\n\n  /**\n   * A state in which a change detector sub tree is not a part of the main tree and\n   * should be skipped.\n   */\n  Detached,\n\n  /**\n   * Indicates that the change detector encountered an error checking a binding\n   * or calling a directive lifecycle method and is now in an inconsistent state. Change\n   * detectors in this state do not detect changes.\n   */\n  Errored,\n\n  /**\n   * Indicates that the change detector has been destroyed.\n   */\n  Destroyed,\n}\n\n/**\n * Reports whether a given strategy is currently the default for change detection.\n * @param changeDetectionStrategy The strategy to check.\n * @returns True if the given strategy is the current default, false otherwise.\n * @see `ChangeDetectorStatus`\n * @see `ChangeDetectorRef`\n */\nexport function isDefaultChangeDetectionStrategy(changeDetectionStrategy: ChangeDetectionStrategy):\n    boolean {\n  return changeDetectionStrategy == null ||\n      changeDetectionStrategy === ChangeDetectionStrategy.Default;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Defines the CSS styles encapsulation policies for the {@link Component} decorator's\n * `encapsulation` option.\n *\n * See {@link Component#encapsulation encapsulation}.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/ts/metadata/encapsulation.ts region='longform'}\n *\n * @publicApi\n */\nexport enum ViewEncapsulation {\n  // TODO: consider making `ViewEncapsulation` a `const enum` instead. See\n  // https://github.com/angular/angular/issues/44119 for additional information.\n\n  /**\n   * Emulates a native Shadow DOM encapsulation behavior by adding a specific attribute to the\n   * component's host element and applying the same attribute to all the CSS selectors provided\n   * via {@link Component#styles styles} or {@link Component#styleUrls styleUrls}.\n   *\n   * This is the default option.\n   */\n  Emulated = 0,\n\n  // Historically the 1 value was for `Native` encapsulation which has been removed as of v11.\n\n  /**\n   * Doesn't provide any sort of CSS style encapsulation, meaning that all the styles provided\n   * via {@link Component#styles styles} or {@link Component#styleUrls styleUrls} are applicable\n   * to any HTML element of the application regardless of their host Component.\n   */\n  None = 2,\n\n  /**\n   * Uses the browser's native Shadow DOM API to encapsulate CSS styles, meaning that it creates\n   * a ShadowRoot for the component's host element which is then used to encapsulate\n   * all the Component's styling.\n   */\n  ShadowDom = 3\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {initNgDevMode} from './ng_dev_mode';\n\n/**\n * This file contains reuseable \"empty\" symbols that can be used as default return values\n * in different parts of the rendering code. Because the same symbols are returned, this\n * allows for identity checks against these values to be consistently used by the framework\n * code.\n */\n\nexport const EMPTY_OBJ: {} = {};\nexport const EMPTY_ARRAY: any[] = [];\n\n// freezing the values prevents any code from accidentally inserting new values in\nif ((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode()) {\n  // These property accesses can be ignored because ngDevMode will be set to false\n  // when optimizing code and the whole if statement will be dropped.\n  // tslint:disable-next-line:no-toplevel-property-access\n  Object.freeze(EMPTY_OBJ);\n  // tslint:disable-next-line:no-toplevel-property-access\n  Object.freeze(EMPTY_ARRAY);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getClosureSafeProperty} from '../util/property';\n\nexport const NG_COMP_DEF = getClosureSafeProperty({ɵcmp: getClosureSafeProperty});\nexport const NG_DIR_DEF = getClosureSafeProperty({ɵdir: getClosureSafeProperty});\nexport const NG_PIPE_DEF = getClosureSafeProperty({ɵpipe: getClosureSafeProperty});\nexport const NG_MOD_DEF = getClosureSafeProperty({ɵmod: getClosureSafeProperty});\nexport const NG_FACTORY_DEF = getClosureSafeProperty({ɵfac: getClosureSafeProperty});\n\n/**\n * If a directive is diPublic, bloomAdd sets a property on the type with this constant as\n * the key and the directive's unique ID as the value. This allows us to map directives to their\n * bloom filter bit for DI.\n */\n// TODO(misko): This is wrong. The NG_ELEMENT_ID should never be minified.\nexport const NG_ELEMENT_ID = getClosureSafeProperty({__NG_ELEMENT_ID__: getClosureSafeProperty});\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ChangeDetectionStrategy} from '../change_detection/constants';\nimport {Mutable, Type} from '../interface/type';\nimport {NgModuleDef, NgModuleType} from '../metadata/ng_module_def';\nimport {SchemaMetadata} from '../metadata/schema';\nimport {ViewEncapsulation} from '../metadata/view';\nimport {noSideEffects} from '../util/closure';\nimport {EMPTY_ARRAY, EMPTY_OBJ} from '../util/empty';\nimport {initNgDevMode} from '../util/ng_dev_mode';\nimport {stringify} from '../util/stringify';\n\nimport {NG_COMP_DEF, NG_DIR_DEF, NG_MOD_DEF, NG_PIPE_DEF} from './fields';\nimport {ComponentDef, ComponentDefFeature, ComponentTemplate, ComponentType, ContentQueriesFunction, DependencyTypeList, DirectiveDef, DirectiveDefFeature, DirectiveDefList, HostBindingsFunction, PipeDef, PipeDefList, TypeOrFactory, ViewQueriesFunction} from './interfaces/definition';\nimport {TAttributes, TConstantsOrFactory} from './interfaces/node';\nimport {CssSelectorList} from './interfaces/projection';\n\n\n/** Counter used to generate unique IDs for component definitions. */\nlet componentDefCount = 0;\n\n\n/**\n * Create a component definition object.\n *\n *\n * # Example\n * ```\n * class MyDirective {\n *   // Generated by Angular Template Compiler\n *   // [Symbol] syntax will not be supported by TypeScript until v2.7\n *   static ɵcmp = defineComponent({\n *     ...\n *   });\n * }\n * ```\n * @codeGenApi\n */\nexport function ɵɵdefineComponent<T>(componentDefinition: {\n  /**\n   * Directive type, needed to configure the injector.\n   */\n  type: Type<T>;\n\n  /** The selectors that will be used to match nodes to this component. */\n  selectors?: CssSelectorList;\n\n  /**\n   * The number of nodes, local refs, and pipes in this component template.\n   *\n   * Used to calculate the length of this component's LView array, so we\n   * can pre-fill the array and set the binding start index.\n   */\n  // TODO(kara): remove queries from this count\n  decls: number;\n\n  /**\n   * The number of bindings in this component template (including pure fn bindings).\n   *\n   * Used to calculate the length of this component's LView array, so we\n   * can pre-fill the array and set the host binding start index.\n   */\n  vars: number;\n\n  /**\n   * A map of input names.\n   *\n   * The format is in: `{[actualPropertyName: string]:(string|[string, string])}`.\n   *\n   * Given:\n   * ```\n   * class MyComponent {\n   *   @Input()\n   *   publicInput1: string;\n   *\n   *   @Input('publicInput2')\n   *   declaredInput2: string;\n   * }\n   * ```\n   *\n   * is described as:\n   * ```\n   * {\n   *   publicInput1: 'publicInput1',\n   *   declaredInput2: ['publicInput2', 'declaredInput2'],\n   * }\n   * ```\n   *\n   * Which the minifier may translate to:\n   * ```\n   * {\n   *   minifiedPublicInput1: 'publicInput1',\n   *   minifiedDeclaredInput2: ['publicInput2', 'declaredInput2'],\n   * }\n   * ```\n   *\n   * This allows the render to re-construct the minified, public, and declared names\n   * of properties.\n   *\n   * NOTE:\n   *  - Because declared and public name are usually same we only generate the array\n   *    `['public', 'declared']` format when they differ.\n   *  - The reason why this API and `outputs` API is not the same is that `NgOnChanges` has\n   *    inconsistent behavior in that it uses declared names rather than minified or public. For\n   *    this reason `NgOnChanges` will be deprecated and removed in future version and this\n   *    API will be simplified to be consistent with `output`.\n   */\n  inputs?: {[P in keyof T]?: string | [string, string]};\n\n  /**\n   * A map of output names.\n   *\n   * The format is in: `{[actualPropertyName: string]:string}`.\n   *\n   * Which the minifier may translate to: `{[minifiedPropertyName: string]:string}`.\n   *\n   * This allows the render to re-construct the minified and non-minified names\n   * of properties.\n   */\n  outputs?: {[P in keyof T]?: string};\n\n  /**\n   * Function executed by the parent template to allow child directive to apply host bindings.\n   */\n  hostBindings?: HostBindingsFunction<T>;\n\n  /**\n   * The number of bindings in this directive `hostBindings` (including pure fn bindings).\n   *\n   * Used to calculate the length of the component's LView array, so we\n   * can pre-fill the array and set the host binding start index.\n   */\n  hostVars?: number;\n\n  /**\n   * Assign static attribute values to a host element.\n   *\n   * This property will assign static attribute values as well as class and style\n   * values to a host element. Since attribute values can consist of different types of values, the\n   * `hostAttrs` array must include the values in the following format:\n   *\n   * attrs = [\n   *   // static attributes (like `title`, `name`, `id`...)\n   *   attr1, value1, attr2, value,\n   *\n   *   // a single namespace value (like `x:id`)\n   *   NAMESPACE_MARKER, namespaceUri1, name1, value1,\n   *\n   *   // another single namespace value (like `x:name`)\n   *   NAMESPACE_MARKER, namespaceUri2, name2, value2,\n   *\n   *   // a series of CSS classes that will be applied to the element (no spaces)\n   *   CLASSES_MARKER, class1, class2, class3,\n   *\n   *   // a series of CSS styles (property + value) that will be applied to the element\n   *   STYLES_MARKER, prop1, value1, prop2, value2\n   * ]\n   *\n   * All non-class and non-style attributes must be defined at the start of the list\n   * first before all class and style values are set. When there is a change in value\n   * type (like when classes and styles are introduced) a marker must be used to separate\n   * the entries. The marker values themselves are set via entries found in the\n   * [AttributeMarker] enum.\n   */\n  hostAttrs?: TAttributes;\n\n  /**\n   * Function to create instances of content queries associated with a given directive.\n   */\n  contentQueries?: ContentQueriesFunction<T>;\n\n  /**\n   * Defines the name that can be used in the template to assign this directive to a variable.\n   *\n   * See: {@link Directive.exportAs}\n   */\n  exportAs?: string[];\n\n  /**\n   * Template function use for rendering DOM.\n   *\n   * This function has following structure.\n   *\n   * ```\n   * function Template<T>(ctx:T, creationMode: boolean) {\n   *   if (creationMode) {\n   *     // Contains creation mode instructions.\n   *   }\n   *   // Contains binding update instructions\n   * }\n   * ```\n   *\n   * Common instructions are:\n   * Creation mode instructions:\n   *  - `elementStart`, `elementEnd`\n   *  - `text`\n   *  - `container`\n   *  - `listener`\n   *\n   * Binding update instructions:\n   * - `bind`\n   * - `elementAttribute`\n   * - `elementProperty`\n   * - `elementClass`\n   * - `elementStyle`\n   *\n   */\n  template: ComponentTemplate<T>;\n\n  /**\n   * Constants for the nodes in the component's view.\n   * Includes attribute arrays, local definition arrays etc.\n   */\n  consts?: TConstantsOrFactory;\n\n  /**\n   * An array of `ngContent[selector]` values that were found in the template.\n   */\n  ngContentSelectors?: string[];\n\n  /**\n   * Additional set of instructions specific to view query processing. This could be seen as a\n   * set of instruction to be inserted into the template function.\n   *\n   * Query-related instructions need to be pulled out to a specific function as a timing of\n   * execution is different as compared to all other instructions (after change detection hooks but\n   * before view hooks).\n   */\n  viewQuery?: ViewQueriesFunction<T>| null;\n\n  /**\n   * A list of optional features to apply.\n   *\n   * See: {@link NgOnChangesFeature}, {@link ProvidersFeature}\n   */\n  features?: ComponentDefFeature[];\n\n  /**\n   * Defines template and style encapsulation options available for Component's {@link Component}.\n   */\n  encapsulation?: ViewEncapsulation;\n\n  /**\n   * Defines arbitrary developer-defined data to be stored on a renderer instance.\n   * This is useful for renderers that delegate to other renderers.\n   *\n   * see: animation\n   */\n  data?: {[kind: string]: any};\n\n  /**\n   * A set of styles that the component needs to be present for component to render correctly.\n   */\n  styles?: string[];\n\n  /**\n   * The strategy that the default change detector uses to detect changes.\n   * When set, takes effect the next time change detection is triggered.\n   */\n  changeDetection?: ChangeDetectionStrategy;\n\n  /**\n   * Registry of directives, components, and pipes that may be found in this component's view.\n   *\n   * This property is either an array of types or a function that returns the array of types. This\n   * function may be necessary to support forward declarations.\n   */\n  dependencies?: TypeOrFactory<DependencyTypeList>;\n\n  /**\n   * The set of schemas that declare elements to be allowed in the component's template.\n   */\n  schemas?: SchemaMetadata[] | null;\n\n  /**\n   * Whether this directive/component is standalone.\n   */\n  standalone?: boolean;\n}): unknown {\n  return noSideEffects(() => {\n    // Initialize ngDevMode. This must be the first statement in ɵɵdefineComponent.\n    // See the `initNgDevMode` docstring for more information.\n    (typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode();\n\n    const type = componentDefinition.type;\n    const standalone = componentDefinition.standalone === true;\n    const declaredInputs: {[key: string]: string} = {} as any;\n    const def: Mutable<ComponentDef<any>, keyof ComponentDef<any>> = {\n      type: type,\n      providersResolver: null,\n      decls: componentDefinition.decls,\n      vars: componentDefinition.vars,\n      factory: null,\n      template: componentDefinition.template || null!,\n      consts: componentDefinition.consts || null,\n      ngContentSelectors: componentDefinition.ngContentSelectors,\n      hostBindings: componentDefinition.hostBindings || null,\n      hostVars: componentDefinition.hostVars || 0,\n      hostAttrs: componentDefinition.hostAttrs || null,\n      contentQueries: componentDefinition.contentQueries || null,\n      declaredInputs: declaredInputs,\n      inputs: null!,   // assigned in noSideEffects\n      outputs: null!,  // assigned in noSideEffects\n      exportAs: componentDefinition.exportAs || null,\n      onPush: componentDefinition.changeDetection === ChangeDetectionStrategy.OnPush,\n      directiveDefs: null!,  // assigned in noSideEffects\n      pipeDefs: null!,       // assigned in noSideEffects\n      standalone,\n      dependencies: standalone && componentDefinition.dependencies || null,\n      getStandaloneInjector: null,\n      selectors: componentDefinition.selectors || EMPTY_ARRAY,\n      viewQuery: componentDefinition.viewQuery || null,\n      features: componentDefinition.features as DirectiveDefFeature[] || null,\n      data: componentDefinition.data || {},\n      encapsulation: componentDefinition.encapsulation || ViewEncapsulation.Emulated,\n      id: `c${componentDefCount++}`,\n      styles: componentDefinition.styles || EMPTY_ARRAY,\n      _: null,\n      setInput: null,\n      schemas: componentDefinition.schemas || null,\n      tView: null,\n    };\n    const dependencies = componentDefinition.dependencies;\n    const feature = componentDefinition.features;\n    def.inputs = invertObject(componentDefinition.inputs, declaredInputs),\n    def.outputs = invertObject(componentDefinition.outputs),\n    feature && feature.forEach((fn) => fn(def));\n    def.directiveDefs = dependencies ?\n        (() => (typeof dependencies === 'function' ? dependencies() : dependencies)\n                   .map(extractDirectiveDef)\n                   .filter(nonNull)) :\n        null;\n    def.pipeDefs = dependencies ?\n        (() => (typeof dependencies === 'function' ? dependencies() : dependencies)\n                   .map(getPipeDef)\n                   .filter(nonNull)) :\n        null;\n\n    return def;\n  });\n}\n\n/**\n * Generated next to NgModules to monkey-patch directive and pipe references onto a component's\n * definition, when generating a direct reference in the component file would otherwise create an\n * import cycle.\n *\n * See [this explanation](https://hackmd.io/Odw80D0pR6yfsOjg_7XCJg?view) for more details.\n *\n * @codeGenApi\n */\nexport function ɵɵsetComponentScope(\n    type: ComponentType<any>, directives: Type<any>[]|(() => Type<any>[]),\n    pipes: Type<any>[]|(() => Type<any>[])): void {\n  const def = (type.ɵcmp as ComponentDef<any>);\n  def.directiveDefs = () =>\n      (typeof directives === 'function' ? directives() : directives).map(extractDirectiveDef) as\n      DirectiveDefList;\n  def.pipeDefs = () =>\n      (typeof pipes === 'function' ? pipes() : pipes).map(getPipeDef) as PipeDefList;\n}\n\nexport function extractDirectiveDef(type: Type<any>): DirectiveDef<any>|ComponentDef<any>|null {\n  return getComponentDef(type) || getDirectiveDef(type);\n}\n\nfunction nonNull<T>(value: T|null): value is T {\n  return value !== null;\n}\n\nexport const autoRegisterModuleById: {[id: string]: NgModuleType} = {};\n\n/**\n * @codeGenApi\n */\nexport function ɵɵdefineNgModule<T>(def: {\n  /** Token representing the module. Used by DI. */\n  type: T;\n\n  /** List of components to bootstrap. */\n  bootstrap?: Type<any>[] | (() => Type<any>[]);\n\n  /** List of components, directives, and pipes declared by this module. */\n  declarations?: Type<any>[] | (() => Type<any>[]);\n\n  /** List of modules or `ModuleWithProviders` imported by this module. */\n  imports?: Type<any>[] | (() => Type<any>[]);\n\n  /**\n   * List of modules, `ModuleWithProviders`, components, directives, or pipes exported by this\n   * module.\n   */\n  exports?: Type<any>[] | (() => Type<any>[]);\n\n  /** The set of schemas that declare elements to be allowed in the NgModule. */\n  schemas?: SchemaMetadata[] | null;\n\n  /** Unique ID for the module that is used with `getModuleFactory`. */\n  id?: string | null;\n}): unknown {\n  return noSideEffects(() => {\n    const res: NgModuleDef<T> = {\n      type: def.type,\n      bootstrap: def.bootstrap || EMPTY_ARRAY,\n      declarations: def.declarations || EMPTY_ARRAY,\n      imports: def.imports || EMPTY_ARRAY,\n      exports: def.exports || EMPTY_ARRAY,\n      transitiveCompileScopes: null,\n      schemas: def.schemas || null,\n      id: def.id || null,\n    };\n    if (def.id != null) {\n      autoRegisterModuleById[def.id!] = def.type as unknown as NgModuleType;\n    }\n    return res;\n  });\n}\n\n/**\n * Adds the module metadata that is necessary to compute the module's transitive scope to an\n * existing module definition.\n *\n * Scope metadata of modules is not used in production builds, so calls to this function can be\n * marked pure to tree-shake it from the bundle, allowing for all referenced declarations\n * to become eligible for tree-shaking as well.\n *\n * @codeGenApi\n */\nexport function ɵɵsetNgModuleScope(type: any, scope: {\n  /** List of components, directives, and pipes declared by this module. */\n  declarations?: Type<any>[]|(() => Type<any>[]);\n\n  /** List of modules or `ModuleWithProviders` imported by this module. */\n  imports?: Type<any>[] | (() => Type<any>[]);\n\n  /**\n   * List of modules, `ModuleWithProviders`, components, directives, or pipes exported by this\n   * module.\n   */\n  exports?: Type<any>[] | (() => Type<any>[]);\n}): unknown {\n  return noSideEffects(() => {\n    const ngModuleDef = getNgModuleDef(type, true);\n    ngModuleDef.declarations = scope.declarations || EMPTY_ARRAY;\n    ngModuleDef.imports = scope.imports || EMPTY_ARRAY;\n    ngModuleDef.exports = scope.exports || EMPTY_ARRAY;\n  });\n}\n\n/**\n * Inverts an inputs or outputs lookup such that the keys, which were the\n * minified keys, are part of the values, and the values are parsed so that\n * the publicName of the property is the new key\n *\n * e.g. for\n *\n * ```\n * class Comp {\n *   @Input()\n *   propName1: string;\n *\n *   @Input('publicName2')\n *   declaredPropName2: number;\n * }\n * ```\n *\n * will be serialized as\n *\n * ```\n * {\n *   propName1: 'propName1',\n *   declaredPropName2: ['publicName2', 'declaredPropName2'],\n * }\n * ```\n *\n * which is than translated by the minifier as:\n *\n * ```\n * {\n *   minifiedPropName1: 'propName1',\n *   minifiedPropName2: ['publicName2', 'declaredPropName2'],\n * }\n * ```\n *\n * becomes: (public name => minifiedName)\n *\n * ```\n * {\n *  'propName1': 'minifiedPropName1',\n *  'publicName2': 'minifiedPropName2',\n * }\n * ```\n *\n * Optionally the function can take `secondary` which will result in: (public name => declared name)\n *\n * ```\n * {\n *  'propName1': 'propName1',\n *  'publicName2': 'declaredPropName2',\n * }\n * ```\n *\n\n */\nfunction invertObject<T>(\n    obj?: {[P in keyof T]?: string|[string, string]},\n    secondary?: {[key: string]: string}): {[P in keyof T]: string} {\n  if (obj == null) return EMPTY_OBJ as any;\n  const newLookup: any = {};\n  for (const minifiedKey in obj) {\n    if (obj.hasOwnProperty(minifiedKey)) {\n      let publicName: string|[string, string] = obj[minifiedKey]!;\n      let declaredName = publicName;\n      if (Array.isArray(publicName)) {\n        declaredName = publicName[1];\n        publicName = publicName[0];\n      }\n      newLookup[publicName] = minifiedKey;\n      if (secondary) {\n        (secondary[publicName] = declaredName as string);\n      }\n    }\n  }\n  return newLookup;\n}\n\n/**\n * Create a directive definition object.\n *\n * # Example\n * ```ts\n * class MyDirective {\n *   // Generated by Angular Template Compiler\n *   // [Symbol] syntax will not be supported by TypeScript until v2.7\n *   static ɵdir = ɵɵdefineDirective({\n *     ...\n *   });\n * }\n * ```\n *\n * @codeGenApi\n */\nexport const ɵɵdefineDirective =\n    ɵɵdefineComponent as any as<T>(directiveDefinition: {\n      /**\n       * Directive type, needed to configure the injector.\n       */\n      type: Type<T>;\n\n      /** The selectors that will be used to match nodes to this directive. */\n      selectors?: CssSelectorList;\n\n      /**\n       * A map of input names.\n       *\n       * The format is in: `{[actualPropertyName: string]:(string|[string, string])}`.\n       *\n       * Given:\n       * ```\n       * class MyComponent {\n       *   @Input()\n       *   publicInput1: string;\n       *\n       *   @Input('publicInput2')\n       *   declaredInput2: string;\n       * }\n       * ```\n       *\n       * is described as:\n       * ```\n       * {\n       *   publicInput1: 'publicInput1',\n       *   declaredInput2: ['declaredInput2', 'publicInput2'],\n       * }\n       * ```\n       *\n       * Which the minifier may translate to:\n       * ```\n       * {\n       *   minifiedPublicInput1: 'publicInput1',\n       *   minifiedDeclaredInput2: [ 'publicInput2', 'declaredInput2'],\n       * }\n       * ```\n       *\n       * This allows the render to re-construct the minified, public, and declared names\n       * of properties.\n       *\n       * NOTE:\n       *  - Because declared and public name are usually same we only generate the array\n       *    `['declared', 'public']` format when they differ.\n       *  - The reason why this API and `outputs` API is not the same is that `NgOnChanges` has\n       *    inconsistent behavior in that it uses declared names rather than minified or public. For\n       *    this reason `NgOnChanges` will be deprecated and removed in future version and this\n       *    API will be simplified to be consistent with `output`.\n       */\n      inputs?: {[P in keyof T]?: string | [string, string]};\n\n      /**\n       * A map of output names.\n       *\n       * The format is in: `{[actualPropertyName: string]:string}`.\n       *\n       * Which the minifier may translate to: `{[minifiedPropertyName: string]:string}`.\n       *\n       * This allows the render to re-construct the minified and non-minified names\n       * of properties.\n       */\n      outputs?: {[P in keyof T]?: string};\n\n      /**\n       * A list of optional features to apply.\n       *\n       * See: {@link NgOnChangesFeature}, {@link ProvidersFeature}, {@link InheritDefinitionFeature}\n       */\n      features?: DirectiveDefFeature[];\n\n      /**\n       * Function executed by the parent template to allow child directive to apply host bindings.\n       */\n      hostBindings?: HostBindingsFunction<T>;\n\n      /**\n       * The number of bindings in this directive `hostBindings` (including pure fn bindings).\n       *\n       * Used to calculate the length of the component's LView array, so we\n       * can pre-fill the array and set the host binding start index.\n       */\n      hostVars?: number;\n\n      /**\n       * Assign static attribute values to a host element.\n       *\n       * This property will assign static attribute values as well as class and style\n       * values to a host element. Since attribute values can consist of different types of values,\n       * the `hostAttrs` array must include the values in the following format:\n       *\n       * attrs = [\n       *   // static attributes (like `title`, `name`, `id`...)\n       *   attr1, value1, attr2, value,\n       *\n       *   // a single namespace value (like `x:id`)\n       *   NAMESPACE_MARKER, namespaceUri1, name1, value1,\n       *\n       *   // another single namespace value (like `x:name`)\n       *   NAMESPACE_MARKER, namespaceUri2, name2, value2,\n       *\n       *   // a series of CSS classes that will be applied to the element (no spaces)\n       *   CLASSES_MARKER, class1, class2, class3,\n       *\n       *   // a series of CSS styles (property + value) that will be applied to the element\n       *   STYLES_MARKER, prop1, value1, prop2, value2\n       * ]\n       *\n       * All non-class and non-style attributes must be defined at the start of the list\n       * first before all class and style values are set. When there is a change in value\n       * type (like when classes and styles are introduced) a marker must be used to separate\n       * the entries. The marker values themselves are set via entries found in the\n       * [AttributeMarker] enum.\n       */\n      hostAttrs?: TAttributes;\n\n      /**\n       * Function to create instances of content queries associated with a given directive.\n       */\n      contentQueries?: ContentQueriesFunction<T>;\n\n      /**\n       * Additional set of instructions specific to view query processing. This could be seen as a\n       * set of instructions to be inserted into the template function.\n       */\n      viewQuery?: ViewQueriesFunction<T>| null;\n\n      /**\n       * Defines the name that can be used in the template to assign this directive to a variable.\n       *\n       * See: {@link Directive.exportAs}\n       */\n      exportAs?: string[];\n    }) => never;\n\n/**\n * Create a pipe definition object.\n *\n * # Example\n * ```\n * class MyPipe implements PipeTransform {\n *   // Generated by Angular Template Compiler\n *   static ɵpipe = definePipe({\n *     ...\n *   });\n * }\n * ```\n * @param pipeDef Pipe definition generated by the compiler\n *\n * @codeGenApi\n */\nexport function ɵɵdefinePipe<T>(pipeDef: {\n  /** Name of the pipe. Used for matching pipes in template to pipe defs. */\n  name: string,\n\n  /** Pipe class reference. Needed to extract pipe lifecycle hooks. */\n  type: Type<T>,\n\n  /** Whether the pipe is pure. */\n  pure?: boolean,\n\n  /**\n   * Whether the pipe is standalone.\n   */\n  standalone?: boolean,\n}): unknown {\n  return (<PipeDef<T>>{\n    type: pipeDef.type,\n    name: pipeDef.name,\n    factory: null,\n    pure: pipeDef.pure !== false,\n    standalone: pipeDef.standalone === true,\n    onDestroy: pipeDef.type.prototype.ngOnDestroy || null\n  });\n}\n\n/**\n * The following getter methods retrieve the definition from the type. Currently the retrieval\n * honors inheritance, but in the future we may change the rule to require that definitions are\n * explicit. This would require some sort of migration strategy.\n */\n\nexport function getComponentDef<T>(type: any): ComponentDef<T>|null {\n  return type[NG_COMP_DEF] || null;\n}\n\nexport function getDirectiveDef<T>(type: any): DirectiveDef<T>|null {\n  return type[NG_DIR_DEF] || null;\n}\n\nexport function getPipeDef<T>(type: any): PipeDef<T>|null {\n  return type[NG_PIPE_DEF] || null;\n}\n\nexport function getNgModuleDef<T>(type: any, throwNotFound: true): NgModuleDef<T>;\nexport function getNgModuleDef<T>(type: any): NgModuleDef<T>|null;\nexport function getNgModuleDef<T>(type: any, throwNotFound?: boolean): NgModuleDef<T>|null {\n  const ngModuleDef = type[NG_MOD_DEF] || null;\n  if (!ngModuleDef && throwNotFound === true) {\n    throw new Error(`Type ${stringify(type)} does not have 'ɵmod' property.`);\n  }\n  return ngModuleDef;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {TNode} from './node';\nimport {RComment, RElement} from './renderer_dom';\nimport {HOST, LView, NEXT, PARENT, T_HOST, TRANSPLANTED_VIEWS_TO_REFRESH} from './view';\n\n\n\n/**\n * Special location which allows easy identification of type. If we have an array which was\n * retrieved from the `LView` and that array has `true` at `TYPE` location, we know it is\n * `LContainer`.\n */\nexport const TYPE = 1;\n\n/**\n * Below are constants for LContainer indices to help us look up LContainer members\n * without having to remember the specific indices.\n * Uglify will inline these when minifying so there shouldn't be a cost.\n */\n\n/**\n * Flag to signify that this `LContainer` may have transplanted views which need to be change\n * detected. (see: `LView[DECLARATION_COMPONENT_VIEW])`.\n *\n * This flag, once set, is never unset for the `LContainer`. This means that when unset we can skip\n * a lot of work in `refreshEmbeddedViews`. But when set we still need to verify\n * that the `MOVED_VIEWS` are transplanted and on-push.\n */\nexport const HAS_TRANSPLANTED_VIEWS = 2;\n\n// PARENT, NEXT, TRANSPLANTED_VIEWS_TO_REFRESH are indices 3, 4, and 5\n// As we already have these constants in LView, we don't need to re-create them.\n\n// T_HOST is index 6\n// We already have this constants in LView, we don't need to re-create it.\n\nexport const NATIVE = 7;\nexport const VIEW_REFS = 8;\nexport const MOVED_VIEWS = 9;\n\n\n/**\n * Size of LContainer's header. Represents the index after which all views in the\n * container will be inserted. We need to keep a record of current views so we know\n * which views are already in the DOM (and don't need to be re-added) and so we can\n * remove views from the DOM when they are no longer required.\n */\nexport const CONTAINER_HEADER_OFFSET = 10;\n\n/**\n * The state associated with a container.\n *\n * This is an array so that its structure is closer to LView. This helps\n * when traversing the view tree (which is a mix of containers and component\n * views), so we can jump to viewOrContainer[NEXT] in the same way regardless\n * of type.\n */\nexport interface LContainer extends Array<any> {\n  /**\n   * The host element of this LContainer.\n   *\n   * The host could be an LView if this container is on a component node.\n   * In that case, the component LView is its HOST.\n   */\n  readonly[HOST]: RElement|RComment|LView;\n\n  /**\n   * This is a type field which allows us to differentiate `LContainer` from `StylingContext` in an\n   * efficient way. The value is always set to `true`\n   */\n  [TYPE]: true;\n\n  /**\n   * Flag to signify that this `LContainer` may have transplanted views which need to be change\n   * detected. (see: `LView[DECLARATION_COMPONENT_VIEW])`.\n   *\n   * This flag, once set, is never unset for the `LContainer`.\n   */\n  [HAS_TRANSPLANTED_VIEWS]: boolean;\n\n  /**\n   * Access to the parent view is necessary so we can propagate back\n   * up from inside a container to parent[NEXT].\n   */\n  [PARENT]: LView;\n\n  /**\n   * This allows us to jump from a container to a sibling container or component\n   * view with the same parent, so we can remove listeners efficiently.\n   */\n  [NEXT]: LView|LContainer|null;\n\n  /**\n   * The number of direct transplanted views which need a refresh or have descendants themselves\n   * that need a refresh but have not marked their ancestors as Dirty. This tells us that during\n   * change detection we should still descend to find those children to refresh, even if the parents\n   * are not `Dirty`/`CheckAlways`.\n   */\n  [TRANSPLANTED_VIEWS_TO_REFRESH]: number;\n\n  /**\n   * A collection of views created based on the underlying `<ng-template>` element but inserted into\n   * a different `LContainer`. We need to track views created from a given declaration point since\n   * queries collect matches from the embedded view declaration point and _not_ the insertion point.\n   */\n  [MOVED_VIEWS]: LView[]|null;\n\n  /**\n   * Pointer to the `TNode` which represents the host of the container.\n   */\n  [T_HOST]: TNode;\n\n  /** The comment element that serves as an anchor for this LContainer. */\n  readonly[NATIVE]:\n      RComment;  // TODO(misko): remove as this value can be gotten by unwrapping `[HOST]`\n\n  /**\n   * Array of `ViewRef`s used by any `ViewContainerRef`s that point to this container.\n   *\n   * This is lazily initialized by `ViewContainerRef` when the first view is inserted.\n   *\n   * NOTE: This is stored as `any[]` because render3 should really not be aware of `ViewRef` and\n   * doing so creates circular dependency.\n   */\n  [VIEW_REFS]: unknown[]|null;\n}\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '../../di/injector';\nimport {ProviderToken} from '../../di/provider_token';\nimport {Type} from '../../interface/type';\nimport {SchemaMetadata} from '../../metadata/schema';\nimport {Sanitizer} from '../../sanitization/sanitizer';\n\nimport {LContainer} from './container';\nimport {ComponentDef, ComponentTemplate, DirectiveDef, DirectiveDefList, HostBindingsFunction, PipeDef, PipeDefList, ViewQueriesFunction} from './definition';\nimport {I18nUpdateOpCodes, TI18n, TIcu} from './i18n';\nimport {TConstants, TNode} from './node';\nimport {PlayerHandler} from './player';\nimport {LQueries, TQueries} from './query';\nimport {Renderer, RendererFactory} from './renderer';\nimport {RComment, RElement} from './renderer_dom';\nimport {TStylingKey, TStylingRange} from './styling';\n\n\n\n// Below are constants for LView indices to help us look up LView members\n// without having to remember the specific indices.\n// Uglify will inline these when minifying so there shouldn't be a cost.\nexport const HOST = 0;\nexport const TVIEW = 1;\nexport const FLAGS = 2;\nexport const PARENT = 3;\nexport const NEXT = 4;\nexport const TRANSPLANTED_VIEWS_TO_REFRESH = 5;\nexport const T_HOST = 6;\nexport const CLEANUP = 7;\nexport const CONTEXT = 8;\nexport const INJECTOR = 9;\nexport const RENDERER_FACTORY = 10;\nexport const RENDERER = 11;\nexport const SANITIZER = 12;\nexport const CHILD_HEAD = 13;\nexport const CHILD_TAIL = 14;\n// FIXME(misko): Investigate if the three declarations aren't all same thing.\nexport const DECLARATION_VIEW = 15;\nexport const DECLARATION_COMPONENT_VIEW = 16;\nexport const DECLARATION_LCONTAINER = 17;\nexport const PREORDER_HOOK_FLAGS = 18;\nexport const QUERIES = 19;\nexport const ID = 20;\nexport const EMBEDDED_VIEW_INJECTOR = 21;\n/**\n * Size of LView's header. Necessary to adjust for it when setting slots.\n *\n * IMPORTANT: `HEADER_OFFSET` should only be referred to the in the `ɵɵ*` instructions to translate\n * instruction index into `LView` index. All other indexes should be in the `LView` index space and\n * there should be no need to refer to `HEADER_OFFSET` anywhere else.\n */\nexport const HEADER_OFFSET = 22;\n\n\n// This interface replaces the real LView interface if it is an arg or a\n// return value of a public instruction. This ensures we don't need to expose\n// the actual interface, which should be kept private.\nexport interface OpaqueViewState {\n  '__brand__': 'Brand for OpaqueViewState that nothing will match';\n}\n\n\n/**\n * `LView` stores all of the information needed to process the instructions as\n * they are invoked from the template. Each embedded view and component view has its\n * own `LView`. When processing a particular view, we set the `viewData` to that\n * `LView`. When that view is done processing, the `viewData` is set back to\n * whatever the original `viewData` was before (the parent `LView`).\n *\n * Keeping separate state for each view facilities view insertion / deletion, so we\n * don't have to edit the data array based on which views are present.\n */\nexport interface LView<T = unknown> extends Array<any> {\n  /**\n   * Human readable representation of the `LView`.\n   *\n   * NOTE: This property only exists if `ngDevMode` is set to `true` and it is not present in\n   * production. Its presence is purely to help debug issue in development, and should not be relied\n   * on in production application.\n   */\n  debug?: LViewDebug;\n\n  /**\n   * The node into which this `LView` is inserted.\n   */\n  [HOST]: RElement|null;\n\n  /**\n   * The static data for this view. We need a reference to this so we can easily walk up the\n   * node tree in DI and get the TView.data array associated with a node (where the\n   * directive defs are stored).\n   */\n  readonly[TVIEW]: TView;\n\n  /** Flags for this view. See LViewFlags for more info. */\n  [FLAGS]: LViewFlags;\n\n  /**\n   * This may store an {@link LView} or {@link LContainer}.\n   *\n   * `LView` - The parent view. This is needed when we exit the view and must restore the previous\n   * LView. Without this, the render method would have to keep a stack of\n   * views as it is recursively rendering templates.\n   *\n   * `LContainer` - The current view is part of a container, and is an embedded view.\n   */\n  [PARENT]: LView|LContainer|null;\n\n  /**\n   *\n   * The next sibling LView or LContainer.\n   *\n   * Allows us to propagate between sibling view states that aren't in the same\n   * container. Embedded views already have a node.next, but it is only set for\n   * views in the same container. We need a way to link component views and views\n   * across containers as well.\n   */\n  [NEXT]: LView|LContainer|null;\n\n  /** Queries active for this view - nodes from a view are reported to those queries. */\n  [QUERIES]: LQueries|null;\n\n  /**\n   * Store the `TNode` of the location where the current `LView` is inserted into.\n   *\n   * Given:\n   * ```\n   * <div>\n   *   <ng-template><span></span></ng-template>\n   * </div>\n   * ```\n   *\n   * We end up with two `TView`s.\n   * - `parent` `TView` which contains `<div><!-- anchor --></div>`\n   * - `child` `TView` which contains `<span></span>`\n   *\n   * Typically the `child` is inserted into the declaration location of the `parent`, but it can be\n   * inserted anywhere. Because it can be inserted anywhere it is not possible to store the\n   * insertion information in the `TView` and instead we must store it in the `LView[T_HOST]`.\n   *\n   * So to determine where is our insertion parent we would execute:\n   * ```\n   * const parentLView = lView[PARENT];\n   * const parentTNode = lView[T_HOST];\n   * const insertionParent = parentLView[parentTNode.index];\n   * ```\n   *\n   *\n   * If `null`, this is the root view of an application (root component is in this view) and it has\n   * no parents.\n   */\n  [T_HOST]: TNode|null;\n\n  /**\n   * When a view is destroyed, listeners need to be released and outputs need to be\n   * unsubscribed. This context array stores both listener functions wrapped with\n   * their context and output subscription instances for a particular view.\n   *\n   * These change per LView instance, so they cannot be stored on TView. Instead,\n   * TView.cleanup saves an index to the necessary context in this array.\n   *\n   * After `LView` is created it is possible to attach additional instance specific functions at the\n   * end of the `lView[CLEANUP]` because we know that no more `T` level cleanup functions will be\n   * added here.\n   */\n  [CLEANUP]: any[]|null;\n\n  /**\n   * - For dynamic views, this is the context with which to render the template (e.g.\n   *   `NgForContext`), or `{}` if not defined explicitly.\n   * - For root view of the root component the context contains change detection data.\n   * - For non-root components, the context is the component instance,\n   * - For inline views, the context is null.\n   */\n  [CONTEXT]: T;\n\n  /** An optional Module Injector to be used as fall back after Element Injectors are consulted. */\n  readonly[INJECTOR]: Injector|null;\n\n  /** Factory to be used for creating Renderer. */\n  [RENDERER_FACTORY]: RendererFactory;\n\n  /** Renderer to be used for this view. */\n  [RENDERER]: Renderer;\n\n  /** An optional custom sanitizer. */\n  [SANITIZER]: Sanitizer|null;\n\n  /**\n   * Reference to the first LView or LContainer beneath this LView in\n   * the hierarchy.\n   *\n   * Necessary to store this so views can traverse through their nested views\n   * to remove listeners and call onDestroy callbacks.\n   */\n  [CHILD_HEAD]: LView|LContainer|null;\n\n  /**\n   * The last LView or LContainer beneath this LView in the hierarchy.\n   *\n   * The tail allows us to quickly add a new state to the end of the view list\n   * without having to propagate starting from the first child.\n   */\n  [CHILD_TAIL]: LView|LContainer|null;\n\n  /**\n   * View where this view's template was declared.\n   *\n   * The template for a dynamically created view may be declared in a different view than\n   * it is inserted. We already track the \"insertion view\" (view where the template was\n   * inserted) in LView[PARENT], but we also need access to the \"declaration view\"\n   * (view where the template was declared). Otherwise, we wouldn't be able to call the\n   * view's template function with the proper contexts. Context should be inherited from\n   * the declaration view tree, not the insertion view tree.\n   *\n   * Example (AppComponent template):\n   *\n   * <ng-template #foo></ng-template>       <-- declared here -->\n   * <some-comp [tpl]=\"foo\"></some-comp>    <-- inserted inside this component -->\n   *\n   * The <ng-template> above is declared in the AppComponent template, but it will be passed into\n   * SomeComp and inserted there. In this case, the declaration view would be the AppComponent,\n   * but the insertion view would be SomeComp. When we are removing views, we would want to\n   * traverse through the insertion view to clean up listeners. When we are calling the\n   * template function during change detection, we need the declaration view to get inherited\n   * context.\n   */\n  [DECLARATION_VIEW]: LView|null;\n\n\n  /**\n   * Points to the declaration component view, used to track transplanted `LView`s.\n   *\n   * See: `DECLARATION_VIEW` which points to the actual `LView` where it was declared, whereas\n   * `DECLARATION_COMPONENT_VIEW` points to the component which may not be same as\n   * `DECLARATION_VIEW`.\n   *\n   * Example:\n   * ```\n   * <#VIEW #myComp>\n   *  <div *ngIf=\"true\">\n   *   <ng-template #myTmpl>...</ng-template>\n   *  </div>\n   * </#VIEW>\n   * ```\n   * In the above case `DECLARATION_VIEW` for `myTmpl` points to the `LView` of `ngIf` whereas\n   * `DECLARATION_COMPONENT_VIEW` points to `LView` of the `myComp` which owns the template.\n   *\n   * The reason for this is that all embedded views are always check-always whereas the component\n   * view can be check-always or on-push. When we have a transplanted view it is important to\n   * determine if we have transplanted a view from check-always declaration to on-push insertion\n   * point. In such a case the transplanted view needs to be added to the `LContainer` in the\n   * declared `LView` and CD during the declared view CD (in addition to the CD at the insertion\n   * point.) (Any transplanted views which are intra Component are of no interest because the CD\n   * strategy of declaration and insertion will always be the same, because it is the same\n   * component.)\n   *\n   * Queries already track moved views in `LView[DECLARATION_LCONTAINER]` and\n   * `LContainer[MOVED_VIEWS]`. However the queries also track `LView`s which moved within the same\n   * component `LView`. Transplanted views are a subset of moved views, and we use\n   * `DECLARATION_COMPONENT_VIEW` to differentiate them. As in this example.\n   *\n   * Example showing intra component `LView` movement.\n   * ```\n   * <#VIEW #myComp>\n   *   <div *ngIf=\"condition; then thenBlock else elseBlock\"></div>\n   *   <ng-template #thenBlock>Content to render when condition is true.</ng-template>\n   *   <ng-template #elseBlock>Content to render when condition is false.</ng-template>\n   * </#VIEW>\n   * ```\n   * The `thenBlock` and `elseBlock` is moved but not transplanted.\n   *\n   * Example showing inter component `LView` movement (transplanted view).\n   * ```\n   * <#VIEW #myComp>\n   *   <ng-template #myTmpl>...</ng-template>\n   *   <insertion-component [template]=\"myTmpl\"></insertion-component>\n   * </#VIEW>\n   * ```\n   * In the above example `myTmpl` is passed into a different component. If `insertion-component`\n   * instantiates `myTmpl` and `insertion-component` is on-push then the `LContainer` needs to be\n   * marked as containing transplanted views and those views need to be CD as part of the\n   * declaration CD.\n   *\n   *\n   * When change detection runs, it iterates over `[MOVED_VIEWS]` and CDs any child `LView`s where\n   * the `DECLARATION_COMPONENT_VIEW` of the current component and the child `LView` does not match\n   * (it has been transplanted across components.)\n   *\n   * Note: `[DECLARATION_COMPONENT_VIEW]` points to itself if the LView is a component view (the\n   *       simplest / most common case).\n   *\n   * see also:\n   *   - https://hackmd.io/@mhevery/rJUJsvv9H write up of the problem\n   *   - `LContainer[HAS_TRANSPLANTED_VIEWS]` which marks which `LContainer` has transplanted views.\n   *   - `LContainer[TRANSPLANT_HEAD]` and `LContainer[TRANSPLANT_TAIL]` storage for transplanted\n   *   - `LView[DECLARATION_LCONTAINER]` similar problem for queries\n   *   - `LContainer[MOVED_VIEWS]` similar problem for queries\n   */\n  [DECLARATION_COMPONENT_VIEW]: LView;\n\n  /**\n   * A declaration point of embedded views (ones instantiated based on the content of a\n   * <ng-template>), null for other types of views.\n   *\n   * We need to track all embedded views created from a given declaration point so we can prepare\n   * query matches in a proper order (query matches are ordered based on their declaration point and\n   * _not_ the insertion point).\n   */\n  [DECLARATION_LCONTAINER]: LContainer|null;\n\n  /**\n   * More flags for this view. See PreOrderHookFlags for more info.\n   */\n  [PREORDER_HOOK_FLAGS]: PreOrderHookFlags;\n\n  /**\n   * The number of direct transplanted views which need a refresh or have descendants themselves\n   * that need a refresh but have not marked their ancestors as Dirty. This tells us that during\n   * change detection we should still descend to find those children to refresh, even if the parents\n   * are not `Dirty`/`CheckAlways`.\n   */\n  [TRANSPLANTED_VIEWS_TO_REFRESH]: number;\n\n  /** Unique ID of the view. Used for `__ngContext__` lookups in the `LView` registry. */\n  [ID]: number;\n\n  /**\n   * Optional injector assigned to embedded views that takes\n   * precedence over the element and module injectors.\n   */\n  readonly[EMBEDDED_VIEW_INJECTOR]: Injector|null;\n}\n\n/** Flags associated with an LView (saved in LView[FLAGS]) */\nexport const enum LViewFlags {\n  /** The state of the init phase on the first 2 bits */\n  InitPhaseStateIncrementer = 0b00000000001,\n  InitPhaseStateMask = 0b00000000011,\n\n  /**\n   * Whether or not the view is in creationMode.\n   *\n   * This must be stored in the view rather than using `data` as a marker so that\n   * we can properly support embedded views. Otherwise, when exiting a child view\n   * back into the parent view, `data` will be defined and `creationMode` will be\n   * improperly reported as false.\n   */\n  CreationMode = 0b00000000100,\n\n  /**\n   * Whether or not this LView instance is on its first processing pass.\n   *\n   * An LView instance is considered to be on its \"first pass\" until it\n   * has completed one creation mode run and one update mode run. At this\n   * time, the flag is turned off.\n   */\n  FirstLViewPass = 0b00000001000,\n\n  /** Whether this view has default change detection strategy (checks always) or onPush */\n  CheckAlways = 0b00000010000,\n\n  /** Whether or not this view is currently dirty (needing check) */\n  Dirty = 0b00000100000,\n\n  /** Whether or not this view is currently attached to change detection tree. */\n  Attached = 0b000001000000,\n\n  /** Whether or not this view is destroyed. */\n  Destroyed = 0b000010000000,\n\n  /** Whether or not this view is the root view */\n  IsRoot = 0b000100000000,\n\n  /**\n   * Whether this moved LView was needs to be refreshed at the insertion location because the\n   * declaration was dirty.\n   */\n  RefreshTransplantedView = 0b001000000000,\n\n  /** Indicates that the view **or any of its ancestors** have an embedded view injector. */\n  HasEmbeddedViewInjector = 0b0010000000000,\n\n  /**\n   * Index of the current init phase on last 21 bits\n   */\n  IndexWithinInitPhaseIncrementer = 0b0100000000000,\n  IndexWithinInitPhaseShift = 11,\n  IndexWithinInitPhaseReset = 0b0011111111111,\n}\n\n/**\n * Possible states of the init phase:\n * - 00: OnInit hooks to be run.\n * - 01: AfterContentInit hooks to be run\n * - 10: AfterViewInit hooks to be run\n * - 11: All init hooks have been run\n */\nexport const enum InitPhaseState {\n  OnInitHooksToBeRun = 0b00,\n  AfterContentInitHooksToBeRun = 0b01,\n  AfterViewInitHooksToBeRun = 0b10,\n  InitPhaseCompleted = 0b11,\n}\n\n/** More flags associated with an LView (saved in LView[PREORDER_HOOK_FLAGS]) */\nexport const enum PreOrderHookFlags {\n  /**\n     The index of the next pre-order hook to be called in the hooks array, on the first 16\n     bits\n   */\n  IndexOfTheNextPreOrderHookMaskMask = 0b01111111111111111,\n\n  /**\n   * The number of init hooks that have already been called, on the last 16 bits\n   */\n  NumberOfInitHooksCalledIncrementer = 0b010000000000000000,\n  NumberOfInitHooksCalledShift = 16,\n  NumberOfInitHooksCalledMask = 0b11111111111111110000000000000000,\n}\n\n/**\n * Stores a set of OpCodes to process `HostBindingsFunction` associated with a current view.\n *\n * In order to invoke `HostBindingsFunction` we need:\n * 1. 'elementIdx`: Index to the element associated with the `HostBindingsFunction`.\n * 2. 'directiveIdx`: Index to the directive associated with the `HostBindingsFunction`. (This will\n *    become the context for the `HostBindingsFunction` invocation.)\n * 3. `bindingRootIdx`: Location where the bindings for the `HostBindingsFunction` start. Internally\n *    `HostBindingsFunction` binding indexes start from `0` so we need to add `bindingRootIdx` to\n *    it.\n * 4. `HostBindingsFunction`: A host binding function to execute.\n *\n * The above information needs to be encoded into the `HostBindingOpCodes` in an efficient manner.\n *\n * 1. `elementIdx` is encoded into the `HostBindingOpCodes` as `~elementIdx` (so a negative number);\n * 2. `directiveIdx`\n * 3. `bindingRootIdx`\n * 4. `HostBindingsFunction` is passed in as is.\n *\n * The `HostBindingOpCodes` array contains:\n * - negative number to select the element index.\n * - followed by 1 or more of:\n *    - a number to select the directive index\n *    - a number to select the bindingRoot index\n *    - and a function to invoke.\n *\n * ## Example\n *\n * ```\n * const hostBindingOpCodes = [\n *   ~30,                               // Select element 30\n *   40, 45, MyDir.ɵdir.hostBindings    // Invoke host bindings on MyDir on element 30;\n *                                      // directiveIdx = 40; bindingRootIdx = 45;\n *   50, 55, OtherDir.ɵdir.hostBindings // Invoke host bindings on OtherDire on element 30\n *                                      // directiveIdx = 50; bindingRootIdx = 55;\n * ]\n * ```\n *\n * ## Pseudocode\n * ```\n * const hostBindingOpCodes = tView.hostBindingOpCodes;\n * if (hostBindingOpCodes === null) return;\n * for (let i = 0; i < hostBindingOpCodes.length; i++) {\n *   const opCode = hostBindingOpCodes[i] as number;\n *   if (opCode < 0) {\n *     // Negative numbers are element indexes.\n *     setSelectedIndex(~opCode);\n *   } else {\n *     // Positive numbers are NumberTuple which store bindingRootIndex and directiveIndex.\n *     const directiveIdx = opCode;\n *     const bindingRootIndx = hostBindingOpCodes[++i] as number;\n *     const hostBindingFn = hostBindingOpCodes[++i] as HostBindingsFunction<any>;\n *     setBindingRootForHostBindings(bindingRootIndx, directiveIdx);\n *     const context = lView[directiveIdx];\n *     hostBindingFn(RenderFlags.Update, context);\n *   }\n * }\n * ```\n *\n */\nexport interface HostBindingOpCodes extends Array<number|HostBindingsFunction<any>> {\n  __brand__: 'HostBindingOpCodes';\n  debug?: string[];\n}\n\n/**\n * Explicitly marks `TView` as a specific type in `ngDevMode`\n *\n * It is useful to know conceptually what time of `TView` we are dealing with when\n * debugging an application (even if the runtime does not need it.) For this reason\n * we store this information in the `ngDevMode` `TView` and than use it for\n * better debugging experience.\n */\nexport const enum TViewType {\n  /**\n   * Root `TView` is the used to bootstrap components into. It is used in conjunction with\n   * `LView` which takes an existing DOM node not owned by Angular and wraps it in `TView`/`LView`\n   * so that other components can be loaded into it.\n   */\n  Root = 0,\n\n  /**\n   * `TView` associated with a Component. This would be the `TView` directly associated with the\n   * component view (as opposed an `Embedded` `TView` which would be a child of `Component` `TView`)\n   */\n  Component = 1,\n\n  /**\n   * `TView` associated with a template. Such as `*ngIf`, `<ng-template>` etc... A `Component`\n   * can have zero or more `Embedded` `TView`s.\n   */\n  Embedded = 2,\n}\n\n/**\n * Converts `TViewType` into human readable text.\n * Make sure this matches with `TViewType`\n */\nexport const TViewTypeAsString = [\n  'Root',       // 0\n  'Component',  // 1\n  'Embedded',   // 2\n] as const;\n\n\n/**\n * The static data for an LView (shared between all templates of a\n * given type).\n *\n * Stored on the `ComponentDef.tView`.\n */\nexport interface TView {\n  /**\n   * Type of `TView` (`Root`|`Component`|`Embedded`).\n   */\n  type: TViewType;\n\n  /**\n   * This is a blueprint used to generate LView instances for this TView. Copying this\n   * blueprint is faster than creating a new LView from scratch.\n   */\n  blueprint: LView;\n\n  /**\n   * The template function used to refresh the view of dynamically created views\n   * and components. Will be null for inline views.\n   */\n  template: ComponentTemplate<{}>|null;\n\n  /**\n   * A function containing query-related instructions.\n   */\n  viewQuery: ViewQueriesFunction<{}>|null;\n\n  /**\n   * A `TNode` representing the declaration location of this `TView` (not part of this TView).\n   */\n  declTNode: TNode|null;\n\n  // FIXME(misko): Why does `TView` not have `declarationTView` property?\n\n  /** Whether or not this template has been processed in creation mode. */\n  firstCreatePass: boolean;\n\n  /**\n   *  Whether or not this template has been processed in update mode (e.g. change detected)\n   *\n   * `firstUpdatePass` is used by styling to set up `TData` to contain metadata about the styling\n   * instructions. (Mainly to build up a linked list of styling priority order.)\n   *\n   * Typically this function gets cleared after first execution. If exception is thrown then this\n   * flag can remain turned un until there is first successful (no exception) pass. This means that\n   * individual styling instructions keep track of if they have already been added to the linked\n   * list to prevent double adding.\n   */\n  firstUpdatePass: boolean;\n\n  /** Static data equivalent of LView.data[]. Contains TNodes, PipeDefInternal or TI18n. */\n  data: TData;\n\n  /**\n   * The binding start index is the index at which the data array\n   * starts to store bindings only. Saving this value ensures that we\n   * will begin reading bindings at the correct point in the array when\n   * we are in update mode.\n   *\n   * -1 means that it has not been initialized.\n   */\n  bindingStartIndex: number;\n\n  /**\n   * The index where the \"expando\" section of `LView` begins. The expando\n   * section contains injectors, directive instances, and host binding values.\n   * Unlike the \"decls\" and \"vars\" sections of `LView`, the length of this\n   * section cannot be calculated at compile-time because directives are matched\n   * at runtime to preserve locality.\n   *\n   * We store this start index so we know where to start checking host bindings\n   * in `setHostBindings`.\n   */\n  expandoStartIndex: number;\n\n  /**\n   * Whether or not there are any static view queries tracked on this view.\n   *\n   * We store this so we know whether or not we should do a view query\n   * refresh after creation mode to collect static query results.\n   */\n  staticViewQueries: boolean;\n\n  /**\n   * Whether or not there are any static content queries tracked on this view.\n   *\n   * We store this so we know whether or not we should do a content query\n   * refresh after creation mode to collect static query results.\n   */\n  staticContentQueries: boolean;\n\n  /**\n   * A reference to the first child node located in the view.\n   */\n  firstChild: TNode|null;\n\n  /**\n   * Stores the OpCodes to be replayed during change-detection to process the `HostBindings`\n   *\n   * See `HostBindingOpCodes` for encoding details.\n   */\n  hostBindingOpCodes: HostBindingOpCodes|null;\n\n  /**\n   * Full registry of directives and components that may be found in this view.\n   *\n   * It's necessary to keep a copy of the full def list on the TView so it's possible\n   * to render template functions without a host component.\n   */\n  directiveRegistry: DirectiveDefList|null;\n\n  /**\n   * Full registry of pipes that may be found in this view.\n   *\n   * The property is either an array of `PipeDefs`s or a function which returns the array of\n   * `PipeDefs`s. The function is necessary to be able to support forward declarations.\n   *\n   * It's necessary to keep a copy of the full def list on the TView so it's possible\n   * to render template functions without a host component.\n   */\n  pipeRegistry: PipeDefList|null;\n\n  /**\n   * Array of ngOnInit, ngOnChanges and ngDoCheck hooks that should be executed for this view in\n   * creation mode.\n   *\n   * This array has a flat structure and contains TNode indices, directive indices (where an\n   * instance can be found in `LView`) and hook functions. TNode index is followed by the directive\n   * index and a hook function. If there are multiple hooks for a given TNode, the TNode index is\n   * not repeated and the next lifecycle hook information is stored right after the previous hook\n   * function. This is done so that at runtime the system can efficiently iterate over all of the\n   * functions to invoke without having to make any decisions/lookups.\n   */\n  preOrderHooks: HookData|null;\n\n  /**\n   * Array of ngOnChanges and ngDoCheck hooks that should be executed for this view in update mode.\n   *\n   * This array has the same structure as the `preOrderHooks` one.\n   */\n  preOrderCheckHooks: HookData|null;\n\n  /**\n   * Array of ngAfterContentInit and ngAfterContentChecked hooks that should be executed\n   * for this view in creation mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  contentHooks: HookData|null;\n\n  /**\n   * Array of ngAfterContentChecked hooks that should be executed for this view in update\n   * mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  contentCheckHooks: HookData|null;\n\n  /**\n   * Array of ngAfterViewInit and ngAfterViewChecked hooks that should be executed for\n   * this view in creation mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  viewHooks: HookData|null;\n\n  /**\n   * Array of ngAfterViewChecked hooks that should be executed for this view in\n   * update mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  viewCheckHooks: HookData|null;\n\n  /**\n   * Array of ngOnDestroy hooks that should be executed when this view is destroyed.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  destroyHooks: DestroyHookData|null;\n\n  /**\n   * When a view is destroyed, listeners need to be released and outputs need to be\n   * unsubscribed. This cleanup array stores both listener data (in chunks of 4)\n   * and output data (in chunks of 2) for a particular view. Combining the arrays\n   * saves on memory (70 bytes per array) and on a few bytes of code size (for two\n   * separate for loops).\n   *\n   * If it's a native DOM listener or output subscription being stored:\n   * 1st index is: event name  `name = tView.cleanup[i+0]`\n   * 2nd index is: index of native element or a function that retrieves global target (window,\n   *               document or body) reference based on the native element:\n   *    `typeof idxOrTargetGetter === 'function'`: global target getter function\n   *    `typeof idxOrTargetGetter === 'number'`: index of native element\n   *\n   * 3rd index is: index of listener function `listener = lView[CLEANUP][tView.cleanup[i+2]]`\n   * 4th index is: `useCaptureOrIndx = tView.cleanup[i+3]`\n   *    `typeof useCaptureOrIndx == 'boolean' : useCapture boolean\n   *    `typeof useCaptureOrIndx == 'number':\n   *         `useCaptureOrIndx >= 0` `removeListener = LView[CLEANUP][useCaptureOrIndx]`\n   *         `useCaptureOrIndx <  0` `subscription = LView[CLEANUP][-useCaptureOrIndx]`\n   *\n   * If it's an output subscription or query list destroy hook:\n   * 1st index is: output unsubscribe function / query list destroy function\n   * 2nd index is: index of function context in LView.cleanupInstances[]\n   *               `tView.cleanup[i+0].call(lView[CLEANUP][tView.cleanup[i+1]])`\n   */\n  cleanup: any[]|null;\n\n  /**\n   * A list of element indices for child components that will need to be\n   * refreshed when the current view has finished its check. These indices have\n   * already been adjusted for the HEADER_OFFSET.\n   *\n   */\n  components: number[]|null;\n\n  /**\n   * A collection of queries tracked in a given view.\n   */\n  queries: TQueries|null;\n\n  /**\n   * An array of indices pointing to directives with content queries alongside with the\n   * corresponding query index. Each entry in this array is a tuple of:\n   * - index of the first content query index declared by a given directive;\n   * - index of a directive.\n   *\n   * We are storing those indexes so we can refresh content queries as part of a view refresh\n   * process.\n   */\n  contentQueries: number[]|null;\n\n  /**\n   * Set of schemas that declare elements to be allowed inside the view.\n   */\n  schemas: SchemaMetadata[]|null;\n\n  /**\n   * Array of constants for the view. Includes attribute arrays, local definition arrays etc.\n   * Used for directive matching, attribute bindings, local definitions and more.\n   */\n  consts: TConstants|null;\n\n  /**\n   * Indicates that there was an error before we managed to complete the first create pass of the\n   * view. This means that the view is likely corrupted and we should try to recover it.\n   */\n  incompleteFirstPass: boolean;\n}\n\nexport const enum RootContextFlags {\n  Empty = 0b00,\n  DetectChanges = 0b01,\n  FlushPlayers = 0b10\n}\n\n\n/**\n * RootContext contains information which is shared for all components which\n * were bootstrapped with {@link renderComponent}.\n */\nexport interface RootContext<T = unknown> {\n  /**\n   * A function used for scheduling change detection in the future. Usually\n   * this is `requestAnimationFrame`.\n   */\n  scheduler: (workFn: () => void) => void;\n\n  /**\n   * A promise which is resolved when all components are considered clean (not dirty).\n   *\n   * This promise is overwritten every time a first call to {@link markDirty} is invoked.\n   */\n  clean: Promise<null>;\n\n  /**\n   * RootComponents - The components that were instantiated by the call to\n   * {@link renderComponent}.\n   */\n  components: T[];\n\n  /**\n   * The player flushing handler to kick off all animations\n   */\n  playerHandler: PlayerHandler|null;\n\n  /**\n   * What render-related operations to run once a scheduler has been set\n   */\n  flags: RootContextFlags;\n}\n\n/** Single hook callback function. */\nexport type HookFn = () => void;\n\n/**\n * Information necessary to call a hook. E.g. the callback that\n * needs to invoked and the index at which to find its context.\n */\nexport type HookEntry = number|HookFn;\n\n/**\n * Array of hooks that should be executed for a view and their directive indices.\n *\n * For each node of the view, the following data is stored:\n * 1) Node index (optional)\n * 2) A series of number/function pairs where:\n *  - even indices are directive indices\n *  - odd indices are hook functions\n *\n * Special cases:\n *  - a negative directive index flags an init hook (ngOnInit, ngAfterContentInit, ngAfterViewInit)\n */\nexport type HookData = HookEntry[];\n\n/**\n * Array of destroy hooks that should be executed for a view and their directive indices.\n *\n * The array is set up as a series of number/function or number/(number|function)[]:\n * - Even indices represent the context with which hooks should be called.\n * - Odd indices are the hook functions themselves. If a value at an odd index is an array,\n *   it represents the destroy hooks of a `multi` provider where:\n *     - Even indices represent the index of the provider for which we've registered a destroy hook,\n *       inside of the `multi` provider array.\n *     - Odd indices are the destroy hook functions.\n * For example:\n * LView: `[0, 1, 2, AService, 4, [BService, CService, DService]]`\n * destroyHooks: `[3, AService.ngOnDestroy, 5, [0, BService.ngOnDestroy, 2, DService.ngOnDestroy]]`\n *\n * In the example above `AService` is a type provider with an `ngOnDestroy`, whereas `BService`,\n * `CService` and `DService` are part of a `multi` provider where only `BService` and `DService`\n * have an `ngOnDestroy` hook.\n */\nexport type DestroyHookData = (HookEntry|HookData)[];\n\n/**\n * Static data that corresponds to the instance-specific data array on an LView.\n *\n * Each node's static data is stored in tData at the same index that it's stored\n * in the data array.  Any nodes that do not have static data store a null value in\n * tData to avoid a sparse array.\n *\n * Each pipe's definition is stored here at the same index as its pipe instance in\n * the data array.\n *\n * Each host property's name is stored here at the same index as its value in the\n * data array.\n *\n * Each property binding name is stored here at the same index as its value in\n * the data array. If the binding is an interpolation, the static string values\n * are stored parallel to the dynamic values. Example:\n *\n * id=\"prefix {{ v0 }} a {{ v1 }} b {{ v2 }} suffix\"\n *\n * LView       |   TView.data\n *------------------------\n *  v0 value   |   'a'\n *  v1 value   |   'b'\n *  v2 value   |   id � prefix � suffix\n *\n * Injector bloom filters are also stored here.\n */\nexport type TData = (TNode|PipeDef<any>|DirectiveDef<any>|ComponentDef<any>|number|TStylingRange|\n                     TStylingKey|ProviderToken<any>|TI18n|I18nUpdateOpCodes|TIcu|null|string)[];\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n\n/**\n * Human readable version of the `LView`.\n *\n * `LView` is a data structure used internally to keep track of views. The `LView` is designed for\n * efficiency and so at times it is difficult to read or write tests which assert on its values. For\n * this reason when `ngDevMode` is true we patch a `LView.debug` property which points to\n * `LViewDebug` for easier debugging and test writing. It is the intent of `LViewDebug` to be used\n * in tests.\n */\nexport interface LViewDebug<T = unknown> {\n  /**\n   * Flags associated with the `LView` unpacked into a more readable state.\n   *\n   * See `LViewFlags` for the flag meanings.\n   */\n  readonly flags: {\n    initPhaseState: number,\n    creationMode: boolean,\n    firstViewPass: boolean,\n    checkAlways: boolean,\n    dirty: boolean,\n    attached: boolean,\n    destroyed: boolean,\n    isRoot: boolean,\n    indexWithinInitPhase: number,\n  };\n\n  /**\n   * Associated TView\n   */\n  readonly tView: TView;\n\n  /**\n   * Parent view (or container)\n   */\n  readonly parent: LViewDebug|LContainerDebug|null;\n\n  /**\n   * Next sibling to the `LView`.\n   */\n  readonly next: LViewDebug|LContainerDebug|null;\n\n  /**\n   * The context used for evaluation of the `LView`\n   *\n   * (Usually the component)\n   */\n  readonly context: T;\n\n  /**\n   * Hierarchical tree of nodes.\n   */\n  readonly nodes: DebugNode[];\n\n  /**\n   * Template structure (no instance data).\n   * (Shows how TNodes are connected)\n   */\n  readonly template: string;\n\n  /**\n   * HTML representation of the `LView`.\n   *\n   * This is only approximate to actual HTML as child `LView`s are removed.\n   */\n  readonly html: string;\n\n  /**\n   * The host element to which this `LView` is attached.\n   */\n  readonly hostHTML: string|null;\n\n  /**\n   * Child `LView`s\n   */\n  readonly childViews: Array<LViewDebug|LContainerDebug>;\n\n  /**\n   * Sub range of `LView` containing decls (DOM elements).\n   */\n  readonly decls: LViewDebugRange;\n\n  /**\n   * Sub range of `LView` containing vars (bindings).\n   */\n  readonly vars: LViewDebugRange;\n\n  /**\n   * Sub range of `LView` containing expando (used by DI).\n   */\n  readonly expando: LViewDebugRange;\n}\n\n/**\n * Human readable version of the `LContainer`\n *\n * `LContainer` is a data structure used internally to keep track of child views. The `LContainer`\n * is designed for efficiency and so at times it is difficult to read or write tests which assert on\n * its values. For this reason when `ngDevMode` is true we patch a `LContainer.debug` property which\n * points to `LContainerDebug` for easier debugging and test writing. It is the intent of\n * `LContainerDebug` to be used in tests.\n */\nexport interface LContainerDebug {\n  readonly native: RComment;\n  /**\n   * Child `LView`s.\n   */\n  readonly views: LViewDebug[];\n  readonly parent: LViewDebug|null;\n  readonly movedViews: LView[]|null;\n  readonly host: RElement|RComment|LView;\n  readonly next: LViewDebug|LContainerDebug|null;\n  readonly hasTransplantedViews: boolean;\n}\n\n\n\n/**\n * `LView` is subdivided to ranges where the actual data is stored. Some of these ranges such as\n * `decls` and `vars` are known at compile time. Other such as `i18n` and `expando` are runtime only\n * concepts.\n */\nexport interface LViewDebugRange {\n  /**\n   * The starting index in `LView` where the range begins. (Inclusive)\n   */\n  start: number;\n\n  /**\n   * The ending index in `LView` where the range ends. (Exclusive)\n   */\n  end: number;\n\n  /**\n   * The length of the range\n   */\n  length: number;\n\n  /**\n   * The merged content of the range. `t` contains data from `TView.data` and `l` contains `LView`\n   * data at an index.\n   */\n  content: LViewDebugRangeContent[];\n}\n\n/**\n * For convenience the static and instance portions of `TView` and `LView` are merged into a single\n * object in `LViewRange`.\n */\nexport interface LViewDebugRangeContent {\n  /**\n   * Index into original `LView` or `TView.data`.\n   */\n  index: number;\n\n  /**\n   * Value from the `TView.data[index]` location.\n   */\n  t: any;\n\n  /**\n   * Value from the `LView[index]` location.\n   */\n  l: any;\n}\n\n\n/**\n * A logical node which comprise into `LView`s.\n *\n */\nexport interface DebugNode {\n  /**\n   * HTML representation of the node.\n   */\n  html: string|null;\n\n  /**\n   * Associated `TNode`\n   */\n  tNode: TNode;\n\n  /**\n   * Human readable node type.\n   */\n  type: string;\n\n  /**\n   * DOM native node.\n   */\n  native: Node;\n\n  /**\n   * Child nodes\n   */\n  children: DebugNode[];\n\n  /**\n   * A list of Component/Directive types which need to be instantiated an this location.\n   */\n  factories: Type<unknown>[];\n\n  /**\n   * A list of Component/Directive instances which were instantiated an this location.\n   */\n  instances: unknown[];\n\n  /**\n   * NodeInjector information.\n   */\n  injector: NodeInjectorDebug;\n\n  /**\n   * Injector resolution path.\n   */\n  injectorResolutionPath: any;\n}\n\nexport interface NodeInjectorDebug {\n  /**\n   * Instance bloom. Does the current injector have a provider with a given bloom mask.\n   */\n  bloom: string;\n\n\n  /**\n   * Cumulative bloom. Do any of the above injectors have a provider with a given bloom mask.\n   */\n  cumulativeBloom: string;\n\n  /**\n   * A list of providers associated with this injector.\n   */\n  providers: (Type<unknown>|DirectiveDef<unknown>|ComponentDef<unknown>)[];\n\n  /**\n   * A list of providers associated with this injector visible to the view of the component only.\n   */\n  viewProviders: Type<unknown>[];\n\n\n  /**\n   * Location of the parent `TNode`.\n   */\n  parentInjectorIndex: number;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {LContainer, TYPE} from './container';\nimport {ComponentDef, DirectiveDef} from './definition';\nimport {TNode, TNodeFlags} from './node';\nimport {RNode} from './renderer_dom';\nimport {FLAGS, LView, LViewFlags} from './view';\n\n\n/**\n * True if `value` is `LView`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nexport function isLView(value: RNode|LView|LContainer|{}|null): value is LView {\n  return Array.isArray(value) && typeof value[TYPE] === 'object';\n}\n\n/**\n * True if `value` is `LContainer`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nexport function isLContainer(value: RNode|LView|LContainer|{}|null): value is LContainer {\n  return Array.isArray(value) && value[TYPE] === true;\n}\n\nexport function isContentQueryHost(tNode: TNode): boolean {\n  return (tNode.flags & TNodeFlags.hasContentQuery) !== 0;\n}\n\nexport function isComponentHost(tNode: TNode): boolean {\n  return (tNode.flags & TNodeFlags.isComponentHost) === TNodeFlags.isComponentHost;\n}\n\nexport function isDirectiveHost(tNode: TNode): boolean {\n  return (tNode.flags & TNodeFlags.isDirectiveHost) === TNodeFlags.isDirectiveHost;\n}\n\nexport function isComponentDef<T>(def: DirectiveDef<T>): def is ComponentDef<T> {\n  return (def as ComponentDef<T>).template !== null;\n}\n\nexport function isRootView(target: LView): boolean {\n  return (target[FLAGS] & LViewFlags.IsRoot) !== 0;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDefined, assertEqual, assertNumber, throwError} from '../util/assert';\n\nimport {getComponentDef, getNgModuleDef} from './definition';\nimport {LContainer} from './interfaces/container';\nimport {DirectiveDef} from './interfaces/definition';\nimport {TIcu} from './interfaces/i18n';\nimport {NodeInjectorOffset} from './interfaces/injector';\nimport {TNode} from './interfaces/node';\nimport {isLContainer, isLView} from './interfaces/type_checks';\nimport {DECLARATION_COMPONENT_VIEW, HEADER_OFFSET, LView, T_HOST, TVIEW, TView} from './interfaces/view';\n\n// [Assert functions do not constraint type when they are guarded by a truthy\n// expression.](https://github.com/microsoft/TypeScript/issues/37295)\n\n\nexport function assertTNodeForLView(tNode: TNode, lView: LView) {\n  assertTNodeForTView(tNode, lView[TVIEW]);\n}\n\nexport function assertTNodeForTView(tNode: TNode, tView: TView) {\n  assertTNode(tNode);\n  tNode.hasOwnProperty('tView_') &&\n      assertEqual(\n          (tNode as any as {tView_: TView}).tView_, tView,\n          'This TNode does not belong to this TView.');\n}\n\nexport function assertTNode(tNode: TNode) {\n  assertDefined(tNode, 'TNode must be defined');\n  if (!(tNode && typeof tNode === 'object' && tNode.hasOwnProperty('directiveStylingLast'))) {\n    throwError('Not of type TNode, got: ' + tNode);\n  }\n}\n\n\nexport function assertTIcu(tIcu: TIcu) {\n  assertDefined(tIcu, 'Expected TIcu to be defined');\n  if (!(typeof tIcu.currentCaseLViewIndex === 'number')) {\n    throwError('Object is not of TIcu type.');\n  }\n}\n\nexport function assertComponentType(\n    actual: any,\n    msg: string = 'Type passed in is not ComponentType, it does not have \\'ɵcmp\\' property.') {\n  if (!getComponentDef(actual)) {\n    throwError(msg);\n  }\n}\n\nexport function assertNgModuleType(\n    actual: any,\n    msg: string = 'Type passed in is not NgModuleType, it does not have \\'ɵmod\\' property.') {\n  if (!getNgModuleDef(actual)) {\n    throwError(msg);\n  }\n}\n\nexport function assertCurrentTNodeIsParent(isParent: boolean) {\n  assertEqual(isParent, true, 'currentTNode should be a parent');\n}\n\nexport function assertHasParent(tNode: TNode|null) {\n  assertDefined(tNode, 'currentTNode should exist!');\n  assertDefined(tNode!.parent, 'currentTNode should have a parent');\n}\n\nexport function assertDataNext(lView: LView, index: number, arr?: any[]) {\n  if (arr == null) arr = lView;\n  assertEqual(\n      arr.length, index, `index ${index} expected to be at the end of arr (length ${arr.length})`);\n}\n\nexport function assertLContainer(value: any): asserts value is LContainer {\n  assertDefined(value, 'LContainer must be defined');\n  assertEqual(isLContainer(value), true, 'Expecting LContainer');\n}\n\nexport function assertLViewOrUndefined(value: any): asserts value is LView|null|undefined {\n  value && assertEqual(isLView(value), true, 'Expecting LView or undefined or null');\n}\n\nexport function assertLView(value: any): asserts value is LView {\n  assertDefined(value, 'LView must be defined');\n  assertEqual(isLView(value), true, 'Expecting LView');\n}\n\nexport function assertFirstCreatePass(tView: TView, errMessage?: string) {\n  assertEqual(\n      tView.firstCreatePass, true, errMessage || 'Should only be called in first create pass.');\n}\n\nexport function assertFirstUpdatePass(tView: TView, errMessage?: string) {\n  assertEqual(\n      tView.firstUpdatePass, true, errMessage || 'Should only be called in first update pass.');\n}\n\n/**\n * This is a basic sanity check that an object is probably a directive def. DirectiveDef is\n * an interface, so we can't do a direct instanceof check.\n */\nexport function assertDirectiveDef<T>(obj: any): asserts obj is DirectiveDef<T> {\n  if (obj.type === undefined || obj.selectors == undefined || obj.inputs === undefined) {\n    throwError(\n        `Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`);\n  }\n}\n\nexport function assertIndexInDeclRange(lView: LView, index: number) {\n  const tView = lView[1];\n  assertBetween(HEADER_OFFSET, tView.bindingStartIndex, index);\n}\n\nexport function assertIndexInVarsRange(lView: LView, index: number) {\n  const tView = lView[1];\n  assertBetween(tView.bindingStartIndex, tView.expandoStartIndex, index);\n}\n\nexport function assertIndexInExpandoRange(lView: LView, index: number) {\n  const tView = lView[1];\n  assertBetween(tView.expandoStartIndex, lView.length, index);\n}\n\nexport function assertBetween(lower: number, upper: number, index: number) {\n  if (!(lower <= index && index < upper)) {\n    throwError(`Index out of range (expecting ${lower} <= ${index} < ${upper})`);\n  }\n}\n\nexport function assertProjectionSlots(lView: LView, errMessage?: string) {\n  assertDefined(lView[DECLARATION_COMPONENT_VIEW], 'Component views should exist.');\n  assertDefined(\n      lView[DECLARATION_COMPONENT_VIEW][T_HOST]!.projection,\n      errMessage ||\n          'Components with projection nodes (<ng-content>) must have projection slots defined.');\n}\n\nexport function assertParentView(lView: LView|null, errMessage?: string) {\n  assertDefined(\n      lView,\n      errMessage || 'Component views should always have a parent view (component\\'s host view)');\n}\n\n\n/**\n * This is a basic sanity check that the `injectorIndex` seems to point to what looks like a\n * NodeInjector data structure.\n *\n * @param lView `LView` which should be checked.\n * @param injectorIndex index into the `LView` where the `NodeInjector` is expected.\n */\nexport function assertNodeInjector(lView: LView, injectorIndex: number) {\n  assertIndexInExpandoRange(lView, injectorIndex);\n  assertIndexInExpandoRange(lView, injectorIndex + NodeInjectorOffset.PARENT);\n  assertNumber(lView[injectorIndex + 0], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 1], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 2], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 3], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 4], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 5], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 6], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 7], 'injectorIndex should point to a bloom filter');\n  assertNumber(\n      lView[injectorIndex + NodeInjectorOffset.PARENT],\n      'injectorIndex should point to parent injector');\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../interface/type';\nimport {stringify} from '../util/stringify';\nimport {NG_FACTORY_DEF} from './fields';\n\n\n/**\n * Definition of what a factory function should look like.\n */\nexport type FactoryFn<T> = {\n  /**\n   * Subclasses without an explicit constructor call through to the factory of their base\n   * definition, providing it with their own constructor to instantiate.\n   */\n  <U extends T>(t?: Type<U>): U;\n\n  /**\n   * If no constructor to instantiate is provided, an instance of type T itself is created.\n   */\n  (t?: undefined): T;\n};\n\n\nexport function getFactoryDef<T>(type: any, throwNotFound: true): FactoryFn<T>;\nexport function getFactoryDef<T>(type: any): FactoryFn<T>|null;\nexport function getFactoryDef<T>(type: any, throwNotFound?: boolean): FactoryFn<T>|null {\n  const hasFactoryDef = type.hasOwnProperty(NG_FACTORY_DEF);\n  if (!hasFactoryDef && throwNotFound === true && ngDevMode) {\n    throw new Error(`Type ${stringify(type)} does not have 'ɵfac' property.`);\n  }\n  return hasFactoryDef ? type[NG_FACTORY_DEF] : null;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Represents a basic change from a previous to a new value for a single\n * property on a directive instance. Passed as a value in a\n * {@link SimpleChanges} object to the `ngOnChanges` hook.\n *\n * @see `OnChanges`\n *\n * @publicApi\n */\nexport class SimpleChange {\n  constructor(public previousValue: any, public currentValue: any, public firstChange: boolean) {}\n  /**\n   * Check whether the new value is the first value assigned.\n   */\n  isFirstChange(): boolean {\n    return this.firstChange;\n  }\n}\n\n/**\n * A hashtable of changes represented by {@link SimpleChange} objects stored\n * at the declared property name they belong to on a Directive or Component. This is\n * the type passed to the `ngOnChanges` hook.\n *\n * @see `OnChanges`\n *\n * @publicApi\n */\nexport interface SimpleChanges {\n  [propName: string]: SimpleChange;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {OnChanges} from '../../interface/lifecycle_hooks';\nimport {SimpleChange, SimpleChanges} from '../../interface/simple_change';\nimport {EMPTY_OBJ} from '../../util/empty';\nimport {DirectiveDef, DirectiveDefFeature} from '../interfaces/definition';\n\n/**\n * The NgOnChangesFeature decorates a component with support for the ngOnChanges\n * lifecycle hook, so it should be included in any component that implements\n * that hook.\n *\n * If the component or directive uses inheritance, the NgOnChangesFeature MUST\n * be included as a feature AFTER {@link InheritDefinitionFeature}, otherwise\n * inherited properties will not be propagated to the ngOnChanges lifecycle\n * hook.\n *\n * Example usage:\n *\n * ```\n * static ɵcmp = defineComponent({\n *   ...\n *   inputs: {name: 'publicName'},\n *   features: [NgOnChangesFeature]\n * });\n * ```\n *\n * @codeGenApi\n */\nexport function ɵɵNgOnChangesFeature<T>(): DirectiveDefFeature {\n  return NgOnChangesFeatureImpl;\n}\n\nexport function NgOnChangesFeatureImpl<T>(definition: DirectiveDef<T>) {\n  if (definition.type.prototype.ngOnChanges) {\n    definition.setInput = ngOnChangesSetInput;\n  }\n  return rememberChangeHistoryAndInvokeOnChangesHook;\n}\n\n// This option ensures that the ngOnChanges lifecycle hook will be inherited\n// from superclasses (in InheritDefinitionFeature).\n/** @nocollapse */\n// tslint:disable-next-line:no-toplevel-property-access\n(ɵɵNgOnChangesFeature as DirectiveDefFeature).ngInherit = true;\n\n/**\n * This is a synthetic lifecycle hook which gets inserted into `TView.preOrderHooks` to simulate\n * `ngOnChanges`.\n *\n * The hook reads the `NgSimpleChangesStore` data from the component instance and if changes are\n * found it invokes `ngOnChanges` on the component instance.\n *\n * @param this Component instance. Because this function gets inserted into `TView.preOrderHooks`,\n *     it is guaranteed to be called with component instance.\n */\nfunction rememberChangeHistoryAndInvokeOnChangesHook(this: OnChanges) {\n  const simpleChangesStore = getSimpleChangesStore(this);\n  const current = simpleChangesStore?.current;\n\n  if (current) {\n    const previous = simpleChangesStore!.previous;\n    if (previous === EMPTY_OBJ) {\n      simpleChangesStore!.previous = current;\n    } else {\n      // New changes are copied to the previous store, so that we don't lose history for inputs\n      // which were not changed this time\n      for (let key in current) {\n        previous[key] = current[key];\n      }\n    }\n    simpleChangesStore!.current = null;\n    this.ngOnChanges(current);\n  }\n}\n\n\nfunction ngOnChangesSetInput<T>(\n    this: DirectiveDef<T>, instance: T, value: any, publicName: string, privateName: string): void {\n  const simpleChangesStore = getSimpleChangesStore(instance) ||\n      setSimpleChangesStore(instance, {previous: EMPTY_OBJ, current: null});\n  const current = simpleChangesStore.current || (simpleChangesStore.current = {});\n  const previous = simpleChangesStore.previous;\n\n  const declaredName = (this.declaredInputs as {[key: string]: string})[publicName];\n  const previousChange = previous[declaredName];\n  current[declaredName] = new SimpleChange(\n      previousChange && previousChange.currentValue, value, previous === EMPTY_OBJ);\n\n  (instance as any)[privateName] = value;\n}\n\nconst SIMPLE_CHANGES_STORE = '__ngSimpleChanges__';\n\nfunction getSimpleChangesStore(instance: any): null|NgSimpleChangesStore {\n  return instance[SIMPLE_CHANGES_STORE] || null;\n}\n\nfunction setSimpleChangesStore(instance: any, store: NgSimpleChangesStore): NgSimpleChangesStore {\n  return instance[SIMPLE_CHANGES_STORE] = store;\n}\n\n/**\n * Data structure which is monkey-patched on the component instance and used by `ngOnChanges`\n * life-cycle hook to track previous input values.\n */\ninterface NgSimpleChangesStore {\n  previous: SimpleChanges;\n  current: SimpleChanges|null;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Profiler events is an enum used by the profiler to distinguish between different calls of user\n * code invoked throughout the application lifecycle.\n */\nexport const enum ProfilerEvent {\n  /**\n   * Corresponds to the point in time before the runtime has called the template function of a\n   * component with `RenderFlags.Create`.\n   */\n  TemplateCreateStart,\n\n  /**\n   * Corresponds to the point in time after the runtime has called the template function of a\n   * component with `RenderFlags.Create`.\n   */\n  TemplateCreateEnd,\n\n  /**\n   * Corresponds to the point in time before the runtime has called the template function of a\n   * component with `RenderFlags.Update`.\n   */\n  TemplateUpdateStart,\n\n  /**\n   * Corresponds to the point in time after the runtime has called the template function of a\n   * component with `RenderFlags.Update`.\n   */\n  TemplateUpdateEnd,\n\n  /**\n   * Corresponds to the point in time before the runtime has called a lifecycle hook of a component\n   * or directive.\n   */\n  LifecycleHookStart,\n\n  /**\n   * Corresponds to the point in time after the runtime has called a lifecycle hook of a component\n   * or directive.\n   */\n  LifecycleHookEnd,\n\n  /**\n   * Corresponds to the point in time before the runtime has evaluated an expression associated with\n   * an event or an output.\n   */\n  OutputStart,\n\n  /**\n   * Corresponds to the point in time after the runtime has evaluated an expression associated with\n   * an event or an output.\n   */\n  OutputEnd,\n}\n\n/**\n * Profiler function which the runtime will invoke before and after user code.\n */\nexport interface Profiler {\n  (event: ProfilerEvent, instance: {}|null, hookOrListener?: (e?: any) => any): void;\n}\n\n\nlet profilerCallback: Profiler|null = null;\n\n/**\n * Sets the callback function which will be invoked before and after performing certain actions at\n * runtime (for example, before and after running change detection).\n *\n * Warning: this function is *INTERNAL* and should not be relied upon in application's code.\n * The contract of the function might be changed in any release and/or the function can be removed\n * completely.\n *\n * @param profiler function provided by the caller or null value to disable profiling.\n */\nexport const setProfiler = (profiler: Profiler|null) => {\n  profilerCallback = profiler;\n};\n\n/**\n * Profiler function which wraps user code executed by the runtime.\n *\n * @param event ProfilerEvent corresponding to the execution context\n * @param instance component instance\n * @param hookOrListener lifecycle hook function or output listener. The value depends on the\n *  execution context\n * @returns\n */\nexport const profiler: Profiler = function(\n    event: ProfilerEvent, instance: {}|null, hookOrListener?: (e?: any) => any) {\n  if (profilerCallback != null /* both `null` and `undefined` */) {\n    profilerCallback(event, instance, hookOrListener);\n  }\n};\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport const SVG_NAMESPACE = 'svg';\nexport const SVG_NAMESPACE_URI = 'http://www.w3.org/2000/svg';\nexport const MATH_ML_NAMESPACE = 'math';\nexport const MATH_ML_NAMESPACE_URI = 'http://www.w3.org/1998/MathML/';\n\nexport function getNamespaceUri(namespace: string): string|null {\n  const name = namespace.toLowerCase();\n  return name === SVG_NAMESPACE ? SVG_NAMESPACE_URI :\n                                  (name === MATH_ML_NAMESPACE ? MATH_ML_NAMESPACE_URI : null);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertGreaterThan, assertGreaterThanOrEqual, assertIndexInRange, assertLessThan} from '../../util/assert';\nimport {assertTNode, assertTNodeForLView} from '../assert';\nimport {LContainer, TYPE} from '../interfaces/container';\nimport {TConstants, TNode} from '../interfaces/node';\nimport {RNode} from '../interfaces/renderer_dom';\nimport {isLContainer, isLView} from '../interfaces/type_checks';\nimport {FLAGS, HEADER_OFFSET, HOST, LView, LViewFlags, PARENT, PREORDER_HOOK_FLAGS, TData, TRANSPLANTED_VIEWS_TO_REFRESH, TView} from '../interfaces/view';\n\n\n\n/**\n * For efficiency reasons we often put several different data types (`RNode`, `LView`, `LContainer`)\n * in same location in `LView`. This is because we don't want to pre-allocate space for it\n * because the storage is sparse. This file contains utilities for dealing with such data types.\n *\n * How do we know what is stored at a given location in `LView`.\n * - `Array.isArray(value) === false` => `RNode` (The normal storage value)\n * - `Array.isArray(value) === true` => then the `value[0]` represents the wrapped value.\n *   - `typeof value[TYPE] === 'object'` => `LView`\n *      - This happens when we have a component at a given location\n *   - `typeof value[TYPE] === true` => `LContainer`\n *      - This happens when we have `LContainer` binding at a given location.\n *\n *\n * NOTE: it is assumed that `Array.isArray` and `typeof` operations are very efficient.\n */\n\n/**\n * Returns `RNode`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nexport function unwrapRNode(value: RNode|LView|LContainer): RNode {\n  while (Array.isArray(value)) {\n    value = value[HOST] as any;\n  }\n  return value as RNode;\n}\n\n/**\n * Returns `LView` or `null` if not found.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nexport function unwrapLView(value: RNode|LView|LContainer): LView|null {\n  while (Array.isArray(value)) {\n    // This check is same as `isLView()` but we don't call at as we don't want to call\n    // `Array.isArray()` twice and give JITer more work for inlining.\n    if (typeof value[TYPE] === 'object') return value as LView;\n    value = value[HOST] as any;\n  }\n  return null;\n}\n\n/**\n * Returns `LContainer` or `null` if not found.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nexport function unwrapLContainer(value: RNode|LView|LContainer): LContainer|null {\n  while (Array.isArray(value)) {\n    // This check is same as `isLContainer()` but we don't call at as we don't want to call\n    // `Array.isArray()` twice and give JITer more work for inlining.\n    if (value[TYPE] === true) return value as LContainer;\n    value = value[HOST] as any;\n  }\n  return null;\n}\n\n/**\n * Retrieves an element value from the provided `viewData`, by unwrapping\n * from any containers, component views, or style contexts.\n */\nexport function getNativeByIndex(index: number, lView: LView): RNode {\n  ngDevMode && assertIndexInRange(lView, index);\n  ngDevMode && assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Expected to be past HEADER_OFFSET');\n  return unwrapRNode(lView[index]);\n}\n\n/**\n * Retrieve an `RNode` for a given `TNode` and `LView`.\n *\n * This function guarantees in dev mode to retrieve a non-null `RNode`.\n *\n * @param tNode\n * @param lView\n */\nexport function getNativeByTNode(tNode: TNode, lView: LView): RNode {\n  ngDevMode && assertTNodeForLView(tNode, lView);\n  ngDevMode && assertIndexInRange(lView, tNode.index);\n  const node: RNode = unwrapRNode(lView[tNode.index]);\n  return node;\n}\n\n/**\n * Retrieve an `RNode` or `null` for a given `TNode` and `LView`.\n *\n * Some `TNode`s don't have associated `RNode`s. For example `Projection`\n *\n * @param tNode\n * @param lView\n */\nexport function getNativeByTNodeOrNull(tNode: TNode|null, lView: LView): RNode|null {\n  const index = tNode === null ? -1 : tNode.index;\n  if (index !== -1) {\n    ngDevMode && assertTNodeForLView(tNode!, lView);\n    const node: RNode|null = unwrapRNode(lView[index]);\n    return node;\n  }\n  return null;\n}\n\n\n// fixme(misko): The return Type should be `TNode|null`\nexport function getTNode(tView: TView, index: number): TNode {\n  ngDevMode && assertGreaterThan(index, -1, 'wrong index for TNode');\n  ngDevMode && assertLessThan(index, tView.data.length, 'wrong index for TNode');\n  const tNode = tView.data[index] as TNode;\n  ngDevMode && tNode !== null && assertTNode(tNode);\n  return tNode;\n}\n\n/** Retrieves a value from any `LView` or `TData`. */\nexport function load<T>(view: LView|TData, index: number): T {\n  ngDevMode && assertIndexInRange(view, index);\n  return view[index];\n}\n\nexport function getComponentLViewByIndex(nodeIndex: number, hostView: LView): LView {\n  // Could be an LView or an LContainer. If LContainer, unwrap to find LView.\n  ngDevMode && assertIndexInRange(hostView, nodeIndex);\n  const slotValue = hostView[nodeIndex];\n  const lView = isLView(slotValue) ? slotValue : slotValue[HOST];\n  return lView;\n}\n\n/** Checks whether a given view is in creation mode */\nexport function isCreationMode(view: LView): boolean {\n  return (view[FLAGS] & LViewFlags.CreationMode) === LViewFlags.CreationMode;\n}\n\n/**\n * Returns a boolean for whether the view is attached to the change detection tree.\n *\n * Note: This determines whether a view should be checked, not whether it's inserted\n * into a container. For that, you'll want `viewAttachedToContainer` below.\n */\nexport function viewAttachedToChangeDetector(view: LView): boolean {\n  return (view[FLAGS] & LViewFlags.Attached) === LViewFlags.Attached;\n}\n\n/** Returns a boolean for whether the view is attached to a container. */\nexport function viewAttachedToContainer(view: LView): boolean {\n  return isLContainer(view[PARENT]);\n}\n\n/** Returns a constant from `TConstants` instance. */\nexport function getConstant<T>(consts: TConstants|null, index: null|undefined): null;\nexport function getConstant<T>(consts: TConstants, index: number): T|null;\nexport function getConstant<T>(consts: TConstants|null, index: number|null|undefined): T|null;\nexport function getConstant<T>(consts: TConstants|null, index: number|null|undefined): T|null {\n  if (index === null || index === undefined) return null;\n  ngDevMode && assertIndexInRange(consts!, index);\n  return consts![index] as unknown as T;\n}\n\n/**\n * Resets the pre-order hook flags of the view.\n * @param lView the LView on which the flags are reset\n */\nexport function resetPreOrderHookFlags(lView: LView) {\n  lView[PREORDER_HOOK_FLAGS] = 0;\n}\n\n/**\n * Updates the `TRANSPLANTED_VIEWS_TO_REFRESH` counter on the `LContainer` as well as the parents\n * whose\n *  1. counter goes from 0 to 1, indicating that there is a new child that has a view to refresh\n *  or\n *  2. counter goes from 1 to 0, indicating there are no more descendant views to refresh\n */\nexport function updateTransplantedViewCount(lContainer: LContainer, amount: 1|- 1) {\n  lContainer[TRANSPLANTED_VIEWS_TO_REFRESH] += amount;\n  let viewOrContainer: LView|LContainer = lContainer;\n  let parent: LView|LContainer|null = lContainer[PARENT];\n  while (parent !== null &&\n         ((amount === 1 && viewOrContainer[TRANSPLANTED_VIEWS_TO_REFRESH] === 1) ||\n          (amount === -1 && viewOrContainer[TRANSPLANTED_VIEWS_TO_REFRESH] === 0))) {\n    parent[TRANSPLANTED_VIEWS_TO_REFRESH] += amount;\n    viewOrContainer = parent;\n    parent = parent[PARENT];\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectFlags} from '../di/interface/injector';\nimport {assertDefined, assertEqual, assertGreaterThanOrEqual, assertLessThan, assertNotEqual, throwError} from '../util/assert';\n\nimport {assertLViewOrUndefined, assertTNodeForLView, assertTNodeForTView} from './assert';\nimport {DirectiveDef} from './interfaces/definition';\nimport {TNode, TNodeType} from './interfaces/node';\nimport {CONTEXT, DECLARATION_VIEW, HEADER_OFFSET, LView, OpaqueViewState, T_HOST, TData, TVIEW, TView, TViewType} from './interfaces/view';\nimport {MATH_ML_NAMESPACE, SVG_NAMESPACE} from './namespaces';\nimport {getTNode} from './util/view_utils';\n\n\n/**\n *\n */\ninterface LFrame {\n  /**\n   * Parent LFrame.\n   *\n   * This is needed when `leaveView` is called to restore the previous state.\n   */\n  parent: LFrame;\n\n  /**\n   * Child LFrame.\n   *\n   * This is used to cache existing LFrames to relieve the memory pressure.\n   */\n  child: LFrame|null;\n\n  /**\n   * State of the current view being processed.\n   *\n   * An array of nodes (text, element, container, etc), pipes, their bindings, and\n   * any local variables that need to be stored between invocations.\n   */\n  lView: LView;\n\n  /**\n   * Current `TView` associated with the `LFrame.lView`.\n   *\n   * One can get `TView` from `lFrame[TVIEW]` however because it is so common it makes sense to\n   * store it in `LFrame` for perf reasons.\n   */\n  tView: TView;\n\n  /**\n   * Used to set the parent property when nodes are created and track query results.\n   *\n   * This is used in conjunction with `isParent`.\n   */\n  currentTNode: TNode|null;\n\n  /**\n   * If `isParent` is:\n   *  - `true`: then `currentTNode` points to a parent node.\n   *  - `false`: then `currentTNode` points to previous node (sibling).\n   */\n  isParent: boolean;\n\n  /**\n   * Index of currently selected element in LView.\n   *\n   * Used by binding instructions. Updated as part of advance instruction.\n   */\n  selectedIndex: number;\n\n  /**\n   * Current pointer to the binding index.\n   */\n  bindingIndex: number;\n\n  /**\n   * The last viewData retrieved by nextContext().\n   * Allows building nextContext() and reference() calls.\n   *\n   * e.g. const inner = x().$implicit; const outer = x().$implicit;\n   */\n  contextLView: LView|null;\n\n  /**\n   * Store the element depth count. This is used to identify the root elements of the template\n   * so that we can then attach patch data `LView` to only those elements. We know that those\n   * are the only places where the patch data could change, this way we will save on number\n   * of places where tha patching occurs.\n   */\n  elementDepthCount: number;\n\n  /**\n   * Current namespace to be used when creating elements\n   */\n  currentNamespace: string|null;\n\n\n  /**\n   * The root index from which pure function instructions should calculate their binding\n   * indices. In component views, this is TView.bindingStartIndex. In a host binding\n   * context, this is the TView.expandoStartIndex + any dirs/hostVars before the given dir.\n   */\n  bindingRootIndex: number;\n\n  /**\n   * Current index of a View or Content Query which needs to be processed next.\n   * We iterate over the list of Queries and increment current query index at every step.\n   */\n  currentQueryIndex: number;\n\n  /**\n   * When host binding is executing this points to the directive index.\n   * `TView.data[currentDirectiveIndex]` is `DirectiveDef`\n   * `LView[currentDirectiveIndex]` is directive instance.\n   */\n  currentDirectiveIndex: number;\n\n  /**\n   * Are we currently in i18