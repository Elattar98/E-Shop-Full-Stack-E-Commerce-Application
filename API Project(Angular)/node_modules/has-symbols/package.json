endCount = 0;
    } else {
      this._str += str;
    }

    if (!maybeNewline && !this._map) {
      this._position.column += len;
      return;
    }

    const {
      column,
      identifierName,
      filename
    } = sourcePos;
    let line = sourcePos.line;
    let i = str.indexOf("\n");
    let last = 0;

    if (i !== 0) {
      this._mark(line, column, identifierName, filename);
    }

    while (i !== -1) {
      this._position.line++;
      this._position.column = 0;
      last = i + 1;

      if (last < str.length) {
        this._mark(++line, 0, identifierName, filename);
      }

      i = str.indexOf("\n", last);
    }

    this._position.column += str.length - last;
  }

  _mark(line, column, identifierName, filename) {
    var _this$_map;

    (_this$_map = this._map) == null ? void 0 : _this$_map.mark(this._position, line, column, identifierName, filename);
  }

  removeTrailingNewline() {
    const queueCursor = this._queueCursor;

    if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 10) {
      this._queueCursor--;
    }
  }

  removeLastSemicolon() {
    const queueCursor = this._queueCursor;

    if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 59) {
      this._queueCursor--;
    }
  }

  getLastChar() {
    const queueCursor = this._queueCursor;
    return queueCursor !== 0 ? this._queue[queueCursor - 1].char : this._last;
  }

  endsWithCharAndNewline() {
    const queue = this._queue;
    const queueCursor = this._queueCursor;

    if (queueCursor !== 0) {
      const lastCp = queue[queueCursor - 1].char;
      if (lastCp !== 10) return;

      if (queueCursor > 1) {
        return queue[queueCursor - 2].char;
      } else {
        return this._last;
      }
    }
  }

  hasContent() {
    return this._queueCursor !== 0 || !!this._last;
  }

  exactSource(loc, cb) {
    if (!this._map) return cb();
    this.source("start", loc);
    cb();
    this.source("end", loc);

    this._disallowPop("start", loc);
  }

  source(prop, loc) {
    if (!loc) return;

    this._normalizePosition(prop, loc, this._sourcePosition);
  }

  withSource(prop, loc, cb) {
    if (!this._map) return cb();
    const originalLine = this._sourcePosition.line;
    const originalColumn = this._sourcePosition.column;
    const originalFilename = this._sourcePosition.filename;
    const originalIdentifierName = this._sourcePosition.identifierName;
    this.source(prop, loc);
    cb();

    if (this._disallowedPop.objectReusable || this._disallowedPop.line !== originalLine || this._disallowedPop.column !== originalColumn || this._disallowedPop.filename !== originalFilename) {
