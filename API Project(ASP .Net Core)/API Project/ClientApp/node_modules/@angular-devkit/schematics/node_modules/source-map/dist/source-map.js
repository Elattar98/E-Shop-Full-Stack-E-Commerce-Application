lse {
                var type = parseTypeAnnotation();
                node = factory.createPropertySignature(modifiers, name, questionToken, type);
                // Although type literal properties cannot not have initializers, we attempt
                // to parse an initializer so we can report in the checker that an interface
                // property or type literal property cannot have an initializer.
                if (token() === 63 /* SyntaxKind.EqualsToken */)
                    node.initializer = parseInitializer();
            }
            parseTypeMemberSemicolon();
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function isTypeMemberStart() {
            // Return true if we have the start of a signature member
            if (token() === 20 /* SyntaxKind.OpenParenToken */ ||
                token() === 29 /* SyntaxKind.LessThanToken */ ||
                token() === 136 /* SyntaxKind.GetKeyword */ ||
                token() === 149 /* SyntaxKind.SetKeyword */) {
                return true;
            }
            var idToken = false;
            // Eat up all modifiers, but hold on to the last one in case it is actually an identifier
            while (ts.isModifierKind(token())) {
                idToken = true;
                nextToken();
            }
            // Index signatures and computed property names are type members
            if (token() === 22 /* SyntaxKind.OpenBracketToken */) {
                return true;
            }
            // Try to get the first property-like token following all modifiers
            if (isLiteralPropertyName()) {
                idToken = true;
                nextToken();
            }
            // If we were able to get any potential identifier, check that it is
            // the start of a member declaration
            if (idToken) {
                return token() === 20 /* SyntaxKind.OpenParenToken */ ||
                    token() === 29 /* SyntaxKind.LessThanToken */ ||
                    token() === 57 /* SyntaxKind.QuestionToken */ ||
                    token() === 58 /* SyntaxKind.ColonToken */ ||
                    token() === 27 /* SyntaxKind.CommaToken */ ||
                    canParseSemicolon();
            }
            return false;
        }
        function parseTypeMember() {
            if (token() === 20 /* SyntaxKind.OpenParenToken */ || token() === 29 /* SyntaxKind.LessThanToken */) {
                return parseSignatureMember(174 /* SyntaxKind.CallSignature */);
            }
            if (token() === 103 /* SyntaxKind.NewKeyword */ && lookAhead(nextTokenIsOpenParenOrLessThan)) {
                return parseSignatureMember(175 /* SyntaxKind.ConstructSignature */);
            }
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            var modifiers = parseModifiers();
            if (parseContextualModifier(136 /* SyntaxKind.GetKeyword */)) {
                return parseAccessorDeclaration(pos, hasJSDoc, /*decorators*/ undefined, modifiers, 172 /* SyntaxKind.GetAccessor */);
            }
            if (parseContextualModifier(149 /* SyntaxKind.SetKeyword */)) {
                return parseAccessorDeclaration(pos, hasJSDoc, /*decorators*/ undefined, modifiers, 173 /* SyntaxKind.SetAccessor */);
            }
            if (isIndexSignature()) {
                return parseIndexSignatureDeclaration(pos, hasJSDoc, /*decorators*/ undefined, modifiers);
            }
            return parsePropertyOrMethodSignature(pos, hasJSDoc, modifiers);
        }
        function nextTokenIsOpenParenOrLessThan() {
            nextToken();
            return token() === 20 /* SyntaxKind.OpenParenToken */ || token() === 29 /* SyntaxKind.LessThanToken */;
        }
        function nextTokenIsDot() {
            return nextToken() === 24 /* SyntaxKind.DotToken */;
        }
        function nextTokenIsOpenParenOrLessThanOrDot() {
            switch (nextToken()) {
                case 20 /* SyntaxKind.OpenParenToken */:
                case 29 /* SyntaxKind.LessThanToken */:
                case 24 /* SyntaxKind.DotToken */:
                    return true;
            }
            return false;
        }
        function parseTypeLiteral() {
            var pos = getNodePos();
            return finishNode(factory.createTypeLiteralNode(parseObjectTypeMembers()), pos);
        }
        function parseObjectTypeMembers() {
            var members;
            if (parseExpected(18 /* SyntaxKind.OpenBraceToken */)) {
                members = parseList(4 /* ParsingContext.TypeMembers */, parseTypeMember);
                parseExpected(19 /* SyntaxKind.CloseBraceToken */);
            }
            else {
                members = createMissingList();
            }
            return members;
        }
        function isStartOfMappedType() {
            nextToken();
            if (token() === 39 /* SyntaxKind.PlusToken */ || token() === 40 /* SyntaxKind.MinusToken */) {
                return nextToken() === 145 /* SyntaxKind.ReadonlyKeyword */;
            }
            if (token() === 145 /* SyntaxKind.ReadonlyKeyword */) {
                nextToken();
            }
            return token() === 22 /* SyntaxKind.OpenBracketToken */ && nextTokenIsIdentifier() && nextToken() === 101 /* SyntaxKind.InKeyword */;
        }
        function parseMappedTypeParameter() {
            var pos = getNodePos();
            var name = parseIdentifierName();
            parseExpected(101 /* SyntaxKind.InKeyword */);
            var type = parseType();
            return finishNode(factory.createTypeParameterDeclaration(/*modifiers*/ undefined, name, type, /*defaultType*/ undefined), pos);
        }
        function parseMappedType() {
            var pos = getNodePos();
            parseExpected(18 /* SyntaxKind.OpenBraceToken */);
            var readonlyToken;
            if (token() === 145 /* SyntaxKind.ReadonlyKeyword */ || token() === 39 /* SyntaxKind.PlusToken */ || token() === 40 /* SyntaxKind.MinusToken */) {
                readonlyToken = parseTokenNode();
                if (readonlyToken.kind !== 145 /* SyntaxKind.ReadonlyKeyword */) {
                    parseExpected(145 /* SyntaxKind.ReadonlyKeyword */);
                }
            }
            parseExpected(22 /* SyntaxKind.OpenBracketToken */);
            var typeParameter = parseMappedTypeParameter();
            var nameType = parseOptional(127 /* SyntaxKind.AsKeyword */) ? parseType() : undefined;
            parseExpected(23 /* SyntaxKind.CloseBracketToken */);
            var questionToken;
            if (token() === 57 /* SyntaxKind.QuestionToken */ || token() === 39 /* SyntaxKind.PlusToken */ || token() === 40 /* SyntaxKind.MinusToken */) {
                questionToken = parseTokenNode();
                if (questionToken.kind !== 57 /* SyntaxKind.QuestionToken */) {
                    parseExpected(57 /* SyntaxKind.QuestionToken */);
                }
            }
            var type = parseTypeAnnotation();
            parseSemicolon();
            var members = parseList(4 /* ParsingContext.TypeMembers */, parseTypeMember);
            parseExpected(19 /* SyntaxKind.CloseBraceToken */);
            return finishNode(factory.createMappedTypeNode(readonlyToken, typeParameter, nameType, questionToken, type, members), pos);
        }
        function parseTupleElementType() {
            var pos = getNodePos();
            if (parseOptional(25 /* SyntaxKind.DotDotDotToken */)) {
                return finishNode(factory.createRestTypeNode(parseType()), pos);
            }
            var type = parseType();
            if (ts.isJSDocNullableType(type) && type.pos === type.type.pos) {
                var node = factory.createOptionalTypeNode(type.type);
                ts.setTextRange(node, type);
                node.flags = type.flags;
                return node;
            }
            return type;
        }
        function isNextTokenColonOrQuestionColon() {
            return nextToken() === 58 /* SyntaxKind.ColonToken */ || (token() === 57 /* SyntaxKind.QuestionToken */ && nextToken() === 58 /* SyntaxKind.ColonToken */);
        }
        function isTupleElementName() {
            if (token() === 25 /* SyntaxKind.DotDotDotToken */) {
                return ts.tokenIsIdentifierOrKeyword(nextToken()) && isNextTokenColonOrQuestionColon();
            }
            return ts.tokenIsIdentifierOrKeyword(token()) && isNextTokenColonOrQuestionColon();
        }
        function parseTupleElementNameOrTupleElementType() {
            if (lookAhead(isTupleElementName)) {
                var pos = getNodePos();
                var hasJSDoc = hasPrecedingJSDocComment();
                var dotDotDotToken = parseOptionalToken(25 /* SyntaxKind.DotDotDotToken */);
                var name = parseIdentifierName();
                var questionToken = parseOptionalToken(57 /* SyntaxKind.QuestionToken */);
                parseExpected(58 /* SyntaxKind.ColonToken */);
                var type = parseTupleElementType();
                var node = factory.createNamedTupleMember(dotDotDotToken, name, questionToken, type);
                return withJSDoc(finishNode(node, pos), hasJSDoc);
            }
            return parseTupleElementType();
        }
        function parseTupleType() {
            var pos = getNodePos();
            return finishNode(factory.createTupleTypeNode(parseBracketedList(21 /* ParsingContext.TupleElementTypes */, parseTupleElementNameOrTupleElementType, 22 /* SyntaxKind.OpenBracketToken */, 23 /* SyntaxKind.CloseBracketToken */)), pos);
        }
        function parseParenthesizedType() {
            var pos = getNodePos();
            parseExpected(20 /* SyntaxKind.OpenParenToken */);
            var type = parseType();
            parseExpected(21 /* SyntaxKind.CloseParenToken */);
            return finishNode(factory.createParenthesizedType(type), pos);
        }
        function parseModifiersForConstructorType() {
            var modifiers;
            if (token() === 126 /* SyntaxKind.AbstractKeyword */) {
                var pos = getNodePos();
                nextToken();
                var modifier = finishNode(factory.createToken(126 /* SyntaxKind.AbstractKeyword */), pos);
                modifiers = createNodeArray([modifier], pos);
            }
            return modifiers;
        }
        function parseFunctionOrConstructorType() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            var modifiers = parseModifiersForConstructorType();
            var isConstructorType = parseOptional(103 /* SyntaxKind.NewKeyword */);
            var typeParameters = parseTypeParameters();
            var parameters = parseParameters(4 /* SignatureFlags.Type */);
            var type = parseReturnType(38 /* SyntaxKind.EqualsGreaterThanToken */, /*isType*/ false);
            var node = isConstructorType
                ? factory.createConstructorTypeNode(modifiers, typeParameters, parameters, type)
                : factory.createFunctionTypeNode(typeParameters, parameters, type);
            if (!isConstructorType)
                node.modifiers = modifiers;
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseKeywordAndNoDot() {
            var node = parseTokenNode();
            return token() === 24 /* SyntaxKind.DotToken */ ? undefined : node;
        }
        function parseLiteralTypeNode(negative) {
            var pos = getNodePos();
            if (negative) {
                nextToken();
            }
            var expression = token() === 110 /* SyntaxKind.TrueKeyword */ || token() === 95 /* SyntaxKind.FalseKeyword */ || token() === 104 /* SyntaxKind.NullKeyword */ ?
                parseTokenNode() :
                parseLiteralLikeNode(token());
            if (negative) {
                expression = finishNode(factory.createPrefixUnaryExpression(40 /* SyntaxKind.MinusToken */, expression), pos);
            }
            return finishNode(factory.createLiteralTypeNode(expression), pos);
        }
        function isStartOfTypeOfImportType() {
            nextToken();
            return token() === 100 /* SyntaxKind.ImportKeyword */;
        }
        function parseImportTypeAssertions() {
            var pos = getNodePos();
            var openBracePosition = scanner.getTokenPos();
            parseExpected(18 /* SyntaxKind.OpenBraceToken */);
            var multiLine = scanner.hasPrecedingLineBreak();
            parseExpected(129 /* SyntaxKind.AssertKeyword */);
            parseExpected(58 /* SyntaxKind.ColonToken */);
            var clause = parseAssertClause(/*skipAssertKeyword*/ true);
            if (!parseExpected(19 /* SyntaxKind.CloseBraceToken */)) {
                var lastError = ts.lastOrUndefined(parseDiagnostics);
                if (lastError && lastError.code === ts.Diagnostics._0_expected.code) {
                    ts.addRelatedInfo(lastError, ts.createDetachedDiagnostic(fileName, openBracePosition, 1, ts.Diagnostics.The_parser_expected_to_find_a_1_to_match_the_0_token_here, "{", "}"));
                }
            }
            return finishNode(factory.createImportTypeAssertionContainer(clause, multiLine), pos);
        }
        function parseImportType() {
            sourceFlags |= 2097152 /* NodeFlags.PossiblyContainsDynamicImport */;
            var pos = getNodePos();
            var isTypeOf = parseOptional(112 /* SyntaxKind.TypeOfKeyword */);
            parseExpected(100 /* SyntaxKind.ImportKeyword */);
            parseExpected(20 /* SyntaxKind.OpenParenToken */);
            var type = parseType();
            var assertions;
            if (parseOptional(27 /* SyntaxKind.CommaToken */)) {
                assertions = parseImportTypeAssertions();
            }
            parseExpected(21 /* SyntaxKind.CloseParenToken */);
            var qualifier = parseOptional(24 /* SyntaxKind.DotToken */) ? parseEntityNameOfTypeReference() : undefined;
            var typeArguments = parseTypeArgumentsOfTypeReference();
            return finishNode(factory.createImportTypeNode(type, assertions, qualifier, typeArguments, isTypeOf), pos);
        }
        function nextTokenIsNumericOrBigIntLiteral() {
            nextToken();
            return token() === 8 /* SyntaxKind.NumericLiteral */ || token() === 9 /* SyntaxKind.BigIntLiteral */;
        }
        function parseNonArrayType() {
            switch (token()) {
                case 130 /* SyntaxKind.AnyKeyword */:
                case 155 /* SyntaxKind.UnknownKeyword */:
                case 150 /* SyntaxKind.StringKeyword */:
                case 147 /* SyntaxKind.NumberKeyword */:
                case 158 /* SyntaxKind.BigIntKeyword */:
                case 151 /* SyntaxKind.SymbolKeyword */:
                case 133 /* SyntaxKind.BooleanKeyword */:
                case 153 /* SyntaxKind.UndefinedKeyword */:
                case 143 /* SyntaxKind.NeverKeyword */:
                case 148 /* SyntaxKind.ObjectKeyword */:
                    // If these are followed by a dot, then parse these out as a dotted type reference instead.
                    return tryParse(parseKeywordAndNoDot) || parseTypeReference();
                case 66 /* SyntaxKind.AsteriskEqualsToken */:
                    // If there is '*=', treat it as * followed by postfix =
                    scanner.reScanAsteriskEqualsToken();
                // falls through
                case 41 /* SyntaxKind.AsteriskToken */:
                    return parseJSDocAllType();
                case 60 /* SyntaxKind.QuestionQuestionToken */:
                    // If there is '??', treat it as prefix-'?' in JSDoc type.
                    scanner.reScanQuestionToken();
                // falls through
                case 57 /* SyntaxKind.QuestionToken */:
                    return parseJSDocUnknownOrNullableType();
                case 98 /* SyntaxKind.FunctionKeyword */:
                    return parseJSDocFunctionType();
                case 53 /* SyntaxKind.ExclamationToken */:
                    return parseJSDocNonNullableType();
                case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
                case 10 /* SyntaxKind.StringLiteral */:
                case 8 /* SyntaxKind.NumericLiteral */:
                case 9 /* SyntaxKind.BigIntLiteral */:
                case 110 /* SyntaxKind.TrueKeyword */:
                case 95 /* SyntaxKind.FalseKeyword */:
                case 104 /* SyntaxKind.NullKeyword */:
                    return parseLiteralTypeNode();
                case 40 /* SyntaxKind.MinusToken */:
                    return lookAhead(nextTokenIsNumericOrBigIntLiteral) ? parseLiteralTypeNode(/*negative*/ true) : parseTypeReference();
                case 114 /* SyntaxKind.VoidKeyword */:
                    return parseTokenNode();
                case 108 /* SyntaxKind.ThisKeyword */: {
                    var thisKeyword = parseThisTypeNode();
                    if (token() === 139 /* SyntaxKind.IsKeyword */ && !scanner.hasPrecedingLineBreak()) {
                        return parseThisTypePredicate(thisKeyword);
                    }
                    else {
                        return thisKeyword;
                    }
                }
                case 112 /* SyntaxKind.TypeOfKeyword */:
                    return lookAhead(isStartOfTypeOfImportType) ? parseImportType() : parseTypeQuery();
                case 18 /* SyntaxKind.OpenBraceToken */:
                    return lookAhead(isStartOfMappedType) ? parseMappedType() : parseTypeLiteral();
                case 22 /* SyntaxKind.OpenBracketToken */:
                    return parseTupleType();
                case 20 /* SyntaxKind.OpenParenToken */:
                    return parseParenthesizedType();
                case 100 /* SyntaxKind.ImportKeyword */:
                    return parseImportType();
                case 128 /* SyntaxKind.AssertsKeyword */:
                    return lookAhead(nextTokenIsIdentifierOrKeywordOnSameLine) ? parseAssertsTypePredicate() : parseTypeReference();
                case 15 /* SyntaxKind.TemplateHead */:
                    return parseTemplateType();
                default:
                    return parseTypeReference();
            }
        }
        function isStartOfType(inStartOfParameter) {
            switch (token()) {
                case 130 /* SyntaxKind.AnyKeyword */:
                case 155 /* SyntaxKind.UnknownKeyword */:
                case 150 /* SyntaxKind.StringKeyword */:
                case 147 /* SyntaxKind.NumberKeyword */:
                case 158 /* SyntaxKind.BigIntKeyword */:
                case 133 /* SyntaxKind.BooleanKeyword */:
                case 145 /* SyntaxKind.ReadonlyKeyword */:
                case 151 /* SyntaxKind.SymbolKeyword */:
                case 154 /* SyntaxKind.UniqueKeyword */:
                case 114 /* SyntaxKind.VoidKeyword */:
                case 153 /* SyntaxKind.UndefinedKeyword */:
                case 104 /* SyntaxKind.NullKeyword */:
                case 108 /* SyntaxKind.ThisKeyword */:
                case 112 /* SyntaxKind.TypeOfKeyword */:
                case 143 /* SyntaxKind.NeverKeyword */:
                case 18 /* SyntaxKind.OpenBraceToken */:
                case 22 /* SyntaxKind.OpenBracketToken */:
                case 29 /* SyntaxKind.LessThanToken */:
                case 51 /* SyntaxKind.BarToken */:
                case 50 /* SyntaxKind.AmpersandToken */:
                case 103 /* SyntaxKind.NewKeyword */:
                case 10 /* SyntaxKind.StringLiteral */:
                case 8 /* SyntaxKind.NumericLiteral */:
                case 9 /* SyntaxKind.BigIntLiteral */:
                case 110 /* SyntaxKind.TrueKeyword */:
                case 95 /* SyntaxKind.FalseKeyword */:
                case 148 /* SyntaxKind.ObjectKeyword */:
                case 41 /* SyntaxKind.AsteriskToken */:
                case 57 /* SyntaxKind.QuestionToken */:
                case 53 /* SyntaxKind.ExclamationToken */:
                case 25 /* SyntaxKind.DotDotDotToken */:
                case 137 /* SyntaxKind.InferKeyword */:
                case 100 /* SyntaxKind.ImportKeyword */:
                case 128 /* SyntaxKind.AssertsKeyword */:
                case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
                case 15 /* SyntaxKind.TemplateHead */:
                    return true;
                case 98 /* SyntaxKind.FunctionKeyword */:
                    return !inStartOfParameter;
                case 40 /* SyntaxKind.MinusToken */:
                    return !inStartOfParameter && lookAhead(nextTokenIsNumericOrBigIntLiteral);
                case 20 /* SyntaxKind.OpenParenToken */:
                    // Only consider '(' the start of a type if followed by ')', '...', an identifier, a modifier,
                    // or something that starts a type. We don't want to consider things like '(1)' a type.
                    return !inStartOfParameter && lookAhead(isStartOfParenthesizedOrFunctionType);
                default:
                    return isIdentifier();
            }
        }
        function isStartOfParenthesizedOrFunctionType() {
            nextToken();
            return token() === 21 /* SyntaxKind.CloseParenToken */ || isStartOfParameter(/*isJSDocParameter*/ false) || isStartOfType();
        }
        function parsePostfixTypeOrHigher() {
            var pos = getNodePos();
            var type = parseNonArrayType();
            while (!scanner.hasPrecedingLineBreak()) {
                switch (token()) {
                    case 53 /* SyntaxKind.ExclamationToken */:
                        nextToken();
                        type = finishNode(factory.createJSDocNonNullableType(type, /*postfix*/ true), pos);
                        break;
                    case 57 /* SyntaxKind.QuestionToken */:
                        // If next token is start of a type we have a conditional type
                        if (lookAhead(nextTokenIsStartOfType)) {
                            return type;
                        }
                        nextToken();
                        type = finishNode(factory.createJSDocNullableType(type, /*postfix*/ true), pos);
                        break;
                    case 22 /* SyntaxKind.OpenBracketToken */:
                        parseExpected(22 /* SyntaxKind.OpenBracketToken */);
                        if (isStartOfType()) {
                            var indexType = parseType();
                            parseExpected(23 /* SyntaxKind.CloseBracketToken */);
                            type = finishNode(factory.createIndexedAccessTypeNode(type, indexType), pos);
                        }
                        else {
                            parseExpected(23 /* SyntaxKind.CloseBracketToken */);
                            type = finishNode(factory.createArrayTypeNode(type), pos);
                        }
                        break;
                    default:
                        return type;
                }
            }
            return type;
        }
        function parseTypeOperator(operator) {
            var pos = getNodePos();
            parseExpected(operator);
            return finishNode(factory.createTypeOperatorNode(operator, parseTypeOperatorOrHigher()), pos);
        }
        function tryParseConstraintOfInferType() {
            if (parseOptional(94 /* SyntaxKind.ExtendsKeyword */)) {
                var constraint = disallowConditionalTypesAnd(parseType);
                if (inDisallowConditionalTypesContext() || token() !== 57 /* SyntaxKind.QuestionToken */) {
                    return constraint;
                }
            }
        }
        function parseTypeParameterOfInferType() {
            var pos = getNodePos();
            var name = parseIdentifier();
            var constraint = tryParse(tryParseConstraintOfInferType);
            var node = factory.createTypeParameterDeclaration(/*modifiers*/ undefined, name, constraint);
            return finishNode(node, pos);
        }
        function parseInferType() {
            var pos = getNodePos();
            parseExpected(137 /* SyntaxKind.InferKeyword */);
            return finishNode(factory.createInferTypeNode(parseTypeParameterOfInferType()), pos);
        }
        function parseTypeOperatorOrHigher() {
            var operator = token();
            switch (operator) {
                case 140 /* SyntaxKind.KeyOfKeyword */:
                case 154 /* SyntaxKind.UniqueKeyword */:
                case 145 /* SyntaxKind.ReadonlyKeyword */:
                    return parseTypeOperator(operator);
                case 137 /* SyntaxKind.InferKeyword */:
                    return parseInferType();
            }
            return allowConditionalTypesAnd(parsePostfixTypeOrHigher);
        }
        function parseFunctionOrConstructorTypeToError(isInUnionType) {
            // the function type and constructor type shorthand notation
            // are not allowed directly in unions and intersections, but we'll
            // try to parse them gracefully and issue a helpful message.
            if (isStartOfFunctionTypeOrConstructorType()) {
                var type = parseFunctionOrConstructorType();
                var diagnostic = void 0;
                if (ts.isFunctionTypeNode(type)) {
                    diagnostic = isInUnionType
                        ? ts.Diagnostics.Function_type_notation_must_be_parenthesized_when_used_in_a_union_type
                        : ts.Diagnostics.Function_type_notation_must_be_parenthesized_when_used_in_an_intersection_type;
                }
                else {
                    diagnostic = isInUnionType
                        ? ts.Diagnostics.Constructor_type_notation_must_be_parenthesized_when_used_in_a_union_type
                        : ts.Diagnostics.Constructor_type_notation_must_be_parenthesized_when_used_in_an_intersection_type;
                }
                parseErrorAtRange(type, diagnostic);
                return type;
            }
            return undefined;
        }
        function parseUnionOrIntersectionType(operator, parseConstituentType, createTypeNode) {
            var pos = getNodePos();
            var isUnionType = operator === 51 /* SyntaxKind.BarToken */;
            var hasLeadingOperator = parseOptional(operator);
            var type = hasLeadingOperator && parseFunctionOrConstructorTypeToError(isUnionType)
                || parseConstituentType();
            if (token() === operator || hasLeadingOperator) {
                var types = [type];
                while (parseOptional(operator)) {
                    types.push(parseFunctionOrConstructorTypeToError(isUnionType) || parseConstituentType());
                }
                type = finishNode(createTypeNode(createNodeArray(types, pos)), pos);
            }
            return type;
        }
        function parseIntersectionTypeOrHigher() {
            return parseUnionOrIntersectionType(50 /* SyntaxKind.AmpersandToken */, parseTypeOperatorOrHigher, factory.createIntersectionTypeNode);
        }
        function parseUnionTypeOrHigher() {
            return parseUnionOrIntersectionType(51 /* SyntaxKind.BarToken */, parseIntersectionTypeOrHigher, factory.createUnionTypeNode);
        }
        function nextTokenIsNewKeyword() {
            nextToken();
            return token() === 103 /* SyntaxKind.NewKeyword */;
        }
        function isStartOfFunctionTypeOrConstructorType() {
            if (token() === 29 /* SyntaxKind.LessThanToken */) {
                return true;
            }
            if (token() === 20 /* SyntaxKind.OpenParenToken */ && lookAhead(isUnambiguouslyStartOfFunctionType)) {
                return true;
            }
            return token() === 103 /* SyntaxKind.NewKeyword */ ||
                token() === 126 /* SyntaxKind.AbstractKeyword */ && lookAhead(nextTokenIsNewKeyword);
        }
        function skipParameterStart() {
            if (ts.isModifierKind(token())) {
                // Skip modifiers
                parseModifiers();
            }
            if (isIdentifier() || token() === 108 /* SyntaxKind.ThisKeyword */) {
                nextToken();
                return true;
            }
            if (token() === 22 /* SyntaxKind.OpenBracketToken */ || token() === 18 /* SyntaxKind.OpenBraceToken */) {
                // Return true if we can parse an array or object binding pattern with no errors
                var previousErrorCount = parseDiagnostics.length;
                parseIdentifierOrPattern();
                return previousErrorCount === parseDiagnostics.length;
            }
            return false;
        }
        function isUnambiguouslyStartOfFunctionType() {
            nextToken();
            if (token() === 21 /* SyntaxKind.CloseParenToken */ || token() === 25 /* SyntaxKind.DotDotDotToken */) {
                // ( )
                // ( ...
                return true;
            }
            if (skipParameterStart()) {
                // We successfully skipped modifiers (if any) and an identifier or binding pattern,
                // now see if we have something that indicates a parameter declaration
                if (token() === 58 /* SyntaxKind.ColonToken */ || token() === 27 /* SyntaxKind.CommaToken */ ||
                    token() === 57 /* SyntaxKind.QuestionToken */ || token() === 63 /* SyntaxKind.EqualsToken */) {
                    // ( xxx :
                    // ( xxx ,
                    // ( xxx ?
                    // ( xxx =
                    return true;
                }
                if (token() === 21 /* SyntaxKind.CloseParenToken */) {
                    nextToken();
                    if (token() === 38 /* SyntaxKind.EqualsGreaterThanToken */) {
                        // ( xxx ) =>
                        return true;
                    }
                }
            }
            return false;
        }
        function parseTypeOrTypePredicate() {
            var pos = getNodePos();
            var typePredicateVariable = isIdentifier() && tryParse(parseTypePredicatePrefix);
            var type = parseType();
            if (typePredicateVariable) {
                return finishNode(factory.createTypePredicateNode(/*assertsModifier*/ undefined, typePredicateVariable, type), pos);
            }
            else {
                return type;
            }
        }
        function parseTypePredicatePrefix() {
            var id = parseIdentifier();
            if (token() === 139 /* SyntaxKind.IsKeyword */ && !scanner.hasPrecedingLineBreak()) {
                nextToken();
                return id;
            }
        }
        function parseAssertsTypePredicate() {
            var pos = getNodePos();
            var assertsModifier = parseExpectedToken(128 /* SyntaxKind.AssertsKeyword */);
            var parameterName = token() === 108 /* SyntaxKind.ThisKeyword */ ? parseThisTypeNode() : parseIdentifier();
            var type = parseOptional(139 /* SyntaxKind.IsKeyword */) ? parseType() : undefined;
            return finishNode(factory.createTypePredicateNode(assertsModifier, parameterName, type), pos);
        }
        function parseType() {
            if (contextFlags & 40960 /* NodeFlags.TypeExcludesFlags */) {
                return doOutsideOfContext(40960 /* NodeFlags.TypeExcludesFlags */, parseType);
            }
            if (isStartOfFunctionTypeOrConstructorType()) {
                return parseFunctionOrConstructorType();
            }
            var pos = getNodePos();
            var type = parseUnionTypeOrHigher();
            if (!inDisallowConditionalTypesContext() && !scanner.hasPrecedingLineBreak() && parseOptional(94 /* SyntaxKind.ExtendsKeyword */)) {
                // The type following 'extends' is not permitted to be another conditional type
                var extendsType = disallowConditionalTypesAnd(parseType);
                parseExpected(57 /* SyntaxKind.QuestionToken */);
                var trueType = allowConditionalTypesAnd(parseType);
                parseExpected(58 /* SyntaxKind.ColonToken */);
                var falseType = allowConditionalTypesAnd(parseType);
                return finishNode(factory.createConditionalTypeNode(type, extendsType, trueType, falseType), pos);
            }
            return type;
        }
        function parseTypeAnnotation() {
            return parseOptional(58 /* SyntaxKind.ColonToken */) ? parseType() : undefined;
        }
        // EXPRESSIONS
        function isStartOfLeftHandSideExpression() {
            switch (token()) {
                case 108 /* SyntaxKind.ThisKeyword */:
                case 106 /* SyntaxKind.SuperKeyword */:
                case 104 /* SyntaxKind.NullKeyword */:
                case 110 /* SyntaxKind.TrueKeyword */:
                case 95 /* SyntaxKind.FalseKeyword */:
                case 8 /* SyntaxKind.NumericLiteral */:
                case 9 /* SyntaxKind.BigIntLiteral */:
                case 10 /* SyntaxKind.StringLiteral */:
                case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
                case 15 /* SyntaxKind.TemplateHead */:
                case 20 /* SyntaxKind.OpenParenToken */:
                case 22 /* SyntaxKind.OpenBracketToken */:
                case 18 /* SyntaxKind.OpenBraceToken */:
                case 98 /* SyntaxKind.FunctionKeyword */:
                case 84 /* SyntaxKind.ClassKeyword */:
                case 103 /* SyntaxKind.NewKeyword */:
                case 43 /* SyntaxKind.SlashToken */:
                case 68 /* SyntaxKind.SlashEqualsToken */:
                case 79 /* SyntaxKind.Identifier */:
                    return true;
                case 100 /* SyntaxKind.ImportKeyword */:
                    return lookAhead(nextTokenIsOpenParenOrLessThanOrDot);
                default:
                    return isIdentifier();
            }
        }
        function isStartOfExpression() {
            if (isStartOfLeftHandSideExpression()) {
                return true;
            }
            switch (token()) {
                case 39 /* SyntaxKind.PlusToken */:
                case 40 /* SyntaxKind.MinusToken */:
                case 54 /* SyntaxKind.TildeToken */:
                case 53 /* SyntaxKind.ExclamationToken */:
                case 89 /* SyntaxKind.DeleteKeyword */:
                case 112 /* SyntaxKind.TypeOfKeyword */:
                case 114 /* SyntaxKind.VoidKeyword */:
                case 45 /* SyntaxKind.PlusPlusToken */:
                case 46 /* SyntaxKind.MinusMinusToken */:
                case 29 /* SyntaxKind.LessThanToken */:
                case 132 /* SyntaxKind.AwaitKeyword */:
                case 125 /* SyntaxKind.YieldKeyword */:
                case 80 /* SyntaxKind.PrivateIdentifier */:
                    // Yield/await always starts an expression.  Either it is an identifier (in which case
                    // it is definitely an expression).  Or it's a keyword (either because we're in
                    // a generator or async function, or in strict mode (or both)) and it started a yield or await expression.
                    return true;
                default:
                    // Error tolerance.  If we see the start of some binary operator, we consider
                    // that the start of an expression.  That way we'll parse out a missing identifier,
                    // give a good message about an identifier being missing, and then consume the
                    // rest of the binary expression.
                    if (isBinaryOperator()) {
                        return true;
                    }
                    return isIdentifier();
            }
        }
        function isStartOfExpressionStatement() {
            // As per the grammar, none of '{' or 'function' or 'class' can start an expression statement.
            return token() !== 18 /* SyntaxKind.OpenBraceToken */ &&
                token() !== 98 /* SyntaxKind.FunctionKeyword */ &&
                token() !== 84 /* SyntaxKind.ClassKeyword */ &&
                token() !== 59 /* SyntaxKind.AtToken */ &&
                isStartOfExpression();
        }
        function parseExpression() {
            // Expression[in]:
            //      AssignmentExpression[in]
            //      Expression[in] , AssignmentExpression[in]
            // clear the decorator context when parsing Expression, as it should be unambiguous when parsing a decorator
            var saveDecoratorContext = inDecoratorContext();
            if (saveDecoratorContext) {
                setDecoratorContext(/*val*/ false);
            }
            var pos = getNodePos();
            var expr = parseAssignmentExpressionOrHigher();
            var operatorToken;
            while ((operatorToken = parseOptionalToken(27 /* SyntaxKind.CommaToken */))) {
                expr = makeBinaryExpression(expr, operatorToken, parseAssignmentExpressionOrHigher(), pos);
            }
            if (saveDecoratorContext) {
                setDecoratorContext(/*val*/ true);
            }
            return expr;
        }
        function parseInitializer() {
            return parseOptional(63 /* SyntaxKind.EqualsToken */) ? parseAssignmentExpressionOrHigher() : undefined;
        }
        function parseAssignmentExpressionOrHigher() {
            //  AssignmentExpression[in,yield]:
            //      1) ConditionalExpression[?in,?yield]
            //      2) LeftHandSideExpression = AssignmentExpression[?in,?yield]
            //      3) LeftHandSideExpression AssignmentOperator AssignmentExpression[?in,?yield]
            //      4) ArrowFunctionExpression[?in,?yield]
            //      5) AsyncArrowFunctionExpression[in,yield,await]
            //      6) [+Yield] YieldExpression[?In]
            //
            // Note: for ease of implementation we treat productions '2' and '3' as the same thing.
            // (i.e. they're both BinaryExpressions with an assignment operator in it).
            // First, do the simple check if we have a YieldExpression (production '6').
            if (isYieldExpression()) {
                return parseYieldExpression();
            }
            // Then, check if we have an arrow function (production '4' and '5') that starts with a parenthesized
            // parameter list or is an async arrow function.
            // AsyncArrowFunctionExpression:
            //      1) async[no LineTerminator here]AsyncArrowBindingIdentifier[?Yield][no LineTerminator here]=>AsyncConciseBody[?In]
            //      2) CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await][no LineTerminator here]=>AsyncConciseBody[?In]
            // Production (1) of AsyncArrowFunctionExpression is parsed in "tryParseAsyncSimpleArrowFunctionExpression".
            // And production (2) is parsed in "tryParseParenthesizedArrowFunctionExpression".
            //
            // If we do successfully parse arrow-function, we must *not* recurse for productions 1, 2 or 3. An ArrowFunction is
            // not a LeftHandSideExpression, nor does it start a ConditionalExpression.  So we are done
            // with AssignmentExpression if we see one.
            var arrowExpression = tryParseParenthesizedArrowFunctionExpression() || tryParseAsyncSimpleArrowFunctionExpression();
            if (arrowExpression) {
                return arrowExpression;
            }
            // Now try to see if we're in production '1', '2' or '3'.  A conditional expression can
            // start with a LogicalOrExpression, while the assignment productions can only start with
            // LeftHandSideExpressions.
            //
            // So, first, we try to just parse out a BinaryExpression.  If we get something that is a
            // LeftHandSide or higher, then we can try to parse out the assignment expression part.
            // Otherwise, we try to parse out the conditional expression bit.  We want to allow any
            // binary expression here, so we pass in the 'lowest' precedence here so that it matches
            // and consumes anything.
            var pos = getNodePos();
            var expr = parseBinaryExpressionOrHigher(0 /* OperatorPrecedence.Lowest */);
            // To avoid a look-ahead, we did not handle the case of an arrow function with a single un-parenthesized
            // parameter ('x => ...') above. We handle it here by checking if the parsed expression was a single
            // identifier and the current token is an arrow.
            if (expr.kind === 79 /* SyntaxKind.Identifier */ && token() === 38 /* SyntaxKind.EqualsGreaterThanToken */) {
                return parseSimpleArrowFunctionExpression(pos, expr, /*asyncModifier*/ undefined);
            }
            // Now see if we might be in cases '2' or '3'.
            // If the expression was a LHS expression, and we have an assignment operator, then
            // we're in '2' or '3'. Consume the assignment and return.
            //
            // Note: we call reScanGreaterToken so that we get an appropriately merged token
            // for cases like `> > =` becoming `>>=`
            if (ts.isLeftHandSideExpression(expr) && ts.isAssignmentOperator(reScanGreaterToken())) {
                return makeBinaryExpression(expr, parseTokenNode(), parseAssignmentExpressionOrHigher(), pos);
            }
            // It wasn't an assignment or a lambda.  This is a conditional expression:
            return parseConditionalExpressionRest(expr, pos);
        }
        function isYieldExpression() {
            if (token() === 125 /* SyntaxKind.YieldKeyword */) {
                // If we have a 'yield' keyword, and this is a context where yield expressions are
                // allowed, then definitely parse out a yield expression.
                if (inYieldContext()) {
                    return true;
                }
                // We're in a context where 'yield expr' is not allowed.  However, if we can
                // definitely tell that the user was trying to parse a 'yield expr' and not
                // just a normal expr that start with a 'yield' identifier, then parse out
                // a 'yield expr'.  We can then report an error later that they are only
                // allowed in generator expressions.
                //
                // for example, if we see 'yield(foo)', then we'll have to treat that as an
                // invocation expression of something called 'yield'.  However, if we have
                // 'yield foo' then that is not legal as a normal expression, so we can
                // definitely recognize this as a yield expression.
                //
                // for now we just check if the next token is an identifier.  More heuristics
                // can be added here later as necessary.  We just need to make sure that we
                // don't accidentally consume something legal.
                return lookAhead(nextTokenIsIdentifierOrKeywordOrLiteralOnSameLine);
            }
            return false;
        }
        function nextTokenIsIdentifierOnSameLine() {
            nextToken();
            return !scanner.hasPrecedingLineBreak() && isIdentifier();
        }
        function parseYieldExpression() {
            var pos = getNodePos();
            // YieldExpression[In] :
            //      yield
            //      yield [no LineTerminator here] [Lexical goal InputElementRegExp]AssignmentExpression[?In, Yield]
            //      yield [no LineTerminator here] * [Lexical goal InputElementRegExp]AssignmentExpression[?In, Yield]
            nextToken();
            if (!scanner.hasPrecedingLineBreak() &&
                (token() === 41 /* SyntaxKind.AsteriskToken */ || isStartOfExpression())) {
                return finishNode(factory.createYieldExpression(parseOptionalToken(41 /* SyntaxKind.AsteriskToken */), parseAssignmentExpressionOrHigher()), pos);
            }
            else {
                // if the next token is not on the same line as yield.  or we don't have an '*' or
                // the start of an expression, then this is just a simple "yield" expression.
                return finishNode(factory.createYieldExpression(/*asteriskToken*/ undefined, /*expression*/ undefined), pos);
            }
        }
        function parseSimpleArrowFunctionExpression(pos, identifier, asyncModifier) {
            ts.Debug.assert(token() === 38 /* SyntaxKind.EqualsGreaterThanToken */, "parseSimpleArrowFunctionExpression should only have been called if we had a =>");
            var parameter = factory.createParameterDeclaration(
            /*decorators*/ undefined, 
            /*modifiers*/ undefined, 
            /*dotDotDotToken*/ undefined, identifier, 
            /*questionToken*/ undefined, 
            /*type*/ undefined, 
            /*initializer*/ undefined);
            finishNode(parameter, identifier.pos);
            var parameters = createNodeArray([parameter], parameter.pos, parameter.end);
            var equalsGreaterThanToken = parseExpectedToken(38 /* SyntaxKind.EqualsGreaterThanToken */);
            var body = parseArrowFunctionExpressionBody(/*isAsync*/ !!asyncModifier);
            var node = factory.createArrowFunction(asyncModifier, /*typeParameters*/ undefined, parameters, /*type*/ undefined, equalsGreaterThanToken, body);
            return addJSDocComment(finishNode(node, pos));
        }
        function tryParseParenthesizedArrowFunctionExpression() {
            var triState = isParenthesizedArrowFunctionExpression();
            if (triState === 0 /* Tristate.False */) {
                // It's definitely not a parenthesized arrow function expression.
                return undefined;
            }
            // If we definitely have an arrow function, then we can just parse one, not requiring a
            // following => or { token. Otherwise, we *might* have an arrow function.  Try to parse
            // it out, but don't allow any ambiguity, and return 'undefined' if this could be an
            // expression instead.
            return triState === 1 /* Tristate.True */ ?
                parseParenthesizedArrowFunctionExpression(/*allowAmbiguity*/ true) :
                tryParse(parsePossibleParenthesizedArrowFunctionExpression);
        }
        //  True        -> We definitely expect a parenthesized arrow function here.
        //  False       -> There *cannot* be a parenthesized arrow function here.
        //  Unknown     -> There *might* be a parenthesized arrow function here.
        //                 Speculatively look ahead to be sure, and rollback if not.
        function isParenthesizedArrowFunctionExpression() {
            if (token() === 20 /* SyntaxKind.OpenParenToken */ || token() === 29 /* SyntaxKind.LessThanToken */ || token() === 131 /* SyntaxKind.AsyncKeyword */) {
                return lookAhead(isParenthesizedArrowFunctionExpressionWorker);
            }
            if (token() === 38 /* SyntaxKind.EqualsGreaterThanToken */) {
                // ERROR RECOVERY TWEAK:
                // If we see a standalone => try to parse it as an arrow function expression as that's
                // likely what the user intended to write.
                return 1 /* Tristate.True */;
            }
            // Definitely not a parenthesized arrow function.
            return 0 /* Tristate.False */;
        }
        function isParenthesizedArrowFunctionExpressionWorker() {
            if (token() === 131 /* SyntaxKind.AsyncKeyword */) {
                nextToken();
                if (scanner.hasPrecedingLineBreak()) {
                    return 0 /* Tristate.False */;
                }
                if (token() !== 20 /* SyntaxKind.OpenParenToken */ && token() !== 29 /* SyntaxKind.LessThanToken */) {
                    return 0 /* Tristate.False */;
                }
            }
            var first = token();
            var second = nextToken();
            if (first === 20 /* SyntaxKind.OpenParenToken */) {
                if (second === 21 /* SyntaxKind.CloseParenToken */) {
                    // Simple cases: "() =>", "(): ", and "() {".
                    // This is an arrow function with no parameters.
                    // The last one is not actually an arrow function,
                    // but this is probably what the user intended.
                    var third = nextToken();
                    switch (third) {
                        case 38 /* SyntaxKind.EqualsGreaterThanToken */:
                        case 58 /* SyntaxKind.ColonToken */:
                        case 18 /* SyntaxKind.OpenBraceToken */:
                            return 1 /* Tristate.True */;
                        default:
                            return 0 /* Tristate.False */;
                    }
                }
                // If encounter "([" or "({", this could be the start of a binding pattern.
                // Examples:
                //      ([ x ]) => { }
                //      ({ x }) => { }
                //      ([ x ])
                //      ({ x })
                if (second === 22 /* SyntaxKind.OpenBracketToken */ || second === 18 /* SyntaxKind.OpenBraceToken */) {
                    return 2 /* Tristate.Unknown */;
                }
                // Simple case: "(..."
                // This is an arrow function with a rest parameter.
                if (second === 25 /* SyntaxKind.DotDotDotToken */) {
                    return 1 /* Tristate.True */;
                }
                // Check for "(xxx yyy", where xxx is a modifier and yyy is an identifier. This
                // isn't actually allowed, but we want to treat it as a lambda so we can provide
                // a good error message.
                if (ts.isModifierKind(second) && second !== 131 /* SyntaxKind.AsyncKeyword */ && lookAhead(nextTokenIsIdentifier)) {
                    if (lookAhead(function () { return nextToken() === 127 /* SyntaxKind.AsKeyword */; })) {
                        // https://github.com/microsoft/TypeScript/issues/44466
                        return 0 /* Tristate.False */;
                    }
                    return 1 /* Tristate.True */;
                }
                // If we had "(" followed by something that's not an identifier,
                // then this definitely doesn't look like a lambda.  "this" is not
                // valid, but we want to parse it and then give a semantic error.
                if (!isIdentifier() && second !== 108 /* SyntaxKind.ThisKeyword */) {
                    return 0 /* Tristate.False */;
                }
                switch (nextToken()) {
                    case 58 /* SyntaxKind.ColonToken */:
                        // If we have something like "(a:", then we must have a
                        // type-annotated parameter in an arrow function expression.
                        return 1 /* Tristate.True */;
                    case 57 /* SyntaxKind.QuestionToken */:
                        nextToken();
                        // If we have "(a?:" or "(a?," or "(a?=" or "(a?)" then it is definitely a lambda.
                        if (token() === 58 /* SyntaxKind.ColonToken */ || token() === 27 /* SyntaxKind.CommaToken */ || token() === 63 /* SyntaxKind.EqualsToken */ || token() === 21 /* SyntaxKind.CloseParenToken */) {
                            return 1 /* Tristate.True */;
                        }
                        // Otherwise it is definitely not a lambda.
                        return 0 /* Tristate.False */;
                    case 27 /* SyntaxKind.CommaToken */:
                    case 63 /* SyntaxKind.EqualsToken */:
                    case 21 /* SyntaxKind.CloseParenToken */:
                        // If we have "(a," or "(a=" or "(a)" this *could* be an arrow function
                        return 2 /* Tristate.Unknown */;
                }
                // It is definitely not an arrow function
                return 0 /* Tristate.False */;
            }
            else {
                ts.Debug.assert(first === 29 /* SyntaxKind.LessThanToken */);
                // If we have "<" not followed by an identifier,
                // then this definitely is not an arrow function.
                if (!isIdentifier()) {
                    return 0 /* Tristate.False */;
                }
                // JSX overrides
                if (languageVariant === 1 /* LanguageVariant.JSX */) {
                    var isArrowFunctionInJsx = lookAhead(function () {
                        var third = nextToken();
                        if (third === 94 /* SyntaxKind.ExtendsKeyword */) {
                            var fourth = nextToken();
                            switch (fourth) {
                                case 63 /* SyntaxKind.EqualsToken */:
                                case 31 /* SyntaxKind.GreaterThanToken */:
                                    return false;
                                default:
                                    return true;
                            }
                        }
                        else if (third === 27 /* SyntaxKind.CommaToken */ || third === 63 /* SyntaxKind.EqualsToken */) {
                            return true;
                        }
                        return false;
                    });
                    if (isArrowFunctionInJsx) {
                        return 1 /* Tristate.True */;
                    }
                    return 0 /* Tristate.False */;
                }
                // This *could* be a parenthesized arrow function.
                return 2 /* Tristate.Unknown */;
            }
        }
        function parsePossibleParenthesizedArrowFunctionExpression() {
            var tokenPos = scanner.getTokenPos();
            if (notParenthesizedArrow === null || notParenthesizedArrow === void 0 ? void 0 : notParenthesizedArrow.has(tokenPos)) {
                return undefined;
            }
            var result = parseParenthesizedArrowFunctionExpression(/*allowAmbiguity*/ false);
            if (!result) {
                (notParenthesizedArrow || (notParenthesizedArrow = new ts.Set())).add(tokenPos);
            }
            return result;
        }
        function tryParseAsyncSimpleArrowFunctionExpression() {
            // We do a check here so that we won't be doing unnecessarily call to "lookAhead"
            if (token() === 131 /* SyntaxKind.AsyncKeyword */) {
                if (lookAhead(isUnParenthesizedAsyncArrowFunctionWorker) === 1 /* Tristate.True */) {
                    var pos = getNodePos();
                    var asyncModifier = parseModifiersForArrowFunction();
                    var expr = parseBinaryExpressionOrHigher(0 /* OperatorPrecedence.Lowest */);
                    return parseSimpleArrowFunctionExpression(pos, expr, asyncModifier);
                }
            }
            return undefined;
        }
        function isUnParenthesizedAsyncArrowFunctionWorker() {
            // AsyncArrowFunctionExpression:
            //      1) async[no LineTerminator here]AsyncArrowBindingIdentifier[?Yield][no LineTerminator here]=>AsyncConciseBody[?In]
            //      2) CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await][no LineTerminator here]=>AsyncConciseBody[?In]
            if (token() === 131 /* SyntaxKind.AsyncKeyword */) {
                nextToken();
                // If the "async" is followed by "=>" token then it is not a beginning of an async arrow-function
                // but instead a simple arrow-function which will be parsed inside "parseAssignmentExpressionOrHigher"
                if (scanner.hasPrecedingLineBreak() || token() === 38 /* SyntaxKind.EqualsGreaterThanToken */) {
                    return 0 /* Tristate.False */;
                }
                // Check for un-parenthesized AsyncArrowFunction
                var expr = parseBinaryExpressionOrHigher(0 /* OperatorPrecedence.Lowest */);
                if (!scanner.hasPrecedingLineBreak() && expr.kind === 79 /* SyntaxKind.Identifier */ && token() === 38 /* SyntaxKind.EqualsGreaterThanToken */) {
                    return 1 /* Tristate.True */;
                }
            }
            return 0 /* Tristate.False */;
        }
        function parseParenthesizedArrowFunctionExpression(allowAmbiguity) {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            var modifiers = parseModifiersForArrowFunction();
            var isAsync = ts.some(modifiers, ts.isAsyncModifier) ? 2 /* SignatureFlags.Await */ : 0 /* SignatureFlags.None */;
            // Arrow functions are never generators.
            //
            // If we're speculatively parsing a signature for a parenthesized arrow function, then
            // we have to have a complete parameter list.  Otherwise we might see something like
            // a => (b => c)
            // And think that "(b =>" was actually a parenthesized arrow function with a missing
            // close paren.
            var typeParameters = parseTypeParameters();
            var parameters;
            if (!parseExpected(20 /* SyntaxKind.OpenParenToken */)) {
                if (!allowAmbiguity) {
                    return undefined;
                }
                parameters = createMissingList();
            }
            else {
                if (!allowAmbiguity) {
                    var maybeParameters = parseParametersWorker(isAsync, allowAmbiguity);
                    if (!maybeParameters) {
                        return undefined;
                    }
                    parameters = maybeParameters;
                }
                else {
                    parameters = parseParametersWorker(isAsync, allowAmbiguity);
                }
                if (!parseExpected(21 /* SyntaxKind.CloseParenToken */) && !allowAmbiguity) {
                    return undefined;
                }
            }
            var type = parseReturnType(58 /* SyntaxKind.ColonToken */, /*isType*/ false);
            if (type && !allowAmbiguity && typeHasArrowFunctionBlockingParseError(type)) {
                return undefined;
            }
            // Parsing a signature isn't enough.
            // Parenthesized arrow signatures often look like other valid expressions.
            // For instance:
            //  - "(x = 10)" is an assignment expression parsed as a signature with a default parameter value.
            //  - "(x,y)" is a comma expression parsed as a signature with two parameters.
            //  - "a ? (b): c" will have "(b):" parsed as a signature with a return type annotation.
            //  - "a ? (b): function() {}" will too, since function() is a valid JSDoc function type.
            //  - "a ? (b): (function() {})" as well, but inside of a parenthesized type with an arbitrary amount of nesting.
            //
            // So we need just a bit of lookahead to ensure that it can only be a signature.
            var unwrappedType = type;
            while ((unwrappedType === null || unwrappedType === void 0 ? void 0 : unwrappedType.kind) === 191 /* SyntaxKind.ParenthesizedType */) {
                unwrappedType = unwrappedType.type; // Skip parens if need be
            }
            var hasJSDocFunctionType = unwrappedType && ts.isJSDocFunctionType(unwrappedType);
            if (!allowAmbiguity && token() !== 38 /* SyntaxKind.EqualsGreaterThanToken */ && (hasJSDocFunctionType || token() !== 18 /* SyntaxKind.OpenBraceToken */)) {
                // Returning undefined here will cause our caller to rewind to where we started from.
                return undefined;
            }
            // If we have an arrow, then try to parse the body. Even if not, try to parse if we
            // have an opening brace, just in case we're in an error state.
            var lastToken = token();
            var equalsGreaterThanToken = parseExpectedToken(38 /* SyntaxKind.EqualsGreaterThanToken */);
            var body = (lastToken === 38 /* SyntaxKind.EqualsGreaterThanToken */ || lastToken === 18 /* SyntaxKind.OpenBraceToken */)
                ? parseArrowFunctionExpressionBody(ts.some(modifiers, ts.isAsyncModifier))
                : parseIdentifier();
            var node = factory.createArrowFunction(modifiers, typeParameters, parameters, type, equalsGreaterThanToken, body);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseArrowFunctionExpressionBody(isAsync) {
            if (token() === 18 /* SyntaxKind.OpenBraceToken */) {
                return parseFunctionBlock(isAsync ? 2 /* SignatureFlags.Await */ : 0 /* SignatureFlags.None */);
            }
            if (token() !== 26 /* SyntaxKind.SemicolonToken */ &&
                token() !== 98 /* SyntaxKind.FunctionKeyword */ &&
                token() !== 84 /* SyntaxKind.ClassKeyword */ &&
                isStartOfStatement() &&
                !isStartOfExpressionStatement()) {
                // Check if we got a plain statement (i.e. no expression-statements, no function/class expressions/declarations)
                //
                // Here we try to recover from a potential error situation in the case where the
                // user meant to supply a block. For example, if the user wrote:
                //
                //  a =>
                //      let v = 0;
                //  }
                //
                // they may be missing an open brace.  Check to see if that's the case so we can
                // try to recover better.  If we don't do this, then the next close curly we see may end
                // up preemptively closing the containing construct.
                //
                // Note: even when 'IgnoreMissingOpenBrace' is passed, parseBody will still error.
                return parseFunctionBlock(16 /* SignatureFlags.IgnoreMissingOpenBrace */ | (isAsync ? 2 /* SignatureFlags.Await */ : 0 /* SignatureFlags.None */));
            }
            var savedTopLevel = topLevel;
            topLevel = false;
            var node = isAsync
                ? doInAwaitContext(parseAssignmentExpressionOrHigher)
                : doOutsideOfAwaitContext(parseAssignmentExpressionOrHigher);
            topLevel = savedTopLevel;
            return node;
        }
        function parseConditionalExpressionRest(leftOperand, pos) {
            // Note: we are passed in an expression which was produced from parseBinaryExpressionOrHigher.
            var questionToken = parseOptionalToken(57 /* SyntaxKind.QuestionToken */);
            if (!questionToken) {
                return leftOperand;
            }
            // Note: we explicitly 'allowIn' in the whenTrue part of the condition expression, and
            // we do not that for the 'whenFalse' part.
            var colonToken;
            return finishNode(factory.createConditionalExpression(leftOperand, questionToken, doOutsideOfContext(disallowInAndDecoratorContext, parseAssignmentExpressionOrHigher), colonToken = parseExpectedToken(58 /* SyntaxKind.ColonToken */), ts.nodeIsPresent(colonToken)
                ? parseAssignmentExpressionOrHigher()
                : createMissingNode(79 /* SyntaxKind.Identifier */, /*reportAtCurrentPosition*/ false, ts.Diagnostics._0_expected, ts.tokenToString(58 /* SyntaxKind.ColonToken */))), pos);
        }
        function parseBinaryExpressionOrHigher(precedence) {
            var pos = getNodePos();
            var leftOperand = parseUnaryExpressionOrHigher();
            return parseBinaryExpressionRest(precedence, leftOperand, pos);
        }
        function isInOrOfKeyword(t) {
            return t === 101 /* SyntaxKind.InKeyword */ || t === 160 /* SyntaxKind.OfKeyword */;
        }
        function parseBinaryExpressionRest(precedence, leftOperand, pos) {
            while (true) {
                // We either have a binary operator here, or we're finished.  We call
                // reScanGreaterToken so that we merge token sequences like > and = into >=
                reScanGreaterToken();
                var newPrecedence = ts.getBinaryOperatorPrecedence(token());
                // Check the precedence to see if we should "take" this operator
                // - For left associative operator (all operator but **), consume the operator,
                //   recursively call the function below, and parse binaryExpression as a rightOperand
                //   of the caller if the new precedence of the operator is greater then or equal to the current precedence.
                //   For example:
                //      a - b - c;
                //            ^token; leftOperand = b. Return b to the caller as a rightOperand
                //      a * b - c
                //            ^token; leftOperand = b. Return b to the caller as a rightOperand
                //      a - b * c;
                //            ^token; leftOperand = b. Return b * c to the caller as a rightOperand
                // - For right associative operator (**), consume the operator, recursively call the function
                //   and parse binaryExpression as a rightOperand of the caller if the new precedence of
                //   the operator is strictly grater than the current precedence
                //   For example:
                //      a ** b ** c;
                //             ^^token; leftOperand = b. Return b ** c to the caller as a rightOperand
                //      a - b ** c;
                //            ^^token; leftOperand = b. Return b ** c to the caller as a rightOperand
                //      a ** b - c
                //             ^token; leftOperand = b. Return b to the caller as a rightOperand
                var consumeCurrentOperator = token() === 42 /* SyntaxKind.AsteriskAsteriskToken */ ?
                    newPrecedence >= precedence :
                    newPrecedence > precedence;
                if (!consumeCurrentOperator) {
                    break;
                }
                if (token() === 101 /* SyntaxKind.InKeyword */ && inDisallowInContext()) {
                    break;
                }
                if (token() === 127 /* SyntaxKind.AsKeyword */) {
                    // Make sure we *do* perform ASI for constructs like this:
                    //    var x = foo
                    //    as (Bar)
                    // This should be parsed as an initialized variable, followed
                    // by a function call to 'as' with the argument 'Bar'
                    if (scanner.hasPrecedingLineBreak()) {
                        break;
                    }
                    else {
                        nextToken();
                        leftOperand = makeAsExpression(leftOperand, parseType());
                    }
                }
                else {
                    leftOperand = makeBinaryExpression(leftOperand, parseTokenNode(), parseBinaryExpressionOrHigher(newPrecedence), pos);
                }
            }
            return leftOperand;
        }
        function isBinaryOperator() {
            if (inDisallowInContext() && token() === 101 /* SyntaxKind.InKeyword */) {
                return false;
            }
            return ts.getBinaryOperatorPrecedence(token()) > 0;
        }
        function makeBinaryExpression(left, operatorToken, right, pos) {
            return finishNode(factory.createBinaryExpression(left, operatorToken, right), pos);
        }
        function makeAsExpression(left, right) {
            return finishNode(factory.createAsExpression(left, right), left.pos);
        }
        function parsePrefixUnaryExpression() {
            var pos = getNodePos();
            return finishNode(factory.createPrefixUnaryExpression(token(), nextTokenAnd(parseSimpleUnaryExpression)), pos);
        }
        function parseDeleteExpression() {
            var pos = getNodePos();
            return finishNode(factory.createDeleteExpression(nextTokenAnd(parseSimpleUnaryExpression)), pos);
        }
        function parseTypeOfExpression() {
            var pos = getNodePos();
            return finishNode(factory.createTypeOfExpression(nextTokenAnd(parseSimpleUnaryExpression)), pos);
        }
        function parseVoidExpression() {
            var pos = getNodePos();
            return finishNode(factory.createVoidExpression(nextTokenAnd(parseSimpleUnaryExpression)), pos);
        }
        function isAwaitExpression() {
            if (token() === 132 /* SyntaxKind.AwaitKeyword */) {
                if (inAwaitContext()) {
                    return true;
                }
                // here we are using similar heuristics as 'isYieldExpression'
                return lookAhead(nextTokenIsIdentifierOrKeywordOrLiteralOnSameLine);
            }
            return false;
        }
        function parseAwaitExpression() {
            var pos = getNodePos();
            return finishNode(factory.createAwaitExpression(nextTokenAnd(parseSimpleUnaryExpression)), pos);
        }
        /**
         * Parse ES7 exponential expression and await expression
         *
         * ES7 ExponentiationExpression:
         *      1) UnaryExpression[?Yield]
         *      2) UpdateExpression[?Yield] ** ExponentiationExpression[?Yield]
         *
         */
        function parseUnaryExpressionOrHigher() {
            /**
             * ES7 UpdateExpression:
             *      1) LeftHandSideExpression[?Yield]
             *      2) LeftHandSideExpression[?Yield][no LineTerminator here]++
             *      3) LeftHandSideExpression[?Yield][no LineTerminator here]--
             *      4) ++UnaryExpression[?Yield]
             *      5) --UnaryExpression[?Yield]
             */
            if (isUpdateExpression()) {
                var pos = getNodePos();
                var updateExpression = parseUpdateExpression();
                return token() === 42 /* SyntaxKind.AsteriskAsteriskToken */ ?
                    parseBinaryExpressionRest(ts.getBinaryOperatorPrecedence(token()), updateExpression, pos) :
                    updateExpression;
            }
            /**
             * ES7 UnaryExpression:
             *      1) UpdateExpression[?yield]
             *      2) delete UpdateExpression[?yield]
             *      3) void UpdateExpression[?yield]
             *      4) typeof UpdateExpression[?yield]
             *      5) + UpdateExpression[?yield]
             *      6) - UpdateExpression[?yield]
             *      7) ~ UpdateExpression[?yield]
             *      8) ! UpdateExpression[?yield]
             */
            var unaryOperator = token();
            var simpleUnaryExpression = parseSimpleUnaryExpression();
            if (token() === 42 /* SyntaxKind.AsteriskAsteriskToken */) {
                var pos = ts.skipTrivia(sourceText, simpleUnaryExpression.pos);
                var end = simpleUnaryExpression.end;
                if (simpleUnaryExpression.kind === 211 /* SyntaxKind.TypeAssertionExpression */) {
                    parseErrorAt(pos, end, ts.Diagnostics.A_type_assertion_expression_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses);
                }
                else {
                    parseErrorAt(pos, end, ts.Diagnostics.An_unary_expression_with_the_0_operator_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses, ts.tokenToString(unaryOperator));
                }
            }
            return simpleUnaryExpression;
        }
        /**
         * Parse ES7 simple-unary expression or higher:
         *
         * ES7 UnaryExpression:
         *      1) UpdateExpression[?yield]
         *      2) delete UnaryExpression[?yield]
         *      3) void UnaryExpression[?yield]
         *      4) typeof UnaryExpression[?yield]
         *      5) + UnaryExpression[?yield]
         *      6) - UnaryExpression[?yield]
         *      7) ~ UnaryExpression[?yield]
         *      8) ! UnaryExpression[?yield]
         *      9) [+Await] await UnaryExpression[?yield]
         */
        function parseSimpleUnaryExpression() {
            switch (token()) {
                case 39 /* SyntaxKind.PlusToken */:
                case 40 /* SyntaxKind.MinusToken */:
                case 54 /* SyntaxKind.TildeToken */:
                case 53 /* SyntaxKind.ExclamationToken */:
                    return parsePrefixUnaryExpression();
                case 89 /* SyntaxKind.DeleteKeyword */:
                    return parseDeleteExpression();
                case 112 /* SyntaxKind.TypeOfKeyword */:
                    return parseTypeOfExpression();
                case 114 /* SyntaxKind.VoidKeyword */:
                    return parseVoidExpression();
                case 29 /* SyntaxKind.LessThanToken */:
                    // This is modified UnaryExpression grammar in TypeScript
                    //  UnaryExpression (modified):
                    //      < type > UnaryExpression
                    return parseTypeAssertion();
                case 132 /* SyntaxKind.AwaitKeyword */:
                    if (isAwaitExpression()) {
                        return parseAwaitExpression();
                    }
                // falls through
                default:
                    return parseUpdateExpression();
            }
        }
        /**
         * Check if the current token can possibly be an ES7 increment expression.
         *
         * ES7 UpdateExpression:
         *      LeftHandSideExpression[?Yield]
         *      LeftHandSideExpression[?Yield][no LineTerminator here]++
         *      LeftHandSideExpression[?Yield][no LineTerminator here]--
         *      ++LeftHandSideExpression[?Yield]
         *      --LeftHandSideExpression[?Yield]
         */
        function isUpdateExpression() {
            // This function is called inside parseUnaryExpression to decide
            // whether to call parseSimpleUnaryExpression or call parseUpdateExpression directly
            switch (token()) {
                case 39 /* SyntaxKind.PlusToken */:
                case 40 /* SyntaxKind.MinusToken */:
                case 54 /* SyntaxKind.TildeToken */:
                case 53 /* SyntaxKind.ExclamationToken */:
                case 89 /* SyntaxKind.DeleteKeyword */:
                case 112 /* SyntaxKind.TypeOfKeyword */:
                case 114 /* SyntaxKind.VoidKeyword */:
                case 132 /* SyntaxKind.AwaitKeyword */:
                    return false;
                case 29 /* SyntaxKind.LessThanToken */:
                    // If we are not in JSX context, we are parsing TypeAssertion which is an UnaryExpression
                    if (languageVariant !== 1 /* LanguageVariant.JSX */) {
                        return false;
                    }
                // We are in JSX context and the token is part of JSXElement.
                // falls through
                default:
                    return true;
            }
        }
        /**
         * Parse ES7 UpdateExpression. UpdateExpression is used instead of ES6's PostFixExpression.
         *
         * ES7 UpdateExpression[yield]:
         *      1) LeftHandSideExpression[?yield]
         *      2) LeftHandSideExpression[?yield] [[no LineTerminator here]]++
         *      3) LeftHandSideExpression[?yield] [[no LineTerminator here]]--
         *      4) ++LeftHandSideExpression[?yield]
         *      5) --LeftHandSideExpression[?yield]
         * In TypeScript (2), (3) are parsed as PostfixUnaryExpression. (4), (5) are parsed as PrefixUnaryExpression
         */
        function parseUpdateExpression() {
            if (token() === 45 /* SyntaxKind.PlusPlusToken */ || token() === 46 /* SyntaxKind.MinusMinusToken */) {
                var pos = getNodePos();
                return finishNode(factory.createPrefixUnaryExpression(token(), nextTokenAnd(parseLeftHandSideExpressionOrHigher)), pos);
            }
            else if (languageVariant === 1 /* LanguageVariant.JSX */ && token() === 29 /* SyntaxKind.LessThanToken */ && lookAhead(nextTokenIsIdentifierOrKeywordOrGreaterThan)) {
                // JSXElement is part of primaryExpression
                return parseJsxElementOrSelfClosingElementOrFragment(/*inExpressionContext*/ true);
            }
            var expression = parseLeftHandSideExpressionOrHigher();
            ts.Debug.assert(ts.isLeftHandSideExpression(expression));
            if ((token() === 45 /* SyntaxKind.PlusPlusToken */ || token() === 46 /* SyntaxKind.MinusMinusToken */) && !scanner.hasPrecedingLineBreak()) {
                var operator = token();
                nextToken();
                return finishNode(factory.createPostfixUnaryExpression(expression, operator), expression.pos);
            }
            return expression;
        }
        function parseLeftHandSideExpressionOrHigher() {
            // Original Ecma:
            // LeftHandSideExpression: See 11.2
            //      NewExpression
            //      CallExpression
            //
            // Our simplification:
            //
            // LeftHandSideExpression: See 11.2
            //      MemberExpression
            //      CallExpression
            //
            // See comment in parseMemberExpressionOrHigher on how we replaced NewExpression with
            // MemberExpression to make our lives easier.
            //
            // to best understand the below code, it's important to see how CallExpression expands
            // out into its own productions:
            //
            // CallExpression:
            //      MemberExpression Arguments
            //      CallExpression Arguments
            //      CallExpression[Expression]
            //      CallExpression.IdentifierName
            //      import (AssignmentExpression)
            //      super Arguments
            //      super.IdentifierName
            //
            // Because of the recursion in these calls, we need to bottom out first. There are three
            // bottom out states we can run into: 1) We see 'super' which must start either of
            // the last two CallExpression productions. 2) We see 'import' which must start import call.
            // 3)we have a MemberExpression which either completes the LeftHandSideExpression,
            // or starts the beginning of the first four CallExpression productions.
            var pos = getNodePos();
            var expression;
            if (token() === 100 /* SyntaxKind.ImportKeyword */) {
                if (lookAhead(nextTokenIsOpenParenOrLessThan)) {
                    // We don't want to eagerly consume all import keyword as import call expression so we look ahead to find "("
                    // For example:
                    //      var foo3 = require("subfolder
                    //      import * as foo1 from "module-from-node
                    // We want this import to be a statement rather than import call expression
                    sourceFlags |= 2097152 /* NodeFlags.PossiblyContainsDynamicImport */;
                    expression = parseTokenNode();
                }
                else if (lookAhead(nextTokenIsDot)) {
                    // This is an 'import.*' metaproperty (i.e. 'import.meta')
                    nextToken(); // advance past the 'import'
                    nextToken(); // advance past the dot
                    expression = finishNode(factory.createMetaProperty(100 /* SyntaxKind.ImportKeyword */, parseIdentifierName()), pos);
                    sourceFlags |= 4194304 /* NodeFlags.PossiblyContainsImportMeta */;
                }
                else {
                    expression = parseMemberExpressionOrHigher();
                }
            }
            else {
                expression = token() === 106 /* SyntaxKind.SuperKeyword */ ? parseSuperExpression() : parseMemberExpressionOrHigher();
            }
            // Now, we *may* be complete.  However, we might have consumed the start of a
            // CallExpression or OptionalExpression.  As such, we need to consume the rest
            // of it here to be complete.
            return parseCallExpressionRest(pos, expression);
        }
        function parseMemberExpressionOrHigher() {
            // Note: to make our lives simpler, we decompose the NewExpression productions and
            // place ObjectCreationExpression and FunctionExpression into PrimaryExpression.
            // like so:
            //
            //   PrimaryExpression : See 11.1
            //      this
            //      Identifier
            //      Literal
            //      ArrayLiteral
            //      ObjectLiteral
            //      (Expression)
            //      FunctionExpression
            //      new MemberExpression Arguments?
            //
            //   MemberExpression : See 11.2
            //      PrimaryExpression
            //      MemberExpression[Expression]
            //      MemberExpression.IdentifierName
            //
            //   CallExpression : See 11.2
            //      MemberExpression
            //      CallExpression Arguments
            //      CallExpression[Expression]
            //      CallExpression.IdentifierName
            //
            // Technically this is ambiguous.  i.e. CallExpression defines:
            //
            //   CallExpression:
            //      CallExpression Arguments
            //
            // If you see: "new Foo()"
            //
            // Then that could be treated as a single ObjectCreationExpression, or it could be
            // treated as the invocation of "new Foo".  We disambiguate that in code (to match
            // the original grammar) by making sure that if we see an ObjectCreationExpression
            // we always consume arguments if they are there. So we treat "new Foo()" as an
            // object creation only, and not at all as an invocation.  Another way to think
            // about this is that for every "new" that we see, we will consume an argument list if
            // it is there as part of the *associated* object creation node.  Any additional
            // argument lists we see, will become invocation expressions.
            //
            // Because there are no other places in the grammar now that refer to FunctionExpression
            // or ObjectCreationExpression, it is safe to push down into the PrimaryExpression
            // production.
            //
            // Because CallExpression and MemberExpression are left recursive, we need to bottom out
            // of the recursion immediately.  So we parse out a primary expression to start with.
            var pos = getNodePos();
            var expression = parsePrimaryExpression();
            return parseMemberExpressionRest(pos, expression, /*allowOptionalChain*/ true);
        }
        function parseSuperExpression() {
            var pos = getNodePos();
            var expression = parseTokenNode();
            if (token() === 29 /* SyntaxKind.LessThanToken */) {
                var startPos = getNodePos();
                var typeArguments = tryParse(parseTypeArgumentsInExpression);
                if (typeArguments !== undefined) {
                    parseErrorAt(startPos, getNodePos(), ts.Diagnostics.super_may_not_use_type_arguments);
                }
            }
            if (token() === 20 /* SyntaxKind.OpenParenToken */ || token() === 24 /* SyntaxKind.DotToken */ || token() === 22 /* SyntaxKind.OpenBracketToken */) {
                return expression;
            }
            // If we have seen "super" it must be followed by '(' or '.'.
            // If it wasn't then just try to parse out a '.' and report an error.
            parseExpectedToken(24 /* SyntaxKind.DotToken */, ts.Diagnostics.super_must_be_followed_by_an_argument_list_or_member_access);
            // private names will never work with `super` (`super.#foo`), but that's a semantic error, not syntactic
            return finishNode(factory.createPropertyAccessExpression(expression, parseRightSideOfDot(/*allowIdentifierNames*/ true, /*allowPrivateIdentifiers*/ true)), pos);
        }
        function parseJsxElementOrSelfClosingElementOrFragment(inExpressionContext, topInvalidNodePosition, openingTag) {
            var pos = getNodePos();
            var opening = parseJsxOpeningOrSelfClosingElementOrOpeningFragment(inExpressionContext);
            var result;
            if (opening.kind === 280 /* SyntaxKind.JsxOpeningElement */) {
                var children = parseJsxChildren(opening);
                var closingElement = void 0;
                var lastChild = children[children.length - 1];
                if ((lastChild === null || lastChild === void 0 ? void 0 : lastChild.kind) === 278 /* SyntaxKind.JsxElement */
                    && !tagNamesAreEquivalent(lastChild.openingElement.tagName, lastChild.closingElement.tagName)
                    && tagNamesAreEquivalent(opening.tagName, lastChild.closingElement.tagName)) {
                    // when an unclosed JsxOpeningElement incorrectly parses its parent's JsxClosingElement,
                    // restructure (<div>(...<span>...</div>)) --> (<div>(...<span>...</>)</div>)
                    // (no need to error; the parent will error)
                    var end = lastChild.children.end;
                    var newLast = finishNode(factory.createJsxElement(lastChild.openingElement, lastChild.children, finishNode(factory.createJsxClosingElement(finishNode(factory.createIdentifier(""), end, end)), end, end)), lastChild.openingElement.pos, end);
                    children = createNodeArray(__spreadArray(__spreadArray([], children.slice(0, children.length - 1), true), [newLast], false), children.pos, end);
                    closingElement = lastChild.closingElement;
                }
                else {
                    closingElement = parseJsxClosingElement(opening, inExpressionContext);
                    if (!tagNamesAreEquivalent(opening.tagName, closingElement.tagName)) {
                        if (openingTag && ts.isJsxOpeningElement(openingTag) && tagNamesAreEquivalent(closingElement.tagName, openingTag.tagName)) {
                            // opening incorrectly matched with its parent's closing -- put error on opening
                            parseErrorAtRange(opening.tagName, ts.Diagnostics.JSX_element_0_has_no_corresponding_closing_tag, ts.getTextOfNodeFromSourceText(sourceText, opening.tagName));
                        }
                        else {
                            // other opening/closing mismatches -- put error on closing
                            parseErrorAtRange(closingElement.tagName, ts.Diagnostics.Expected_corresponding_JSX_closing_tag_for_0, ts.getTextOfNodeFromSourceText(sourceText, opening.tagName));
                        }
                    }
                }
                result = finishNode(factory.createJsxElement(opening, children, closingElement), pos);
            }
            else if (opening.kind === 283 /* SyntaxKind.JsxOpeningFragment */) {
                result = finishNode(factory.createJsxFragment(opening, parseJsxChildren(opening), parseJsxClosingFragment(inExpressionContext)), pos);
            }
            else {
                ts.Debug.assert(opening.kind === 279 /* SyntaxKind.JsxSelfClosingElement */);
                // Nothing else to do for self-closing elements
                result = opening;
            }
            // If the user writes the invalid code '<div></div><div></div>' in an expression context (i.e. not wrapped in
            // an enclosing tag), we'll naively try to parse   ^ this as a 'less than' operator and the remainder of the tag
            // as garbage, which will cause the formatter to badly mangle the JSX. Perform a speculative parse of a JSX
            // element if we see a < token so that we can wrap it in a synthetic binary expression so the formatter
            // does less damage and we can report a better error.
            // Since JSX elements are invalid < operands anyway, this lookahead parse will only occur in error scenarios
            // of one sort or another.
            if (inExpressionContext && token() === 29 /* SyntaxKind.LessThanToken */) {
                var topBadPos_1 = typeof topInvalidNodePosition === "undefined" ? result.pos : topInvalidNodePosition;
                var invalidElement = tryParse(function () { return parseJsxElementOrSelfClosingElementOrFragment(/*inExpressionContext*/ true, topBadPos_1); });
                if (invalidElement) {
                    var operatorToken = createMissingNode(27 /* SyntaxKind.CommaToken */, /*reportAtCurrentPosition*/ false);
                    ts.setTextRangePosWidth(operatorToken, invalidElement.pos, 0);
                    parseErrorAt(ts.skipTrivia(sourceText, topBadPos_1), invalidElement.end, ts.Diagnostics.JSX_expressions_must_have_one_parent_element);
                    return finishNode(factory.createBinaryExpression(result, operatorToken, invalidElement), pos);
                }
            }
            return result;
        }
        function parseJsxText() {
            var pos = getNodePos();
            var node = factory.createJsxText(scanner.getTokenValue(), currentToken === 12 /* SyntaxKind.JsxTextAllWhiteSpaces */);
            currentToken = scanner.scanJsxToken();
            return finishNode(node, pos);
        }
        function parseJsxChild(openingTag, token) {
            switch (token) {
                case 1 /* SyntaxKind.EndOfFileToken */:
                    // If we hit EOF, issue the error at the tag that lacks the closing element
                    // rather than at the end of the file (which is useless)
                    if (ts.isJsxOpeningFragment(openingTag)) {
                        parseErrorAtRange(openingTag, ts.Diagnostics.JSX_fragment_has_no_corresponding_closing_tag);
                    }
                    else {
                        // We want the error span to cover only 'Foo.Bar' in < Foo.Bar >
                        // or to cover only 'Foo' in < Foo >
                        var tag = openingTag.tagName;
                        var start = ts.skipTrivia(sourceText, tag.pos);
                        parseErrorAt(start, tag.end, ts.Diagnostics.JSX_element_0_has_no_corresponding_closing_tag, ts.getTextOfNodeFromSourceText(sourceText, openingTag.tagName));
                    }
                    return undefined;
                case 30 /* SyntaxKind.LessThanSlashToken */:
                case 7 /* SyntaxKind.ConflictMarkerTrivia */:
                    return undefined;
                case 11 /* SyntaxKind.JsxText */:
                case 12 /* SyntaxKind.JsxTextAllWhiteSpaces */:
                    return parseJsxText();
                case 18 /* SyntaxKind.OpenBraceToken */:
                    return parseJsxExpression(/*inExpressionContext*/ false);
                case 29 /* SyntaxKind.LessThanToken */:
                    return parseJsxElementOrSelfClosingElementOrFragment(/*inExpressionContext*/ false, /*topInvalidNodePosition*/ undefined, openingTag);
                default:
                    return ts.Debug.assertNever(token);
            }
        }
        function parseJsxChildren(openingTag) {
            var list = [];
            var listPos = getNodePos();
            var saveParsingContext = parsingContext;
            parsingContext |= 1 << 14 /* ParsingContext.JsxChildren */;
            while (true) {
                var child = parseJsxChild(openingTag, currentToken = scanner.reScanJsxToken());
                if (!child)
                    break;
                list.push(child);
                if (ts.isJsxOpeningElement(openingTag)
                    && (child === null || child === void 0 ? void 0 : child.kind) === 278 /* SyntaxKind.JsxElement */
                    && !tagNamesAreEquivalent(child.openingElement.tagName, child.closingElement.tagName)
                    && tagNamesAreEquivalent(openingTag.tagName, child.closingElement.tagName)) {
                    // stop after parsing a mismatched child like <div>...(<span></div>) in order to reattach the </div> higher
                    break;
                }
            }
            parsingContext = saveParsingContext;
            return createNodeArray(list, listPos);
        }
        function parseJsxAttributes() {
            var pos = getNodePos();
            return finishNode(factory.createJsxAttributes(parseList(13 /* ParsingContext.JsxAttributes */, parseJsxAttribute)), pos);
        }
        function parseJsxOpeningOrSelfClosingElementOrOpeningFragment(inExpressionContext) {
            var pos = getNodePos();
            parseExpected(29 /* SyntaxKind.LessThanToken */);
            if (token() === 31 /* SyntaxKind.GreaterThanToken */) {
                // See below for explanation of scanJsxText
                scanJsxText();
                return finishNode(factory.createJsxOpeningFragment(), pos);
            }
            var tagName = parseJsxElementName();
            var typeArguments = (contextFlags & 262144 /* NodeFlags.JavaScriptFile */) === 0 ? tryParseTypeArguments() : undefined;
            var attributes = parseJsxAttributes();
            var node;
            if (token() === 31 /* SyntaxKind.GreaterThanToken */) {
                // Closing tag, so scan the immediately-following text with the JSX scanning instead
                // of regular scanning to avoid treating illegal characters (e.g. '#') as immediate
                // scanning errors
                scanJsxText();
                node = factory.createJsxOpeningElement(tagName, typeArguments, attributes);
            }
            else {
                parseExpected(43 /* SyntaxKind.SlashToken */);
                if (parseExpected(31 /* SyntaxKind.GreaterThanToken */, /*diagnostic*/ undefined, /*shouldAdvance*/ false)) {
                    // manually advance the scanner in order to look for jsx text inside jsx
                    if (inExpressionContext) {
                        nextToken();
                    }
                    else {
                        scanJsxText();
                    }
                }
                node = factory.createJsxSelfClosingElement(tagName, typeArguments, attributes);
            }
            return finishNode(node, pos);
        }
        function parseJsxElementName() {
            var pos = getNodePos();
            scanJsxIdentifier();
            // JsxElement can have name in the form of
            //      propertyAccessExpression
            //      primaryExpression in the form of an identifier and "this" keyword
            // We can't just simply use parseLeftHandSideExpressionOrHigher because then we will start consider class,function etc as a keyword
            // We only want to consider "this" as a primaryExpression
            var expression = token() === 108 /* SyntaxKind.ThisKeyword */ ?
                parseTokenNode() : parseIdentifierName();
            while (parseOptional(24 /* SyntaxKind.DotToken */)) {
                expression = finishNode(factory.createPropertyAccessExpression(expression, parseRightSideOfDot(/*allowIdentifierNames*/ true, /*allowPrivateIdentifiers*/ false)), pos);
            }
            return expression;
        }
        function parseJsxExpression(inExpressionContext) {
            var pos = getNodePos();
            if (!parseExpected(18 /* SyntaxKind.OpenBraceToken */)) {
                return undefined;
            }
            var dotDotDotToken;
            var expression;
            if (token() !== 19 /* SyntaxKind.CloseBraceToken */) {
                dotDotDotToken = parseOptionalToken(25 /* SyntaxKind.DotDotDotToken */);
                // Only an AssignmentExpression is valid here per the JSX spec,
                // but we can unambiguously parse a comma sequence and provide
                // a better error message in grammar checking.
                expression = parseExpression();
            }
            if (inExpressionContext) {
                parseExpected(19 /* SyntaxKind.CloseBraceToken */);
            }
            else {
                if (parseExpected(19 /* SyntaxKind.CloseBraceToken */, /*message*/ undefined, /*shouldAdvance*/ false)) {
                    scanJsxText();
                }
            }
            return finishNode(factory.createJsxExpression(dotDotDotToken, expression), pos);
        }
        function parseJsxAttribute() {
            if (token() === 18 /* SyntaxKind.OpenBraceToken */) {
                return parseJsxSpreadAttribute();
            }
            scanJsxIdentifier();
            var pos = getNodePos();
            return finishNode(factory.createJsxAttribute(parseIdentifierName(), token() !== 63 /* SyntaxKind.EqualsToken */ ? undefined :
                scanJsxAttributeValue() === 10 /* SyntaxKind.StringLiteral */ ? parseLiteralNode() :
                    parseJsxExpression(/*inExpressionContext*/ true)), pos);
        }
        function parseJsxSpreadAttribute() {
            var pos = getNodePos();
            parseExpected(18 /* SyntaxKind.OpenBraceToken */);
            parseExpected(25 /* SyntaxKind.DotDotDotToken */);
            var expression = parseExpression();
            parseExpected(19 /* SyntaxKind.CloseBraceToken */);
            return finishNode(factory.createJsxSpreadAttribute(expression), pos);
        }
        function parseJsxClosingElement(open, inExpressionContext) {
            var pos = getNodePos();
            parseExpected(30 /* SyntaxKind.LessThanSlashToken */);
            var tagName = parseJsxElementName();
            if (parseExpected(31 /* SyntaxKind.GreaterThanToken */, /*diagnostic*/ undefined, /*shouldAdvance*/ false)) {
                // manually advance the scanner in order to look for jsx text inside jsx
                if (inExpressionContext || !tagNamesAreEquivalent(open.tagName, tagName)) {
                    nextToken();
                }
                else {
                    scanJsxText();
                }
            }
            return finishNode(factory.createJsxClosingElement(tagName), pos);
        }
        function parseJsxClosingFragment(inExpressionContext) {
            var pos = getNodePos();
            parseExpected(30 /* SyntaxKind.LessThanSlashToken */);
            if (ts.tokenIsIdentifierOrKeyword(token())) {
                parseErrorAtRange(parseJsxElementName(), ts.Diagnostics.Expected_corresponding_closing_tag_for_JSX_fragment);
            }
            if (parseExpected(31 /* SyntaxKind.GreaterThanToken */, /*diagnostic*/ undefined, /*shouldAdvance*/ false)) {
                // manually advance the scanner in order to look for jsx text inside jsx
                if (inExpressionContext) {
                    nextToken();
                }
                else {
                    scanJsxText();
                }
            }
            return finishNode(factory.createJsxJsxClosingFragment(), pos);
        }
        function parseTypeAssertion() {
            var pos = getNodePos();
            parseExpected(29 /* SyntaxKind.LessThanToken */);
            var type = parseType();
            parseExpected(31 /* SyntaxKind.GreaterThanToken */);
            var expression = parseSimpleUnaryExpression();
            return finishNode(factory.createTypeAssertion(type, expression), pos);
        }
        function nextTokenIsIdentifierOrKeywordOrOpenBracketOrTemplate() {
            nextToken();
            return ts.tokenIsIdentifierOrKeyword(token())
                || token() === 22 /* SyntaxKind.OpenBracketToken */
                || isTemplateStartOfTaggedTemplate();
        }
        function isStartOfOptionalPropertyOrElementAccessChain() {
            return token() === 28 /* SyntaxKind.QuestionDotToken */
                && lookAhead(nextTokenIsIdentifierOrKeywordOrOpenBracketOrTemplate);
        }
        function tryReparseOptionalChain(node) {
            if (node.flags & 32 /* NodeFlags.OptionalChain */) {
                return true;
            }
            // check for an optional chain in a non-null expression
            if (ts.isNonNullExpression(node)) {
                var expr = node.expression;
                while (ts.isNonNullExpression(expr) && !(expr.flags & 32 /* NodeFlags.OptionalChain */)) {
                    expr = expr.expression;
                }
                if (expr.flags & 32 /* NodeFlags.OptionalChain */) {
                    // this is part of an optional chain. Walk down from `node` to `expression` and set the flag.
                    while (ts.isNonNullExpression(node)) {
                        node.flags |= 32 /* NodeFlags.OptionalChain */;
                        node = node.expression;
                    }
                    return true;
                }
            }
            return false;
        }
        function parsePropertyAccessExpressionRest(pos, expression, questionDotToken) {
            var name = parseRightSideOfDot(/*allowIdentifierNames*/ true, /*allowPrivateIdentifiers*/ true);
            var isOptionalChain = questionDotToken || tryReparseOptionalChain(expression);
            var propertyAccess = isOptionalChain ?
                factory.createPropertyAccessChain(expression, questionDotToken, name) :
                factory.createPropertyAccessExpression(expression, name);
            if (isOptionalChain && ts.isPrivateIdentifier(propertyAccess.name)) {
                parseErrorAtRange(propertyAccess.name, ts.Diagnostics.An_optional_chain_cannot_contain_private_identifiers);
            }
            return finishNode(propertyAccess, pos);
        }
        function parseElementAccessExpressionRest(pos, expression, questionDotToken) {
            var argumentExpression;
            if (token() === 23 /* SyntaxKind.CloseBracketToken */) {
                argumentExpression = createMissingNode(79 /* SyntaxKind.Identifier */, /*reportAtCurrentPosition*/ true, ts.Diagnostics.An_element_access_expression_should_take_an_argument);
            }
            else {
                var argument = allowInAnd(parseExpression);
                if (ts.isStringOrNumericLiteralLike(argument)) {
                    argument.text = internIdentifier(argument.text);
                }
                argumentExpression = argument;
            }
            parseExpected(23 /* SyntaxKind.CloseBracketToken */);
            var indexedAccess = questionDotToken || tryReparseOptionalChain(expression) ?
                factory.createElementAccessChain(expression, questionDotToken, argumentExpression) :
                factory.createElementAccessExpression(expression, argumentExpression);
            return finishNode(indexedAccess, pos);
        }
        function parseMemberExpressionRest(pos, expression, allowOptionalChain) {
            while (true) {
                var questionDotToken = void 0;
                var isPropertyAccess = false;
                if (allowOptionalChain && isStartOfOptionalPropertyOrElementAccessChain()) {
                    questionDotToken = parseExpectedToken(28 /* SyntaxKind.QuestionDotToken */);
                    isPropertyAccess = ts.tokenIsIdentifierOrKeyword(token());
                }
                else {
                    isPropertyAccess = parseOptional(24 /* SyntaxKind.DotToken */);
                }
                if (isPropertyAccess) {
                    expression = parsePropertyAccessExpressionRest(pos, expression, questionDotToken);
                    continue;
                }
                // when in the [Decorator] context, we do not parse ElementAccess as it could be part of a ComputedPropertyName
                if ((questionDotToken || !inDecoratorContext()) && parseOptional(22 /* SyntaxKind.OpenBracketToken */)) {
                    expression = parseElementAccessExpressionRest(pos, expression, questionDotToken);
                    continue;
                }
                if (isTemplateStartOfTaggedTemplate()) {
                    // Absorb type arguments into TemplateExpression when preceding expression is ExpressionWithTypeArguments
                    expression = !questionDotToken && expression.kind === 228 /* SyntaxKind.ExpressionWithTypeArguments */ ?
                        parseTaggedTemplateRest(pos, expression.expression, questionDotToken, expression.typeArguments) :
                        parseTaggedTemplateRest(pos, expression, questionDotToken, /*typeArguments*/ undefined);
                    continue;
                }
                if (!questionDotToken) {
                    if (token() === 53 /* SyntaxKind.ExclamationToken */ && !scanner.hasPrecedingLineBreak()) {
                        nextToken();
                        expression = finishNode(factory.createNonNullExpression(expression), pos);
                        continue;
                    }
                    var typeArguments = tryParse(parseTypeArgumentsInExpression);
                    if (typeArguments) {
                        expression = finishNode(factory.createExpressionWithTypeArguments(expression, typeArguments), pos);
                        continue;
                    }
                }
                return expression;
            }
        }
        function isTemplateStartOfTaggedTemplate() {
            return token() === 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */ || token() === 15 /* SyntaxKind.TemplateHead */;
        }
        function parseTaggedTemplateRest(pos, tag, questionDotToken, typeArguments) {
            var tagExpression = factory.createTaggedTemplateExpression(tag, typeArguments, token() === 14 /* SyntaxKind.NoSubst