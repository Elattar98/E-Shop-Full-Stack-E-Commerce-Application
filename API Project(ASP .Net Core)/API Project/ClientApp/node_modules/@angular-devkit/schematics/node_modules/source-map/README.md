nt !== 'undefined') {\n    return document;\n  }\n  // No \"document\" can be found. This should only happen if we are running ivy outside Angular and\n  // the current platform is not a browser. Since this is not a supported scenario at the moment\n  // this should not happen in Angular apps.\n  // Once we support running ivy outside of Angular we will need to publish `setDocument()` as a\n  // public API. Meanwhile we just return `undefined` and let the application fail.\n  return undefined!;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @fileoverview\n * A module to facilitate use of a Trusted Types policy internally within\n * Angular. It lazily constructs the Trusted Types policy, providing helper\n * utilities for promoting strings to Trusted Types. When Trusted Types are not\n * available, strings are used as a fallback.\n * @security All use of this module is security-sensitive and should go through\n * security review.\n */\n\nimport {global} from '../global';\nimport {TrustedHTML, TrustedScript, TrustedScriptURL, TrustedTypePolicy, TrustedTypePolicyFactory} from './trusted_type_defs';\n\n/**\n * The Trusted Types policy, or null if Trusted Types are not\n * enabled/supported, or undefined if the policy has not been created yet.\n */\nlet policy: TrustedTypePolicy|null|undefined;\n\n/**\n * Returns the Trusted Types policy, or null if Trusted Types are not\n * enabled/supported. The first call to this function will create the policy.\n */\nfunction getPolicy(): TrustedTypePolicy|null {\n  if (policy === undefined) {\n    policy = null;\n    if (global.trustedTypes) {\n      try {\n        policy = (global.trustedTypes as TrustedTypePolicyFactory).createPolicy('angular', {\n          createHTML: (s: string) => s,\n          createScript: (s: string) => s,\n          createScriptURL: (s: string) => s,\n        });\n      } catch {\n        // trustedTypes.createPolicy throws if called with a name that is\n        // already registered, even in report-only mode. Until the API changes,\n        // catch the error not to break the applications functionally. In such\n        // cases, the code will fall back to using strings.\n      }\n    }\n  }\n  return policy;\n}\n\n/**\n * Unsafely promote a string to a TrustedHTML, falling back to strings when\n * Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that the\n * provided string will never cause an XSS vulnerability if used in a context\n * that will be interpreted as HTML by a browser, e.g. when assigning to\n * element.innerHTML.\n */\nexport function trustedHTMLFromString(html: string): TrustedHTML|string {\n  return getPolicy()?.createHTML(html) || html;\n}\n\n/**\n * Unsafely promote a string to a TrustedScript, falling back to strings when\n * Trusted Types are not available.\n * @security In particular, it must be assured that the provided string will\n * never cause an XSS vulnerability if used in a context that will be\n * interpreted and executed as a script by a browser, e.g. when calling eval.\n */\nexport function trustedScriptFromString(script: string): TrustedScript|string {\n  return getPolicy()?.createScript(script) || script;\n}\n\n/**\n * Unsafely promote a string to a TrustedScriptURL, falling back to strings\n * when Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that the\n * provided string will never cause an XSS vulnerability if used in a context\n * that will cause a browser to load and execute a resource, e.g. when\n * assigning to script.src.\n */\nexport function trustedScriptURLFromString(url: string): TrustedScriptURL|string {\n  return getPolicy()?.createScriptURL(url) || url;\n}\n\n/**\n * Unsafely call the Function constructor with the given string arguments. It\n * is only available in development mode, and should be stripped out of\n * production code.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only called from development code, as use in production code can lead to\n * XSS vulnerabilities.\n */\nexport function newTrustedFunctionForDev(...args: string[]): Function {\n  if (typeof ngDevMode === 'undefined') {\n    throw new Error('newTrustedFunctionForDev should never be called in production');\n  }\n  if (!global.trustedTypes) {\n    // In environments that don't support Trusted Types, fall back to the most\n    // straightforward implementation:\n    return new Function(...args);\n  }\n\n  // Chrome currently does not support passing TrustedScript to the Function\n  // constructor. The following implements the workaround proposed on the page\n  // below, where the Chromium bug is also referenced:\n  // https://github.com/w3c/webappsec-trusted-types/wiki/Trusted-Types-for-function-constructor\n  const fnArgs = args.slice(0, -1).join(',');\n  const fnBody = args[args.length - 1];\n  const body = `(function anonymous(${fnArgs}\n) { ${fnBody}\n})`;\n\n  // Using eval directly confuses the compiler and prevents this module from\n  // being stripped out of JS binaries even if not used. The global['eval']\n  // indirection fixes that.\n  const fn = global['eval'](trustedScriptFromString(body) as string) as Function;\n  if (fn.bind === undefined) {\n    // Workaround for a browser bug that only exists in Chrome 83, where passing\n    // a TrustedScript to eval just returns the TrustedScript back without\n    // evaluating it. In that case, fall back to the most straightforward\n    // implementation:\n    return new Function(...args);\n  }\n\n  // To completely mimic the behavior of calling \"new Function\", two more\n  // things need to happen:\n  // 1. Stringifying the resulting function should return its source code\n  fn.toString = () => body;\n  // 2. When calling the resulting function, `this` should refer to `global`\n  return fn.bind(global);\n\n  // When Trusted Types support in Function constructors is widely available,\n  // the implementation of this function can be simplified to:\n  // return new Function(...args.map(a => trustedScriptFromString(a)));\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @fileoverview\n * A module to facilitate use of a Trusted Types policy internally within\n * Angular specifically for bypassSecurityTrust* and custom sanitizers. It\n * lazily constructs the Trusted Types policy, providing helper utilities for\n * promoting strings to Trusted Types. When Trusted Types are not available,\n * strings are used as a fallback.\n * @security All use of this module is security-sensitive and should go through\n * security review.\n */\n\nimport {global} from '../global';\nimport {TrustedHTML, TrustedScript, TrustedScriptURL, TrustedTypePolicy, TrustedTypePolicyFactory} from './trusted_type_defs';\n\n/**\n * The Trusted Types policy, or null if Trusted Types are not\n * enabled/supported, or undefined if the policy has not been created yet.\n */\nlet policy: TrustedTypePolicy|null|undefined;\n\n/**\n * Returns the Trusted Types policy, or null if Trusted Types are not\n * enabled/supported. The first call to this function will create the policy.\n */\nfunction getPolicy(): TrustedTypePolicy|null {\n  if (policy === undefined) {\n    policy = null;\n    if (global.trustedTypes) {\n      try {\n        policy = (global.trustedTypes as TrustedTypePolicyFactory)\n                     .createPolicy('angular#unsafe-bypass', {\n                       createHTML: (s: string) => s,\n                       createScript: (s: string) => s,\n                       createScriptURL: (s: string) => s,\n                     });\n      } catch {\n        // trustedTypes.createPolicy throws if called with a name that is\n        // already registered, even in report-only mode. Until the API changes,\n        // catch the error not to break the applications functionally. In such\n        // cases, the code will fall back to using strings.\n      }\n    }\n  }\n  return policy;\n}\n\n/**\n * Unsafely promote a string to a TrustedHTML, falling back to strings when\n * Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only passed strings that come directly from custom sanitizers or the\n * bypassSecurityTrust* functions.\n */\nexport function trustedHTMLFromStringBypass(html: string): TrustedHTML|string {\n  return getPolicy()?.createHTML(html) || html;\n}\n\n/**\n * Unsafely promote a string to a TrustedScript, falling back to strings when\n * Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only passed strings that come directly from custom sanitizers or the\n * bypassSecurityTrust* functions.\n */\nexport function trustedScriptFromStringBypass(script: string): TrustedScript|string {\n  return getPolicy()?.createScript(script) || script;\n}\n\n/**\n * Unsafely promote a string to a TrustedScriptURL, falling back to strings\n * when Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only passed strings that come directly from custom sanitizers or the\n * bypassSecurityTrust* functions.\n */\nexport function trustedScriptURLFromStringBypass(url: string): TrustedScriptURL|string {\n  return getPolicy()?.createScriptURL(url) || url;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nexport const enum BypassType {\n  Url = 'URL',\n  Html = 'HTML',\n  ResourceUrl = 'ResourceURL',\n  Script = 'Script',\n  Style = 'Style',\n}\n\n/**\n * Marker interface for a value that's safe to use in a particular context.\n *\n * @publicApi\n */\nexport interface SafeValue {}\n\n/**\n * Marker interface for a value that's safe to use as HTML.\n *\n * @publicApi\n */\nexport interface SafeHtml extends SafeValue {}\n\n/**\n * Marker interface for a value that's safe to use as style (CSS).\n *\n * @publicApi\n */\nexport interface SafeStyle extends SafeValue {}\n\n/**\n * Marker interface for a value that's safe to use as JavaScript.\n *\n * @publicApi\n */\nexport interface SafeScript extends SafeValue {}\n\n/**\n * Marker interface for a value that's safe to use as a URL linking to a document.\n *\n * @publicApi\n */\nexport interface SafeUrl extends SafeValue {}\n\n/**\n * Marker interface for a value that's safe to use as a URL to load executable code from.\n *\n * @publicApi\n */\nexport interface SafeResourceUrl extends SafeValue {}\n\n\nabstract class SafeValueImpl implements SafeValue {\n  constructor(public changingThisBreaksApplicationSecurity: string) {}\n\n  abstract getTypeName(): string;\n\n  toString() {\n    return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity}` +\n        ` (see https://g.co/ng/security#xss)`;\n  }\n}\n\nclass SafeHtmlImpl extends SafeValueImpl implements SafeHtml {\n  override getTypeName() {\n    return BypassType.Html;\n  }\n}\nclass SafeStyleImpl extends SafeValueImpl implements SafeStyle {\n  override getTypeName() {\n    return BypassType.Style;\n  }\n}\nclass SafeScriptImpl extends SafeValueImpl implements SafeScript {\n  override getTypeName() {\n    return BypassType.Script;\n  }\n}\nclass SafeUrlImpl extends SafeValueImpl implements SafeUrl {\n  override getTypeName() {\n    return BypassType.Url;\n  }\n}\nclass SafeResourceUrlImpl extends SafeValueImpl implements SafeResourceUrl {\n  override getTypeName() {\n    return BypassType.ResourceUrl;\n  }\n}\n\nexport function unwrapSafeValue(value: SafeValue): string;\nexport function unwrapSafeValue<T>(value: T): T;\nexport function unwrapSafeValue<T>(value: T|SafeValue): T {\n  return value instanceof SafeValueImpl ? value.changingThisBreaksApplicationSecurity as any as T :\n                                          value as any as T;\n}\n\n\nexport function allowSanitizationBypassAndThrow(\n    value: any, type: BypassType.Html): value is SafeHtml;\nexport function allowSanitizationBypassAndThrow(\n    value: any, type: BypassType.ResourceUrl): value is SafeResourceUrl;\nexport function allowSanitizationBypassAndThrow(\n    value: any, type: BypassType.Script): value is SafeScript;\nexport function allowSanitizationBypassAndThrow(\n    value: any, type: BypassType.Style): value is SafeStyle;\nexport function allowSanitizationBypassAndThrow(value: any, type: BypassType.Url): value is SafeUrl;\nexport function allowSanitizationBypassAndThrow(value: any, type: BypassType): boolean;\nexport function allowSanitizationBypassAndThrow(value: any, type: BypassType): boolean {\n  const actualType = getSanitizationBypassType(value);\n  if (actualType != null && actualType !== type) {\n    // Allow ResourceURLs in URL contexts, they are strictly more trusted.\n    if (actualType === BypassType.ResourceUrl && type === BypassType.Url) return true;\n    throw new Error(\n        `Required a safe ${type}, got a ${actualType} (see https://g.co/ng/security#xss)`);\n  }\n  return actualType === type;\n}\n\nexport function getSanitizationBypassType(value: any): BypassType|null {\n  return value instanceof SafeValueImpl && value.getTypeName() as BypassType || null;\n}\n\n/**\n * Mark `html` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link htmlSanitizer} to be trusted implicitly.\n *\n * @param trustedHtml `html` string which needs to be implicitly trusted.\n * @returns a `html` which has been branded to be implicitly trusted.\n */\nexport function bypassSanitizationTrustHtml(trustedHtml: string): SafeHtml {\n  return new SafeHtmlImpl(trustedHtml);\n}\n/**\n * Mark `style` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link styleSanitizer} to be trusted implicitly.\n *\n * @param trustedStyle `style` string which needs to be implicitly trusted.\n * @returns a `style` hich has been branded to be implicitly trusted.\n */\nexport function bypassSanitizationTrustStyle(trustedStyle: string): SafeStyle {\n  return new SafeStyleImpl(trustedStyle);\n}\n/**\n * Mark `script` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link scriptSanitizer} to be trusted implicitly.\n *\n * @param trustedScript `script` string which needs to be implicitly trusted.\n * @returns a `script` which has been branded to be implicitly trusted.\n */\nexport function bypassSanitizationTrustScript(trustedScript: string): SafeScript {\n  return new SafeScriptImpl(trustedScript);\n}\n/**\n * Mark `url` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link urlSanitizer} to be trusted implicitly.\n *\n * @param trustedUrl `url` string which needs to be implicitly trusted.\n * @returns a `url`  which has been branded to be implicitly trusted.\n */\nexport function bypassSanitizationTrustUrl(trustedUrl: string): SafeUrl {\n  return new SafeUrlImpl(trustedUrl);\n}\n/**\n * Mark `url` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link resourceUrlSanitizer} to be trusted implicitly.\n *\n * @param trustedResourceUrl `url` string which needs to be implicitly trusted.\n * @returns a `url` which has been branded to be implicitly trusted.\n */\nexport function bypassSanitizationTrustResourceUrl(trustedResourceUrl: string): SafeResourceUrl {\n  return new SafeResourceUrlImpl(trustedResourceUrl);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {trustedHTMLFromString} from '../util/security/trusted_types';\n\n/**\n * This helper is used to get hold of an inert tree of DOM elements containing dirty HTML\n * that needs sanitizing.\n * Depending upon browser support we use one of two strategies for doing this.\n * Default: DOMParser strategy\n * Fallback: InertDocument strategy\n */\nexport function getInertBodyHelper(defaultDoc: Document): InertBodyHelper {\n  const inertDocumentHelper = new InertDocumentHelper(defaultDoc);\n  return isDOMParserAvailable() ? new DOMParserHelper(inertDocumentHelper) : inertDocumentHelper;\n}\n\nexport interface InertBodyHelper {\n  /**\n   * Get an inert DOM element containing DOM created from the dirty HTML string provided.\n   */\n  getInertBodyElement: (html: string) => HTMLElement | null;\n}\n\n/**\n * Uses DOMParser to create and fill an inert body element.\n * This is the default strategy used in browsers that support it.\n */\nclass DOMParserHelper implements InertBodyHelper {\n  constructor(private inertDocumentHelper: InertBodyHelper) {}\n\n  getInertBodyElement(html: string): HTMLElement|null {\n    // We add these extra elements to ensure that the rest of the content is parsed as expected\n    // e.g. leading whitespace is maintained and tags like `<meta>` do not get hoisted to the\n    // `<head>` tag. Note that the `<body>` tag is closed implicitly to prevent unclosed tags\n    // in `html` from consuming the otherwise explicit `</body>` tag.\n    html = '<body><remove></remove>' + html;\n    try {\n      const body = new window.DOMParser()\n                       .parseFromString(trustedHTMLFromString(html) as string, 'text/html')\n                       .body as HTMLBodyElement;\n      if (body === null) {\n        // In some browsers (e.g. Mozilla/5.0 iPad AppleWebKit Mobile) the `body` property only\n        // becomes available in the following tick of the JS engine. In that case we fall back to\n        // the `inertDocumentHelper` instead.\n        return this.inertDocumentHelper.getInertBodyElement(html);\n      }\n      body.removeChild(body.firstChild!);\n      return body;\n    } catch {\n      return null;\n    }\n  }\n}\n\n/**\n * Use an HTML5 `template` element, if supported, or an inert body element created via\n * `createHtmlDocument` to create and fill an inert DOM element.\n * This is the fallback strategy if the browser does not support DOMParser.\n */\nclass InertDocumentHelper implements InertBodyHelper {\n  private inertDocument: Document;\n\n  constructor(private defaultDoc: Document) {\n    this.inertDocument = this.defaultDoc.implementation.createHTMLDocument('sanitization-inert');\n\n    if (this.inertDocument.body == null) {\n      // usually there should be only one body element in the document, but IE doesn't have any, so\n      // we need to create one.\n      const inertHtml = this.inertDocument.createElement('html');\n      this.inertDocument.appendChild(inertHtml);\n      const inertBodyElement = this.inertDocument.createElement('body');\n      inertHtml.appendChild(inertBodyElement);\n    }\n  }\n\n  getInertBodyElement(html: string): HTMLElement|null {\n    // Prefer using <template> element if supported.\n    const templateEl = this.inertDocument.createElement('template');\n    if ('content' in templateEl) {\n      templateEl.innerHTML = trustedHTMLFromString(html) as string;\n      return templateEl;\n    }\n\n    // Note that previously we used to do something like `this.inertDocument.body.innerHTML = html`\n    // and we returned the inert `body` node. This was changed, because IE seems to treat setting\n    // `innerHTML` on an inserted element differently, compared to one that hasn't been inserted\n    // yet. In particular, IE appears to split some of the text into multiple text nodes rather\n    // than keeping them in a single one which ends up messing with Ivy's i18n parsing further\n    // down the line. This has been worked around by creating a new inert `body` and using it as\n    // the root node in which we insert the HTML.\n    const inertBody = this.inertDocument.createElement('body');\n    inertBody.innerHTML = trustedHTMLFromString(html) as string;\n\n    // Support: IE 11 only\n    // strip custom-namespaced attributes on IE<=11\n    if ((this.defaultDoc as any).documentMode) {\n      this.stripCustomNsAttrs(inertBody);\n    }\n\n    return inertBody;\n  }\n\n  /**\n   * When IE11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1'\n   * attribute to declare ns1 namespace and prefixes the attribute with 'ns1' (e.g.\n   * 'ns1:xlink:foo').\n   *\n   * This is undesirable since we don't want to allow any of these custom attributes. This method\n   * strips them all.\n   */\n  private stripCustomNsAttrs(el: Element) {\n    const elAttrs = el.attributes;\n    // loop backwards so that we can support removals.\n    for (let i = elAttrs.length - 1; 0 < i; i--) {\n      const attrib = elAttrs.item(i);\n      const attrName = attrib!.name;\n      if (attrName === 'xmlns:ns1' || attrName.indexOf('ns1:') === 0) {\n        el.removeAttribute(attrName);\n      }\n    }\n    let childNode = el.firstChild as Node | null;\n    while (childNode) {\n      if (childNode.nodeType === Node.ELEMENT_NODE) this.stripCustomNsAttrs(childNode as Element);\n      childNode = childNode.nextSibling;\n    }\n  }\n}\n\n/**\n * We need to determine whether the DOMParser exists in the global context and\n * supports parsing HTML; HTML parsing support is not as wide as other formats, see\n * https://developer.mozilla.org/en-US/docs/Web/API/DOMParser#Browser_compatibility.\n *\n * @suppress {uselessCode}\n */\nexport function isDOMParserAvailable() {\n  try {\n    return !!new window.DOMParser().parseFromString(\n        trustedHTMLFromString('') as string, 'text/html');\n  } catch {\n    return false;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n/**\n * A pattern that recognizes a commonly useful subset of URLs that are safe.\n *\n * This regular expression matches a subset of URLs that will not cause script\n * execution if used in URL context within a HTML document. Specifically, this\n * regular expression matches if (comment from here on and regex copied from\n * Soy's EscapingConventions):\n * (1) Either an allowed protocol (http, https, mailto or ftp).\n * (2) or no protocol.  A protocol must be followed by a colon. The below\n *     allows that by allowing colons only after one of the characters [/?#].\n *     A colon after a hash (#) must be in the fragment.\n *     Otherwise, a colon after a (?) must be in a query.\n *     Otherwise, a colon after a single solidus (/) must be in a path.\n *     Otherwise, a colon after a double solidus (//) must be in the authority\n *     (before port).\n *\n * The pattern disallows &, used in HTML entity declarations before\n * one of the characters in [/?#]. This disallows HTML entities used in the\n * protocol name, which should never happen, e.g. \"h&#116;tp\" for \"http\".\n * It also disallows HTML entities in the first path part of a relative path,\n * e.g. \"foo&lt;bar/baz\".  Our existing escaping functions should not produce\n * that. More importantly, it disallows masking of a colon,\n * e.g. \"javascript&#58;...\".\n *\n * This regular expression was taken from the Closure sanitization library.\n */\nconst SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi;\n\n/* A pattern that matches safe srcset values */\nconst SAFE_SRCSET_PATTERN = /^(?:(?:https?|file):|[^&:/?#]*(?:[/?#]|$))/gi;\n\n/** A pattern that matches safe data URLs. Only matches image, video and audio types. */\nconst DATA_URL_PATTERN =\n    /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\\/]+=*$/i;\n\nexport function _sanitizeUrl(url: string): string {\n  url = String(url);\n  if (url.match(SAFE_URL_PATTERN) || url.match(DATA_URL_PATTERN)) return url;\n\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    console.warn(`WARNING: sanitizing unsafe URL value ${url} (see https://g.co/ng/security#xss)`);\n  }\n\n  return 'unsafe:' + url;\n}\n\nexport function sanitizeSrcset(srcset: string): string {\n  srcset = String(srcset);\n  return srcset.split(',').map((srcset) => _sanitizeUrl(srcset.trim())).join(', ');\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {TrustedHTML} from '../util/security/trusted_type_defs';\nimport {trustedHTMLFromString} from '../util/security/trusted_types';\nimport {getInertBodyHelper, InertBodyHelper} from './inert_body';\nimport {_sanitizeUrl, sanitizeSrcset} from './url_sanitizer';\n\nfunction tagSet(tags: string): {[k: string]: boolean} {\n  const res: {[k: string]: boolean} = {};\n  for (const t of tags.split(',')) res[t] = true;\n  return res;\n}\n\nfunction merge(...sets: {[k: string]: boolean}[]): {[k: string]: boolean} {\n  const res: {[k: string]: boolean} = {};\n  for (const s of sets) {\n    for (const v in s) {\n      if (s.hasOwnProperty(v)) res[v] = true;\n    }\n  }\n  return res;\n}\n\n// Good source of info about elements and attributes\n// https://html.spec.whatwg.org/#semantics\n// https://simon.html5.org/html-elements\n\n// Safe Void Elements - HTML5\n// https://html.spec.whatwg.org/#void-elements\nconst VOID_ELEMENTS = tagSet('area,br,col,hr,img,wbr');\n\n// Elements that you can, intentionally, leave open (and which close themselves)\n// https://html.spec.whatwg.org/#optional-tags\nconst OPTIONAL_E