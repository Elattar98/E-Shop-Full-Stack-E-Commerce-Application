er worker process to replace #${worker.id}...`);
        this.remainingRespawnAttempts--;
        cluster.fork();
      } else {
        throw new Error("All worker processes crashed and attempts to re-spawn them failed. Please check your system and ensure there is enough memory available.");
      }
    }
  }
  onWorkerMessage(workerId, msg) {
    if (msg.type === "ready") {
      this.onWorkerReady(workerId);
      return;
    }
    if (!this.taskAssignments.has(workerId)) {
      const knownWorkers = Array.from(this.taskAssignments.keys());
      throw new Error(`Received message from unknown worker #${workerId} (known workers: ${knownWorkers.join(", ")}): ${JSON.stringify(msg)}`);
    }
    switch (msg.type) {
      case "error":
        throw new Error(`Error on worker #${workerId}: ${msg.error}`);
      case "task-completed":
        return this.onWorkerTaskCompleted(workerId, msg);
      case "transformed-files":
        return this.onWorkerTransformedFiles(workerId, msg);
      case "update-package-json":
        return this.onWorkerUpdatePackageJson(workerId, msg);
      default:
        throw new Error(`Invalid message received from worker #${workerId}: ${JSON.stringify(msg)}`);
    }
  }
  onWorkerReady(workerId) {
    if (this.taskAssignments.has(workerId)) {
      throw new Error(`Invariant violated: Worker #${workerId} came online more than once.`);
    }
    if (this.processingStartTime === -1) {
      this.logger.debug("Processing tasks...");
      this.processingStartTime = Date.now();
    }
    this.taskAssignments.set(workerId, null);
    this.maybeDistributeWork();
  }
  onWorkerTaskCompleted(workerId, msg) {
    const assignment = this.taskAssignments.get(workerId) || null;
    if (assignment === null) {
      throw new Error(`Expected worker #${workerId} to have a task assigned, while handling message: ` + JSON.stringify(msg));
    }
    this.onTaskCompleted(assignment.task, msg.outcome, msg.message);
    this.taskQueue.markAsCompleted(assignment.task);
    this.taskAssignments.set(workerId, null);
    this.maybeDistributeWork();
  }
  onWorkerTransformedFiles(workerId, msg) {
    const assignment = this.taskAssignments.get(workerId) || null;
    if (assignment === null) {
      throw new Error(`Expected worker #${workerId} to have a task assigned, while handling message: ` + JSON.stringify(msg));
    }
    const oldFiles = assignment.files;
    const newFiles = msg.files;
    if (oldFiles !== void 0) {
      throw new Error(`Worker #${workerId} reported transformed files more than once.
  Old files (${oldFiles.length}): [${oldFiles.join(", ")}]
  New files (${newFiles.length}): [${newFiles.join(", ")}]
`);
    }
    assignment.files = newFiles;
  }
  onWorkerUpdatePackageJson(workerId, msg) {
    const assignment = this.taskAssignments.get(workerId) || null;
    if (assignment === null) {
      throw new Error(`Expected worker #${workerId} to have a task assigned, while handling message: ` + JSON.stringify(msg));
    }
    const entryPoint = assignment.task.entryPoint;
    const expectedPackageJsonPath = this.fileSystem.resolve(entryPoint.path, "package.json");
    if (expectedPackageJsonPath !== msg.packageJsonPath) {
      throw new Error(`Received '${msg.type}' message from worker #${workerId} for '${msg.packageJsonPath}', but was expecting '${expectedPackageJsonPath}' (based on task assignment).`);
    }
    this.pkgJsonUpdater.writeChanges(msg.changes, msg.packageJsonPath, entryPoint.packageJson);
  }
  stopWorkers() {
    const workers = Object.values(cluster.workers);
    this.logger.debug(`Stopping ${workers.length} workers...`);
    cluster.removeAllListeners();
    workers.forEach((worker) => worker.kill());
  }
  wrapEventHandler(fn) {
    return async (...args) => {
      try {
        await fn(...args);
      } catch (err) {
        this.finishedDeferred.reject(err);
      }
    };
  }
};
function getClusterWorkerScriptPath(fileSystem) {
  const requireFn = typeof __require !== "undefined" ? __require : module2.createRequire(__ESM_IMPORT_META_URL__);
  const workerScriptPath = requireFn.resolve("@angular/compiler-cli/ngcc/src/execution/cluster/ngcc_cluster_worker");
  return fileSystem.resolve(workerScriptPath);
}

// bazel-out/k8-fastbuild/bin/packages/compiler-cli/ngcc/src/execution/cluster/executor.mjs
var ClusterExecutor = class {
  constructor(workerCou