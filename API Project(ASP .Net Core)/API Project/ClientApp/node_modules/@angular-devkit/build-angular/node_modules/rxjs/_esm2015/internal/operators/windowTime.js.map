onst otherTask = candidateDependencies.get(entryPointPath);
        throw new Error(`Invariant violated: Multiple tasks are assigned generating typings for '${entryPointPath}':
  - ${stringifyTask(otherTask)}
  - ${stringifyTask(task)}`);
      }
      candidateDependencies.set(entryPointPath, task);
    } else {
      if (candidateDependencies.has(entryPointPath)) {
        const typingsTask = candidateDependencies.get(entryPointPath);
        const typingsTaskDependents = getDependentsSet(dependencies, typingsTask);
        typingsTaskDependents.add(task);
      }
    }
  });
  return dependencies;
}
function getDependentsSet(map, task) {
  if (!map.has(task)) {
    map.set(task, /* @__PURE__ */ new Set());
  }
  return map.get(task);
}
function getBlockedTasks(dependencies) {
  const blockedTasks = /* @__PURE__ */ new Map();
  for (const [dependency, dependents] of dependencies) {
    for (const dependent of dependents) {
      const dependentSet = getDependentsSet(blockedTasks, dependent);
      dependentSet.add(dependency);
    }
  }
  return blockedTasks;
}
function sortTasksByPriority(tasks, dependencies) {
  const priorityPerTask = /* @__PURE__ */ new Map();
  const computePriority = (task, idx) => [dependencies.has(task) ? dependencies.get(task).size : 0, idx];
  tasks.forEach((task, i) => priorityPerTask.set(task, computePriority(task, i)));
  return tasks.slice().sort((task1, task2) => {
    const [p1, idx1] = priorityPerTask.get(task1);
    const [p2, idx2] = priorityPerTask.get(task2);
    return p2 - p1 || idx1 - idx2;
  });
}

// bazel-out/k8-fastbuild/bin/packages/compiler-cli/ngcc/src/execution/cluster/utils.mjs
import cluster from "cluster";
var Deferred = class {
  constructor() {
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
  }
};
var sendMessageToMaster = (msg) => {
  if (cluster.isMaster) {
    throw new Error("Unable to send message to the master process: Already on the master process.");
  }
  return new Promise((resolve, reject) => {
    if (process.send === void 0) {
      throw new Error("Unable to send message to the master process: Missing `process.send()`.");
    }
    process.send(msg, (err) => err === null ? resolve() : reject(err));
  });
};
var sendMessageToWorker = (workerId, msg) => {
  if (!cluster.isMaster) {
    throw new Error("Unable to send message to worker process: Sender is not the master process.");
  }
  const worker = cluster.workers[workerId];
  if (worker === void 0 || worker.isDead() || !worker.isConnected()) {
    throw new Error("Unable to send message to worker process: Recipient does not exist or has disconnected.");
  }
  return new Promise((resolve, reject) => {
    worker.send(msg, void 0, (err) => err === null ? resolve() : reject(err));
  });
};

// bazel-out/k8-fastbuild/bin/packages/compiler-cli/ngcc/src/writing/package_json_updater.mjs
var PackageJsonUpdate = class {
  constructor(writeChangesImpl) {
    this.writeChangesImpl = writeChangesImpl;
    this.changes = [];
    this.applied = false;
  }
  addChange(propertyPath, value, positioning = "unimportant") {
    this.ensureNotApplied();
    this.changes.push([propertyPath, value, positioning]);
    return this;
  }
  writeChanges(packageJsonPath, parsedJson) {
    this.ensureNotApplied();
    this.ensureNotSynthesized(parsedJson);
    this.writeChangesImpl(this.changes, packageJsonPath, parsedJson);
    this.applied = true;
  }
  ensureNotApplied() {
    if (this.applied) {
      throw new Error("Trying to apply a `PackageJsonUpdate` that has already been applied.");
    }
  }
  ensureNotSynthesized(parsedJson) {
    if (parsedJson == null ? void 0 : parsedJson.synthesized) {
      throw new Error("Trying to update a non-existent (synthesized) `package.json` file.");
    }
  }
};
var DirectPackageJsonUpdater = class {
  constructor(fs) {
    this.fs = fs;
  }
  createUpdate() {
    return new PackageJsonUpdate((...args) => this.writeChanges(...args));
  }
  writeChanges(changes, packageJsonPath, preExistingParsedJson) {
    if (changes.length === 0) {
      throw new Error(`No changes to write to '${packageJsonPath}'.`);
    }
    const parsedJson = this.fs.exists(packageJsonPath) ? JSON.parse(this.fs.readFile(packageJsonPath)) : {};
    for (const [propPath, value, positioning] of changes) {
      if (propPath.length === 0) {
        throw new Error(`Missing property path for writing value to '${packageJsonPath}'.`);
      }
      applyChange(parsedJson, propPath, value, positioning);
      if (preExistingParsedJson) {
        applyChange(preExistingParsedJson, propPath, value, "unimportant");
      }
    }
    this.fs.ensureDir(dirname(packageJsonPath));
    this.fs.writeFile(packageJsonPath, `${JSON.stringify(parsedJson, null, 2)}
`);
  }
};
function applyChange(ctx, propPath, value, positioning) {
  const lastPropIdx = propPath.length - 1;
  const lastProp = propPath[lastPropIdx];
  for (let i = 0; i < lastPropIdx; i++) {
    const key = propPath[i];
    const newCtx = ctx.hasO