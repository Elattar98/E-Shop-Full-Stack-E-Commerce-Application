mplateTypeChecker` for retrieving `Symbol`s. For example, as an optimization,
     * the TCB will not generate variable declaration statements for directives that have no
     * references, inputs, or outputs. However, the `TemplateTypeChecker` always needs these
     * statements to be present in order to provide `ts.Symbol`s and `ts.Type`s for the directives.
     *
     * When set to `false`, enables TCB optimizations for template diagnostics.
     * When set to `true`, ensures all information required by `TemplateTypeChecker` to
     * retrieve symbols for template nodes is available in the TCB.
     */
    enableTemplateTypeChecker: boolean;
    /**
     * Whether to include type information from pipes in the type-checking operation.
     *
     * If this is `true`, then the pipe's type signature for `transform()` will be used to check the
     * usage of the pipe. If this is `false`, then the result of applying a pipe will be `any`, and
     * the types of the pipe's value and arguments will not be matched against the `transform()`
     * method.
     */
    checkTypeOfPipes: boolean;
    /**
     * Whether to narrow the types of template contexts.
     */
    applyTemplateContextGuards: boolean;
    /**
     * Whether to use a strict type for null-safe navigation operations.
     *
     * If this is `false`, then the return type of `a?.b` or `a?()` will be `any`. If set to `true`,
     * then the return type of `a?.b` for example will be the same as the type of the ternary
     * expression `a != null ? a.b : a`.
     */
    strictSafeNavigationTypes: boolean;
    /**
     * Whether to descend into template bodies and check any bindings there.
     */
    checkTemplateBodies: boolean;
    /**
     * Whether to always apply DOM schema checks in template bodies, independently of the
     * `checkTemplateBodies` setting.
     */
    alwaysCheckSchemaInTemplateBodies: boolean;
    /**
     * Whether to check resolvable queries.
     *
     * This is currently an unsupported feature.
     */
    checkQueries: false;
    /**
     * Whether to use any generic types of the context component.
     *
     * If this is `true`, then if the context component has generic types, those will be mirrored in
     * the template type-checking context. If `false`, any generic type parameters of the context
     * component will be set to `any` during type-checking.
     */
    useContextGenericType: boolean;
    /**
     * Whether or not to infer types for object and array literals in the template.
     *
     * If this is `true`, then the type of an object or an array literal in the template will be the
     * same type that TypeScript would infer if the literal appeared in code. If `false`, then such
     * literals are cast to `any` when declared.
     */
    strictLiteralTypes: boolean;
    /**
     * Whether to use inline type constructors.
     *
     * If this is `true`, create inline type constructors when required. For example, if a type
     * constructor's parameters has private types, it cannot be created normally, so we inline it in
     * the directives definition file.
     *
     * If false, do not create inline type constructors. Fall back to using `any` type for
     * constructors that normally require inlining.
     *
     * This option requires the environment to support inlining. If the environment does not support
     * inlining, this must be set to `false`.
     */
    useInlineTypeConstructors: boolean;
    /**
     * Whether or not to produce diagnostic suggestions in cases where the compiler could have
     * inferred a better type for a construct, but was prevented from doing so by the current type
     * checking configuration.
     *
     * For example, if the compiler could have used a template context guard to infer a better type
     * for a structural directive's context and `let-` variables, but the user is in
     * `fullTemplateTypeCheck` mode and such guards are therefore disabled.
     *
     * This mode is useful for clients like the Language Service which want to inform users of
     * opp