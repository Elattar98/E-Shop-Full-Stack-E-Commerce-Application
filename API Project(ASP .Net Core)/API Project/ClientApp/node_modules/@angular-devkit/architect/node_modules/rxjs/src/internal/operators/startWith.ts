 chars.$LF;\n    case chars.$f:\n      return chars.$FF;\n    case chars.$r:\n      return chars.$CR;\n    case chars.$t:\n      return chars.$TAB;\n    case chars.$v:\n      return chars.$VTAB;\n    default:\n      return code;\n  }\n}\n\nfunction parseIntAutoRadix(text: string): number {\n  const result: number = parseInt(text);\n  if (isNaN(result)) {\n    throw new Error('Invalid integer literal when parsing ' + text);\n  }\n  return result;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as chars from '../chars';\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from '../ml_parser/interpolation_config';\nimport {InterpolatedAttributeToken, InterpolatedTextToken, TokenType as MlParserTokenType} from '../ml_parser/tokens';\n\nimport {AbsoluteSourceSpan, AST, ASTWithSource, Binary, BindingPipe, Call, Chain, Conditional, EmptyExpr, ExpressionBinding, ImplicitReceiver, Interpolation, KeyedRead, KeyedWrite, LiteralArray, LiteralMap, LiteralMapKey, LiteralPrimitive, NonNullAssert, ParserError, ParseSpan, PrefixNot, PropertyRead, PropertyWrite, RecursiveAstVisitor, SafeCall, SafeKeyedRead, SafePropertyRead, TemplateBinding, TemplateBindingIdentifier, ThisReceiver, Unary, VariableBinding} from './ast';\nimport {EOF, Lexer, Token, TokenType} from './lexer';\n\nexport interface InterpolationPiece {\n  text: string;\n  start: number;\n  end: number;\n}\nexport class SplitInterpolation {\n  constructor(\n      public strings: InterpolationPiece[], public expressions: InterpolationPiece[],\n      public offsets: number[]) {}\n}\n\nexport class TemplateBindingParseResult {\n  constructor(\n      public templateBindings: TemplateBinding[], public warnings: string[],\n      public errors: ParserError[]) {}\n}\n\n/**\n * Represents the possible parse modes to be used as a bitmask.\n */\nexport const enum ParseFlags {\n  None = 0,\n\n  /**\n   * Whether an output binding is being parsed.\n   */\n  Action = 1 << 0,\n\n  /**\n   * Whether an assignment event is being parsed, i.e. an expression originating from\n   * two-way-binding aka banana-in-a-box syntax.\n   */\n  AssignmentEvent = 1 << 1,\n}\n\nexport class Parser {\n  private errors: ParserError[] = [];\n\n  constructor(private _lexer: Lexer) {}\n\n  parseAction(\n      input: string, isAssignmentEvent: boolean, location: string, absoluteOffset: number,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n    this._checkNoInterpolation(input, location, interpolationConfig);\n    const sourceToLex = this._stripComments(input);\n    const tokens = this._lexer.tokenize(sourceToLex);\n    let flags = ParseFlags.Action;\n    if (isAssignmentEvent) {\n      flags |= ParseFlags.AssignmentEvent;\n    }\n    const ast =\n        new _ParseAST(input, location, absoluteOffset, tokens, flags, this.errors, 0).parseChain();\n    return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n  }\n\n  parseBinding(\n      input: string, location: string, absoluteOffset: number,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n    const ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);\n    return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n  }\n\n  private checkSimpleExpression(ast: AST): string[] {\n    const checker = new SimpleExpressionChecker();\n    ast.visit(checker);\n    return checker.errors;\n  }\n\n  parseSimpleBinding(\n      input: string, location: string, absoluteOffset: number,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n    const ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);\n    const errors = this.checkSimpleExpression(ast);\n    if (errors.length > 0) {\n      this._reportError(\n          `Host binding expression cannot contain ${errors.join(' ')}`, input, location);\n    }\n    return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n  }\n\n  private _reportError(message: string, input: string, errLocation: string, ctxLocation?: string) {\n    this.errors.push(new ParserError(message, input, errLocation, ctxLocation));\n  }\n\n  private _parseBindingAst(\n      input: