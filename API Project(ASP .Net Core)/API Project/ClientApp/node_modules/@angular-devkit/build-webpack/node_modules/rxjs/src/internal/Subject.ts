ess(ast, leftMostSafe, mode);\n    } else {\n      return convertToStatementIfNeeded(\n          mode,\n          this._visit(ast.receiver, _Mode.Expression).key(this._visit(ast.key, _Mode.Expression)));\n    }\n  }\n\n  visitKeyedWrite(ast: cdAst.KeyedWrite, mode: _Mode): any {\n    const obj: o.Expression = this._visit(ast.receiver, _Mode.Expression);\n    const key: o.Expression = this._visit(ast.key, _Mode.Expression);\n    const value: o.Expression = this._visit(ast.value, _Mode.Expression);\n\n    if (obj === this._implicitReceiver) {\n      this._localResolver.maybeRestoreView();\n    }\n\n    return convertToStatementIfNeeded(mode, obj.key(key).set(value));\n  }\n\n  visitLiteralArray(ast: cdAst.LiteralArray, mode: _Mode): any {\n    throw new Error(`Illegal State: literal arrays should have been converted into functions`);\n  }\n\n  visitLiteralMap(ast: cdAst.LiteralMap, mode: _Mode): any {\n    throw new Error(`Illegal State: literal maps should have been converted into functions`);\n  }\n\n  visitLiteralPrimitive(ast: cdAst.LiteralPrimitive, mode: _Mode): any {\n    // For literal values of null, undefined, true, or false allow type interference\n    // to infer the type.\n    const type =\n        ast.value === null || ast.value === undefined || ast.value === true || ast.value === true ?\n        o.INFERRED_TYPE :\n        undefined;\n    return convertToStatementIfNeeded(\n        mode, o.literal(ast.value, type, this.convertSourceSpan(ast.span)));\n  }\n\n  private _getLocal(name: string, receiver: cdAst.AST): o.Expression|null {\n    if (this._localResolver.globals?.has(name) && receiver instanceof cdAst.ThisReceiver) {\n      return null;\n    }\n\n    return this._localResolver.getLocal(name);\n  }\n\n  visitPrefixNot(ast: cdAst.PrefixNot, mode: _Mode): any {\n    return convertToStatementIfNeeded(mode, o.not(this._visit(ast.expression, _Mode.Expression)));\n  }\n\n  visitNonNullAssert(ast: cdAst.NonNullAssert, mode: _Mode): any {\n    return convertToStatementIfNeeded(mode, this._visit(ast.expression, _Mode.Expression));\n  }\n\n  visitPropertyRead(ast: cdAst.PropertyRead, mode: _Mode): any {\n    const leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    } else {\n      let result: any = null;\n      const prevUsesImplicitReceiver = this.usesImplicitReceiver;\n      const receiver = this._visit(ast.receiver, _Mode.Expression);\n      if (receiver === this._implicitReceiver) {\n        result = this._getLocal(ast.name, ast.receiver);\n        if (result) {\n          // Restore the previous \"usesImplicitReceiver\" state since the implicit\n          // receiver has been replaced with a resolved local expression.\n          this.usesImplicitReceiver = prevUsesImplicitReceiver;\n          this.addImplicitReceiverAccess(ast.name);\n        }\n      }\n      if (result == null) {\n        result = receiver.prop(ast.name, this.convertSourceSpan(ast.span));\n      }\n      return convertToStatementIfNeeded(mode, result);\n    }\n  }\n\n  visitPropertyWrite(ast: cdAst.PropertyWrite, mode: _Mode): any {\n    const receiver: o.Expression = this._visit(ast.receiver, _Mode.Expression);\n    const prevUsesImplicitReceiver = this.usesImplicitReceiver;\n\n    let varExpr: o.ReadPropExpr|null = null;\n    if (receiver === this._implicitReceiver) {\n      const localExpr = this._getLocal(ast.name, ast.receiver);\n      if (localExpr) {\n        if (localExpr instanceof o.ReadPropExpr) {\n          // If the local variable is a property read expression, it's a reference\n          // to a 'context.property' value and will be used as the target of the\n          // write expression.\n          varExpr = localExpr;\n          // Restore the previous \"usesImplicitReceiver\" state since the implicit\n          // receiver has been replaced with a resolved local expression.\n          this.usesImplicitReceiver = prevUsesImplicitReceiver;\n          this.addImplicitReceiverAccess(ast.name);\n        } else {\n          // Otherwise it's an error.\n          const receiver = ast.name;\n          const value = (ast.value instanceof cdAst.PropertyRead) ? ast.value.name : undefined;\n          throw new Error(`Cannot assign value \"${value}\" to template variable \"${\n              receiver}\". Template variables are read-only.`);\n        }\n      }\n    }\n    // If no local expression could be produced, use the original receiver's\n    // property as the target.\n    if (varExpr === null) {\n      varExpr = receiver.prop(ast.name, this.convertSourceSpan(ast.span));\n    }\n    return convertToStatementIfNeeded(mode, varExpr.set(this._visit(ast.value, _Mode.Expression)));\n  }\n\n  visitSafePropertyRead(ast: cdAst.SafePropertyRead, mode: _Mode): any {\n    return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n  }\n\n  visitSafeKeyedRead(ast: