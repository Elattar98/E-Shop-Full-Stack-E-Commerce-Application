.\n   *\n   * This form of emit supports JIT and can be optimized away if the `ngJitMode` flag is set to\n   * false, which allows unused directives and pipes to be tree-shaken.\n   */\n  SideEffect,\n\n  /**\n   * Don't generate selector scopes at all.\n   *\n   * This is useful for contexts where JIT support is known to be unnecessary.\n   */\n  Omit,\n}\n\n/**\n * Metadata required by the module compiler to generate a module def (`ɵmod`) for a type.\n */\nexport interface R3NgModuleMetadata {\n  /**\n   * An expression representing the module type being compiled.\n   */\n  type: R3Reference;\n\n  /**\n   * An expression representing the module type being compiled, intended for use within a class\n   * definition itself.\n   *\n   * This can differ from the outer `type` if the class is being compiled by ngcc and is inside\n   * an IIFE structure that uses a different name internally.\n   */\n  internalType: o.Expression;\n\n  /**\n   * An expression intended for use by statements that are adjacent (i.e. tightly coupled) to but\n   * not internal to a class definition.\n   *\n   * This can differ from the outer `type` if the class is being compiled by ngcc and is inside\n   * an IIFE structure that uses a different name internally.\n   */\n  adjacentType: o.Expression;\n\n  /**\n   * An array of expressions representing the bootstrap components specified by the module.\n   */\n  bootstrap: R3Reference[];\n\n  /**\n   * An array of expressions representing the directives and pipes declared by the module.\n   */\n  declarations: R3Reference[];\n\n  /**\n   * Those declarations which should be visible to downstream consumers. If not specified, all\n   * declarations are made visible to downstream consumers.\n   */\n  publicDeclarationTypes: o.Expression[]|null;\n\n  /**\n   * An array of expressions representing the imports of the module.\n   */\n  imports: R3Reference[];\n\n  /**\n   * Whether or not to include `imports` in generated type declarations.\n   */\n  includeImportTypes: boolean;\n\n  /**\n   * An array of expressions representing the exports of the module.\n   */\n  exports: R3Reference[];\n\n  /**\n   * How to emit the selector scope values (declarations, imports, exports).\n   */\n  selectorScopeMode: R3SelectorScopeMode;\n\n  /**\n   * Whether to generate closure wrappers for bootstrap, declarations, imports, and exports.\n   */\n  containsForwardDecls: boolean;\n\n  /**\n   * The set of schemas that declare elements to be allowed in the NgModule.\n   */\n  schemas: R3Reference[]|null;\n\n  /** Unique ID or expression representing the unique ID of an NgModule. */\n  id: o.Expression|null;\n}\n\n/**\n * The shape of the object literal that is passed to the `ɵɵdefineNgModule()` call.\n */\ninterface R3NgModuleDefMap {\n  /**\n   * An expression representing the module type being compiled.\n   */\n  type: o.Expression;\n  /**\n   * An expression evaluating to an array of expressions representing the bootstrap components\n   * specified by the module.\n   */\n  bootstrap?: o.Expression;\n  /**\n   * An expression evaluating to an array of expressions representing the directives and pipes\n   * declared by the module.\n   */\n  declarations?: o.Expression;\n  /**\n   * An expression evaluating to an array of expressions representing the imports of the module.\n   */\n  imports?: o.Expression;\n  /**\n   * An expression evaluating to an array of expressions representing the exports of the module.\n   */\n  exports?: o.Expression;\n  /**\n   * A literal array expression containing the schemas that declare elements to be allowed in the\n   * NgModule.\n   */\n  schemas?: o.LiteralArrayExpr;\n  /**\n   * An expression evaluating to the unique ID of an NgModule.\n   * */\n  id?: o.Expression;\n}\n\n/**\n * Construct an `R3NgModuleDef` for the given `R3NgModuleMetadata`.\n */\nexport function compileNgModule(meta: R3NgModuleMetadata): R3CompiledExpression {\n  const {\n    adjacentType,\n    internalType,\n    bootstrap,\n    declarations,\n    imports,\n    exports,\n    schemas,\n    containsForwardDecls,\n    selectorScopeMode,\n    id\n  } = meta;\n\n  const statements: o.Statement[] = [];\n  const definitionMap = new DefinitionMap<R3NgModuleDefMap>();\n  definitionMap.set('type', internalType);\n\n  if (bootstrap.length > 0) {\n    definitionMap.set('bootstrap', refsToArray(bootstrap, containsForwardDecls));\n  }\n\n  if (selectorScopeMode === R3SelectorScopeMode.Inline) {\n    // If requested to emit scope information inline, pass the `declarations`, `imports` and\n    // `exports` to the `ɵɵdefineNgModule()` call directly.\n\n    if (declarations.length > 0) {\n      definitionMap.set('declarations', refsToArray(declarations, containsForwardDecls));\n    }\n\n    if (imports.length > 0) {\n      definitionMap.set('imports', refsToArray(imports, containsForwardDecls));\n    }\n\n    if (exports.length > 0) {\n      definitionMap.set('exports', refsToArray(exports, containsForwardDecls));\n    }\n  } else if (selectorScopeMode === R3SelectorScopeMode.SideEffect) {\n    // In this mode, scope information is not passed into `ɵɵdefineNgModule` as it\n    // would prevent tree-shaking of the declarations, imports and exports references. Instead, it's\n    // patched onto the NgModule definition with a `ɵɵsetNgModuleScope` call that's guarded by the\n    // `ngJitMode` flag.\n    const setNgModuleScopeCall = generateSetNgModuleScopeCall(meta);\n    if (setNgModuleScopeCall !== null) {\n      statements.push(setNgModuleScopeCall);\n    }\n  } else {\n    // Selector scope emit was not requested, so skip it.\n  }\n\n  if (schemas !== null && schemas.length > 0) {\n    definitionMap.set('schemas', o.literalArr(schemas.map(ref => ref.value)));\n  }\n\n  if (id !== null) {\n    definitionMap.set('id', id);\n\n    // Generate a side-effectful call to register this NgModule by its id, as per the semantics of\n    // NgModule ids.\n    statements.push(o.importExpr(R3.registerNgModuleType).callFn([adjacentType, id]).toStmt());\n  }\n\n  const expression =\n      o.importExpr(R3.defineNgModule).callFn([definitionMap.toLiteralMap()], undefined, true);\n  const type = createNgModuleType(meta);\n\n  return {expression, type, statements};\n}\n\n/**\n * This function is used in JIT mode to generate the call to `ɵɵdefineNgModule()` from a call to\n * `ɵɵngDeclareNgModule()`.\n */\nexport function compileNgModuleDeclarationExpression(meta: R3DeclareNgModuleFacade): o.Expression {\n  const definitionMap = new DefinitionMap<R3NgModuleDefMap>();\n  definitionMap.set('type', new o.WrappedNodeExpr(meta.type));\n  if (meta.bootstrap !== undefined) {\n    definitionMap.set('bootstrap', new o.WrappedNodeExpr(meta.bootstrap));\n  }\n  if (meta.declarations !== undefined) {\n    definitionMap.set('declarations', new o.WrappedNodeExpr(meta.declarations));\n  }\n  if (meta.imports !== undefined) {\n    definitionMap.set('imports', new o.WrappedNodeExpr(meta.imports));\n  }\n  if (meta.exports !== undefined) {\n    definitionMap.set('exports', new o.WrappedNodeExpr(meta.exports));\n  }\n  if (meta.schemas !== undefined) {\n    definitionMap.set('schemas', new o.WrappedNodeExpr(meta.schemas));\n  }\n  if (meta.id !== undefined) {\n    definitionMap.set('id', new o.WrappedNodeExpr(meta.id));\n  }\n  return o.importExpr(R3.defineNgModule).callFn([definitionMap.toLiteralMap()]);\n}\n\nexport function createNgModuleType(\n    {type: moduleType, declarations, exports, imports, includeImportTypes, publicDeclarationTypes}:\n        R3NgModuleMetadata): o.ExpressionType {\n  return new o.ExpressionType(o.importExpr(R3.NgModuleDeclaration, [\n    new o.ExpressionType(moduleType.type),\n    publicDeclarationTypes === null ? tupleTypeOf(declarations) :\n                                      tupleOfTypes(publicDeclarationTypes),\n    includeImportTypes ? tupleTypeOf(imports) : o.NONE_TYPE,\n    tupleTypeOf(exports),\n  ]));\n}\n\n/**\n * Generates a function call to `ɵɵsetNgModuleScope` with all necessary information so that the\n * transitive module scope can be computed during runtime in JIT mode. This call is marked pure\n * such that the references to declarations, imports and exports may be elided causing these\n * symbols to become tree-shakeable.\n */\nfunction generateSetNgModuleScopeCall(meta: R3NgModuleMetadata): o.Statement|null {\n  const {adjacentType: moduleType, declarations, imports, exports, containsForwardDecls} = meta;\n\n  const scopeMap = new DefinitionMap<\n      {declarations: o.Expression, imports: o.Expression, exports: o.Expression}>();\n\n  if (declarations.length > 0) {\n    scopeMap.set('declarations', refsToArray(declarations, containsForwardDecls));\n  }\n\n  if (imports.length > 0) {\n    scopeMap.set('imports', refsToArray(imports, containsForwardDecls));\n  }\n\n  if (exports.length > 0) {\n    scopeMap.set('exports', refsToArray(exports, containsForwardDecls));\n  }\n\n  if (Object.keys(scopeMap.values).length === 0) {\n    return null;\n  }\n\n  // setNgModuleScope(...)\n  const fnCall = new o.InvokeFunctionExpr(\n      /* fn */ o.importExpr(R3.setNgModuleScope),\n      /* args */[moduleType, scopeMap.toLiteralMap()]);\n\n  // (ngJitMode guard) && setNgModuleScope(...)\n  const guardedCall = jitOnlyGuardedExpression(fnCall);\n\n  // function() { (ngJitMode guard) && setNgModuleScope(...); }\n  const iife = new o.FunctionExpr(\n      /* params */[],\n      /*