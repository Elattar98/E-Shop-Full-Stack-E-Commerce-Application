export type SourceMapSegment =
  | [number]
  | [number, number, number, number]
  | [number, number, number, number, number];
export type SourceMapLine = SourceMapSegment[];
export type SourceMapMappings = SourceMapLine[];

const comma = ','.charCodeAt(0);
const semicolon = ';'.charCodeAt(0);
const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
const intToChar = new Uint8Array(64); // 64 possible chars.
const charToInt = new Uint8Array(128); // z is 122 in ASCII

for (let i = 0; i < chars.length; i++) {
  const c = chars.charCodeAt(i);
  intToChar[i] = c;
  charToInt[c] = i;
}

// Provide a fallback for older environments.
const td =
  typeof TextDecoder !== 'undefined'
    ? /* #__PURE__ */ new TextDecoder()
    : typeof Buffer !== 'undefined'
    ? {
        decode(buf: Uint8Array) {
          const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
          return out.toString();
        },
      }
    : {
        decode(buf: Uint8Array) {
          let out = '';
          for (let i = 0; i < buf.length; i++) {
            out += String.fromCharCode(buf[i]);
          }
          return out;
        },
      };

export function decode(mappings: string): SourceMapMappings {
  const state: [number, number, number, number, number] = new Int32Array(5) as any;
  const decoded: SourceMapMappings = [];

  let index = 0;
  do {
    const semi = indexOf(mappings, index);
    const line: SourceMapLine = [];
    let sorted = true;
    let lastCol = 0;
    state[0] = 0;

    for (let i = index; i < semi; i++) {
      let seg: SourceMapSegment;

      i = decodeInteger(mappings, i, state, 0); // genColumn
      const col = state[0];
      if (col < lastCol) sorted = false;
      lastCol = col;

      if (hasMoreVlq(mappings, i, semi)) {
        i = decodeInteger(mappings, i, state, 1); // sourcesIndex
        i = decodeInteger(mappings, i, state, 2); // sourceLine
        i = decodeInteger(mappings, i, state, 3); // sourceColumn

        if (hasMoreVlq(mappings, i, semi)) {
          i = decodeInteger(mappings, i, state, 4); // namesIndex
          seg = [col, state[1], state[2], state[3], state[4]];
        } else {
          seg = [col, state[1], state[2], state[3]];
        }
      } else {
        seg = [col];
      }

      line.push(seg);
    }

    if (!sorted) sort(line);
    decoded.push(line);
    index = semi + 1;
  } while (index <= mappings.length);

  return decoded;
}

function indexOf(mappin