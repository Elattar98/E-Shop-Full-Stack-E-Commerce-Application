 nodes will have parents unless:\n   *\n   * - They are the first node of a component or embedded view\n   * - They are dynamically created\n   */\n  parent: TElementNode|TElementContainerNode|null;\n  tViews: TView|TView[]|null;\n  projection: null;\n  value: null;\n}\n\n/** Static data for an <ng-container> */\nexport interface TElementContainerNode extends TNode {\n  /** Index in the LView[] array. */\n  index: number;\n  child: TElementNode|TTextNode|TContainerNode|TElementContainerNode|TProjectionNode|null;\n  parent: TElementNode|TElementContainerNode|null;\n  tViews: null;\n  projection: null;\n}\n\n/** Static data for an ICU expression */\nexport interface TIcuContainerNode extends TNode {\n  /** Index in the LView[] array. */\n  index: number;\n  child: null;\n  parent: TElementNode|TElementContainerNode|null;\n  tViews: null;\n  projection: null;\n  value: TIcu;\n}\n\n/** Static data for an LProjectionNode  */\nexport interface TProjectionNode extends TNode {\n  /** Index in the data[] array */\n  child: null;\n  /**\n   * Projection nodes will have parents unless they are the first node of a component\n   * or embedded view (which means their parent is in a different view and must be\n   * retrieved using LView.node).\n   */\n  parent: TElementNode|TElementContainerNode|null;\n  tViews: null;\n\n  /** Index of the projection node. (See TNode.projection for more info.) */\n  projection: number;\n  value: null;\n}\n\n/**\n * A union type representing all TNode types that can host a directive.\n */\nexport type TDirectiveHostNode = TElementNode|TContainerNode|TElementContainerNode;\n\n/**\n * This mapping is necessary so we can set input properties and output listeners\n * properly at runtime when property names are minified or aliased.\n *\n * Key: unminified / public input or output name\n * Value: array containing minified / internal name and related directive index\n *\n * The value must be an array to support inputs and outputs with the same name\n * on the same node.\n */\nexport type PropertyAliases = {\n  // This uses an object map because using the Map type would be too slow\n  [key: string]: PropertyAliasValue\n};\n\n/**\n * Store the runtime input or output names for all the directives.\n *\n * i+0: directive instance index\n * i+1: privateName\n *\n * e.g. [0, 'change-minified']\n */\nexport type PropertyAliasValue = (number|string)[];\n\n/**\n * This array contains information about input properties that\n * need to be set once from attribute data. It's ordered by\n * directive index (relative to element) so it's simple to\n * look up a specific directive's initial input data.\n *\n * Within each sub-array:\n *\n * i+0: attribute name\n * i+1: minified/internal input name\n * i+2: initial value\n *\n * If a directive on a node does not have any input properties\n * that should be set from attributes, its index is set to null\n * to avoid a sparse array.\n *\n * e.g. [null, ['role-min', 'minified-input', 'button']]\n */\nexport type InitialInputData = (InitialInputs|null)[];\n\n/**\n * Used by InitialInputData to store input properties\n * that should be set once from attributes.\n *\n * i+0: attribute name\n * i+1: minified/internal input name\n * i+2: initial value\n *\n * e.g. ['role-min', 'minified-input', 'button']\n */\nexport type InitialInputs = string[];\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n\n/**\n * Type representing a set of TNodes that can have local refs (`#foo`) placed on them.\n */\nexport type TNodeWithLocalRefs = TContainerNode|TElementNode|TElementContainerNode;\n\n/**\n * Type for a function that extracts a value for a local refs.\n * Example:\n * - `<div #nativeDivEl>` - `nativeDivEl` should point to the native `<div>` element;\n * - `<ng-template #tplRef>` - `tplRef` should point to the `TemplateRef` instance;\n */\nexport type LocalRefExtractor = (tNode: TNodeWithLocalRefs, currentView: LView) => any;\n\n/**\n * Returns `true` if the `TNode` has a directive which has `@Input()` for `class` binding.\n *\n * ```\n * <div my-dir [class]=\"exp\"></div>\n * ```\n * and\n * ```\n * @Directive({\n * })\n * class MyDirective {\n *   @Input()\n *   class: string;\n * }\n * ```\n *\n * In the above case it is necessary to write the reconciled styling information into the\n * directive's input.\n *\n * @param tNode\n */\nexport function hasClassInput(tNode: TNode) {\n  return (tNode.flags & TNodeFlags.hasClassInput) !== 0;\n}\n\n/**\n * Returns `true` if the `TNode` has a directive which has `@Input()` for `style` binding.\n *\n * ```\n * <div my-dir [style]=\"exp\"></div>\n * ```\n * and\n * ```\n * @Directive({\n * })\n * class MyDirective {\n *   @Input()\n *   class: string;\n * }\n * ```\n *\n * In the above case it is necessary to write the reconciled styling information into the\n * directive's input.\n *\n * @param tNode\n */\nexport function hasStyleInput(tNode: TNode) {\n  return (tNode.flags & TNodeFlags.hasStyleInput) !== 0;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDefined, throwError} from '../util/assert';\nimport {TNode, TNodeType, toTNodeTypeAsString} from './interfaces/node';\n\nexport function assertTNodeType(\n    tNode: TNode|null, expectedTypes: TNodeType, message?: string): void {\n  assertDefined(tNode, 'should be called with a TNode');\n  if ((tNode.type & expectedTypes) === 0) {\n    throwError(\n        message ||\n        `Expected [${toTNodeTypeAsString(expectedTypes)}] but got ${\n            toTNodeTypeAsString(tNode.type)}.`);\n  }\n}\n\nexport function assertPureTNodeType(type: TNodeType) {\n  if (!(type === TNodeType.Element ||           //\n        type === TNodeType.Text ||              //\n        type === TNodeType.Container ||         //\n        type === TNodeType.ElementContainer ||  //\n        type === TNodeType.Icu ||               //\n        type === TNodeType.Projection ||        //\n        type === TNodeType.Placeholder)) {\n    throwError(`Expected TNodeType to have only a single type selected, but got ${\n        toTNodeTypeAsString(type)}.`);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {CharCode} from '../../util/char_code';\nimport {AttributeMarker, TAttributes} from '../interfaces/node';\nimport {CssSelector} from '../interfaces/projection';\nimport {Renderer} from '../interfaces/renderer';\nimport {RElement} from '../interfaces/renderer_dom';\n\n\n\n/**\n * Assigns all attribute values to the provided element via the inferred renderer.\n *\n * This function accepts two forms of attribute entries:\n *\n * default: (key, value):\n *  attrs = [key1, value1, key2, value2]\n *\n * namespaced: (NAMESPACE_MARKER, uri, name, value)\n *  attrs = [NAMESPACE_MARKER, uri, name, value, NAMESPACE_MARKER, uri, name, value]\n *\n * The `attrs` array can contain a mix of both the default and namespaced entries.\n * The \"default\" values are set without a marker, but if the function comes across\n * a marker value then it will attempt to set a namespaced value. If the marker is\n * not of a namespaced value then the function will quit and return the index value\n * where it stopped during the iteration of the attrs array.\n *\n * See [AttributeMarker] to understand what the namespace marker value is.\n *\n * Note that this instruction does not support assigning style and class values to\n * an element. See `elementStart` and `elementHostAttrs` to learn how styling values\n * are applied to an element.\n * @param renderer The renderer to be used\n * @param native The element that the attributes will be assigned to\n * @param attrs The attribute array of values that will be assigned to the element\n * @returns the index value that was last accessed in the attributes array\n */\nexport function setUpAttributes(renderer: Renderer, native: RElement, attrs: TAttributes): number {\n  let i = 0;\n  while (i < attrs.length) {\n    const value = attrs[i];\n    if (typeof value === 'number') {\n      // only namespaces are supported. Other value types (such as style/class\n      // entries) are not supported in this function.\n      if (value !== AttributeMarker.NamespaceURI) {\n        break;\n      }\n\n      // we just landed on the marker value ... therefore\n      // we should skip to the next entry\n      i++;\n\n      const namespaceURI = attrs[i++] as string;\n      const attrName = attrs[i++] as string;\n      const attrVal = attrs[i++] as string;\n      ngDevMode && ngDevMode.rendererSetAttribute++;\n      renderer.setAttribute(native, attrName, attrVal, namespaceURI);\n    } else {\n      // attrName is string;\n      const attrName = value as string;\n      const attrVal = attrs[++i];\n      // Standard attributes\n      ngDevMode && ngDevMode.rendererSetAttribute++;\n      if (isAnimationProp(attrName)) {\n        renderer.setProperty(native, attrName, attrVal);\n      } else {\n        renderer.setAttribute(native, attrName, attrVal as string);\n      }\n      i++;\n    }\n  }\n\n  // another piece of code may iterate over the same attributes array. Therefore\n  // it may be helpful to return the exact spot where the attributes array exited\n  // whether by running into an unsupported marker or if all the static values were\n  // iterated over.\n  return i;\n}\n\n/**\n * Test whether the given value is a marker that indicates that the following\n * attribute values in a `TAttributes` array are only the names of attributes,\n * and not name-value pairs.\n * @param marker The attribute marker                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              