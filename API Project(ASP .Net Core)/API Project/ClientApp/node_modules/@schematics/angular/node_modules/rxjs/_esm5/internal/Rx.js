);

test('normalize', function (t) {
    var dir = path.join(__dirname, 'resolver/biz/node_modules/grux');

    t.equal(
        resolve.sync('../grux', { basedir: dir }),
        path.join(dir, 'index.js')
    );
    if (requireResolveSupportsPaths) {
        t.equal(
            resolve.sync('../grux', { basedir: dir }),
            require.resolve('../grux', { paths: [dir] }),
            '../grux: resolve.sync === require.resolve'
        );
    }

    t.end();
});

test('cup', function (t) {
    var dir = path.join(__dirname, 'resolver');

    t.equal(
        resolve.sync('./cup', {
            basedir: dir,
            extensions: ['.js', '.coffee']
        }),
        path.join(dir, 'cup.coffee'),
        './cup -> ./cup.coffee'
    );

    t.equal(
        resolve.sync('./cup.coffee', { basedir: dir }),
        path.join(dir, 'cup.coffee'),
        './cup.coffee'
    );

    t.throws(function () {
        resolve.sync('./cup', {
            basedir: dir,
            extensions: ['.js']
        });
    });

    if (requireResolveSupportsPaths) {
        t.equal(
            resolve.sync('./cup.coffee', { basedir: dir, extensions: ['.js', '.coffee'] }),
            require.resolve('./cup.coffee', { paths: [dir] }),
            './cup.coffee: resolve.sync === require.resolve'
        );
    }

    t.end();
});

test('mug', function (t) {
    var dir = path.join(__dirname, 'resolver');

    t.equal(
        resolve.sync('./mug', { basedir: dir }),
        path.join(dir, 'mug.js'),
        './mug -> ./mug.js'
    );
    if (requireResolveSupportsPaths) {
        t.equal(
            resolve.sync('./mug', { basedir: dir }),
            require.resolve('./mug', { paths: [dir] }),
            './mug: resolve.sync === require.resolve'
        );
    }

    t.equal(
        resolve.sync('./mug', {
            basedir: dir,
            extensions: ['.coffee', '.js']
        }),
        path.join(dir, 'mug.coffee'),
        './mug -> ./mug.coffee'
    );

    t.equal(
        resolve.sync('./mug', {
            basedir: dir,
            extensions: ['.js', '.coffee']
        }),
        path.join(dir, 'mug.js'),
        './mug -> ./mug.js'
    );

    t.end();
});

test('other path', function (t) {
    var resolverDir = path.join(__dirname, 'resolver');
    var dir = path.join(resolverDir, 'bar');
    var otherDir = path.join(resolverDir, 'other_path');

    t.equal(
        resolve.sync('root', {
            basedir: dir,
            paths: [otherDir]
        }),
        path.join(resolverDir, 'other_path/root.js')
    );

    t.equal(
        resolve.sync('lib/other-lib', {
            basedir: dir,
            paths: [otherDir]
        }),
        path.join(resolverDir, 'other_path/lib/other-lib.js')
    );

    t.throws(function () {
        resolve.sync('root', { basedir: dir });
    });

    t.throws(function () {
        resolve.sync('zzz', {
            basedir: dir,
            paths: [otherDir]
        });
    });

    t.end();
});

test('path iterator', function (t) {
    var resolverDir = path.join(__dirname, 'resolver');

    var exactIterator = function (x, start, getPackageCandidates, opts) {
        return [path.join(resolverDir, x)];
    };

    t.equal(
        resolve.sync('baz', { packageIterator: exactIterator }),
        path.join(resolverDir, 'baz/quux.js')
    );

    t.end();
});

test('incorrect main', function (t) {
    var resolverDir = path.join(__dirname, 'resolver');
    var dir = path.join(resolverDir, 'incorrect_main');

    t.equal(
        resolve.sync('./incorrect_main', { basedir: resolverDir }),
        path.join(dir, 'index.js')
    );
    if (requireResolveSupportsPaths) {
        t.equal(
            resolve.sync('./incorrect_main', { basedir: resolverDir }),
            require.resolve('./incorrect_main', { paths: [resolverDir] }),
            './incorrect_main: resolve.sync === require.resolve'
        );
    }

    t.end();
});

var stubStatSync = function stubStatSync(fn) {
    var statSync = fs.statSync;
    try {
        fs.statSync = function () {
            throw new EvalError('Unknown Error');
        };
        return fn();
    } finally {
        fs.statSync = statSync;
    }
};

test('#79 - re-throw non ENOENT errors from stat', function (t) {
    var dir = path.join(__dirname, 'resolver');

    stubStatSync(function () {
        t.throws(function () {
            resolve.sync('foo', { basedir: dir });
        }, /Unknown Error/);
    });

    t.end();
});

test('#52 - incorrectly resolves module-paths like "./someFolder/" when there is a file of the same name', function (t) {
    var dir = path.join(__dirname, 'resolver');
    var basedir = path.join(dir, 'same_names');

    t.equal(
        resolve.sync('./foo', { basedir: basedir }),
        path.join(dir, 'same_names/foo.js')
    );
    if (requireResolveSupportsPaths) {
        t.equal(
            resolve.sync('./foo', { basedir: basedir }),
            require.resolve('./foo', { paths: [basedir] }),
            './foo: resolve.sync === require.resolve'
        );
    }

    t.equal(
        resolve.sync('./foo/', { basedir: basedir }),
        path.join(dir, 'same_names/foo/index.js')
    );
    if (requireResolveSupportsPaths) {
        t.equal(
            resolve.sync('./foo/', { basedir: basedir }),
            require.resolve('./foo/', { paths: [basedir] }),
            './foo/: resolve.sync === require.resolve'
        );
    }

    t.end();
});

test('#211 - incorrectly resolves module-paths like "." when from inside a folder with a sibling file of the same name', function (t) {
    var dir = path.join(__dirname, 'resolver');
    var basedir = path.join(dir, 'same_names/foo');

    t.equal(
        resolve.sync('./', { basedir: basedir }),
        path.join(dir, 'same_names/foo/index.js'),
        './'
    );
    if (requireResolveSupportsPaths) {
        t.equal(
            resolve.sync('./', { basedir: basedir }),
            require.resolve('./', { paths: [basedir] }),
            './: resolve.sync === require.resolve'
        );
    }

    t.equal(
        resolve.sync('.', { basedir: basedir }),
        path.join(dir, 'same_names/foo/index.js'),
        '.'
    );
    if (requireResolveSupportsPaths) {
        t.equal(
            resolve.sync('.', { basedir: basedir }),
            require.resolve('.', { paths: [basedir] }),
            '.: resolve.sync === require.resolve',
            { todo: true }
        );
    }

    t.end();
});

test('sync: #121 - treating an existing file as a dir when no basedir', function (t) {
    var testFile = path.basename(__filename);

    t.test('sanity check', function (st) {
        st.equal(
            resolve.sync('./' + testFile),
            __filename,
            'sanity check'
        );
        st.equal(
            resolve.sync('./' + testFile),
            require.resolve('./' + testFile),
            'sanity check: resolve.sync === require.resolve'
        );

        st.end();
    });

    t.test('with a fake directory', function (st) {
        function run() { return resolve.sync('./' + testFile + '/blah'); }

        st.throws(run, 'throws an error');

        try {
            run();
        } catch (e) {
            st.equal(e.code, 'MODULE_NOT_FOUND', 'error code matches require.resolve');
            st.equal(
                e.message,
                'Cannot find module \'./' + testFile + '/blah\' from \'' + __dirname + '\'',
                'can not find nonexistent module'
            );
        }

        st.end();
    });

    t.end();
});

test('sync dot main', function (t) {
    var start = new Date();

    t.equal(
        resolve.sync('./resolver/dot_main'),
        path.join(__dirname, 'resolver/dot_main/index.js'),
        './resolver/dot_main'
    );
    t.equal(
        resolve.sync('./resolver/dot_main'),
  