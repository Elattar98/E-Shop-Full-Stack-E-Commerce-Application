late(), parseLiteralNode()) :
                parseTemplateExpression(/*isTaggedTemplate*/ true));
            if (questionDotToken || tag.flags & 32 /* NodeFlags.OptionalChain */) {
                tagExpression.flags |= 32 /* NodeFlags.OptionalChain */;
            }
            tagExpression.questionDotToken = questionDotToken;
            return finishNode(tagExpression, pos);
        }
        function parseCallExpressionRest(pos, expression) {
            while (true) {
                expression = parseMemberExpressionRest(pos, expression, /*allowOptionalChain*/ true);
                var typeArguments = void 0;
                var questionDotToken = parseOptionalToken(28 /* SyntaxKind.QuestionDotToken */);
                if (questionDotToken) {
                    typeArguments = tryParse(parseTypeArgumentsInExpression);
                    if (isTemplateStartOfTaggedTemplate()) {
                        expression = parseTaggedTemplateRest(pos, expression, questionDotToken, typeArguments);
                        continue;
                    }
                }
                if (typeArguments || token() === 20 /* SyntaxKind.OpenParenToken */) {
                    // Absorb type arguments into CallExpression when preceding expression is ExpressionWithTypeArguments
                    if (!questionDotToken && expression.kind === 228 /* SyntaxKind.ExpressionWithTypeArguments */) {
                        typeArguments = expression.typeArguments;
                        expression = expression.expression;
                    }
                    var argumentList = parseArgumentList();
                    var callExpr = questionDotToken || tryReparseOptionalChain(expression) ?
                        factory.createCallChain(expression, questionDotToken, typeArguments, argumentList) :
                        factory.createCallExpression(expression, typeArguments, argumentList);
                    expression = finishNode(callExpr, pos);
                    continue;
                }
                if (questionDotToken) {
                    // We parsed `?.` but then failed to parse anything, so report a missing identifier here.
                    var name = createMissingNode(79 /* SyntaxKind.Identifier */, /*reportAtCurrentPosition*/ false, ts.Diagnostics.Identifier_expected);
                    expression = finishNode(factory.createPropertyAccessChain(expression, questionDotToken, name), pos);
                }
                break;
            }
            return expression;
        }
        function parseArgumentList() {
            parseExpected(20 /* SyntaxKind.OpenParenToken */);
            var result = parseDelimitedList(11 /* ParsingContext.ArgumentExpressions */, parseArgumentExpression);
            parseExpected(21 /* SyntaxKind.CloseParenToken */);
            return result;
        }
        function parseTypeArgumentsInExpression() {
            if ((contextFlags & 262144 /* NodeFlags.JavaScriptFile */) !== 0) {
                // TypeArguments must not be parsed in JavaScript files to avoid ambiguity with binary operators.
                return undefined;
            }
            if (reScanLessThanToken() !== 29 /* SyntaxKind.LessThanToken */) {
                return undefined;
            }
            nextToken();
            var typeArguments = parseDelimitedList(20 /* ParsingContext.TypeArguments */, parseType);
            if (reScanGreaterToken() !== 31 /* SyntaxKind.GreaterThanToken */) {
                // If it doesn't have the closing `>` then it's definitely not an type argument list.
                return undefined;
            }
            nextToken();
            // We successfully parsed a type argument list. The next token determines whether we want to
            // treat it as such. If the type argument list is followed by `(` or a template literal, as in
            // `f<number>(42)`, we favor the type argument interpretation even though JavaScript would view
            // it as a relational expression.
            return typeArguments && canFollowTypeArgumentsInExpression() ? typeArguments : undefined;
        }
        function canFollowTypeArgumentsInExpression() {
            switch (token()) {
                // These tokens can follow a type argument list in a call expression.
                case 20 /* SyntaxKind.OpenParenToken */: // foo<x>(
                case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */: // foo<T> `...`
                case 15 /* SyntaxKind.TemplateHead */: // foo<T> `...${100}...`
                    return true;
            }
            // Consider something a type argument list only if the following token can't start an expression.
            return !isStartOfExpression();
        }
        function parsePrimaryExpression() {
            switch (token()) {
                case 8 /* SyntaxKind.NumericLiteral */:
                case 9 /* SyntaxKind.BigIntLiteral */:
                case 10 /* SyntaxKind.StringLiteral */:
                case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
                    return parseLiteralNode();
                case 108 /* SyntaxKind.ThisKeyword */:
                case 106 /* SyntaxKind.SuperKeyword */:
                case 104 /* SyntaxKind.NullKeyword */:
                case 110 /* SyntaxKind.TrueKeyword */:
                case 95 /* SyntaxKind.FalseKeyword */:
                    return parseTokenNode();
                case 20 /* SyntaxKind.OpenParenToken */:
                    return parseParenthesizedExpression();
                case 22 /* SyntaxKind.OpenBracketToken */:
                    return parseArrayLiteralExpression();
                case 18 /* SyntaxKind.OpenBraceToken */:
                    return parseObjectLiteralExpression();
                case 131 /* SyntaxKind.AsyncKeyword */:
                    // Async arrow functions are parsed earlier in parseAssignmentExpressionOrHigher.
                    // If we encounter `async [no LineTerminator here] function` then this is an async
                    // function; otherwise, its an identifier.
                    if (!lookAhead(nextTokenIsFunctionKeywordOnSameLine)) {
                        break;
                    }
                    return parseFunctionExpression();
                case 84 /* SyntaxKind.ClassKeyword */:
                    return parseClassExpression();
                case 98 /* SyntaxKind.FunctionKeyword */:
                    return parseFunctionExpression();
                case 103 /* SyntaxKind.NewKeyword */:
                    return parseNewExpressionOrNewDotTarget();
                case 43 /* SyntaxKind.SlashToken */:
                case 68 /* SyntaxKind.SlashEqualsToken */:
                    if (reScanSlashToken() === 13 /* SyntaxKind.RegularExpressionLiteral */) {
                        return parseLiteralNode();
                    }
                    break;
                case 15 /* SyntaxKind.TemplateHead */:
                    return parseTemplateExpression(/* isTaggedTemplate */ false);
                case 80 /* SyntaxKind.PrivateIdentifier */:
                    return parsePrivateIdentifier();
            }
            return parseIdentifier(ts.Diagnostics.Expression_expected);
        }
        function parseParenthesizedExpression() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(20 /* SyntaxKind.OpenParenToken */);
            var expression = allowInAnd(parseExpression);
            parseExpected(21 /* SyntaxKind.CloseParenToken */);
            return withJSDoc(finishNode(factory.createParenthesizedExpression(expression), pos), hasJSDoc);
        }
        function parseSpreadElement() {
            var pos = getNodePos();
            parseExpected(25 /* SyntaxKind.DotDotDotToken */);
            var expression = parseAssignmentExpressionOrHigher();
            return finishNode(factory.createSpreadElement(expression), pos);
        }
        function parseArgumentOrArrayLiteralElement() {
            return token() === 25 /* SyntaxKind.DotDotDotToken */ ? parseSpreadElement() :
                token() === 27 /* SyntaxKind.CommaToken */ ? finishNode(factory.createOmittedExpression(), getNodePos()) :
                    parseAssignmentExpressionOrHigher();
        }
        function parseArgumentExpression() {
            return doOutsideOfContext(disallowInAndDecoratorContext, parseArgumentOrArrayLiteralElement);
        }
        function parseArrayLiteralExpression() {
            var pos = getNodePos();
            var openBracketPosition = scanner.getTokenPos();
            var openBracketParsed = parseExpected(22 /* SyntaxKind.OpenBracketToken */);
            var multiLine = scanner.hasPrecedingLineBreak();
            var elements = parseDelimitedList(15 /* ParsingContext.ArrayLiteralMembers */, parseArgumentOrArrayLiteralElement);
            parseExpectedMatchingBrackets(22 /* SyntaxKind.OpenBracketToken */, 23 /* SyntaxKind.CloseBracketToken */, openBracketParsed, openBracketPosition);
            return finishNode(factory.createArrayLiteralExpression(elements, multiLine), pos);
        }
        function parseObjectLiteralElement() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            if (parseOptionalToken(25 /* SyntaxKind.DotDotDotToken */)) {
                var expression = parseAssignmentExpressionOrHigher();
                return withJSDoc(finishNode(factory.createSpreadAssignment(expression), pos), hasJSDoc);
            }
            var decorators = parseDecorators();
            var modifiers = parseModifiers();
            if (parseContextualModifier(136 /* SyntaxKind.GetKeyword */)) {
                return parseAccessorDeclaration(pos, hasJSDoc, decorators, modifiers, 172 /* SyntaxKind.GetAccessor */);
            }
            if (parseContextualModifier(149 /* SyntaxKind.SetKeyword */)) {
                return parseAccessorDeclaration(pos, hasJSDoc, decorators, modifiers, 173 /* SyntaxKind.SetAccessor */);
            }
            var asteriskToken = parseOptionalToken(41 /* SyntaxKind.AsteriskToken */);
            var tokenIsIdentifier = isIdentifier();
            var name = parsePropertyName();
            // Disallowing of optional property assignments and definite assignment assertion happens in the grammar checker.
            var questionToken = parseOptionalToken(57 /* SyntaxKind.QuestionToken */);
            var exclamationToken = parseOptionalToken(53 /* SyntaxKind.ExclamationToken */);
            if (asteriskToken || token() === 20 /* SyntaxKind.OpenParenToken */ || token() === 29 /* SyntaxKind.LessThanToken */) {
                return parseMethodDeclaration(pos, hasJSDoc, decorators, modifiers, asteriskToken, name, questionToken, exclamationToken);
            }
            // check if it is short-hand property assignment or normal property assignment
            // NOTE: if token is EqualsToken it is interpreted as CoverInitializedName production
            // CoverInitializedName[Yield] :
            //     IdentifierReference[?Yield] Initializer[In, ?Yield]
            // this is necessary because ObjectLiteral productions are also used to cover grammar for ObjectAssignmentPattern
            var node;
            var isShorthandPropertyAssignment = tokenIsIdentifier && (token() !== 58 /* SyntaxKind.ColonToken */);
            if (isShorthandPropertyAssignment) {
                var equalsToken = parseOptionalToken(63 /* SyntaxKind.EqualsToken */);
                var objectAssignmentInitializer = equalsToken ? allowInAnd(parseAssignmentExpressionOrHigher) : undefined;
                node = factory.createShorthandPropertyAssignment(name, objectAssignmentInitializer);
                // Save equals token for error reporting.
                // TODO(rbuckton): Consider manufacturing this when we need to report an error as it is otherwise not useful.
                node.equalsToken = equalsToken;
            }
            else {
                parseExpected(58 /* SyntaxKind.ColonToken */);
                var initializer = allowInAnd(parseAssignmentExpressionOrHigher);
                node = factory.createPropertyAssignment(name, initializer);
            }
            // Decorators, Modifiers, questionToken, and exclamationToken are not supported by property assignments and are reported in the grammar checker
            node.decorators = decorators;
            node.modifiers = modifiers;
            node.questionToken = questionToken;
            node.exclamationToken = exclamationToken;
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseObjectLiteralExpression() {
            var pos = getNodePos();
            var openBracePosition = scanner.getTokenPos();
            var openBraceParsed = parseExpected(18 /* SyntaxKind.OpenBraceToken */);
            var multiLine = scanner.hasPrecedingLineBreak();
            var properties = parseDelimitedList(12 /* ParsingContext.ObjectLiteralMembers */, parseObjectLiteralElement, /*considerSemicolonAsDelimiter*/ true);
            parseExpectedMatchingBrackets(18 /* SyntaxKind.OpenBraceToken */, 19 /* SyntaxKind.CloseBraceToken */, openBraceParsed, openBracePosition);
            return finishNode(factory.createObjectLiteralExpression(properties, multiLine), pos);
        }
        function parseFunctionExpression() {
            // GeneratorExpression:
            //      function* BindingIdentifier [Yield][opt](FormalParameters[Yield]){ GeneratorBody }
            //
            // FunctionExpression:
            //      function BindingIdentifier[opt](FormalParameters){ FunctionBody }
            var savedDecoratorContext = inDecoratorContext();
            setDecoratorContext(/*val*/ false);
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            var modifiers = parseModifiers();
            parseExpected(98 /* SyntaxKind.FunctionKeyword */);
            var asteriskToken = parseOptionalToken(41 /* SyntaxKind.AsteriskToken */);
            var isGenerator = asteriskToken ? 1 /* SignatureFlags.Yield */ : 0 /* SignatureFlags.None */;
            var isAsync = ts.some(modifiers, ts.isAsyncModifier) ? 2 /* SignatureFlags.Await */ : 0 /* SignatureFlags.None */;
            var name = isGenerator && isAsync ? doInYieldAndAwaitContext(parseOptionalBindingIdentifier) :
                isGenerator ? doInYieldContext(parseOptionalBindingIdentifier) :
                    isAsync ? doInAwaitContext(parseOptionalBindingIdentifier) :
                        parseOptionalBindingIdentifier();
            var typeParameters = parseTypeParameters();
            var parameters = parseParameters(isGenerator | isAsync);
            var type = parseReturnType(58 /* SyntaxKind.ColonToken */, /*isType*/ false);
            var body = parseFunctionBlock(isGenerator | isAsync);
            setDecoratorContext(savedDecoratorContext);
            var node = factory.createFunctionExpression(modifiers, asteriskToken, name, typeParameters, parameters, type, body);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseOptionalBindingIdentifier() {
            return isBindingIdentifier() ? parseBindingIdentifier() : undefined;
        }
        function parseNewExpressionOrNewDotTarget() {
            var pos = getNodePos();
            parseExpected(103 /* SyntaxKind.NewKeyword */);
            if (parseOptional(24 /* SyntaxKind.DotToken */)) {
                var name = parseIdentifierName();
                return finishNode(factory.createMetaProperty(103 /* SyntaxKind.NewKeyword */, name), pos);
            }
            var expressionPos = getNodePos();
            var expression = parseMemberExpressionRest(expressionPos, parsePrimaryExpression(), /*allowOptionalChain*/ false);
            var typeArguments;
            // Absorb type arguments into NewExpression when preceding expression is ExpressionWithTypeArguments
            if (expression.kind === 228 /* SyntaxKind.ExpressionWithTypeArguments */) {
                typeArguments = expression.typeArguments;
                expression = expression.expression;
            }
            var argumentList = token() === 20 /* SyntaxKind.OpenParenToken */ ? parseArgumentList() : undefined;
            return finishNode(factory.createNewExpression(expression, typeArguments, argumentList), pos);
        }
        // STATEMENTS
        function parseBlock(ignoreMissingOpenBrace, diagnosticMessage) {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            var openBracePosition = scanner.getTokenPos();
            var openBraceParsed = parseExpected(18 /* SyntaxKind.OpenBraceToken */, diagnosticMessage);
            if (openBraceParsed || ignoreMissingOpenBrace) {
                var multiLine = scanner.hasPrecedingLineBreak();
                var statements = parseList(1 /* ParsingContext.BlockStatements */, parseStatement);
                parseExpectedMatchingBrackets(18 /* SyntaxKind.OpenBraceToken */, 19 /* SyntaxKind.CloseBraceToken */, openBraceParsed, openBracePosition);
                var result = withJSDoc(finishNode(factory.createBlock(statements, multiLine), pos), hasJSDoc);
                if (token() === 63 /* SyntaxKind.EqualsToken */) {
                    parseErrorAtCurrentToken(ts.Diagnostics.Declaration_or_statement_expected_This_follows_a_block_of_statements_so_if_you_intended_to_write_a_destructuring_assignment_you_might_need_to_wrap_the_the_whole_assignment_in_parentheses);
                    nextToken();
                }
                return result;
            }
            else {
                var statements = createMissingList();
                return withJSDoc(finishNode(factory.createBlock(statements, /*multiLine*/ undefined), pos), hasJSDoc);
            }
        }
        function parseFunctionBlock(flags, diagnosticMessage) {
            var savedYieldContext = inYieldContext();
            setYieldContext(!!(flags & 1 /* SignatureFlags.Yield */));
            var savedAwaitContext = inAwaitContext();
            setAwaitContext(!!(flags & 2 /* SignatureFlags.Await */));
            var savedTopLevel = topLevel;
            topLevel = false;
            // We may be in a [Decorator] context when parsing a function expression or
            // arrow function. The body of the function is not in [Decorator] context.
            var saveDecoratorContext = inDecoratorContext();
            if (saveDecoratorContext) {
                setDecoratorContext(/*val*/ false);
            }
            var block = parseBlock(!!(flags & 16 /* SignatureFlags.IgnoreMissingOpenBrace */), diagnosticMessage);
            if (saveDecoratorContext) {
                setDecoratorContext(/*val*/ true);
            }
            topLevel = savedTopLevel;
            setYieldContext(savedYieldContext);
            setAwaitContext(savedAwaitContext);
            return block;
        }
        function parseEmptyStatement() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(26 /* SyntaxKind.SemicolonToken */);
            return withJSDoc(finishNode(factory.createEmptyStatement(), pos), hasJSDoc);
        }
        function parseIfStatement() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(99 /* SyntaxKind.IfKeyword */);
            var openParenPosition = scanner.getTokenPos();
            var openParenParsed = parseExpected(20 /* SyntaxKind.OpenParenToken */);
            var expression = allowInAnd(parseExpression);
            parseExpectedMatchingBrackets(20 /* SyntaxKind.OpenParenToken */, 21 /* SyntaxKind.CloseParenToken */, openParenParsed, openParenPosition);
            var thenStatement = parseStatement();
            var elseStatement = parseOptional(91 /* SyntaxKind.ElseKeyword */) ? parseStatement() : undefined;
            return withJSDoc(finishNode(factory.createIfStatement(expression, thenStatement, elseStatement), pos), hasJSDoc);
        }
        function parseDoStatement() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(90 /* SyntaxKind.DoKeyword */);
            var statement = parseStatement();
            parseExpected(115 /* SyntaxKind.WhileKeyword */);
            var openParenPosition = scanner.getTokenPos();
            var openParenParsed = parseExpected(20 /* SyntaxKind.OpenParenToken */);
            var expression = allowInAnd(parseExpression);
            parseExpectedMatchingBrackets(20 /* SyntaxKind.OpenParenToken */, 21 /* SyntaxKind.CloseParenToken */, openParenParsed, openParenPosition);
            // From: https://mail.mozilla.org/pipermail/es-discuss/2011-August/016188.html
            // 157 min --- All allen at wirfs-brock.com CONF --- "do{;}while(false)false" prohibited in
            // spec but allowed in consensus reality. Approved -- this is the de-facto standard whereby
            //  do;while(0)x will have a semicolon inserted before x.
            parseOptional(26 /* SyntaxKind.SemicolonToken */);
            return withJSDoc(finishNode(factory.createDoStatement(statement, expression), pos), hasJSDoc);
        }
        function parseWhileStatement() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(115 /* SyntaxKind.WhileKeyword */);
            var openParenPosition = scanner.getTokenPos();
            var openParenParsed = parseExpected(20 /* SyntaxKind.OpenParenToken */);
            var expression = allowInAnd(parseExpression);
            parseExpectedMatchingBrackets(20 /* SyntaxKind.OpenParenToken */, 21 /* SyntaxKind.CloseParenToken */, openParenParsed, openParenPosition);
            var statement = parseStatement();
            return withJSDoc(finishNode(factory.createWhileStatement(expression, statement), pos), hasJSDoc);
        }
        function parseForOrForInOrForOfStatement() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(97 /* SyntaxKind.ForKeyword */);
            var awaitToken = parseOptionalToken(132 /* SyntaxKind.AwaitKeyword */);
            parseExpected(20 /* SyntaxKind.OpenParenToken */);
            var initializer;
            if (token() !== 26 /* SyntaxKind.SemicolonToken */) {
                if (token() === 113 /* SyntaxKind.VarKeyword */ || token() === 119 /* SyntaxKind.LetKeyword */ || token() === 85 /* SyntaxKind.ConstKeyword */) {
                    initializer = parseVariableDeclarationList(/*inForStatementInitializer*/ true);
                }
                else {
                    initializer = disallowInAnd(parseExpression);
                }
            }
            var node;
            if (awaitToken ? parseExpected(160 /* SyntaxKind.OfKeyword */) : parseOptional(160 /* SyntaxKind.OfKeyword */)) {
                var expression = allowInAnd(parseAssignmentExpressionOrHigher);
                parseExpected(21 /* SyntaxKind.CloseParenToken */);
                node = factory.createForOfStatement(awaitToken, initializer, expression, parseStatement());
            }
            else if (parseOptional(101 /* SyntaxKind.InKeyword */)) {
                var expression = allowInAnd(parseExpression);
                parseExpected(21 /* SyntaxKind.CloseParenToken */);
                node = factory.createForInStatement(initializer, expression, parseStatement());
            }
            else {
                parseExpected(26 /* SyntaxKind.SemicolonToken */);
                var condition = token() !== 26 /* SyntaxKind.SemicolonToken */ && token() !== 21 /* SyntaxKind.CloseParenToken */
                    ? allowInAnd(parseExpression)
                    : undefined;
                parseExpected(26 /* SyntaxKind.SemicolonToken */);
                var incrementor = token() !== 21 /* SyntaxKind.CloseParenToken */
                    ? allowInAnd(parseExpression)
                    : undefined;
                parseExpected(21 /* SyntaxKind.CloseParenToken */);
                node = factory.createForStatement(initializer, condition, incrementor, parseStatement());
            }
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseBreakOrContinueStatement(kind) {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(kind === 246 /* SyntaxKind.BreakStatement */ ? 81 /* SyntaxKind.BreakKeyword */ : 86 /* SyntaxKind.ContinueKeyword */);
            var label = canParseSemicolon() ? undefined : parseIdentifier();
            parseSemicolon();
            var node = kind === 246 /* SyntaxKind.BreakStatement */
                ? factory.createBreakStatement(label)
                : factory.createContinueStatement(label);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseReturnStatement() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(105 /* SyntaxKind.ReturnKeyword */);
            var expression = canParseSemicolon() ? undefined : allowInAnd(parseExpression);
            parseSemicolon();
            return withJSDoc(finishNode(factory.createReturnStatement(expression), pos), hasJSDoc);
        }
        function parseWithStatement() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(116 /* SyntaxKind.WithKeyword */);
            var openParenPosition = scanner.getTokenPos();
            var openParenParsed = parseExpected(20 /* SyntaxKind.OpenParenToken */);
            var expression = allowInAnd(parseExpression);
            parseExpectedMatchingBrackets(20 /* SyntaxKind.OpenParenToken */, 21 /* SyntaxKind.CloseParenToken */, openParenParsed, openParenPosition);
            var statement = doInsideOfContext(33554432 /* NodeFlags.InWithStatement */, parseStatement);
            return withJSDoc(finishNode(factory.createWithStatement(expression, statement), pos), hasJSDoc);
        }
        function parseCaseClause() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(82 /* SyntaxKind.CaseKeyword */);
            var expression = allowInAnd(parseExpression);
            parseExpected(58 /* SyntaxKind.ColonToken */);
            var statements = parseList(3 /* ParsingContext.SwitchClauseStatements */, parseStatement);
            return withJSDoc(finishNode(factory.createCaseClause(expression, statements), pos), hasJSDoc);
        }
        function parseDefaultClause() {
            var pos = getNodePos();
            parseExpected(88 /* SyntaxKind.DefaultKeyword */);
            parseExpected(58 /* SyntaxKind.ColonToken */);
            var statements = parseList(3 /* ParsingContext.SwitchClauseStatements */, parseStatement);
            return finishNode(factory.createDefaultClause(statements), pos);
        }
        function parseCaseOrDefaultClause() {
            return token() === 82 /* SyntaxKind.CaseKeyword */ ? parseCaseClause() : parseDefaultClause();
        }
        function parseCaseBlock() {
            var pos = getNodePos();
            parseExpected(18 /* SyntaxKind.OpenBraceToken */);
            var clauses = parseList(2 /* ParsingContext.SwitchClauses */, parseCaseOrDefaultClause);
            parseExpected(19 /* SyntaxKind.CloseBraceToken */);
            return finishNode(factory.createCaseBlock(clauses), pos);
        }
        function parseSwitchStatement() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(107 /* SyntaxKind.SwitchKeyword */);
            parseExpected(20 /* SyntaxKind.OpenParenToken */);
            var expression = allowInAnd(parseExpression);
            parseExpected(21 /* SyntaxKind.CloseParenToken */);
            var caseBlock = parseCaseBlock();
            return withJSDoc(finishNode(factory.createSwitchStatement(expression, caseBlock), pos), hasJSDoc);
        }
        function parseThrowStatement() {
            // ThrowStatement[Yield] :
            //      throw [no LineTerminator here]Expression[In, ?Yield];
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(109 /* SyntaxKind.ThrowKeyword */);
            // Because of automatic semicolon insertion, we need to report error if this
            // throw could be terminated with a semicolon.  Note: we can't call 'parseExpression'
            // directly as that might consume an expression on the following line.
            // Instead, we create a "missing" identifier, but don't report an error. The actual error
            // will be reported in the grammar walker.
            var expression = scanner.hasPrecedingLineBreak() ? undefined : allowInAnd(parseExpression);
            if (expression === undefined) {
                identifierCount++;
                expression = finishNode(factory.createIdentifier(""), getNodePos());
            }
            if (!tryParseSemicolon()) {
                parseErrorForMissingSemicolonAfter(expression);
            }
            return withJSDoc(finishNode(factory.createThrowStatement(expression), pos), hasJSDoc);
        }
        // TODO: Review for error recovery
        function parseTryStatement() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(111 /* SyntaxKind.TryKeyword */);
            var tryBlock = parseBlock(/*ignoreMissingOpenBrace*/ false);
            var catchClause = token() === 83 /* SyntaxKind.CatchKeyword */ ? parseCatchClause() : undefined;
            // If we don't have a catch clause, then we must have a finally clause.  Try to parse
            // one out no matter what.
            var finallyBlock;
            if (!catchClause || token() === 96 /* SyntaxKind.FinallyKeyword */) {
                parseExpected(96 /* SyntaxKind.FinallyKeyword */, ts.Diagnostics.catch_or_finally_expected);
                finallyBlock = parseBlock(/*ignoreMissingOpenBrace*/ false);
            }
            return withJSDoc(finishNode(factory.createTryStatement(tryBlock, catchClause, finallyBlock), pos), hasJSDoc);
        }
        function parseCatchClause() {
            var pos = getNodePos();
            parseExpected(83 /* SyntaxKind.CatchKeyword */);
            var variableDeclaration;
            if (parseOptional(20 /* SyntaxKind.OpenParenToken */)) {
                variableDeclaration = parseVariableDeclaration();
                parseExpected(21 /* SyntaxKind.CloseParenToken */);
            }
            else {
                // Keep shape of node to avoid degrading performance.
                variableDeclaration = undefined;
            }
            var block = parseBlock(/*ignoreMissingOpenBrace*/ false);
            return finishNode(factory.createCatchClause(variableDeclaration, block), pos);
        }
        function parseDebuggerStatement() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(87 /* SyntaxKind.DebuggerKeyword */);
            parseSemicolon();
            return withJSDoc(finishNode(factory.createDebuggerStatement(), pos), hasJSDoc);
        }
        function parseExpressionOrLabeledStatement() {
            // Avoiding having to do the lookahead for a labeled statement by just trying to parse
            // out an expression, seeing if it is identifier and then seeing if it is followed by
            // a colon.
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            var node;
            var hasParen = token() === 20 /* SyntaxKind.OpenParenToken */;
            var expression = allowInAnd(parseExpression);
            if (ts.isIdentifier(expression) && parseOptional(58 /* SyntaxKind.ColonToken */)) {
                node = factory.createLabeledStatement(expression, parseStatement());
            }
            else {
                if (!tryParseSemicolon()) {
                    parseErrorForMissingSemicolonAfter(expression);
                }
                node = factory.createExpressionStatement(expression);
                if (hasParen) {
                    // do not parse the same jsdoc twice
                    hasJSDoc = false;
                }
            }
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function nextTokenIsIdentifierOrKeywordOnSameLine() {
            nextToken();
            return ts.tokenIsIdentifierOrKeyword(token()) && !scanner.hasPrecedingLineBreak();
        }
        function nextTokenIsClassKeywordOnSameLine() {
            nextToken();
            return token() === 84 /* SyntaxKind.ClassKeyword */ && !scanner.hasPrecedingLineBreak();
        }
        function nextTokenIsFunctionKeywordOnSameLine() {
            nextToken();
            return token() === 98 /* SyntaxKind.FunctionKeyword */ && !scanner.hasPrecedingLineBreak();
        }
        function nextTokenIsIdentifierOrKeywordOrLiteralOnSameLine() {
            nextToken();
            return (ts.tokenIsIdentifierOrKeyword(token()) || token() === 8 /* SyntaxKind.NumericLiteral */ || token() === 9 /* SyntaxKind.BigIntLiteral */ || token() === 10 /* SyntaxKind.StringLiteral */) && !scanner.hasPrecedingLineBreak();
        }
        function isDeclaration() {
            while (true) {
                switch (token()) {
                    case 113 /* SyntaxKind.VarKeyword */:
                    case 119 /* SyntaxKind.LetKeyword */:
                    case 85 /* SyntaxKind.ConstKeyword */:
                    case 98 /* SyntaxKind.FunctionKeyword */:
                    case 84 /* SyntaxKind.ClassKeyword */:
                    case 92 /* SyntaxKind.EnumKeyword */:
                        return true;
                    // 'declare', 'module', 'namespace', 'interface'* and 'type' are all legal JavaScript identifiers;
                    // however, an identifier cannot be followed by another identifier on the same line. This is what we
                    // count on to parse out the respective declarations. For instance, we exploit this to say that
                    //
                    //    namespace n
                    //
                    // can be none other than the beginning of a namespace declaration, but need to respect that JavaScript sees
                    //
                    //    namespace
                    //    n
                    //
                    // as the identifier 'namespace' on one line followed by the identifier 'n' on another.
                    // We need to look one token ahead to see if it permissible to try parsing a declaration.
                    //
                    // *Note*: 'interface' is actually a strict mode reserved word. So while
                    //
                    //   "use strict"
                    //   interface
                    //   I {}
                    //
                    // could be legal, it would add complexity for very little gain.
                    case 118 /* SyntaxKind.InterfaceKeyword */:
                    case 152 /* SyntaxKind.TypeKeyword */:
                        return nextTokenIsIdentifierOnSameLine();
                    case 141 /* SyntaxKind.ModuleKeyword */:
                    case 142 /* SyntaxKind.NamespaceKeyword */:
                        return nextTokenIsIdentifierOrStringLiteralOnSameLine();
                    case 126 /* SyntaxKind.AbstractKeyword */:
                    case 131 /* SyntaxKind.AsyncKeyword */:
                    case 135 /* SyntaxKind.DeclareKeyword */:
                    case 121 /* SyntaxKind.PrivateKeyword */:
                    case 122 /* SyntaxKind.ProtectedKeyword */:
                    case 123 /* SyntaxKind.PublicKeyword */:
                    case 145 /* SyntaxKind.ReadonlyKeyword */:
                        nextToken();
                        // ASI takes effect for this modifier.
                        if (scanner.hasPrecedingLineBreak()) {
                            return false;
                        }
                        continue;
                    case 157 /* SyntaxKind.GlobalKeyword */:
                        nextToken();
                        return token() === 18 /* SyntaxKind.OpenBraceToken */ || token() === 79 /* SyntaxKind.Identifier */ || token() === 93 /* SyntaxKind.ExportKeyword */;
                    case 100 /* SyntaxKind.ImportKeyword */:
                        nextToken();
                        return token() === 10 /* SyntaxKind.StringLiteral */ || token() === 41 /* SyntaxKind.AsteriskToken */ ||
                            token() === 18 /* SyntaxKind.OpenBraceToken */ || ts.tokenIsIdentifierOrKeyword(token());
                    case 93 /* SyntaxKind.ExportKeyword */:
                        var currentToken_1 = nextToken();
                        if (currentToken_1 === 152 /* SyntaxKind.TypeKeyword */) {
                            currentToken_1 = lookAhead(nextToken);
                        }
                        if (currentToken_1 === 63 /* SyntaxKind.EqualsToken */ || currentToken_1 === 41 /* SyntaxKind.AsteriskToken */ ||
                            currentToken_1 === 18 /* SyntaxKind.OpenBraceToken */ || currentToken_1 === 88 /* SyntaxKind.DefaultKeyword */ ||
                            currentToken_1 === 127 /* SyntaxKind.AsKeyword */) {
                            return true;
                        }
                        continue;
                    case 124 /* SyntaxKind.StaticKeyword */:
                        nextToken();
                        continue;
                    default:
                        return false;
                }
            }
        }
        function isStartOfDeclaration() {
            return lookAhead(isDeclaration);
        }
        function isStartOfStatement() {
            switch (token()) {
                case 59 /* SyntaxKind.AtToken */:
                case 26 /* SyntaxKind.SemicolonToken */:
                case 18 /* SyntaxKind.OpenBraceToken */:
                case 113 /* SyntaxKind.VarKeyword */:
                case 119 /* SyntaxKind.LetKeyword */:
                case 98 /* SyntaxKind.FunctionKeyword */:
                case 84 /* SyntaxKind.ClassKeyword */:
                case 92 /* SyntaxKind.EnumKeyword */:
                case 99 /* SyntaxKind.IfKeyword */:
                case 90 /* SyntaxKind.DoKeyword */:
                case 115 /* SyntaxKind.WhileKeyword */:
                case 97 /* SyntaxKind.ForKeyword */:
                case 86 /* SyntaxKind.ContinueKeyword */:
                case 81 /* SyntaxKind.BreakKeyword */:
                case 105 /* SyntaxKind.ReturnKeyword */:
                case 116 /* SyntaxKind.WithKeyword */:
                case 107 /* SyntaxKind.SwitchKeyword */:
                case 109 /* SyntaxKind.ThrowKeyword */:
                case 111 /* SyntaxKind.TryKeyword */:
                case 87 /* SyntaxKind.DebuggerKeyword */:
                // 'catch' and 'finally' do not actually indicate that the code is part of a statement,
                // however, we say they are here so that we may gracefully parse them and error later.
                // falls through
                case 83 /* SyntaxKind.CatchKeyword */:
                case 96 /* SyntaxKind.FinallyKeyword */:
                    return true;
                case 100 /* SyntaxKind.ImportKeyword */:
                    return isStartOfDeclaration() || lookAhead(nextTokenIsOpenParenOrLessThanOrDot);
                case 85 /* SyntaxKind.ConstKeyword */:
                case 93 /* SyntaxKind.ExportKeyword */:
                    return isStartOfDeclaration();
                case 131 /* SyntaxKind.AsyncKeyword */:
                case 135 /* SyntaxKind.DeclareKeyword */:
                case 118 /* SyntaxKind.InterfaceKeyword */:
                case 141 /* SyntaxKind.ModuleKeyword */:
                case 142 /* SyntaxKind.NamespaceKeyword */:
                case 152 /* SyntaxKind.TypeKeyword */:
                case 157 /* SyntaxKind.GlobalKeyword */:
                    // When these don't start a declaration, they're an identifier in an expression statement
                    return true;
                case 123 /* SyntaxKind.PublicKeyword */:
                case 121 /* SyntaxKind.PrivateKeyword */:
                case 122 /* SyntaxKind.ProtectedKeyword */:
                case 124 /* SyntaxKind.StaticKeyword */:
                case 145 /* SyntaxKind.ReadonlyKeyword */:
                    // When these don't start a declaration, they may be the start of a class member if an identifier
                    // immediately follows. Otherwise they're an identifier in an expression statement.
                    return isStartOfDeclaration() || !lookAhead(nextTokenIsIdentifierOrKeywordOnSameLine);
                default:
                    return isStartOfExpression();
            }
        }
        function nextTokenIsBindingIdentifierOrStartOfDestructuring() {
            nextToken();
            return isBindingIdentifier() || token() === 18 /* SyntaxKind.OpenBraceToken */ || token() === 22 /* SyntaxKind.OpenBracketToken */;
        }
        function isLetDeclaration() {
            // In ES6 'let' always starts a lexical declaration if followed by an identifier or {
            // or [.
            return lookAhead(nextTokenIsBindingIdentifierOrStartOfDestructuring);
        }
        function parseStatement() {
            switch (token()) {
                case 26 /* SyntaxKind.SemicolonToken */:
                    return parseEmptyStatement();
                case 18 /* SyntaxKind.OpenBraceToken */:
                    return parseBlock(/*ignoreMissingOpenBrace*/ false);
                case 113 /* SyntaxKind.VarKeyword */:
                    return parseVariableStatement(getNodePos(), hasPrecedingJSDocComment(), /*decorators*/ undefined, /*modifiers*/ undefined);
                case 119 /* SyntaxKind.LetKeyword */:
                    if (isLetDeclaration()) {
                        return parseVariableStatement(getNodePos(), hasPrecedingJSDocComment(), /*decorators*/ undefined, /*modifiers*/ undefined);
                    }
                    break;
                case 98 /* SyntaxKind.FunctionKeyword */:
                    return parseFunctionDeclaration(getNodePos(), hasPrecedingJSDocComment(), /*decorators*/ undefined, /*modifiers*/ undefined);
                case 84 /* SyntaxKind.ClassKeyword */:
                    return parseClassDeclaration(getNodePos(), hasPrecedingJSDocComment(), /*decorators*/ undefined, /*modifiers*/ undefined);
                case 99 /* SyntaxKind.IfKeyword */:
                    return parseIfStatement();
                case 90 /* SyntaxKind.DoKeyword */:
                    return parseDoStatement();
                case 115 /* SyntaxKind.WhileKeyword */:
                    return parseWhileStatement();
                case 97 /* SyntaxKind.ForKeyword */:
                    return parseForOrForInOrForOfStatement();
                case 86 /* SyntaxKind.ContinueKeyword */:
                    return parseBreakOrContinueStatement(245 /* SyntaxKind.ContinueStatement */);
                case 81 /* SyntaxKind.BreakKeyword */:
                    return parseBreakOrContinueStatement(246 /* SyntaxKind.BreakStatement */);
                case 105 /* SyntaxKind.ReturnKeyword */:
                    return parseReturnStatement();
                case 116 /* SyntaxKind.WithKeyword */:
                    return parseWithStatement();
                case 107 /* SyntaxKind.SwitchKeyword */:
                    return parseSwitchStatement();
                case 109 /* SyntaxKind.ThrowKeyword */:
                    return parseThrowStatement();
                case 111 /* SyntaxKind.TryKeyword */:
                // Include 'catch' and 'finally' for error recovery.
                // falls through
                case 83 /* SyntaxKind.CatchKeyword */:
                case 96 /* SyntaxKind.FinallyKeyword */:
                    return parseTryStatement();
                case 87 /* SyntaxKind.DebuggerKeyword */:
                    return parseDebuggerStatement();
                case 59 /* SyntaxKind.AtToken */:
                    return parseDeclaration();
                case 131 /* SyntaxKind.AsyncKeyword */:
                case 118 /* SyntaxKind.InterfaceKeyword */:
                case 152 /* SyntaxKind.TypeKeyword */:
                case 141 /* SyntaxKind.ModuleKeyword */:
                case 142 /* SyntaxKind.NamespaceKeyword */:
                case 135 /* SyntaxKind.DeclareKeyword */:
                case 85 /* SyntaxKind.ConstKeyword */:
                case 92 /* SyntaxKind.EnumKeyword */:
                case 93 /* SyntaxKind.ExportKeyword */:
                case 100 /* SyntaxKind.ImportKeyword */:
                case 121 /* SyntaxKind.PrivateKeyword */:
                case 122 /* SyntaxKind.ProtectedKeyword */:
                case 123 /* SyntaxKind.PublicKeyword */:
                case 126 /* SyntaxKind.AbstractKeyword */:
                case 124 /* SyntaxKind.StaticKeyword */:
                case 145 /* SyntaxKind.ReadonlyKeyword */:
                case 157 /* SyntaxKind.GlobalKeyword */:
                    if (isStartOfDeclaration()) {
                        return parseDeclaration();
                    }
                    break;
            }
            return parseExpressionOrLabeledStatement();
        }
        function isDeclareModifier(modifier) {
            return modifier.kind === 135 /* SyntaxKind.DeclareKeyword */;
        }
        function parseDeclaration() {
            // TODO: Can we hold onto the parsed decorators/modifiers and advance the scanner
            //       if we can't reuse the declaration, so that we don't do this work twice?
            //
            // `parseListElement` attempted to get the reused node at this position,
            // but the ambient context flag was not yet set, so the node appeared
            // not reusable in that context.
            var isAmbient = ts.some(lookAhead(function () { return (parseDecorators(), parseModifiers()); }), isDeclareModifier);
            if (isAmbient) {
                var node = tryReuseAmbientDeclaration();
                if (node) {
                    return node;
                }
            }
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            var decorators = parseDecorators();
            var modifiers = parseModifiers();
            if (isAmbient) {
                for (var _i = 0, _a = modifiers; _i < _a.length; _i++) {
                    var m = _a[_i];
                    m.flags |= 16777216 /* NodeFlags.Ambient */;
                }
                return doInsideOfContext(16777216 /* NodeFlags.Ambient */, function () { return parseDeclarationWorker(pos, hasJSDoc, decorators, modifiers); });
            }
            else {
                return parseDeclarationWorker(pos, hasJSDoc, decorators, modifiers);
            }
        }
        function tryReuseAmbientDeclaration() {
            return doInsideOfContext(16777216 /* NodeFlags.Ambient */, function () {
                var node = currentNode(parsingContext);
                if (node) {
                    return consumeNode(node);
                }
            });
        }
        function parseDeclarationWorker(pos, hasJSDoc, decorators, modifiers) {
            switch (token()) {
                case 113 /* SyntaxKind.VarKeyword */:
                case 119 /* SyntaxKind.LetKeyword */:
                case 85 /* SyntaxKind.ConstKeyword */:
                    return parseVariableStatement(pos, hasJSDoc, decorators, modifiers);
                case 98 /* SyntaxKind.FunctionKeyword */:
                    return parseFunctionDeclaration(pos, hasJSDoc, decorators, modifiers);
                case 84 /* SyntaxKind.ClassKeyword */:
                    return parseClassDeclaration(pos, hasJSDoc, decorators, modifiers);
                case 118 /* SyntaxKind.InterfaceKeyword */:
                    return parseInterfaceDeclaration(pos, hasJSDoc, decorators, modifiers);
                case 152 /* SyntaxKind.TypeKeyword */:
                    return parseTypeAliasDeclaration(pos, hasJSDoc, decorators, modifiers);
                case 92 /* SyntaxKind.EnumKeyword */:
                    return parseEnumDeclaration(pos, hasJSDoc, decorators, modifiers);
                case 157 /* SyntaxKind.GlobalKeyword */:
                case 141 /* SyntaxKind.ModuleKeyword */:
                case 142 /* SyntaxKind.NamespaceKeyword */:
                    return parseModuleDeclaration(pos, hasJSDoc, decorators, modifiers);
                case 100 /* SyntaxKind.ImportKeyword */:
                    return parseImportDeclarationOrImportEqualsDeclaration(pos, hasJSDoc, decorators, modifiers);
                case 93 /* SyntaxKind.ExportKeyword */:
                    nextToken();
                    switch (token()) {
                        case 88 /* SyntaxKind.DefaultKeyword */:
                        case 63 /* SyntaxKind.EqualsToken */:
                            return parseExportAssignment(pos, hasJSDoc, decorators, modifiers);
                        case 127 /* SyntaxKind.AsKeyword */:
                            return parseNamespaceExportDeclaration(pos, hasJSDoc, decorators, modifiers);
                        default:
                            return parseExportDeclaration(pos, hasJSDoc, decorators, modifiers);
                    }
                default:
                    if (decorators || modifiers) {
                        // We reached this point because we encountered decorators and/or modifiers and assumed a declaration
                        // would follow. For recovery and error reporting purposes, return an incomplete declaration.
                        var missing = createMissingNode(276 /* SyntaxKind.MissingDeclaration */, /*reportAtCurrentPosition*/ true, ts.Diagnostics.Declaration_expected);
                        ts.setTextRangePos(missing, pos);
                        missing.decorators = decorators;
                        missing.modifiers = modifiers;
                        return missing;
                    }
                    return undefined; // TODO: GH#18217
            }
        }
        function nextTokenIsIdentifierOrStringLiteralOnSameLine() {
            nextToken();
            return !scanner.hasPrecedingLineBreak() && (isIdentifier() || token() === 10 /* SyntaxKind.StringLiteral */);
        }
        function parseFunctionBlockOrSemicolon(flags, diagnosticMessage) {
            if (token() !== 18 /* SyntaxKind.OpenBraceToken */ && canParseSemicolon()) {
                parseSemicolon();
                return;
            }
            return parseFunctionBlock(flags, diagnosticMessage);
        }
        // DECLARATIONS
        function parseArrayBindingElement() {
            var pos = getNodePos();
            if (token() === 27 /* SyntaxKind.CommaToken */) {
                return finishNode(factory.createOmittedExpression(), pos);
            }
            var dotDotDotToken = parseOptionalToken(25 /* SyntaxKind.DotDotDotToken */);
            var name = parseIdentifierOrPattern();
            var initializer = parseInitializer();
            return finishNode(factory.createBindingElement(dotDotDotToken, /*propertyName*/ undefined, name, initializer), pos);
        }
        function parseObjectBindingElement() {
            var pos = getNodePos();
            var dotDotDotToken = parseOptionalToken(25 /* SyntaxKind.DotDotDotToken */);
            var tokenIsIdentifier = isBindingIdentifier();
            var propertyName = parsePropertyName();
            var name;
            if (tokenIsIdentifier && token() !== 58 /* SyntaxKind.ColonToken */) {
                name = propertyName;
                propertyName = undefined;
            }
            else {
                parseExpected(58 /* SyntaxKind.ColonToken */);
                name = parseIdentifierOrPattern();
            }
            var initializer = parseInitializer();
            return finishNode(factory.createBindingElement(dotDotDotToken, propertyName, name, initializer), pos);
        }
        function parseObjectBindingPattern() {
            var pos = getNodePos();
            parseExpected(18 /* SyntaxKind.OpenBraceToken */);
            var elements = parseDelimitedList(9 /* ParsingContext.ObjectBindingElements */, parseObjectBindingElement);
            parseExpected(19 /* SyntaxKind.CloseBraceToken */);
            return finishNode(factory.createObjectBindingPattern(elements), pos);
        }
        function parseArrayBindingPattern() {
            var pos = getNodePos();
            parseExpected(22 /* SyntaxKind.OpenBracketToken */);
            var elements = parseDelimitedList(10 /* ParsingContext.ArrayBindingElements */, parseArrayBindingElement);
            parseExpected(23 /* SyntaxKind.CloseBracketToken */);
            return finishNode(factory.createArrayBindingPattern(elements), pos);
        }
        function isBindingIdentifierOrPrivateIdentifierOrPattern() {
            return token() === 18 /* SyntaxKind.OpenBraceToken */
                || token() === 22 /* SyntaxKind.OpenBracketToken */
                || token() === 80 /* SyntaxKind.PrivateIdentifier */
                || isBindingIdentifier();
        }
        function parseIdentifierOrPattern(privateIdentifierDiagnosticMessage) {
            if (token() === 22 /* SyntaxKind.OpenBracketToken */) {
                return parseArrayBindingPattern();
            }
            if (token() === 18 /* SyntaxKind.OpenBraceToken */) {
                return parseObjectBindingPattern();
            }
            return parseBindingIdentifier(privateIdentifierDiagnosticMessage);
        }
        function parseVariableDeclarationAllowExclamation() {
            return parseVariableDeclaration(/*allowExclamation*/ true);
        }
        function parseVariableDeclaration(allowExclamation) {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            var name = parseIdentifierOrPattern(ts.Diagnostics.Private_identifiers_are_not_allowed_in_variable_declarations);
            var exclamationToken;
            if (allowExclamation && name.kind === 79 /* SyntaxKind.Identifier */ &&
                token() === 53 /* SyntaxKind.ExclamationToken */ && !scanner.hasPrecedingLineBreak()) {
                exclamationToken = parseTokenNode();
            }
            var type = parseTypeAnnotation();
            var initializer = isInOrOfKeyword(token()) ? undefined : parseInitializer();
            var node = factory.createVariableDeclaration(name, exclamationToken, type, initializer);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseVariableDeclarationList(inForStatementInitializer) {
            var pos = getNodePos();
            var flags = 0;
            switch (token()) {
                case 113 /* SyntaxKind.VarKeyword */:
                    break;
                case 119 /* SyntaxKind.LetKeyword */:
                    flags |= 1 /* NodeFlags.Let */;
                    break;
                case 85 /* SyntaxKind.ConstKeyword */:
                    flags |= 2 /* NodeFlags.Const */;
                    break;
                default:
                    ts.Debug.fail();
            }
            nextToken();
            // The user may have written the following:
            //
            //    for (let of X) { }
            //
            // In this case, we want to parse an empty declaration list, and then parse 'of'
            // as a keyword. The reason this is not automatic is that 'of' is a valid identifier.
            // So we need to look ahead to determine if 'of' should be treated as a keyword in
            // this context.
            // The checker will then give an error that there is an empty declaration list.
            var declarations;
            if (token() === 160 /* SyntaxKind.OfKeyword */ && lookAhead(canFollowContextualOfKeyword)) {
                declarations = createMissingList();
            }
            else {
                var savedDisallowIn = inDisallowInContext();
                setDisallowInContext(inForStatementInitializer);
                declarations = parseDelimitedList(8 /* ParsingContext.VariableDeclarations */, inForStatementInitializer ? parseVariableDeclaration : parseVariableDeclarationAllowExclamation);
                setDisallowInContext(savedDisallowIn);
            }
            return finishNode(factory.createVariableDeclarationList(declarations, flags), pos);
        }
        function canFollowContextualOfKeyword() {
            return nextTokenIsIdentifier() && nextToken() === 21 /* SyntaxKind.CloseParenToken */;
        }
        function parseVariableStatement(pos, hasJSDoc, decorators, modifiers) {
            var declarationList = parseVariableDeclarationList(/*inForStatementInitializer*/ false);
            parseSemicolon();
            var node = factory.createVariableStatement(modifiers, declarationList);
            // Decorators are not allowed on a variable statement, so we keep track of them to report them in the grammar checker.
            node.decorators = decorators;
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseFunctionDeclaration(pos, hasJSDoc, decorators, modifiers) {
            var savedAwaitContext = inAwaitContext();
            var modifierFlags = ts.modifiersToFlags(modifiers);
            parseExpected(98 /* SyntaxKind.FunctionKeyword */);
            var asteriskToken = parseOptionalToken(41 /* SyntaxKind.AsteriskToken */);
            // We don't parse the name here in await context, instead we will report a grammar error in the checker.
            var name = modifierFlags & 512 /* ModifierFlags.Default */ ? parseOptionalBindingIdentifier() : parseBindingIdentifier();
            var isGenerator = asteriskToken ? 1 /* SignatureFlags.Yield */ : 0 /* SignatureFlags.None */;
            var isAsync = modifierFlags & 256 /* ModifierFlags.Async */ ? 2 /* SignatureFlags.Await */ : 0 /* SignatureFlags.None */;
            var typeParameters = parseTypeParameters();
            if (modifierFlags & 1 /* ModifierFlags.Export */)
                setAwaitContext(/*value*/ true);
            var parameters = parseParameters(isGenerator | isAsync);
            var type = parseReturnType(58 /* SyntaxKind.ColonToken */, /*isType*/ false);
            var body = parseFunctionBlockOrSemicolon(isGenerator | isAsync, ts.Diagnostics.or_expected);
            setAwaitContext(savedAwaitContext);
            var node = factory.createFunctionDeclaration(decorators, modifiers, asteriskToken, name, typeParameters, parameters, type, body);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseConstructorName() {
            if (token() === 134 /* SyntaxKind.ConstructorKeyword */) {
                return parseExpected(134 /* SyntaxKind.ConstructorKeyword */);
            }
            if (token() === 10 /* SyntaxKind.StringLiteral */ && lookAhead(nextToken) === 20 /* SyntaxKind.OpenParenToken */) {
                return tryParse(function () {
                    var literalNode = parseLiteralNode();
                    return literalNode.text === "constructor" ? literalNode : undefined;
                });
            }
        }
        function tryParseConstructorDeclaration(pos, hasJSDoc, decorators, modifiers) {
            return tryParse(function () {
                if (parseConstructorName()) {
                    var typeParameters = parseTypeParameters();
                    var parameters = parseParameters(0 /* SignatureFlags.None */);
                    var type = parseReturnType(58 /* SyntaxKind.ColonToken */, /*isType*/ false);
                    var body = parseFunctionBlockOrSemicolon(0 /* SignatureFlags.None */, ts.Diagnostics.or_expected);
                    var node = factory.createConstructorDeclaration(decorators, modifiers, parameters, body);
                    // Attach `typeParameters` and `type` if they exist so that we can report them in the grammar checker.
                    node.typeParameters = typeParameters;
                    node.type = type;
                    return withJSDoc(finishNode(node, pos), hasJSDoc);
                }
            });
        }
        function parseMethodDeclaration(pos, hasJSDoc, decorators, modifiers, asteriskToken, name, questionToken, exclamationToken, diagnosticMessage) {
            var isGenerator = asteriskToken ? 1 /* SignatureFlags.Yield */ : 0 /* SignatureFlags.None */;
            var isAsync = ts.some(modifiers, ts.isAsyncModifier) ? 2 /* SignatureFlags.Await */ : 0 /* SignatureFlags.None */;
            var typeParameters = parseTypeParameters();
            var parameters = parseParameters(isGenerator | isAsync);
            var type = parseReturnType(58 /* SyntaxKind.ColonToken */, /*isType*/ false);
            var body = parseFunctionBlockOrSemicolon(isGenerator | isAsync, diagnosticMessage);
            var node = factory.createMethodDeclaration(decorators, modifiers, asteriskToken, name, questionToken, typeParameters, parameters, type, body);
            // An exclamation token on a method is invalid syntax and will be handled by the grammar checker
            node.exclamationToken = exclamationToken;
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parsePropertyDeclaration(pos, hasJSDoc, decorators, modifiers, name, questionToken) {
            var exclamationToken = !questionToken && !scanner.hasPrecedingLineBreak() ? parseOptionalToken(53 /* SyntaxKind.ExclamationToken */) : undefined;
            var type = parseTypeAnnotation();
            var initializer = doOutsideOfContext(8192 /* NodeFlags.YieldContext */ | 32768 /* NodeFlags.AwaitContext */ | 4096 /* NodeFlags.DisallowInContext */, parseInitializer);
            parseSemicolonAfterPropertyName(name, type, initializer);
            var node = factory.createPropertyDeclaration(decorators, modifiers, name, questionToken || exclamationToken, type, initializer);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parsePropertyOrMethodDeclaration(pos, hasJSDoc, decorators, modifiers) {
            var asteriskToken = parseOptionalToken(41 /* SyntaxKind.AsteriskToken */);
            var name = parsePropertyName();
            // Note: this is not legal as per the grammar.  But we allow it in the parser and
            // report an error in the grammar checker.
            var questionToken = parseOptionalToken(57 /* SyntaxKind.QuestionToken */);
            if (asteriskToken || token() === 20 /* SyntaxKind.OpenParenToken */ || token() === 29 /* SyntaxKind.LessThanToken */) {
                return parseMethodDeclaration(pos, hasJSDoc, decorators, modifiers, asteriskToken, name, questionToken, /*exclamationToken*/ undefined, ts.Diagnostics.or_expected);
            }
            return parsePropertyDeclaration(pos, hasJSDoc, decorators, modifiers, name, questionToken);
        }
        function parseAccessorDeclaration(pos, hasJSDoc, decorators, modifiers, kind) {
            var name = parsePropertyName();
            var typeParameters = parseTypeParameters();
            var parameters = parseParameters(0 /* SignatureFlags.None */);
            var type = parseReturnType(58 /* SyntaxKind.ColonToken */, /*isType*/ false);
            var body = parseFunctionBlockOrSemicolon(0 /* SignatureFlags.None */);
            var node = kind === 172 /* SyntaxKind.GetAccessor */
                ? factory.createGetAccessorDeclaration(decorators, modifiers, name, parameters, type, body)
                : factory.createSetAccessorDeclaration(decorators, modifiers, name, parameters, body);
            // Keep track of `typeParameters` (for both) and `type` (for setters) if they were parsed those indicate grammar errors
            node.typeParameters = typeParameters;
            if (type && node.kind === 173 /* SyntaxKind.SetAccessor */)
                node.type = type;
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function isClassMemberStart() {
            var idToken;
            if (token() === 59 /* SyntaxKind.AtToken */) {
                return true;
            }
            // Eat up all modifiers, but hold on to the last one in case it is actually an identifier.
            while (ts.isModifierKind(token())) {
                idToken = token();
                // If the idToken is a class modifier (protected, private, public, and static), it is
                // certain that we are starting to parse class member. This allows better error recovery
                // Example:
                //      public foo() ...     // true
                //      public @dec blah ... // true; we will then report an error later
                //      export public ...    // true; we will then report an error later
                if (ts.isClassMemberModifier(idToken)) {
                    return true;
                }
                nextToken();
            }
            if (token() === 41 /* SyntaxKind.AsteriskToken */) {
                return true;
            }
            // Try to get the first property-like token following all modifiers.
            // This can either be an identifier or the 'get' or 'set' keywords.
            if (isLiteralPropertyName()) {
                idToken = token();
                nextToken();
            }
            // Index signatures and computed properties are class members; we can parse.
            if (token() === 22 /* SyntaxKind.OpenBracketToken */) {
                return true;
            }
            // If we were able to get any potential identifier...
            if (idToken !== undefined) {
                // If we have a non-keyword identifier, or if we have an accessor, then it's safe to parse.
                if (!ts.isKeyword(idToken) || idToken === 149 /* SyntaxKind.SetKeyword */ || idToken === 136 /* SyntaxKind.GetKeyword */) {
                    return true;
                }
                // If it *is* a keyword, but not an accessor, check a little farther along
                // to see if it should actually be parsed as a class member.
                switch (token()) {
                    case 20 /* SyntaxKind.OpenParenToken */: // Method declaration
                    case 29 /* SyntaxKind.LessThanToken */: // Generic Method declaration
                    case 53 /* SyntaxKind.ExclamationToken */: // Non-null assertion on property name
                    case 58 /* SyntaxKind.ColonToken */: // Type Annotation for declaration
                    case 63 /* SyntaxKind.EqualsToken */: // Initializer for declaration
                    case 57 /* SyntaxKind.QuestionToken */: // Not valid, but permitted so that it gets caught later on.
                        return true;
                    default:
                        // Covers
                        //  - Semicolons     (declaration termination)
                        //  - Closing braces (end-of-class, must be declaration)
                        //  - End-of-files   (not valid, but permitted so that it gets caught later on)
                        //  - Line-breaks    (enabling *automatic semicolon insertion*)
                        return canParseSemicolon();
                }
            }
            return false;
        }
        function parseClassStaticBlockDeclaration(pos, hasJSDoc, decorators, modifiers) {
            parseExpectedToken(124 /* SyntaxKind.StaticKeyword */);
            var body = parseClassStaticBlockBody();
            return withJSDoc(finishNode(factory.createClassStaticBlockDeclaration(decorators, modifiers, body), pos), hasJSDoc);
        }
        function parseClassStaticBlockBody() {
            var savedYieldContext = inYieldContext();
            var savedAwaitContext = inAwaitContext();
            setYieldContext(false);
            setAwaitContext(true);
            var body = parseBlock(/*ignoreMissingOpenBrace*/ false);
            setYieldContext(savedYieldContext);
            setAwaitContext(savedAwaitContext);
            return body;
        }
        function parseDecoratorExpression() {
            if (inAwaitContext() && token() === 132 /* SyntaxKind.AwaitKeyword */) {
                // `@await` is is disallowed in an [Await] context, but can cause parsing to go off the rails
                // This simply parses the missing identifier and moves on.
                var pos = getNodePos();
                var awaitExpression = parseIdentifier(ts.Diagnostics.Expression_expected);
                nextToken();
                var memberExpression = parseMemberExpressionRest(pos, awaitExpression, /*allowOptionalChain*/ true);
                return parseCallExpressionRest(pos, memberExpression);
            }
            return parseLeftHandSideExpressionOrHigher();
        }
        function tryParseDecorator() {
            var pos = getNodePos();
            if (!parseOptional(59 /* SyntaxKind.AtToken */)) {
                return undefined;
            }
            var expression = doInDecoratorContext(parseDecoratorExpression);
            return finishNode(factory.createDecorator(expression), pos);
        }
        function parseDecorators() {
            var pos = getNodePos();
            var list, decorator;
            while (decorator = tryParseDecorator()) {
                list = ts.append(list, decorator);
            }
            return list && createNodeArray(list, pos);
        }
        function tryParseModifier(permitInvalidConstAsModifier, stopOnStartOfClassStaticBlock, hasSeenStaticModifier) {
            var pos = getNodePos();
            var kind = token();
            if (token() === 85 /* SyntaxKind.ConstKeyword */ && permitInvalidConstAsModifier) {
                // We need to ensure that any subsequent modifiers appear on the same line
                // so that when 'const' is a standalone declaration, we don't issue an error.
                if (!tryParse(nextTokenIsOnSameLineAndCanFollowModifier)) {
                    return undefined;
                }
            }
            else if (stopOnStartOfClassStaticBlock && token() === 124 /* SyntaxKind.StaticKeyword */ && lookAhead(nextTokenIsOpenBrace)) {
                return undefined;
            }
            else if (hasSeenStaticModifier && token() === 124 /* SyntaxKind.StaticKeyword */) {
                return undefined;
            }
            else {
                if (!parseAnyContextualModifier()) {
                    return undefined;
                }
            }
            return finishNode(factory.createToken(kind), pos);
        }
        /*
         * There are situations in which a modifier like 'const' will appear unexpectedly, such as on a class member.
         * In those situations, if we are entirely sure that 'const' is not valid on its own (such as when ASI takes effect
         * and turns it into a standalone declaration), then it is better to parse it and report an error later.
         *
         * In such situations, 'permitInvalidConstAsModifier' should be set to true.
         */
        function parseModifiers(permitInvalidConstAsModifier, stopOnStartOfClassStaticBlock) {
            var pos = getNodePos();
            var list, modifier, hasSeenStatic = false;
            while (modifier = tryParseModifier(permitInvalidConstAsModifier, stopOnStartOfClassStaticBlock, hasSeenStatic)) {
                if (modifier.kind === 124 /* SyntaxKind.StaticKeyword */)
                    hasSeenStatic = true;
                list = ts.append(list, modifier);
            }
            return list && createNodeArray(list, pos);
        }
        function parseModifiersForArrowFunction() {
            var modifiers;
            if (token() === 131 /* SyntaxKind.AsyncKeyword */) {
                var pos = getNodePos();
                nextToken();
                var modifier = finishNode(factory.createToken(131 /* SyntaxKind.AsyncKeyword */), pos);
                modifiers = createNodeArray([modifier], pos);
            }
            return modifiers;
        }
        function parseClassElement() {
            var pos = getNodePos();
            if (token() === 26 /* SyntaxKind.SemicolonToken */) {
                nextToken();
                return finishNode(factory.createSemicolonClassElement(), pos);
            }
            var hasJSDoc = hasPrecedingJSDocComment();
            var decorators = parseDecorators();
            var modifiers = parseModifiers(/*permitInvalidConstAsModifier*/ true, /*stopOnStartOfClassStaticBlock*/ true);
            if (token() === 124 /* SyntaxKind.StaticKeyword */ && lookAhead(nextTokenIsOpenBrace)) {
                return parseClassStaticBlockDeclaration(pos, hasJSDoc, decorators, modifiers);
            }
            if (parseContextualModifier(136 /* SyntaxKind.GetKeyword */)) {
                return parseAccessorDeclaration(pos, hasJSDoc, decorators, modifiers, 172 /* SyntaxKind.GetAccessor */);
            }
            if (parseContextualModifier(149 /* SyntaxKind.SetKeyword */)) {
                return parseAccessorDeclaration(pos, hasJSDoc, decorators, modifiers, 173 /* SyntaxKind.SetAccessor */);
            }
            if (token() === 134 /* SyntaxKind.ConstructorKeyword */ || token() === 10 /* SyntaxKind.StringLiteral */) {
                var constructorDeclaration = tryParseConstructorDeclaration(pos, hasJSDoc, decorators, modifiers);
                if (constructorDeclaration) {
                    return constructorDeclaration;
                }
            }
            if (isIndexSignature()) {
                return parseIndexSignatureDeclaration(pos, hasJSDoc, decorators, modifiers);
            }
            // It is very important that we check this *after* checking indexers because
            // the [ token can start an index signature or a computed property name
            if (ts.tokenIsIdentifierOrKeyword(token()) ||
                token() === 10 /* SyntaxKind.StringLiteral */ ||
                token() === 8 /* SyntaxKind.NumericLiteral */ ||
                token() === 41 /* SyntaxKind.AsteriskToken */ ||
                token() === 22 /* SyntaxKind.OpenBracketToken */) {
                var isAmbient = ts.some(modifiers, isDeclareModifier);
                if (isAmbient) {
                    for (var _i = 0, _a = modifiers; _i < _a.length; _i++) {
                        var m = _a[_i];
                        m.flags |= 16777216 /* NodeFlags.Ambient */;
                    }
                    return doInsideOfContext(16777216 /* NodeFlags.Ambient */, function () { return parsePropertyOrMethodDeclaration(pos, hasJSDoc, decorators, modifiers); });
                }
                else {
                    return parsePropertyOrMethodDeclaration(pos, hasJSDoc, decorators, modifiers);
                }
            }
            if (decorators || modifiers) {
                // treat this as a property declaration with a missing name.
                var name = createMissingNode(79 /* SyntaxKind.Identifier */, /*reportAtCurrentPosition*/ true, ts.Diagnostics.Declaration_expected);
                return parsePropertyDeclaration(pos, hasJSDoc, decorators, modifiers, name, /*questionToken*/ undefined);
            }
            // 'isClassMemberStart' should have hinted not to attempt parsing.
            return ts.Debug.fail("Should not have attempted to parse class member declaration.");
        }
        function parseClassExpression() {
            return parseClassDeclarationOrExpression(getNodePos(), hasPrecedingJSDocComment(), /*decorators*/ undefined, /*modifiers*/ undefined, 226 /* SyntaxKind.ClassExpression */);
        }
        function parseClassDeclaration(pos, hasJSDoc, decorators, modifiers) {
            return parseClassDeclarationOrExpression(pos, hasJSDoc, decorators, modifiers, 257 /* SyntaxKind.ClassDeclaration */);
        }
        function parseClassDeclarationOrExpression(pos, hasJSDoc, decorators, modifiers, kind) {
            var savedAwaitContext = inAwaitContext();
            parseExpected(84 /* SyntaxKind.ClassKeyword */);
            // We don't parse the name here in await context, instead we will report a grammar error in the checker.
            var name = parseNameOfClassDeclarationOrExpression();
            var typeParameters = parseTypeParameters();
            if (ts.some(modifiers, ts.isExportModifier))
                setAwaitContext(/*value*/ true);
            var heritageClauses = parseHeritageClauses();
            var members;
            if (parseExpected(18 /* SyntaxKind.OpenBraceToken */)) {
                // ClassTail[Yield,Await] : (Modified) See 14.5
                //      ClassHeritage[?Yield,?Await]opt { ClassBody[?Yield,?Await]opt }
                members = parseClassMembers();
                parseExpected(19 /* SyntaxKind.CloseBraceToken */);
            }
            else {
                members = createMissingList();
            }
            setAwaitContext(savedAwaitContext);
            var node = kind === 257 /* SyntaxKind.ClassDeclaration */
                ? factory.createClassDeclaration(decorators, modifiers, name, typeParameters, heritageClauses, members)
                : factory.createClassExpression(decorators, modifiers, name, typeParameters, heritageClauses, members);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseNameOfClassDeclarationOrExpression() {
            // implements is a future reserved word so
            // 'class implements' might mean either
            // - class expression with omitted name, 'implements' starts heritage clause
            // - class with name 'implements'
            // 'isImplementsClause' helps to disambiguate between these two cases
            return isBindingIdentifier() && !isImplementsClause()
                ? createIdentifier(isBindingIdentifier())
                : undefined;
        }
        function isImplementsClause() {
            return token() === 117 /* SyntaxKind.ImplementsKeyword */ && lookAhead(nextTokenIsIdentifierOrKeyword);
        }
        function parseHeritageClauses() {
            // ClassTail[Yield,Await] : (Modified) See 14.5
            //      ClassHeritage[?Yield,?Await]opt { ClassBody[?Yield,?Await]opt }
            if (isHeritageClause()) {
                return parseList(22 /* ParsingContext.HeritageClauses */, parseHeritageClause);
            }
            return undefined;
        }
        function parseHeritageClause() {
            var pos = getNodePos();
            var tok = token();
            ts.Debug.assert(tok === 94 /* SyntaxKind.ExtendsKeyword */ || tok === 117 /* SyntaxKind.ImplementsKeyword */); // isListElement() should ensure this.
            nextToken();
            var types = parseDelimitedList(7 /* ParsingContext.HeritageClauseElement */, parseExpressionWithTypeArguments);
            return finishNode(factory.createHeritageClause(tok, types), pos);
        }
        function parseExpressionWithTypeArguments() {
            var pos = getNodePos();
            var expression = parseLeftHandSideExpressionOrHigher();
            if (expression.kind === 228 /* SyntaxKind.ExpressionWithTypeArguments */) {
                return expression;
            }
            var typeArguments = tryParseTypeArguments();
            return finishNode(factory.createExpressionWithTypeArguments(expression, typeArguments), pos);
        }
        function tryParseTypeArguments() {
            return token() === 29 /* SyntaxKind.LessThanToken */ ?
                parseBracketedList(20 /* ParsingContext.TypeArguments */, parseType, 29 /* SyntaxKind.LessThanToken */, 31 /* SyntaxKind.GreaterThanToken */) : undefined;
        }
        function isHeritageClause() {
            return token() === 94 /* SyntaxKind.ExtendsKeyword */ || token() === 117 /* SyntaxKind.ImplementsKeyword */;
        }
        function parseClassMembers() {
            return parseList(5 /* ParsingContext.ClassMembers */, parseClassElement);
        }
        function parseInterfaceDeclaration(pos, hasJSDoc, decorators, modifiers) {
            parseExpected(118 /* SyntaxKind.InterfaceKeyword */);
            var name = parseIdentifier();
            var typeParameters = parseTypeParameters();
            var heritageClauses = parseHeritageClauses();
            var members = parseObjectTypeMembers();
            var node = factory.createInterfaceDeclaration(decorators, modifiers, name, typeParameters, heritageClauses, members);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseTypeAliasDeclaration(pos, hasJSDoc, decorators, modifiers) {
            parseExpected(152 /* SyntaxKind.TypeKeyword */);
            var name = parseIdentifier();
            var typeParameters = parseTypeParameters();
            parseExpected(63 /* SyntaxKind.EqualsToken */);
            var type = token() === 138 /* SyntaxKind.IntrinsicKeyword */ && tryParse(parseKeywordAndNoDot) || parseType();
            parseSemicolon();
            var node = factory.createTypeAliasDeclaration(decorators, modifiers, name, typeParameters, type);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        // In an ambient declaration, the grammar only allows integer literals as initializers.
        // In a non-ambient declaration, the grammar allows uninitialized members only in a
        // ConstantEnumMemberSection, which starts at the beginning of an enum declaration
        // or any time an integer literal initializer is encountered.
        function parseEnumMember() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            var name = parsePropertyName();
            var initializer = allowInAnd(parseInitializer);
            return withJSDoc(finishNode(factory.createEnumMember(name, initializer), pos), hasJSDoc);
        }
        function parseEnumDeclaration(pos, hasJSDoc, decorators, modifiers) {
            parseExpected(92 /* SyntaxKind.EnumKeyword */);
            var name = parseIdentifier();
            var members;
            if (parseExpected(18 /* SyntaxKind.OpenBraceToken */)) {
                members = doOutsideOfYieldAndAwaitContext(function () { return parseDelimitedList(6 /* ParsingContext.EnumMembers */, parseEnumMember); });
                parseExpected(19 /* SyntaxKind.CloseBraceToken */);
            }
            else {
                members = createMissingList();
            }
            var node = factory.createEnumDeclaration(decorators, modifiers, name, members);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseModuleBlock() {
            var pos = getNodePos();
            var statements;
            if (parseExpected(18 /* SyntaxKind.OpenBraceToken */)) {
                statements = parseList(1 /* ParsingContext.BlockStatements */, parseStatement);
                parseExpected(19 /* SyntaxKind.CloseBraceToken */);
            }
            else {
                statements = createMissingList();
            }
            return finishNode(factory.createModuleBlock(statements), pos);
        }
        function parseModuleOrNamespaceDeclaration(pos, hasJSDoc, decorators, modifiers, flags) {
            // If we are parsing a dotted namespace name, we want to
            // propagate the 'Namespace' flag across the names if set.
            var namespaceFlag = flags & 16 /* NodeFlags.Namespace */;
            var name = parseIdentifier();
            var body = parseOptional(24 /* SyntaxKind.DotToken */)
                ? parseModuleOrNamespaceDeclaration(getNodePos(), /*hasJSDoc*/ false, /*decorators*/ undefined, /*modifiers*/ undefined, 4 /* NodeFlags.NestedNamespace */ | namespaceFlag)
                : parseModuleBlock();
            var node = factory.createModuleDeclaration(decorators, modifiers, name, body, flags);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseAmbientExternalModuleDeclaration(pos, hasJSDoc, decorators, modifiers) {
            var flags = 0;
            var name;
            if (token() === 157 /* SyntaxKind.GlobalKeyword */) {
                // parse 'global' as name of global scope augmentation
                name = parseIdentifier();
                flags |= 1024 /* NodeFlags.GlobalAugmentation */;
            }
            else {
                name = parseLiteralNode();
                name.text = internIdentifier(name.text);
            }
            var body;
            if (token() === 18 /* SyntaxKind.OpenBraceToken */) {
                body = parseModuleBlock();
            }
            else {
                parseSemicolon();
            }
            var node = factory.createModuleDeclaration(decorators, modifiers, name, body, flags);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseModuleDeclaration(pos, hasJSDoc, decorators, modifiers) {
            var flags = 0;
            if (token() === 157 /* SyntaxKind.GlobalKeyword */) {
                // global augmentation
                return parseAmbientExternalModuleDeclaration(pos, hasJSDoc, decorators, modifiers);
            }
            else if (parseOptional(142 /* SyntaxKind.NamespaceKeyword */)) {
                flags |= 16 /* NodeFlags.Namespace */;
            }
            else {
                parseExpected(141 /* SyntaxKind.ModuleKeyword */);
                if (token() === 10 /* SyntaxKind.StringLiteral */) {
                    return parseAmbientExternalModuleDeclaration(pos, hasJSDoc, decorators, modifiers);
                }
            }
            return parseModuleOrNamespaceDeclaration(pos, hasJSDoc, decorators, modifiers, flags);
        }
        function isExternalModuleReference() {
            return token() === 146 /* SyntaxKind.RequireKeyword */ &&
                lookAhead(nextTokenIsOpenParen);
        }
        function nextTokenIsOpenParen() {
            return nextToken() === 20 /* SyntaxKind.OpenParenToken */;
        }
        function nextTokenIsOpenBrace() {
            return nextToken() === 18 /* SyntaxKind.OpenBraceToken */;
        }
        function nextTokenIsSlash() {
            return nextToken() === 43 /* SyntaxKind.SlashToken */;
        }
        function parseNamespaceExportDeclaration(pos, hasJSDoc, decorators, modifiers) {
            parseExpected(127 /* SyntaxKind.AsKeyword */);
            parseExpected(142 /* SyntaxKind.NamespaceKeyword */);
            var name = parseIdentifier();
            parseSemicolon();
            var node = factory.createNamespaceExportDeclaration(name);
            // NamespaceExportDeclaration nodes cannot have decorators or modifiers, so we attach them here so we can report them in the grammar checker
            node.decorators = decorators;
            node.modifiers = modifiers;
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseImportDeclarationOrImportEqualsDeclaration(pos, hasJSDoc, decorators, modifiers) {
            parseExpected(100 /* SyntaxKind.ImportKeyword */);
            var afterImportPos = scanner.getStartPos();
            // We don't parse the identifier here in await context, instead we will report a grammar error in the checker.
            var identifier;
            if (isIdentifier()) {
                identifier = parseIdentifier();
            }
            var isTypeOnly = false;
            if (token() !== 156 /* SyntaxKind.FromKeyword */ &&
                (identifier === null || identifier === void 0 ? void 0 : identifier.escapedText) === "type" &&
                (isIdentifier() || tokenAfterImportDefinitelyProducesImportDeclaration())) {
                isTypeOnly = true;
                identifier = isIdentifier() ? parseIdentifier() : undefined;
            }
            if (identifier && !tokenAfterImportedIdentifierDefinitelyProducesImportDeclaration()) {
                return parseImportEqualsDeclaration(pos, hasJSDoc, decorators, modifiers, identifier, isTypeOnly);
            }
            // ImportDeclaration:
            //  import ImportClause from ModuleSpecifier ;
            //  import ModuleSpecifier;
            var importClause;
            if (identifier || // import id
                token() === 41 /* SyntaxKind.AsteriskToken */ || // import *
                token() === 18 /* SyntaxKind.OpenBraceToken */ // import {
            ) {
                importClause = parseImportClause(identifier, afterImportPos, isTypeOnly);
                parseExpected(156 /* SyntaxKind.FromKeyword */);
            }
            var moduleSpecifier = parseModuleSpecifier();
            var assertClause;
            if (token() === 129 /* SyntaxKind.AssertKeyword */ && !scanner.hasPrecedingLineBreak()) {
                assertClause = parseAssertClause();
            }
            parseSemicolon();
            var node = factory.createImportDeclaration(decorators, modifiers, importClause, moduleSpecifier, assertClause);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseAssertEntry() {
            var pos = getNodePos();
            var name = ts.tokenIsIdentifierOrKeyword(token()) ? parseIdentifierName() : parseLiteralLikeNode(10 /* SyntaxKind.StringLiteral */);
            parseExpected(58 /* SyntaxKind.ColonToken */);
            var value = parseAssignmentExpressionOrHigher();
            return finishNode(factory.createAssertEntry(name, value), pos);
        }
        function parseAssertClause(skipAssertKeyword) {
            var pos = getNodePos();
            if (!skipAssertKeyword) {
                parseExpected(129 /* SyntaxKind.AssertKeyword */);
            }
            var openBracePosition = scanner.getTokenPos();
            if (parseExpected(18 /* SyntaxKind.OpenBraceToken */)) {
                var multiLine = scanner.hasPrecedingLineBreak();
                var elements = parseDelimitedList(24 /* ParsingContext.AssertEntries */, parseAssertEntry, /*considerSemicolonAsDelimiter*/ true);
                if (!parseExpected(19 /* SyntaxKind.CloseBraceToken */)) {
                    var lastError = ts.lastOrUndefined(parseDiagnostics);
                    if (lastError && lastError.code === ts.Diagnostics._0_expected.code) {
                        ts.addRelatedInfo(lastError, ts.createDetachedDiagnostic(fileName, openBracePosition, 1, ts.Diagnostics.The_parser_expected_to_find_a_1_to_match_the_0_token_here, "{", "}"));
                    }
                }
                return finishNode(factory.createAssertClause(elements, multiLine), pos);
            }
            else {
                var elements = createNodeArray([], getNodePos(), /*end*/ undefined, /*hasTrailingComma*/ false);
                return finishNode(factory.createAssertClause(elements, /*multiLine*/ false), pos);
            }
        }
        function tokenAfterImportDefinitelyProducesImportDeclaration() {
            return token() === 41 /* SyntaxKind.AsteriskToken */ || token() === 18 /* SyntaxKind.OpenBraceToken */;
        }
        function tokenAfterImportedIdentifierDefinitelyProducesImportDeclaration() {
            // In `import id ___`, the current token decides whether to produce
            // an ImportDeclaration or ImportEqualsDeclaration.
            return token() === 27 /* SyntaxKind.CommaToken */ || token() === 156 /* SyntaxKind.FromKeyword */;
        }
        function parseImportEqualsDeclaration(pos, hasJSDoc, decorators, modifiers, identifier, isTypeOnly) {
            parseExpected(63 /* SyntaxKind.EqualsToken */);
            var moduleReference = parseModuleReference();
            parseSemicolon();
            var node = factory.createImportEqualsDeclaration(decorators, modifiers, isTypeOnly, identifier, moduleReference);
            var finished = withJSDoc(finishNode(node, pos), hasJSDoc);
            return finished;
        }
        function parseImportClause(identifier, pos, isTypeOnly) {
            // ImportClause:
            //  ImportedDefaultBinding
            //  NameSpaceImport
            //  NamedImports
            //  ImportedDefaultBinding, NameSpaceImport
            //  ImportedDefaultBinding, NamedImports
            // If there was no default import or if there is comma token after default import
            // parse namespace or named imports
            var namedBindings;
            if (!identifier ||
                parseOptional(27 /* SyntaxKind.CommaToken */)) {
                namedBindings = token() === 41 /* SyntaxKind.AsteriskToken */ ? parseNamespaceImport() : parseNamedImportsOrExports(269 /* SyntaxKind.NamedImports */);
            }
            return finishNode(factory.createImportClause(isTypeOnly, identifier, namedBindings), pos);
        }
        function parseModuleReference() {
            return isExternalModuleReference()
                ? parseExternalModuleReference()
                : parseEntityName(/*allowReservedWords*/ false);
        }
        function parseExternalModuleReference() {
            var pos = getNodePos();
            parseExpected(146 /* SyntaxKind.RequireKeyword */);
            parseExpected(20 /* SyntaxKind.OpenParenToken */);
            var expression = parseModuleSpecifier();
            parseExpected(21 /* SyntaxKind.CloseParenToken */);
            return finishNode(factory.createExternalModuleReference(expression), pos);
        }
        function parseModuleSpecifier() {
            if (token() === 10 /* SyntaxKind.StringLiteral */) {
                var result = parseLiteralNode();
                result.text = internIdentifier(result.text);
                return result;
            }
            else {
                // We allow arbitrary expressions here, even though the grammar only allows string
                // literals.  We check to ensure that it is only a string literal later in the grammar
                // check pass.
                return parseExpression();
            }
        }
        function parseNamespaceImport() {
            // NameSpaceImport:
            //  * as ImportedBinding
            var pos = getNodePos();
            parseExpected(41 /* SyntaxKind.AsteriskToken */);
            parseExpected(127 /* SyntaxKind.AsKeyword */);
            var name = parseIdentifier();
            return finishNode(factory.createNamespaceImport(name), pos);
        }
        function parseNamedImportsOrExports(kind) {
            var pos = getNodePos();
            // NamedImports:
            //  { }
            //  { ImportsList }
            //  { ImportsList, }
            // ImportsList:
            //  ImportSpecifier
            //  ImportsList, ImportSpecifier
            var node = kind === 269 /* SyntaxKind.NamedImports */
                ? factory.createNamedImports(parseBracketedList(23 /* ParsingContext.ImportOrExportSpecifiers */, parseImportSpecifier, 18 /* SyntaxKind.OpenBraceToken */, 19 /* SyntaxKind.CloseBraceToken */))
                : factory.createNamedExports(parseBracketedList(23 /* ParsingContext.ImportOrExportSpecifiers */, parseExportSpecifier, 18 /* SyntaxKind.OpenBraceToken */, 19 /* SyntaxKind.CloseBraceToken */));
            return finishNode(node, pos);
        }
        function parseExportSpecifier() {
            var hasJSDoc = hasPrecedingJSDocComment();
            return withJSDoc(parseImportOrExportSpecifier(275 /* SyntaxKind.ExportSpecifier */), hasJSDoc);
        }
        function parseImportSpecifier() {
            return parseImportOrExportSpecifier(270 /* SyntaxKind.ImportSpecifier */);
        }
        function parseImportOrExportSpecifier(kind) {
            var pos = getNodePos();
            // ImportSpecifier:
            //   BindingIdentifier
            //   IdentifierName as BindingIdentifier
            // ExportSpecifier:
            //   IdentifierName
            //   IdentifierName as IdentifierName
            var checkIdentifierIsKeyword = ts.isKeyword(token()) && !isIdentifier();
            var checkIdentifierStart = scanner.getTokenPos();
            var checkIdentifierEnd = scanner.getTextPos();
            var isTypeOnly = false;
            var propertyName;
            var canParseAsKeyword = true;
            var name = parseIdentifierName();
            if (name.escapedText === "type") {
                // If the first token of an import specifier is 'type', there are a lot of possibilities,
                // especially if we see 'as' afterwards:
                //
                // import { type } from "mod";          - isTypeOnly: false,   name: type
                // import { type as } from "mod";       - isTypeOnly: true,    name: as
                // import { type as as } from "mod";    - isTypeOnly: false,   name: as,    propertyName: type
                // import { type as as as } from "mod"; - isTypeOnly: true,    name: as,    propertyName: as
                if (token() === 127 /* SyntaxKind.AsKeyword */) {
                    // { type as ...? }
                    var firstAs = parseIdentifierName();
                    if (token() === 127 /* SyntaxKind.AsKeyword */) {
                        // { type as as ...? }
                        var secondAs = parseIdentifierName();
                        if (ts.tokenIsIdentifierOrKeyword(token())) {
                            // { type as as something }
                            isTypeOnly = true;
                            propertyName = firstAs;
                            name = parseNameWithKeywordCheck();
                            canParseAsKeyword = false;
                        }
                        else {
                            // { type as as }
                            propertyName = name;
                            name = secondAs;
                            canParseAsKeyword = false;
                        }
                    }
                    else if (ts.tokenIsIdentifierOrKeyword(token())) {
                        // { type as something }
                        propertyName = name;
                        canParseAsKeyword = false;
                        name = parseNameWithKeywordCheck();
                    }
                    else {
                        // { type as }
                        isTypeOnly = true;
                        name = firstAs;
                    }
                }
                else if (ts.tokenIsIdentifierOrKeyword(token())) {
                    // { type something ...? }
                    isTypeOnly = true;
                    name = parseNameWithKeywordCheck();
                }
            }
            if (canParseAsKeyword && token() === 127 /* SyntaxKind.AsKeyword */) {
                propertyName = name;
                parseExpected(127 /* SyntaxKind.AsKeyword */);
                name = parseNameWithKeywordCheck();
            }
            if (kind === 270 /* SyntaxKind.ImportSpecifier */ && checkIdentifierIsKeyword) {
                parseErrorAt(checkIdentifierStart, checkIdentifierEnd, ts.Diagnostics.Identifier_expected);
            }
            var node = kind === 270 /* SyntaxKind.ImportSpecifier */
                ? factory.createImportSpecifier(isTypeOnly, propertyName, name)
                : factory.createExportSpecifier(isTypeOnly, propertyName, name);
            return finishNode(node, pos);
            function parseNameWithKeywordCheck() {
                checkIdentifierIsKeyword = ts.isKeyword(token()) && !isIdentifier();
                checkIdentifierStart = scanner.getTokenPos();
                checkIdentifierEnd = scanner.getTextPos();
                return parseIdentifierName();
            }
        }
        function parseNamespaceExport(pos) {
            return finishNode(factory.createNamespaceExport(parseIdentifierName()), pos);
        }
        function parseExportDeclaration(pos, hasJSDoc, decorators, modifiers) {
            var savedAwaitContext = inAwaitContext();
            setAwaitContext(/*value*/ true);
            var exportClause;
            var moduleSpecifier;
            var assertClause;
            var isTypeOnly = parseOptional(152 /* SyntaxKind.TypeKeyword */);
            var namespaceExportPos = getNodePos();
            if (parseOptional(41 /* SyntaxKind.AsteriskToken */)) {
                if (parseOptional(127 /* SyntaxKind.AsKeyword */)) {
                    exportClause = parseNamespaceExport(namespaceExportPos);
                }
                parseExpected(156 /* SyntaxKind.FromKeyword */);
                moduleSpecifier = parseModuleSpecifier();
            }
            else {
                exportClause = parseNamedImportsOrExports(273 /* SyntaxKind.NamedExports */);
                // It is not uncommon to accidentally omit the 'from' keyword. Additionally, in editing scenarios,
                // the 'from' keyword can be parsed as a named export when the export clause is unterminated (i.e. `export { from "moduleName";`)
                // If we don't have a 'from' keyword, see if we have a string literal such that ASI won't take effect.
                if (token() === 156 /* SyntaxKind.FromKeyword */ || (token() === 10 /* SyntaxKind.StringLiteral */ && !scanner.hasPrecedingLineBreak())) {
                    parseExpected(156 /* SyntaxKind.FromKeyword */);
                    moduleSpecifier = parseModuleSpecifier();
                }
            }
            if (moduleSpecifier && token() === 129 /* SyntaxKind.AssertKeyword */ && !scanner.hasPrecedingLineBreak()) {
                assertClause = parseAssertClause();
            }
            parseSemicolon();
            setAwaitContext(savedAwaitContext);
            var node = factory.createExportDeclaration(decorators, modifiers, isTypeOnly, exportClause, moduleSpecifier, assertClause);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseExportAssignment(pos, hasJSDoc, decorators, modifiers) {
            var savedAwaitContext = inAwaitContext();
            setAwaitContext(/*value*/ true);
            var isExportEquals;
            if (parseOptional(63 /* SyntaxKind.EqualsToken */)) {
                isExportEquals = true;
            }
            else {
                parseExpected(88 /* SyntaxKind.DefaultKeyword */);
            }
            var expression = parseAssignmentExpressionOrHigher();
            parseSemicolon();
            setAwaitContext(savedAwaitContext);
            var node = factory.createExportAssignment(decorators, modifiers, isExportEquals, expression);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        var ParsingContext;
        (function (ParsingContext) {
            ParsingContext[ParsingContext["SourceElements"] = 0] = "SourceElements";
            ParsingContext[ParsingContext["BlockStatements"] = 1] = "BlockStatements";
            ParsingContext[ParsingContext["SwitchClauses"] = 2] = "SwitchClauses";
            ParsingContext[ParsingContext["SwitchClauseStatements"] = 3] = "SwitchClauseStatements";
            ParsingContext[ParsingContext["TypeMembers"] = 4] = "TypeMembers";
            ParsingContext[ParsingContext["ClassMembers"] = 5] = "ClassMembers";
            ParsingContext[ParsingContext["EnumMembers"] = 6] = "EnumMembers";
            ParsingContext[ParsingContext["HeritageClauseElement"] = 7] = "HeritageClauseElement";
            ParsingContext[ParsingContext["VariableDeclarations"] = 8] = "VariableDeclarations";
            ParsingContext[ParsingContext["ObjectBindingElements"] = 9] = "ObjectBindingElements";
            ParsingContext[ParsingContext["ArrayBindingElements"] = 10] = "ArrayBindingElements";
            ParsingContext[ParsingContext["ArgumentExpressions"] = 11] = "ArgumentExpressions";
            ParsingContext[ParsingContext["ObjectLiteralMembers"] = 12] = "ObjectLiteralMembers";
            ParsingContext[ParsingContext["JsxAttributes"] = 13] = "JsxAttributes";
            ParsingContext[ParsingContext["JsxChildren"] = 14] = "JsxChildren";
            ParsingContext[ParsingContext["ArrayLiteralMembers"] = 15] = "ArrayLiteralMembers";
            ParsingContext[ParsingContext["Parameters"] = 16] = "Parameters";
            ParsingContext[ParsingContext["JSDocParameters"] = 17] = "JSDocParameters";
            ParsingContext[ParsingContext["RestProperties"] = 18] = "RestProperties";
            ParsingContext[ParsingContext["TypeParameters"] = 19] = "TypeParameters";
            ParsingContext[ParsingContext["TypeArguments"] = 20] = "TypeArguments";
            ParsingContext[ParsingContext["TupleElementTypes"] = 21] = "TupleElementTypes";
            ParsingContext[ParsingContext["HeritageClauses"] = 22] = "HeritageClauses";
            ParsingContext[ParsingContext["ImportOrExportSpecifiers"] = 23] = "ImportOrExportSpecifiers";
            ParsingContext[ParsingContext["AssertEntries"] = 24] = "AssertEntries";
            ParsingContext[ParsingContext["Count"] = 25] = "Count"; // Number of parsing contexts
        })(ParsingContext || (ParsingContext = {}));
        var Tristate;
        (function (Tristate) {
            Tristate[Tristate["False"] = 0] = "False";
            Tristate[Tristate["True"] = 1] = "True";
           