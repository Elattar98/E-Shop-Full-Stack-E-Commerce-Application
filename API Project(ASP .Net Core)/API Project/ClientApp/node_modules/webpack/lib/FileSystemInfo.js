    return displayPart(" ", ts.SymbolDisplayPartKind.space);
    }
    ts.spacePart = spacePart;
    function keywordPart(kind) {
        return displayPart(ts.tokenToString(kind), ts.SymbolDisplayPartKind.keyword);
    }
    ts.keywordPart = keywordPart;
    function punctuationPart(kind) {
        return displayPart(ts.tokenToString(kind), ts.SymbolDisplayPartKind.punctuation);
    }
    ts.punctuationPart = punctuationPart;
    function operatorPart(kind) {
        return displayPart(ts.tokenToString(kind), ts.SymbolDisplayPartKind.operator);
    }
    ts.operatorPart = operatorPart;
    function parameterNamePart(text) {
        return displayPart(text, ts.SymbolDisplayPartKind.parameterName);
    }
    ts.parameterNamePart = parameterNamePart;
    function propertyNamePart(text) {
        return displayPart(text, ts.SymbolDisplayPartKind.propertyName);
    }
    ts.propertyNamePart = propertyNamePart;
    function textOrKeywordPart(text) {
        var kind = ts.stringToToken(text);
        return kind === undefined
            ? textPart(text)
            : keywordPart(kind);
    }
    ts.textOrKeywordPart = textOrKeywordPart;
    function textPart(text) {
        return displayPart(text, ts.SymbolDisplayPartKind.text);
    }
    ts.textPart = textPart;
    function typeAliasNamePart(text) {
        return displayPart(text, ts.SymbolDisplayPartKind.aliasName);
    }
    ts.typeAliasNamePart = typeAliasNamePart;
    function typeParameterNamePart(text) {
        return displayPart(text, ts.SymbolDisplayPartKind.typeParameterName);
    }
    ts.typeParameterNamePart = typeParameterNamePart;
    function linkTextPart(text) {
        return displayPart(text, ts.SymbolDisplayPartKind.linkText);
    }
    ts.linkTextPart = linkTextPart;
    function linkNamePart(text, target) {
        return {
            text: text,
            kind: ts.SymbolDisplayPartKind[ts.SymbolDisplayPartKind.linkName],
            target: {
                fileName: ts.getSourceFileOfNode(target).fileName,
                textSpan: createTextSpanFromNode(target),
            },
        };
    }
    ts.linkNamePart = linkNamePart;
    function linkPart(text) {
        return displayPart(text, ts.SymbolDisplayPartKind.link);
    }
    ts.linkPart = linkPart;
    function buildLinkParts(link, checker) {
        var _a;
        var prefix = ts.isJSDocLink(link) ? "link"
            : ts.isJSDocLinkCode(link) ? "linkcode"
                : "linkplain";
        var parts = [linkPart("{@".concat(prefix, " "))];
        if (!link.name) {
            if (link.text) {
                parts.push(linkTextPart(link.text));
            }
        }
        else {
            var symbol = checker === null || checker === void 0 ? void 0 : checker.getSymbolAtLocation(link.name);
            var suffix = findLinkNameEnd(link.text);
            var name = ts.getTextOfNode(link.name) + link.text.slice(0, suffix);
            var text = skipSeparatorFromLinkText(link.text.slice(suffix));
            var decl = (symbol === null || symbol === void 0 ? void 0 : symbol.valueDeclaration) || ((_a = symbol === null || symbol === void 0 ? void 0 : symbol.declarations) === null || _a === void 0 ? void 0 : _a[0]);
            if (decl) {
                parts.push(linkNamePart(name, decl));
                if (text)
                    parts.push(linkTextPart(text));
            }
            else {
                parts.push(linkTextPart(name + (suffix || text.indexOf("://") === 0 ? "" : " ") + text));
            }
        }
        parts.push(linkPart("}"));
        return parts;
    }
    ts.buildLinkParts = buildLinkParts;
    function skipSeparatorFromLinkText(text) {
        var pos = 0;
        if (text.charCodeAt(pos++) === 124 /* CharacterCodes.bar */) {
            while (pos < text.length && text.charCodeAt(pos) === 32 /* CharacterCodes.space */)
                pos++;
            return text.slice(pos);
        }
        return text;
    }
    function findLinkNameEnd(text) {
        if (text.indexOf("()") === 0)
            return 2;
        if (text[0] !== "<")
            return 0;
        var brackets = 0;
        var i = 0;
        while (i < text.length) {
            if (text[i] === "<")
                brackets++;
            if (text[i] === ">")
                brackets--;
            i++;
            if (!brackets)
                return i;
        }
        return 0;
    }
    var carriageReturnLineFeed = "\r\n";
    /**
     * The default is CRLF.
     */
    function getNewLineOrDefaultFromHost(host, formatSettings) {
        var _a;
        return (formatSettings === null || formatSettings === void 0 ? void 0 : formatSettings.newLineCharacter) ||
            ((_a = host.getNewLine) === null || _a === void 0 ? void 0 : _a.call(host)) ||
            carriageReturnLineFeed;
    }
    ts.getNewLineOrDefaultFromHost = getNewLineOrDefaultFromHost;
    function lineBreakPart() {
        return displayPart("\n", ts.SymbolDisplayPartKind.lineBreak);
    }
    ts.lineBreakPart = lineBreakPart;
    function mapToDisplayParts(writeDisplayParts) {
        try {
            writeDisplayParts(displayPartWriter);
            return displayPartWriter.displayParts();
        }
        finally {
            displayPartWriter.clear();
        }
    }
    ts.mapToDisplayParts = mapToDisplayParts;
    function typeToDisplayParts(typechecker, type, enclosingDeclaration, flags) {
        if (flags === void 0) { flags = 0 /* TypeFormatFlags.None */; }
        return mapToDisplayParts(function (writer) {
            typechecker.writeType(type, enclosingDeclaration, flags | 1024 /* TypeFormatFlags.MultilineObjectLiterals */ | 16384 /* TypeFormatFlags.UseAliasDefinedOutsideCurrentScope */, writer);
        });
    }
    ts.typeToDisplayParts = typeToDisplayParts;
    function symbolToDisplayParts(typeChecker, symbol, enclosingDeclaration, meaning, flags) {
        if (flags === void 0) { flags = 0 /* SymbolFormatFlags.None */; }
        return mapToDisplayParts(function (writer) {
            typeChecker.writeSymbol(symbol, enclosingDeclaration, meaning, flags | 8 /* SymbolFormatFlags.UseAliasDefinedOutsideCurrentScope */, writer);
        });
    }
    ts.symbolToDisplayParts = symbolToDisplayParts;
    function signatureToDisplayParts(typechecker, signature, enclosingDeclaration, flags) {
        if (flags === void 0) { flags = 0 /* TypeFormatFlags.None */; }
        flags |= 16384 /* TypeFormatFlags.UseAliasDefinedOutsideCurrentScope */ | 1024 /* TypeFormatFlags.MultilineObjectLiterals */ | 32 /* TypeFormatFlags.WriteTypeArgumentsOfSignature */ | 8192 /* TypeFormatFlags.OmitParameterModifiers */;
        return mapToDisplayParts(function (writer) {
            typechecker.writeSignature(signature, enclosingDeclaration, flags, /*signatureKind*/ undefined, writer);
        });
    }
    ts.signatureToDisplayParts = signatureToDisplayParts;
    function nodeToDisplayParts(node, enclosingDeclaration) {
        var file = enclosingDeclaration.getSourceFile();
        return mapToDisplayParts(function (writer) {
            var printer = ts.createPrinter({ removeComments: true, omitTrailingSemicolon: true });
            printer.writeNode(4 /* EmitHint.Unspecified */, node, file, writer);
        });
    }
    ts.nodeToDisplayParts = nodeToDisplayParts;
    function isImportOrExportSpecifierName(location) {
        return !!location.parent && ts.isImportOrExportSpecifier(location.parent) && location.parent.propertyName === location;
    }
    ts.isImportOrExportSpecifierName = isImportOrExportSpecifierName;
    function getScriptKind(fileName, host) {
        // First check to see if the script kind was specified by the host. Chances are the host
        // may override the default script kind for the file extension.
        return ts.ensureScriptKind(fileName, host.getScriptKind && host.getScriptKind(fileName));
    }
    ts.getScriptKind = getScriptKind;
    function getSymbolTarget(symbol, checker) {
        var next = symbol;
        while (isAliasSymbol(next) || (isTransientSymbol(next) && next.target)) {
            if (isTransientSymbol(next) && next.target) {
                next = next.target;
            }
            else {
                next = ts.skipAlias(next, checker);
            }
        }
        return next;
    }
    ts.getSymbolTarget = getSymbolTarget;
    function isTransientSymbol(symbol) {
        return (symbol.flags & 33554432 /* SymbolFlags.Transient */) !== 0;
    }
    function isAliasSymbol(symbol) {
        return (symbol.flags & 2097152 /* SymbolFlags.Alias */) !== 0;
    }
    function getUniqueSymbolId(symbol, checker) {
        return ts.getSymbolId(ts.skipAlias(symbol, checker));
    }
    ts.getUniqueSymbolId = getUniqueSymbolId;
    function getFirstNonSpaceCharacterPosition(text, position) {
        while (ts.isWhiteSpaceLike(text.charCodeAt(position))) {
            position += 1;
        }
        return position;
    }
    ts.getFirstNonSpaceCharacterPosition = getFirstNonSpaceCharacterPosition;
    function getPrecedingNonSpaceCharacterPosition(text, position) {
        while (position > -1 && ts.isWhiteSpaceSingleLine(text.charCodeAt(position))) {
            position -= 1;
        }
        return position + 1;
    }
    ts.getPrecedingNonSpaceCharacterPosition = getPrecedingNonSpaceCharacterPosition;
    /**
     * Creates a deep, memberwise clone of a node with no source map location.
     *
     * WARNING: This is an expensive operation and is only intended to be used in refactorings
     * and code fixes (because those are triggered by explicit user actions).
     */
    function getSynthesizedDeepClone(node, includeTrivia) {
        if (includeTrivia === void 0) { includeTrivia = true; }
        var clone = node && getSynthesizedDeepCloneWorker(node);
        if (clone && !includeTrivia)
            suppressLeadingAndTrailingTrivia(clone);
        return clone;
    }
    ts.getSynthesizedDeepClone = getSynthesizedDeepClone;
    function getSynthesizedDeepCloneWithReplacements(node, includeTrivia, replaceNode) {
        var clone = replaceNode(node);
        if (clone) {
            ts.setOriginalNode(clone, node);
        }
        else {
            clone = getSynthesizedDeepCloneWorker(node, replaceNode);
        }
        if (clone && !includeTrivia)
            suppressLeadingAndTrailingTrivia(clone);
        return clone;
    }
    ts.getSynthesizedDeepCloneWithReplacements = getSynthesizedDeepCloneWithReplacements;
    function getSynthesizedDeepCloneWorker(node, replaceNode) {
        var nodeClone = replaceNode
            ? function (n) { return getSynthesizedDeepCloneWithReplacements(n, /*includeTrivia*/ true, replaceNode); }
            : getSynthesizedDeepClone;
        var nodesClone = replaceNode
            ? function (ns) { return ns && getSynthesizedDeepClonesWithReplacements(ns, /*includeTrivia*/ true, replaceNode); }
            : function (ns) { return ns && getSynthesizedDeepClones(ns); };
        var visited = ts.visitEachChild(node, nodeClone, ts.nullTransformationContext, nodesClone, nodeClone);
        if (visited === node) {
            // This only happens for leaf nodes - internal nodes always see their children change.
            var clone_1 = ts.isStringLiteral(node) ? ts.setOriginalNode(ts.factory.createStringLiteralFromNode(node), node) :
                ts.isNumericLiteral(node) ? ts.setOriginalNode(ts.factory.createNumericLiteral(node.text, node.numericLiteralFlags), node) :
                    ts.factory.cloneNode(node);
            return ts.setTextRange(clone_1, node);
        }
        // PERF: As an optimization, rather than calling factory.cloneNode, we'll update
        // the new node created by visitEachChild with the extra changes factory.cloneNode
        // would have made.
        visited.parent = undefined;
        return visited;
    }
    function getSynthesizedDeepClones(nodes, includeTrivia) {
        if (includeTrivia === void 0) { includeTrivia = true; }
        return nodes && ts.factory.createNodeArray(nodes.map(function (n) { return getSynthesizedDeepClone(n, includeTrivia); }), nodes.hasTrailingComma);
    }
    ts.getSynthesizedDeepClones = getSynthesizedDeepClones;
    function getSynthesizedDeepClonesWithReplacements(nodes, includeTrivia, replaceNode) {
        return ts.factory.createNodeArray(nodes.map(function (n) { return getSynthesizedDeepCloneWithReplacements(n, includeTrivia, replaceNode); }), nodes.hasTrailingComma);
    }
    ts.getSynthesizedDeepClonesWithReplacements = getSynthesizedDeepClonesWithReplacements;
    /**
     * Sets EmitFlags to suppress leading and trailing trivia on the node.
     */
    function suppressLeadingAndTrailingTrivia(node) {
        suppressLeadingTrivia(node);
        suppressTrailingTrivia(node);
    }
    ts.suppressLeadingAndTrailingTrivia = suppressLeadingAndTrailingTrivia;
    /**
     * Sets EmitFlags to suppress leading trivia on the node.
     */
    function suppressLeadingTrivia(node) {
        addEmitFlagsRecursively(node, 512 /* EmitFlags.NoLeadingComments */, getFirstChild);
    }
    ts.suppressLeadingTrivia = suppressLeadingTrivia;
    /**
     * Sets EmitFlags to suppress trailing trivia on the node.
     */
    function suppressTrailingTrivia(node) {
        addEmitFlagsRecursively(node, 1024 /* EmitFlags.NoTrailingComments */, ts.getLastChild);
    }
    ts.suppressTrailingTrivia = suppressTrailingTrivia;
    function copyComments(sourceNode, targetNode) {
        var sourceFile = sourceNode.getSourceFile();
        var text = sourceFile.text;
        if (hasLeadingLineBreak(sourceNode, text)) {
            copyLeadingComments(sourceNode, targetNode, sourceFile);
        }
        else {
            copyTrailingAsLeadingComments(sourceNode, targetNode, sourceFile);
        }
        copyTrailingComments(sourceNode, targetNode, sourceFile);
    }
    ts.copyComments = copyComments;
    function hasLeadingLineBreak(node, text) {
        var start = node.getFullStart();
        var end = node.getStart();
        for (var i = start; i < end; i++) {
            if (text.charCodeAt(i) === 10 /* CharacterCodes.lineFeed */)
                return true;
        }
        return false;
    }
    function addEmitFlagsRecursively(node, flag, getChild) {
        ts.addEmitFlags(node, flag);
        var child = getChild(node);
        if (child)
            addEmitFlagsRecursively(child, flag, getChild);
    }
    function getFirstChild(node) {
        return node.forEachChild(function (child) { return child; });
    }
    function getUniqueName(baseName, sourceFile) {
        var nameText = baseName;
        for (var i = 1; !ts.isFileLevelUniqueName(sourceFile, nameText); i++) {
            nameText = "".concat(baseName, "_").concat(i);
        }
        return nameText;
    }
    ts.getUniqueName = getUniqueName;
    /**
     * @return The index of the (only) reference to the extracted symbol.  We want the cursor
     * to be on the reference, rather than the declaration, because it's closer to where the
     * user was before extracting it.
     */
    function getRenameLocation(edits, renameFilename, name, preferLastLocation) {
        var delta = 0;
        var lastPos = -1;
        for (var _i = 0, edits_1 = edits; _i < edits_1.length; _i++) {
            var _a = edits_1[_i], fileName = _a.fileName, textChanges_2 = _a.textChanges;
            ts.Debug.assert(fileName === renameFilename);
            for (var _b = 0, textChanges_1 = textChanges_2; _b < textChanges_1.length; _b++) {
                var change = textChanges_1[_b];
                var span = change.span, newText = change.newText;
                var index = indexInTextChange(newText, name);
                if (index !== -1) {
                    lastPos = span.start + delta + index;
                    // If the reference comes first, return immediately.
                    if (!preferLastLocation) {
                        return lastPos;
                    }
                }
                delta += newText.length - span.length;
            }
        }
        // If the declaration comes first, return the position of the last occurrence.
        ts.Debug.assert(preferLastLocation);
        ts.Debug.assert(lastPos >= 0);
        return lastPos;
    }
    ts.getRenameLocation = getRenameLocation;
    function copyLeadingComments(sourceNode, targetNode, sourceFile, commentKind, hasTrailingNewLine) {
        ts.forEachLeadingCommentRange(sourceFile.text, sourceNode.pos, getAddCommentsFunction(targetNode, sourceFile, commentKind, hasTrailingNewLine, ts.addSyntheticLeadingComment));
    }
    ts.copyLeadingComments = copyLeadingComments;
    function copyTrailingComments(sourceNode, targetNode, sourceFile, commentKind, hasTrailingNewLine) {
        ts.forEachTrailingCommentRange(sourceFile.text, sourceNode.end, getAddCommentsFunction(targetNode, sourceFile, commentKind, hasTrailingNewLine, ts.addSyntheticTrailingComment));
    }
    ts.copyTrailingComments = copyTrailingComments;
    /**
     * This function copies the trailing comments for the token that comes before `sourceNode`, as leading comments of `targetNode`.
     * This is useful because sometimes a comment that refers to `sourceNode` will be a leading comment for `sourceNode`, according to the
     * notion of trivia ownership, and instead will be a trailing comment for the token before `sourceNode`, e.g.:
     * `function foo(\* not leading comment for a *\ a: string) {}`
     * The comment refers to `a` but belongs to the `(` token, but we might want to copy it.
     */
    function copyTrailingAsLeadingComments(sourceNode, targetNode, sourceFile, commentKind, hasTrailingNewLine) {
        ts.forEachTrailingCommentRange(sourceFile.text, sourceNode.pos, getAddCommentsFunction(targetNode, sourceFile, commentKind, hasTrailingNewLine, ts.addSyntheticLeadingComment));
    }
    ts.copyTrailingAsLeadingComments = copyTrailingAsLeadingComments;
    function getAddCommentsFunction(targetNode, sourceFile, commentKind, hasTrailingNewLine, cb) {
        return function (pos, end, kind, htnl) {
            if (kind === 3 /* SyntaxKind.MultiLineCommentTrivia */) {
                // Remove leading /*
                pos += 2;
                // Remove trailing */
                end -= 2;
            }
            else {
                // Remove leading //
                pos += 2;
            }
            cb(targetNode, commentKind || kind, sourceFile.text.slice(pos, end), hasTrailingNewLine !== undefined ? hasTrailingNewLine : htnl);
        };
    }
    function indexInTextChange(change, name) {
        if (ts.startsWith(change, name))
            return 0;
        // Add a " " to avoid references inside words
        var idx = change.indexOf(" " + name);
        if (idx === -1)
            idx = change.indexOf("." + name);
        if (idx === -1)
            idx = change.indexOf('"' + name);
        return idx === -1 ? -1 : idx + 1;
    }
    /* @internal */
    function needsParentheses(expression) {
        return ts.isBinaryExpression(expression) && expression.operatorToken.kind === 27 /* SyntaxKind.CommaToken */
            || ts.isObjectLiteralExpression(expression)
            || ts.isAsExpression(expression) && ts.isObjectLiteralExpression(expression.expression);
    }
    ts.needsParentheses = needsParentheses;
    function getContextualTypeFromParent(node, checker) {
        var parent = node.parent;
        switch (parent.kind) {
            case 209 /* SyntaxKind.NewExpression */:
                return checker.getContextualType(parent);
            case 221 /* SyntaxKind.BinaryExpression */: {
                var _a = parent, left = _a.left, operatorToken = _a.operatorToken, right = _a.right;
                return isEqualityOperatorKind(operatorToken.kind)
                    ? checker.getTypeAtLocation(node === right ? left : right)
                    : checker.getContextualType(node);
            }
            case 289 /* SyntaxKind.CaseClause */:
                return parent.expression === node ? getSwitchedType(parent, checker) : undefined;
            default:
                return checker.getContextualType(node);
        }
    }
    ts.getContextualTypeFromParent = getContextualTypeFromParent;
    function quote(sourceFile, preferences, text) {
        // Editors can pass in undefined or empty string - we want to infer the preference in those cases.
        var quotePreference = getQuotePreference(sourceFile, preferences);
        var quoted = JSON.stringify(text);
        return quotePreference === 0 /* QuotePreference.Single */ ? "'".concat(ts.stripQuotes(quoted).replace(/'/g, "\\'").replace(/\\"/g, '"'), "'") : quoted;
    }
    ts.quote = quote;
    function isEqualityOperatorKind(kind) {
        switch (kind) {
            case 36 /* SyntaxKind.EqualsEqualsEqualsToken */:
            case 34 /* SyntaxKind.EqualsEqualsToken */:
            case 37 /* SyntaxKind.ExclamationEqualsEqualsToken */:
            case 35 /* SyntaxKind.ExclamationEqualsToken */:
                return true;
            default:
                return false;
        }
    }
    ts.isEqualityOperatorKind = isEqualityOperatorKind;
    function isStringLiteralOrTemplate(node) {
        switch (node.kind) {
            case 10 /* SyntaxKind.StringLiteral */:
            case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
            case 223 /* SyntaxKind.TemplateExpression */:
            case 210 /* SyntaxKind.TaggedTemplateExpression */:
                return true;
            default:
                return false;
        }
    }
    ts.isStringLiteralOrTemplate = isStringLiteralOrTemplate;
    function hasIndexSignature(type) {
        return !!type.getStringIndexType() || !!type.getNumberIndexType();
    }
    ts.hasIndexSignature = hasIndexSignature;
    function getSwitchedType(caseClause, checker) {
        return checker.getTypeAtLocation(caseClause.parent.parent.expression);
    }
    ts.getSwitchedType = getSwitchedType;
    ts.ANONYMOUS = "anonymous function";
    function getTypeNodeIfAccessible(type, enclosingScope, program, host) {
        var checker = program.getTypeChecker();
        var typeIsAccessible = true;
        var notAccessible = function () { return typeIsAccessible = false; };
        var res = checker.typeToTypeNode(type, enclosingScope, 1 /* NodeBuilderFlags.NoTruncation */, {
            trackSymbol: function (symbol, declaration, meaning) {
                typeIsAccessible = typeIsAccessible && checker.isSymbolAccessible(symbol, declaration, meaning, /*shouldComputeAliasToMarkVisible*/ false).accessibility === 0 /* SymbolAccessibility.Accessible */;
                return !typeIsAccessible;
            },
            reportInaccessibleThisError: notAccessible,
            reportPrivateInBaseOfClassExpression: notAccessible,
            reportInaccessibleUniqueSymbolError: notAccessible,
            moduleResolverHost: getModuleSpecifierResolverHost(program, host)
        });
        return typeIsAccessible ? res : undefined;
    }
    ts.getTypeNodeIfAccessible = getTypeNodeIfAccessible;
    function syntaxRequiresTrailingCommaOrSemicolonOrASI(kind) {
        return kind === 174 /* SyntaxKind.CallSignature */
            || kind === 175 /* SyntaxKind.ConstructSignature */
            || kind === 176 /* SyntaxKind.IndexSignature */
            || kind === 166 /* SyntaxKind.PropertySignature */
            || kind === 168 /* SyntaxKind.MethodSignature */;
    }
    function syntaxRequiresTrailingFunctionBlockOrSemicolonOrASI(kind) {
        return kind === 256 /* SyntaxKind.FunctionDeclaration */
            || kind === 171 /* SyntaxKind.Constructor */
            || kind === 169 /* SyntaxKind.MethodDeclaration */
            || kind === 172 /* SyntaxKind.GetAccessor */
            || kind === 173 /* SyntaxKind.SetAccessor */;
    }
    function syntaxRequiresTrailingModuleBlockOrSemicolonOrASI(kind) {
        return kind === 261 /* SyntaxKind.ModuleDeclaration */;
    }
    function syntaxRequiresTrailingSemicolonOrASI(kind) {
        return kind === 237 /* SyntaxKind.VariableStatement */
            || kind === 238 /* SyntaxKind.ExpressionStatement */
            || kind === 240 /* SyntaxKind.DoStatement */
            || kind === 245 /* SyntaxKind.ContinueStatement */
            || kind === 246 /* SyntaxKind.BreakStatement */
            || kind === 247 /* SyntaxKind.ReturnStatement */
            || kind === 251 /* SyntaxKind.ThrowStatement */
            || kind === 253 /* SyntaxKind.DebuggerStatement */
            || kind === 167 /* SyntaxKind.PropertyDeclaration */
            || kind === 259 /* SyntaxKind.TypeAliasDeclaration */
            || kind === 266 /* SyntaxKind.ImportDeclaration */
            || kind === 265 /* SyntaxKind.ImportEqualsDeclaration */
            || kind === 272 /* SyntaxKind.ExportDeclaration */
            || kind === 264 /* SyntaxKind.NamespaceExportDeclaration */
            || kind === 271 /* SyntaxKind.ExportAssignment */;
    }
    ts.syntaxRequiresTrailingSemicolonOrASI = syntaxRequiresTrailingSemicolonOrASI;
    ts.syntaxMayBeASICandidate = ts.or(syntaxRequiresTrailingCommaOrSemicolonOrASI, syntaxRequiresTrailingFunctionBlockOrSemicolonOrASI, syntaxRequiresTrailingModuleBlockOrSemicolonOrASI, syntaxRequiresTrailingSemicolonOrASI);
    function nodeIsASICandidate(node, sourceFile) {
        var lastToken = node.getLastToken(sourceFile);
        if (lastToken && lastToken.kind === 26 /* SyntaxKind.SemicolonToken */) {
            return false;
        }
        if (syntaxRequiresTrailingCommaOrSemicolonOrASI(node.kind)) {
            if (lastToken && lastToken.kind === 27 /* SyntaxKind.CommaToken */) {
                return false;
            }
        }
        else if (syntaxRequiresTrailingModuleBlockOrSemicolonOrASI(node.kind)) {
            var lastChild = ts.last(node.getChildren(sourceFile));
            if (lastChild && ts.isModuleBlock(lastChild)) {
                return false;
            }
        }
        else if (syntaxRequiresTrailingFunctionBlockOrSemicolonOrASI(node.kind)) {
            var lastChild = ts.last(node.getChildren(sourceFile));
            if (lastChild && ts.isFunctionBlock(lastChild)) {
                return false;
            }
        }
        else if (!syntaxRequiresTrailingSemicolonOrASI(node.kind)) {
            return false;
        }
        // See comment in parser’s `parseDoStatement`
        if (node.kind === 240 /* SyntaxKind.DoStatement */) {
            return true;
        }
        var topNode = ts.findAncestor(node, function (ancestor) { return !ancestor.parent; });
        var nextToken = findNextToken(node, topNode, sourceFile);
        if (!nextToken || nextToken.kind === 19 /* SyntaxKind.CloseBraceToken */) {
            return true;
        }
        var startLine = sourceFile.getLineAndCharacterOfPosition(node.getEnd()).line;
        var endLine = sourceFile.getLineAndCharacterOfPosition(nextToken.getStart(sourceFile)).line;
        return startLine !== endLine;
    }
    function positionIsASICandidate(pos, context, sourceFile) {
        var contextAncestor = ts.findAncestor(context, function (ancestor) {
            if (ancestor.end !== pos) {
                return "quit";
            }
            return ts.syntaxMayBeASICandidate(ancestor.kind);
        });
        return !!contextAncestor && nodeIsASICandidate(contextAncestor, sourceFile);
    }
    ts.positionIsASICandidate = positionIsASICandidate;
    function probablyUsesSemicolons(sourceFile) {
        var withSemicolon = 0;
        var withoutSemicolon = 0;
        var nStatementsToObserve = 5;
        ts.forEachChild(sourceFile, function visit(node) {
            if (syntaxRequiresTrailingSemicolonOrASI(node.kind)) {
                var lastToken = node.getLastToken(sourceFile);
                if ((lastToken === null || lastToken === void 0 ? void 0 : lastToken.kind) === 26 /* SyntaxKind.SemicolonToken */) {
                    withSemicolon++;
                }
                else {
                    withoutSemicolon++;
                }
            }
            else if (syntaxRequiresTrailingCommaOrSemicolonOrASI(node.kind)) {
                var lastToken = node.getLastToken(sourceFile);
                if ((lastToken === null || lastToken === void 0 ? void 0 : lastToken.kind) === 26 /* SyntaxKind.SemicolonToken */) {
                    withSemicolon++;
                }
                else if (lastToken && lastToken.kind !== 27 /* SyntaxKind.CommaToken */) {
                    var lastTokenLine = ts.getLineAndCharacterOfPosition(sourceFile, lastToken.getStart(sourceFile)).line;
                    var nextTokenLine = ts.getLineAndCharacterOfPosition(sourceFile, ts.getSpanOfTokenAtPosition(sourceFile, lastToken.end).start).line;
                    // Avoid counting missing semicolon in single-line objects:
                    // `function f(p: { x: string /*no semicolon here is insignificant*/ }) {`
                    if (lastTokenLine !== nextTokenLine) {
                        withoutSemicolon++;
                    }
                }
            }
            if (withSemicolon + withoutSemicolon >= nStatementsToObserve) {
                return true;
            }
            return ts.forEachChild(node, visit);
        });
        // One statement missing a semicolon isn't sufficient evidence to say the user
        // doesn’t want semicolons, because they may not even be done writing that statement.
        if (withSemicolon === 0 && withoutSemicolon <= 1) {
            return true;
        }
        // If even 2/5 places have a semicolon, the user probably wants semicolons
        return withSemicolon / withoutSemicolon > 1 / nStatementsToObserve;
    }
    ts.probablyUsesSemicolons = probablyUsesSemicolons;
    function tryGetDirectories(host, directoryName) {
        return tryIOAndConsumeErrors(host, host.getDirectories, directoryName) || [];
    }
    ts.tryGetDirectories = tryGetDirectories;
    function tryReadDirectory(host, path, extensions, exclude, include) {
        return tryIOAndConsumeErrors(host, host.readDirectory, path, extensions, exclude, include) || ts.emptyArray;
    }
    ts.tryReadDirectory = tryReadDirectory;
    function tryFileExists(host, path) {
        return tryIOAndConsumeErrors(host, host.fileExists, path);
    }
    ts.tryFileExists = tryFileExists;
    function tryDirectoryExists(host, path) {
        return tryAndIgnoreErrors(function () { return ts.directoryProbablyExists(path, host); }) || false;
    }
    ts.tryDirectoryExists = tryDirectoryExists;
    function tryAndIgnoreErrors(cb) {
        try {
            return cb();
        }
        catch (_a) {
            return undefined;
        }
    }
    ts.tryAndIgnoreErrors = tryAndIgnoreErrors;
    function tryIOAndConsumeErrors(host, toApply) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        return tryAndIgnoreErrors(function () { return toApply && toApply.apply(host, args); });
    }
    ts.tryIOAndConsumeErrors = tryIOAndConsumeErrors;
    function findPackageJsons(startDirectory, host, stopDirectory) {
        var paths = [];
        ts.forEachAncestorDirectory(startDirectory, function (ancestor) {
            if (ancestor === stopDirectory) {
                return true;
            }
            var currentConfigPath = ts.combinePaths(ancestor, "package.json");
            if (tryFileExists(host, currentConfigPath)) {
                paths.push(currentConfigPath);
            }
        });
        return paths;
    }
    ts.findPackageJsons = findPackageJsons;
    function findPackageJson(directory, host) {
        var packageJson;
        ts.forEachAncestorDirectory(directory, function (ancestor) {
            if (ancestor === "node_modules")
                return true;
            packageJson = ts.findConfigFile(ancestor, function (f) { return tryFileExists(host, f); }, "package.json");
            if (packageJson) {
                return true; // break out
            }
        });
        return packageJson;
    }
    ts.findPackageJson = findPackageJson;
    function getPackageJsonsVisibleToFile(fileName, host) {
        if (!host.fileExists) {
            return [];
        }
        var packageJsons = [];
        ts.forEachAncestorDirectory(ts.getDirectoryPath(fileName), function (ancestor) {
            var packageJsonFileName = ts.combinePaths(ancestor, "package.json");
            if (host.fileExists(packageJsonFileName)) {
                var info = createPackageJsonInfo(packageJsonFileName, host);
                if (info) {
                    packageJsons.push(info);
                }
            }
        });
        return packageJsons;
    }
    ts.getPackageJsonsVisibleToFile = getPackageJsonsVisibleToFile;
    function createPackageJsonInfo(fileName, host) {
        if (!host.readFile) {
            return undefined;
        }
        var dependencyKeys = ["dependencies", "devDependencies", "optionalDependencies", "peerDependencies"];
        var stringContent = host.readFile(fileName) || "";
        var content = tryParseJson(stringContent);
        var info = {};
        if (content) {
            for (var _i = 0, dependencyKeys_1 = dependencyKeys; _i < dependencyKeys_1.length; _i++) {
                var key = dependencyKeys_1[_i];
                var dependencies = content[key];
                if (!dependencies) {
                    continue;
                }
                var dependencyMap = new ts.Map();
                for (var packageName in dependencies) {
                    dependencyMap.set(packageName, dependencies[packageName]);
                }
                info[key] = dependencyMap;
            }
        }
        var dependencyGroups = [
            [1 /* PackageJsonDependencyGroup.Dependencies */, info.dependencies],
            [2 /* PackageJsonDependencyGroup.DevDependencies */, info.devDependencies],
            [8 /* PackageJsonDependencyGroup.OptionalDependencies */, info.optionalDependencies],
            [4 /* PackageJsonDependencyGroup.PeerDependencies */, info.peerDependencies],
        ];
        return __assign(__assign({}, info), { parseable: !!content, fileName: fileName, get: get, has: function (dependencyName, inGroups) {
                return !!get(dependencyName, inGroups);
            } });
        function get(dependencyName, inGroups) {
            if (inGroups === void 0) { inGroups = 15 /* PackageJsonDependencyGroup.All */; }
            for (var _i = 0, dependencyGroups_1 = dependencyGroups; _i < dependencyGroups_1.length; _i++) {
                var _a = dependencyGroups_1[_i], group_1 = _a[0], deps = _a[1];
                if (deps && (inGroups & group_1)) {
                    var dep = deps.get(dependencyName);
                    if (dep !== undefined) {
                        return dep;
                    }
                }
            }
        }
    }
    ts.createPackageJsonInfo = createPackageJsonInfo;
    function createPackageJsonImportFilter(fromFile, preferences, host) {
        var packageJsons = ((host.getPackageJsonsVisibleToFile && host.getPackageJsonsVisibleToFile(fromFile.fileName)) || getPackageJsonsVisibleToFile(fromFile.fileName, host)).filter(function (p) { return p.parseable; });
        var usesNodeCoreModules;
        return { allowsImportingAmbientModule: allowsImportingAmbientModule, allowsImportingSourceFile: allowsImportingSourceFile, allowsImportingSpecifier: allowsImportingSpecifier };
        function moduleSpecifierIsCoveredByPackageJson(specifier) {
            var packageName = getNodeModuleRootSpecifier(specifier);
            for (var _i = 0, packageJsons_1 = packageJsons; _i < packageJsons_1.length; _i++) {
                var packageJson = packageJsons_1[_i];
                if (packageJson.has(packageName) || packageJson.has(ts.getTypesPackageName(packageName))) {
                    return true;
                }
            }
            return false;
        }
        function allowsImportingAmbientModule(moduleSymbol, moduleSpecifierResolutionHost) {
            if (!packageJsons.length || !moduleSymbol.valueDeclaration) {
                return true;
            }
            var declaringSourceFile = moduleSymbol.valueDeclaration.getSourceFile();
            var declaringNodeModuleName = getNodeModulesPackageNameFromFileName(declaringSourceFile.fileName, moduleSpecifierResolutionHost);
            if (typeof declaringNodeModuleName === "undefined") {
                return true;
            }
            var declaredModuleSpecifier = ts.stripQuotes(moduleSymbol.getName());
            if (isAllowedCoreNodeModulesImport(declaredModuleSpecifier)) {
                return true;
            }
            return moduleSpecifierIsCoveredByPackageJson(declaringNodeModuleName)
                || moduleSpecifierIsCoveredByPackageJson(declaredModuleSpecifier);
        }
        function allowsImportingSourceFile(sourceFile, moduleSpecifierResolutionHost) {
            if (!packageJsons.length) {
                return true;
            }
            var moduleSpecifier = getNodeModulesPackageNameFromFileName(sourceFile.fileName, moduleSpecifierResolutionHost);
            if (!moduleSpecifier) {
                return true;
            }
            return moduleSpecifierIsCoveredByPackageJson(moduleSpecifier);
        }
        function allowsImportingSpecifier(moduleSpecifier) {
            if (!packageJsons.length || isAllowedCoreNodeModulesImport(moduleSpecifier)) {
                return true;
            }
            if (ts.pathIsRelative(moduleSpecifier) || ts.isRootedDiskPath(moduleSpecifier)) {
                return true;
            }
            return moduleSpecifierIsCoveredByPackageJson(moduleSpecifier);
        }
        function isAllowedCoreNodeModulesImport(moduleSpecifier) {
            // If we’re in JavaScript, it can be difficult to tell whether the user wants to import
            // from Node core modules or not. We can start by seeing if the user is actually using
            // any node core modules, as opposed to simply having @types/node accidentally as a
            // dependency of a dependency.
            if (ts.isSourceFileJS(fromFile) && ts.JsTyping.nodeCoreModules.has(moduleSpecifier)) {
                if (usesNodeCoreModules === undefined) {
                    usesNodeCoreModules = consumesNodeCoreModules(fromFile);
                }
                if (usesNodeCoreModules) {
                    return true;
                }
            }
            return false;
        }
        function getNodeModulesPackageNameFromFileName(importedFileName, moduleSpecifierResolutionHost) {
            if (!ts.stringContains(importedFileName, "node_modules")) {
                return undefined;
            }
            var specifier = ts.moduleSpecifiers.getNodeModulesPackageName(host.getCompilationSettings(), fromFile, importedFileName, moduleSpecifierResolutionHost, preferences);
            if (!specifier) {
                return undefined;
            }
            // Paths here are not node_modules, so we don’t care about them;
            // returning anything will trigger a lookup in package.json.
            if (!ts.pathIsRelative(specifier) && !ts.isRootedDiskPath(specifier)) {
                return getNodeModuleRootSpecifier(specifier);
            }
        }
        function getNodeModuleRootSpecifier(fullSpecifier) {
            var components = ts.getPathComponents(ts.getPackageNameFromTypesPackageName(fullSpecifier)).slice(1);
            // Scoped packages
            if (ts.startsWith(components[0], "@")) {
                return "".concat(components[0], "/").concat(components[1]);
            }
            return components[0];
        }
    }
    ts.createPackageJsonImportFilter = createPackageJsonImportFilter;
    function tryParseJson(text) {
        try {
            return JSON.parse(text);
        }
        catch (_a) {
            return undefined;
        }
    }
    function consumesNodeCoreModules(sourceFile) {
        return ts.some(sourceFile.imports, function (_a) {
            var text = _a.text;
            return ts.JsTyping.nodeCoreModules.has(text);
        });
    }
    ts.consumesNodeCoreModules = consumesNodeCoreModules;
    function isInsideNodeModules(fileOrDirectory) {
        return ts.contains(ts.getPathComponents(fileOrDirectory), "node_modules");
    }
    ts.isInsideNodeModules = isInsideNodeModules;
    function isDiagnosticWithLocation(diagnostic) {
        return diagnostic.file !== undefined && diagnostic.start !== undefined && diagnostic.length !== undefined;
    }
    ts.isDiagnosticWithLocation = isDiagnosticWithLocation;
    function findDiagnosticForNode(node, sortedFileDiagnostics) {
        var span = createTextSpanFromNode(node);
        var index = ts.binarySearchKey(sortedFileDiagnostics, span, ts.identity, ts.compareTextSpans);
        if (index >= 0) {
            var diagnostic = sortedFileDiagnostics[index];
            ts.Debug.assertEqual(diagnostic.file, node.getSourceFile(), "Diagnostics proided to 'findDiagnosticForNode' must be from a single SourceFile");
            return ts.cast(diagnostic, isDiagnosticWithLocation);
        }
    }
    ts.findDiagnosticForNode = findDiagnosticForNode;
    function getDiagnosticsWithinSpan(span, sortedFileDiagnostics) {
        var _a;
        var index = ts.binarySearchKey(sortedFileDiagnostics, span.start, function (diag) { return diag.start; }, ts.compareValues);
        if (index < 0) {
            index = ~index;
        }
        while (((_a = sortedFileDiagnostics[index - 1]) === null || _a === void 0 ? void 0 : _a.start) === span.start) {
            index--;
        }
        var result = [];
        var end = ts.textSpanEnd(span);
        while (true) {
            var diagnostic = ts.tryCast(sortedFileDiagnostics[index], isDiagnosticWithLocation);
            if (!diagnostic || diagnostic.start > end) {
                break;
            }
            if (ts.textSpanContainsTextSpan(span, diagnostic)) {
                result.push(diagnostic);
            }
            index++;
        }
        return result;
    }
    ts.getDiagnosticsWithinSpan = getDiagnosticsWithinSpan;
    /* @internal */
    function getRefactorContextSpan(_a) {
        var startPosition = _a.startPosition, endPosition = _a.endPosition;
        return ts.createTextSpanFromBounds(startPosition, endPosition === undefined ? startPosition : endPosition);
    }
    ts.getRefactorContextSpan = getRefactorContextSpan;
    /* @internal */
    function getFixableErrorSpanExpression(sourceFile, span) {
        var token = getTokenAtPosition(sourceFile, span.start);
        // Checker has already done work to determine that await might be possible, and has attached
        // related info to the node, so start by finding the expression that exactly matches up
        // with the diagnostic range.
        var expression = ts.findAncestor(token, function (node) {
            if (node.getStart(sourceFile) < span.start || node.getEnd() > ts.textSpanEnd(span)) {
                return "quit";
            }
            return ts.isExpression(node) && textSpansEqual(span, createTextSpanFromNode(node, sourceFile));
        });
        return expression;
    }
    ts.getFixableErrorSpanExpression = getFixableErrorSpanExpression;
    function mapOneOrMany(valueOrArray, f, resultSelector) {
        if (resultSelector === void 0) { resultSelector = ts.identity; }
        return valueOrArray ? ts.isArray(valueOrArray) ? resultSelector(ts.map(valueOrArray, f)) : f(valueOrArray, 0) : undefined;
    }
    ts.mapOneOrMany = mapOneOrMany;
    /**
     * If the provided value is an array, the first element of the array is returned; otherwise, the provided value is returned instead.
     */
    function firstOrOnly(valueOrArray) {
        return ts.isArray(valueOrArray) ? ts.first(valueOrArray) : valueOrArray;
    }
    ts.firstOrOnly = firstOrOnly;
    function getNamesForExportedSymbol(symbol, scriptTarget) {
        if (needsNameFromDeclaration(symbol)) {
            var fromDeclaration = getDefaultLikeExportNameFromDeclaration(symbol);
            if (fromDeclaration)
                return fromDeclaration;
            var fileNameCase = ts.codefix.moduleSymbolToValidIdentifier(getSymbolParentOrFail(symbol), scriptTarget, /*preferCapitalized*/ false);
            var capitalized = ts.codefix.moduleSymbolToValidIdentifier(getSymbolParentOrFail(symbol), scriptTarget, /*preferCapitalized*/ true);
            if (fileNameCase === capitalized)
                return fileNameCase;
            return [fileNameCase, capitalized];
        }
        return symbol.name;
    }
    ts.getNamesForExportedSymbol = getNamesForExportedSymbol;
    function getNameForExportedSymbol(symbol, scriptTarget, preferCapitalized) {
        if (needsNameFromDeclaration(symbol)) {
            // Name of "export default foo;" is "foo". Name of "export default 0" is the filename converted to camelCase.
            return getDefaultLikeExportNameFromDeclaration(symbol)
                || ts.codefix.moduleSymbolToValidIdentifier(getSymbolParentOrFail(symbol), scriptTarget, !!preferCapitalized);
        }
        return symbol.name;
    }
    ts.getNameForExportedSymbol = getNameForExportedSymbol;
    function needsNameFromDeclaration(symbol) {
        return !(symbol.flags & 33554432 /* SymbolFlags.Transient */) && (symbol.escapedName === "export=" /* InternalSymbolName.ExportEquals */ || symbol.escapedName === "default" /* InternalSymbolName.Default */);
    }
    function getDefaultLikeExportNameFromDeclaration(symbol) {
        return ts.firstDefined(symbol.declarations, function (d) { var _a; return ts.isExportAssignment(d) ? (_a = ts.tryCast(ts.skipOuterExpressions(d.expression), ts.isIdentifier)) === null || _a === void 0 ? void 0 : _a.text : undefined; });
    }
    function getSymbolParentOrFail(symbol) {
        var _a;
        return ts.Debug.checkDefined(symbol.parent, "Symbol parent was undefined. Flags: ".concat(ts.Debug.formatSymbolFlags(symbol.flags), ". ") +
            "Declarations: ".concat((_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a.map(function (d) {
                var kind = ts.Debug.formatSyntaxKind(d.kind);
                var inJS = ts.isInJSFile(d);
                var expression = d.expression;
                return (inJS ? "[JS]" : "") + kind + (expression ? " (expression: ".concat(ts.Debug.formatSyntaxKind(expression.kind), ")") : "");
            }).join(", "), "."));
    }
    /**
     * Useful to check whether a string contains another string at a specific index
     * without allocating another string or traversing the entire contents of the outer string.
     *
     * This function is useful in place of either of the following:
     *
     * ```ts
     * // Allocates
     * haystack.substr(startIndex, needle.length) === needle
     *
     * // Full traversal
     * haystack.indexOf(needle, startIndex) === startIndex
     * ```
     *
     * @param haystack The string that potentially contains `needle`.
     * @param needle The string whose content might sit within `haystack`.
     * @param startIndex The index within `haystack` to start searching for `needle`.
     */
    function stringContainsAt(haystack, needle, startIndex) {
        var needleLength = needle.length;
        if (needleLength + startIndex > haystack.length) {
            return false;
        }
        for (var i = 0; i < needleLength; i++) {
            if (needle.charCodeAt(i) !== haystack.charCodeAt(i + startIndex))
                return false;
        }
        return true;
    }
    ts.stringContainsAt = stringContainsAt;
    function startsWithUnderscore(name) {
        return name.charCodeAt(0) === 95 /* CharacterCodes._ */;
    }
    ts.startsWithUnderscore = startsWithUnderscore;
    function isGlobalDeclaration(declaration) {
        return !isNonGlobalDeclaration(declaration);
    }
    ts.isGlobalDeclaration = isGlobalDeclaration;
    function isNonGlobalDeclaration(declaration) {
        var sourceFile = declaration.getSourceFile();
        // If the file is not a module, the declaration is global
        if (!sourceFile.externalModuleIndicator && !sourceFile.commonJsModuleIndicator) {
            return false;
        }
        // If the file is a module written in TypeScript, it still might be in a `declare global` augmentation
        return ts.isInJSFile(declaration) || !ts.findAncestor(declaration, ts.isGlobalScopeAugmentation);
    }
    ts.isNonGlobalDeclaration = isNonGlobalDeclaration;
    function isDeprecatedDeclaration(decl) {
        return !!(ts.getCombinedNodeFlagsAlwaysIncludeJSDoc(decl) & 8192 /* ModifierFlags.Deprecated */);
    }
    ts.isDeprecatedDeclaration = isDeprecatedDeclaration;
    function shouldUseUriStyleNodeCoreModules(file, program) {
        var decisionFromFile = ts.firstDefined(file.imports, function (node) {
            if (ts.JsTyping.nodeCoreModules.has(node.text)) {
                return ts.startsWith(node.text, "node:");
            }
        });
        return decisionFromFile !== null && decisionFromFile !== void 0 ? decisionFromFile : program.usesUriStyleNodeCoreModules;
    }
    ts.shouldUseUriStyleNodeCoreModules = shouldUseUriStyleNodeCoreModules;
    function getNewLineKind(newLineCharacter) {
        return newLineCharacter === "\n" ? 1 /* NewLineKind.LineFeed */ : 0 /* NewLineKind.CarriageReturnLineFeed */;
    }
    ts.getNewLineKind = getNewLineKind;
    function diagnosticToString(diag) {
        return ts.isArray(diag)
            ? ts.formatStringFromArgs(ts.getLocaleSpecificMessage(diag[0]), diag.slice(1))
            : ts.getLocaleSpecificMessage(diag);
    }
    ts.diagnosticToString = diagnosticToString;
    /**
     * Get format code settings for a code writing context (e.g. when formatting text changes or completions code).
     */
    function getFormatCodeSettingsForWriting(_a, sourceFile) {
        var options = _a.options;
        var shouldAutoDetectSemicolonPreference = !options.semicolons || options.semicolons === ts.SemicolonPreference.Ignore;
        var shouldRemoveSemicolons = options.semicolons === ts.SemicolonPreference.Remove || shouldAutoDetectSemicolonPreference && !probablyUsesSemicolons(sourceFile);
        return __assign(__assign({}, options), { semicolons: shouldRemoveSemicolons ? ts.SemicolonPreference.Remove : ts.SemicolonPreference.Ignore });
    }
    ts.getFormatCodeSettingsForWriting = getFormatCodeSettingsForWriting;
    function jsxModeNeedsExplicitImport(jsx) {
        return jsx === 2 /* JsxEmit.React */ || jsx === 3 /* JsxEmit.ReactNative */;
    }
    ts.jsxModeNeedsExplicitImport = jsxModeNeedsExplicitImport;
    // #endregion
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    var ImportKind;
    (function (ImportKind) {
        ImportKind[ImportKind["Named"] = 0] = "Named";
        ImportKind[ImportKind["Default"] = 1] = "Default";
        ImportKind[ImportKind["Namespace"] = 2] = "Namespace";
        ImportKind[ImportKind["CommonJS"] = 3] = "CommonJS";
    })(ImportKind = ts.ImportKind || (ts.ImportKind = {}));
    var ExportKind;
    (function (ExportKind) {
        ExportKind[ExportKind["Named"] = 0] = "Named";
        ExportKind[ExportKind["Default"] = 1] = "Default";
        ExportKind[ExportKind["ExportEquals"] = 2] = "ExportEquals";
        ExportKind[ExportKind["UMD"] = 3] = "UMD";
    })(ExportKind = ts.ExportKind || (ts.ExportKind = {}));
    function createCacheableExportInfoMap(host) {
        var exportInfoId = 1;
        var exportInfo = ts.createMultiMap();
        var symbols = new ts.Map();
        /**
         * Key: node_modules package name (no @types).
         * Value: path to deepest node_modules folder seen that is
         * both visible to `usableByFileName` and contains the package.
         *
         * Later, we can see if a given SymbolExportInfo is shadowed by
         * a another installation of the same package in a deeper
         * node_modules folder by seeing if its path starts with the
         * value stored here.
         */
        var packages = new ts.Map();
        var usableByFileName;
        var cache = {
            isUsableByFile: function (importingFile) { return importingFile === usableByFileName; },
            isEmpty: function () { return !exportInfo.size; },
            clear: function () {
                exportInfo.clear();
                symbols.clear();
                usableByFileName = undefined;
            },
            add: function (importingFile, symbol, symbolTableKey, moduleSymbol, moduleFile, exportKind, isFromPackageJson, checker) {
                if (importingFile !== usableByFileName) {
                    cache.clear();
                    usableByFileName = importingFile;
                }
                var packageName;
                if (moduleFile) {
                    var nodeModulesPathParts = ts.getNodeModulePathParts(moduleFile.fileName);
                    if (nodeModulesPathParts) {
                        var topLevelNodeModulesIndex = nodeModulesPathParts.topLevelNodeModulesIndex, topLevelPackageNameIndex = nodeModulesPathParts.topLevelPackageNameIndex, packageRootIndex = nodeModulesPathParts.packageRootIndex;
                        packageName = ts.unmangleScopedPackageName(ts.getPackageNameFromTypesPackageName(moduleFile.fileName.substring(topLevelPackageNameIndex + 1, packageRootIndex)));
                        if (ts.startsWith(importingFile, moduleFile.path.substring(0, topLevelNodeModulesIndex))) {
                            var prevDeepestNodeModulesPath = packages.get(packageName);
                            var nodeModulesPath = moduleFile.fileName.substring(0, topLevelPackageNameIndex + 1);
                            if (prevDeepestNodeModulesPath) {
                                var prevDeepestNodeModulesIndex = prevDeepestNodeModulesPath.indexOf(ts.nodeModulesPathPart);
                                if (topLevelNodeModulesIndex > prevDeepestNodeModulesIndex) {
                                    packages.set(packageName, nodeModulesPath);
                                }
                            }
                            else {
                                packages.set(packageName, nodeModulesPath);
                            }
                        }
                    }
                }
                var isDefault = exportKind === 1 /* ExportKind.Default */;
                var namedSymbol = isDefault && ts.getLocalSymbolForExportDefault(symbol) || symbol;
                // 1. A named export must be imported by its key in `moduleSymbol.exports` or `moduleSymbol.members`.
                // 2. A re-export merged with an export from a module augmentation can result in `symbol`
                //    being an external module symbol; the name it is re-exported by will be `symbolTableKey`
                //    (which comes from the keys of `moduleSymbol.exports`.)
                // 3. Otherwise, we have a default/namespace import that can be imported by any name, and
                //    `symbolTableKey` will be something undesirable like `export=` or `default`, so we try to
                //    get a better name.
                var names = exportKind === 0 /* ExportKind.Named */ || ts.isExternalModuleSymbol(namedSymbol)
                    ? ts.unescapeLeadingUnderscores(symbolTableKey)
                    : ts.getNamesForExportedSymbol(namedSymbol, /*scriptTarget*/ undefined);
                var symbolName = typeof names === "string" ? names : names[0];
                var capitalizedSymbolName = typeof names === "string" ? undefined : names[1];
                var moduleName = ts.stripQuotes(moduleSymbol.name);
                var id = exportInfoId++;
                var target = ts.skipAlias(symbol, checker);
                var storedSymbol = symbol.flags & 33554432 /* SymbolFlags.Transient */ ? undefined : symbol;
                var storedModuleSymbol = moduleSymbol.flags & 33554432 /* SymbolFlags.Transient */ ? undefined : moduleSymbol;
                if (!storedSymbol || !storedModuleSymbol)
                    symbols.set(id, [symbol, moduleSymbol]);
                exportInfo.add(key(symbolName, symbol, ts.isExternalModuleNameRelative(moduleName) ? undefined : moduleName, checker), {
                    id: id,
                    symbolTableKey: symbolTableKey,
                    symbolName: symbolName,
                    capitalizedSymbolName: capitalizedSymbolName,
                    moduleName: moduleName,
                    moduleFile: moduleFile,
                    moduleFileName: moduleFile === null || moduleFile === void 0 ? void 0 : moduleFile.fileName,
                    packageName: packageName,
                    exportKind: exportKind,
                    targetFlags: target.flags,
                    isFromPackageJson: isFromPackageJson,
                    symbol: storedSymbol,
                    moduleSymbol: storedModuleSymbol,
                });
            },
            get: function (importingFile, key) {
                if (importingFile !== usableByFileName)
                    return;
                var result = exportInfo.get(key);
                return result === null || result === void 0 ? void 0 : result.map(rehydrateCachedInfo);
            },
            search: function (importingFile, preferCapitalized, matches, action) {
                if (importingFile !== usableByFileName)
                    return;
                exportInfo.forEach(function (info, key) {
                    var _a = parseKey(key), symbolName = _a.symbolName, ambientModuleName = _a.ambientModuleName;
                    var name = preferCapitalized && info[0].capitalizedSymbolName || symbolName;
                    if (matches(name, info[0].targetFlags)) {
                        var rehydrated = info.map(rehydrateCachedInfo);
                        var filtered = rehydrated.filter(function (r, i) { return isNotShadowedByDeeperNodeModulesPackage(r, info[i].packageName); });
                        if (filtered.length) {
                            action(filtered, name, !!ambientModuleName, key);
                        }
                    }
                });
            },
            releaseSymbols: function () {
                symbols.clear();
            },
            onFileChanged: function (oldSourceFile, newSourceFile, typeAcquisitionEnabled) {
                if (fileIsGlobalOnly(oldSourceFile) && fileIsGlobalOnly(newSourceFile)) {
                    // File is purely global; doesn't affect export map
                    return false;
                }
                if (usableByFileName && usableByFileName !== newSourceFile.path ||
                    // If ATA is enabled, auto-imports uses existing imports to guess whether you want auto-imports from node.
                    // Adding or removing imports from node could change the outcome of that guess, so could change the suggestions list.
                    typeAcquisitionEnabled && ts.consumesNodeCoreModules(oldSourceFile) !== ts.consumesNodeCoreModules(newSourceFile) ||
                    // Module agumentation and ambient module changes can add or remove exports available to be auto-imported.
                    // Changes elsewhere in the file can change the *type* of an export in a module augmentation,
                    // but type info is gathered in getCompletionEntryDetails, which doesn’t use the cache.
                    !ts.arrayIsEqualTo(oldSourceFile.moduleAugmentations, newSourceFile.moduleAugmentations) ||
                    !ambientModuleDeclarationsAreEqual(oldSourceFile, newSourceFile)) {
                    cache.clear();
                    return true;
                }
                usableByFileName = newSourceFile.path;
                return false;
            },
        };
        if (ts.Debug.isDebugging) {
            Object.defineProperty(cache, "__cache", { get: function () { return exportInfo; } });
        }
        return cache;
        function rehydrateCachedInfo(info) {
            if (info.symbol && info.moduleSymbol)
                return info;
            var id = info.id, exportKind = info.exportKind, targetFlags = info.targetFlags, isFromPackageJson = info.isFromPackageJson, moduleFileName = info.moduleFileName;
            var _a = symbols.get(id) || ts.emptyArray, cachedSymbol = _a[0], cachedModuleSymbol = _a[1];
            if (cachedSymbol && cachedModuleSymbol) {
                return {
                    symbol: cachedSymbol,
                    moduleSymbol: cachedModuleSymbol,
                    moduleFileName: moduleFileName,
                    exportKind: exportKind,
                    targetFlags: targetFlags,
                    isFromPackageJson: isFromPackageJson,
                };
            }
            var checker = (isFromPackageJson
                ? host.getPackageJsonAutoImportProvider()
                : host.getCurrentProgram()).getTypeChecker();
            var moduleSymbol = info.moduleSymbol || cachedModuleSymbol || ts.Debug.checkDefined(info.moduleFile
                ? checker.getMergedSymbol(info.moduleFile.symbol)
                : checker.tryFindAmbientModule(info.moduleName));
            var symbol = info.symbol || cachedSymbol || ts.Debug.checkDefined(exportKind === 2 /* ExportKind.ExportEquals */
                ? checker.resolveExternalModuleSymbol(moduleSymbol)
                : checker.tryGetMemberInModuleExportsAndProperties(ts.unescapeLeadingUnderscores(info.symbolTableKey), moduleSymbol), "Could not find symbol '".concat(info.symbolName, "' by key '").concat(info.symbolTableKey, "' in module ").concat(moduleSymbol.name));
            symbols.set(id, [symbol, moduleSymbol]);
            return {
                symbol: symbol,
                moduleSymbol: moduleSymbol,
                moduleFileName: moduleFileName,
                exportKind: exportKind,
                targetFlags: targetFlags,
                isFromPackageJson: isFromPackageJson,
            };
        }
        function key(importedName, symbol, ambientModuleName, checker) {
            var moduleKey = ambientModuleName || "";
            return "".concat(importedName, "|").concat(ts.getSymbolId(ts.skipAlias(symbol, checker)), "|").concat(moduleKey);
        }
        function parseKey(key) {
            var symbolName = key.substring(0, key.indexOf("|"));
            var moduleKey = key.substring(key.lastIndexOf("|") + 1);
            var ambientModuleName = moduleKey === "" ? undefined : moduleKey;
            return { symbolName: symbolName, ambientModuleName: ambientModuleName };
        }
        function fileIsGlobalOnly(file) {
            return !file.commonJsModuleIndicator && !file.externalModuleIndicator && !file.moduleAugmentations && !file.ambientModuleNames;
        }
        function ambientModuleDeclarationsAreEqual(oldSourceFile, newSourceFile) {
            if (!ts.arrayIsEqualTo(oldSourceFile.ambientModuleNames, newSourceFile.ambientModuleNames)) {
                return false;
            }
            var oldFileStatementIndex = -1;
            var newFileStatementIndex = -1;
            var _loop_2 = function (ambientModuleName) {
                var isMatchingModuleDeclaration = function (node) { return ts.isNonGlobalAmbientModule(node) && node.name.text === ambientModuleName; };
                oldFileStatementIndex = ts.findIndex(oldSourceFile.statements, isMatchingModuleDeclaration, oldFileStatementIndex + 1);
                newFileStatementIndex = ts.findIndex(newSourceFile.statements, isMatchingModuleDeclaration, newFileStatementIndex + 1);
                if (oldSourceFile.statements[oldFileStatementIndex] !== newSourceFile.statements[newFileStatementIndex]) {
                    return { value: false };
                }
            };
            for (var _i = 0, _a = newSourceFile.ambientModuleNames; _i < _a.length; _i++) {
                var ambientModuleName = _a[_i];
                var state_2 = _loop_2(ambientModuleName);
                if (typeof state_2 === "object")
                    return state_2.value;
            }
            return true;
        }
        function isNotShadowedByDeeperNodeModulesPackage(info, packageName) {
            if (!packageName || !info.moduleFileName)
                return true;
            var typingsCacheLocation = host.getGlobalTypingsCacheLocation();
            if (typingsCacheLocation && ts.startsWith(info.moduleFileName, typingsCacheLocation))
                return true;
            var packageDeepestNodeModulesPath = packages.get(packageName);
            return !packageDeepestNodeModulesPath || ts.startsWith(info.moduleFileName, packageDeepestNodeModulesPath);
        }
    }
    ts.createCacheableExportInfoMap = createCacheableExportInfoMap;
    function isImportableFile(program, from, to, preferences, packageJsonFilter, moduleSpecifierResolutionHost, moduleSpecifierCache) {
        var _a;
        if (from === to)
            return false;
        var cachedResult = moduleSpecifierCache === null || moduleSpecifierCache === void 0 ? void 0 : moduleSpecifierCache.get(from.path, to.path, preferences, {});
        if ((cachedResult === null || cachedResult === void 0 ? void 0 : cachedResult.isBlockedByPackageJsonDependencies) !== undefined) {
            return !cachedResult.isBlockedByPackageJsonDependencies;
        }
        var getCanonicalFileName = ts.hostGetCanonicalFileName(moduleSpecifierResolutionHost);
        var globalTypingsCache = (_a = moduleSpecifierResolutionHost.getGlobalTypingsCacheLocation) === null || _a === void 0 ? void 0 : _a.call(moduleSpecifierResolutionHost);
        var hasImportablePath = !!ts.moduleSpecifiers.forEachFileNameOfModule(from.fileName, to.fileName, moduleSpecifierResolutionHost, 
        /*preferSymlinks*/ false, function (toPath) {
            var toFile = program.getSourceFile(toPath);
            // Determine to import using toPath only if toPath is what we were looking at
            // or there doesnt exist the file in the program by the symlink
            return (toFile === to || !toFile) &&
                isImportablePath(from.fileName, toPath, getCanonicalFileName, globalTypingsCache);
        });
        if (packageJsonFilter) {
            var isAutoImportable = hasImportablePath && packageJsonFilter.allowsImportingSourceFile(to, moduleSpecifierResolutionHost);
            moduleSpecifierCache === null || moduleSpecifierCache === void 0 ? void 0 : moduleSpecifierCache.setBlockedByPackageJsonDependencies(from.path, to.path, preferences, {}, !isAutoImportable);
            return isAutoImportable;
        }
        return hasImportablePath;
    }
    ts.isImportableFile = isImportableFile;
    /**
     * Don't include something from a `node_modules` that isn't actually reachable by a global import.
     * A relative import to node_modules is usually a bad idea.
     */
    function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {
        // If it's in a `node_modules` but is not reachable from here via a global import, don't bother.
        var toNodeModules = ts.forEachAncestorDirectory(toPath, function (ancestor) { return ts.getBaseFileName(ancestor) === "node_modules" ? ancestor : undefined; });
        var toNodeModulesParent = toNodeModules && ts.getDirectoryPath(getCanonicalFileName(toNodeModules));
        return toNodeModulesParent === undefined
            || ts.startsWith(getCanonicalFileName(fromPath), toNodeModulesParent)
            || (!!globalCachePath && ts.startsWith(getCanonicalFileName(globalCachePath), toNodeModulesParent));
    }
    function forEachExternalModuleToImportFrom(program, host, useAutoImportProvider, cb) {
        var _a, _b;
        forEachExternalModule(program.getTypeChecker(), program.getSourceFiles(), function (module, file) { return cb(module, file, program, /*isFromPackageJson*/ false); });
        var autoImportProvider = useAutoImportProvider && ((_a = host.getPackageJsonAutoImportProvider) === null || _a === void 0 ? void 0 : _a.call(host));
        if (autoImportProvider) {
            var start = ts.timestamp();
            forEachExternalModule(autoImportProvider.getTypeChecker(), autoImportProvider.getSourceFiles(), function (module, file) { return cb(module, file, autoImportProvider, /*isFromPackageJson*/ true); });
            (_b = host.log) === null || _b === void 0 ? void 0 : _b.call(host, "forEachExternalModuleToImportFrom autoImportProvider: ".concat(ts.timestamp() - start));
        }
    }
    ts.forEachExternalModuleToImportFrom = forEachExternalModuleToImportFrom;
    function forEachExternalModule(checker, allSourceFiles, cb) {
        for (var _i = 0, _a = checker.getAmbientModules(); _i < _a.length; _i++) {
            var ambient = _a[_i];
            if (!ts.stringContains(ambient.name, "*")) {
                cb(ambient, /*sourceFile*/ undefined);
            }
        }
        for (var _b = 0, allSourceFiles_1 = allSourceFiles; _b < allSourceFiles_1.length; _b++) {
            var sourceFile = allSourceFiles_1[_b];
            if (ts.isExternalOrCommonJsModule(sourceFile)) {
                cb(checker.getMergedSymbol(sourceFile.symbol), sourceFile);
            }
        }
    }
    function getExportInfoMap(importingFile, host, program, cancellationToken) {
        var _a, _b, _c, _d, _e;
        var start = ts.timestamp();
        // Pulling the AutoImportProvider project will trigger its updateGraph if pending,
        // which will invalidate the export map cache if things change, so pull it before
        // checking the cache.
        (_a = host.getPackageJsonAutoImportProvider) === null || _a === void 0 ? void 0 : _a.call(host);
        var cache = ((_b = host.getCachedExportInfoMap) === null || _b === void 0 ? void 0 : _b.call(host)) || createCacheableExportInfoMap({
            getCurrentProgram: function () { return program; },
            getPackageJsonAutoImportProvider: function () { var _a; return (_a = host.getPackageJsonAutoImportProvider) === null || _a === void 0 ? void 0 : _a.call(host); },
            getGlobalTypingsCacheLocation: function () { var _a; return (_a = host.getGlobalTypingsCacheLocation) === null || _a === void 0 ? void 0 : _a.call(host); },
        });
        if (cache.isUsableByFile(importingFile.path)) {
            (_c = host.log) === null || _c === void 0 ? void 0 : _c.call(host, "getExportInfoMap: cache hit");
            return cache;
        }
        (_d = host.log) === null || _d === void 0 ? void 0 : _d.call(host, "getExportInfoMap: cache miss or empty; calculating new results");
        var compilerOptions = program.getCompilerOptions();
        var moduleCount = 0;
        try {
            forEachExternalModuleToImportFrom(program, host, /*useAutoImportProvider*/ true, function (moduleSymbol, moduleFile, program, isFromPackageJson) {
                if (++moduleCount % 100 === 0)
                    cancellationToken === null || cancellationToken === void 0 ? void 0 : cancellationToken.throwIfCancellationRequested();
                var seenExports = new ts.Map();
                var checker = program.getTypeChecker();
                var defaultInfo = getDefaultLikeExportInfo(moduleSymbol, checker, compilerOptions);
                // Note: I think we shouldn't actually see resolved module symbols here, but weird merges
                // can cause it to happen: see 'completionsImport_mergedReExport.ts'
                if (defaultInfo && isImportableSymbol(defaultInfo.symbol, checker)) {
                    cache.add(importingFile.path, defaultInfo.symbol, defaultInfo.exportKind === 1 /* ExportKind.Default */ ? "default" /* InternalSymbolName.Default */ : "export=" /* InternalSymbolName.ExportEquals */, moduleSymbol, moduleFile, defaultInfo.exportKind, isFromPackageJson, checker);
                }
                checker.forEachExportAndPropertyOfModule(moduleSymbol, function (exported, key) {
                    if (exported !== (defaultInfo === null || defaultInfo === void 0 ? void 0 : defaultInfo.symbol) && isImportableSymbol(exported, checker) && ts.addToSeen(seenExports, key)) {
                        cache.add(importingFile.path, exported, key, moduleSymbol, moduleFile, 0 /* ExportKind.Named */, isFromPackageJson, checker);
                    }
                });
            });
        }
        catch (err) {
            // Ensure cache is reset if operation is cancelled
            cache.clear();
            throw err;
        }
        (_e = host.log) === null || _e === void 0 ? void 0 : _e.call(host, "getExportInfoMap: done in ".concat(ts.timestamp() - start, " ms"));
        return cache;
    }
    ts.getExportInfoMap = getExportInfoMap;
    function getDefaultLikeExportInfo(moduleSymbol, checker, compilerOptions) {
        var exported = getDefaultLikeExportWorker(moduleSymbol, checker);
        if (!exported)
            return undefined;
        var symbol = exported.symbol, exportKind = exported.exportKind;
        var info = getDefaultExportInfoWorker(symbol, checker, compilerOptions);
        return info && __assign({ symbol: symbol, exportKind: exportKind }, info);
    }
    ts.getDefaultLikeExportInfo = getDefaultLikeExportInfo;
    function isImportableSymbol(symbol, checker) {
        return !checker.isUndefinedSymbol(symbol) && !checker.isUnknownSymbol(symbol) && !ts.isKnownSymbol(symbol) && !ts.isPrivateIdentifierSymbol(symbol);
    }
    function getDefaultLikeExportWorker(moduleSymbol, checker) {
        var exportEquals = checker.resolveExternalModuleSymbol(moduleSymbol);
        if (exportEquals !== moduleSymbol)
            return { symbol: exportEquals, exportKind: 2 /* ExportKind.ExportEquals */ };
        var defaultExport = checker.tryGetMemberInModuleExports("default" /* InternalSymbolName.Default */, moduleSymbol);
        if (defaultExport)
            return { symbol: defaultExport, exportKind: 1 /* ExportKind.Default */ };
    }
    function getDefaultExportInfoWorker(defaultExport, checker, compilerOptions) {
        var localSymbol = ts.getLocalSymbolForExportDefault(defaultExport);
        if (localSymbol)
            return { symbolForMeaning: localSymbol, name: localSymbol.name };
        var name = getNameForExportDefault(defaultExport);
        if (name !== undefined)
            return { symbolForMeaning: defaultExport, name: name };
        if (defaultExport.flags & 2097152 /* SymbolFlags.Alias */) {
            var aliased = checker.getImmediateAliasedSymbol(defaultExport);
            if (aliased && aliased.parent) {
                // - `aliased` will be undefined if the module is exporting an unresolvable name,
                //    but we can still offer completions for it.
                // - `aliased.parent` will be undefined if the module is exporting `globalThis.something`,
                //    or another expression that resolves to a global.
                return getDefaultExportInfoWorker(aliased, checker, compilerOptions);
            }
        }
        if (defaultExport.escapedName !== "default" /* InternalSymbolName.Default */ &&
            defaultExport.escapedName !== "export=" /* InternalSymbolName.ExportEquals */) {
            return { symbolForMeaning: defaultExport, name: defaultExport.getName() };
        }
        return { symbolForMeaning: defaultExport, name: ts.getNameForExportedSymbol(defaultExport, compilerOptions.target) };
    }
    function getNameForExportDefault(symbol) {
        return symbol.declarations && ts.firstDefined(symbol.declarations, function (declaration) {
            var _a;
            if (ts.isExportAssignment(declaration)) {
                return (_a = ts.tryCast(ts.skipOuterExpressions(declaration.expression), ts.isIdentifier)) === null || _a === void 0 ? void 0 : _a.text;
            }
            else if (ts.isExportSpecifier(declaration)) {
                ts.Debug.assert(declaration.name.text === "default" /* InternalSymbolName.Default */, "Expected the specifier to be a default export");
                return declaration.propertyName && declaration.propertyName.text;
            }
        });
    }
})(ts || (ts = {}));
var ts;
(function (ts) {
    /** The classifier is used for syntactic highlighting in editors via the TSServer */
    function createClassifier() {
        var scanner = ts.createScanner(99 /* ScriptTarget.Latest */, /*skipTrivia*/ false);
        function getClassificationsForLine(text, lexState, syntacticClassifierAbsent) {
            return convertClassificationsToResult(getEncodedLexicalClassifications(text, lexState, syntacticClassifierAbsent), text);
        }
        // If there is a syntactic classifier ('syntacticClassifierAbsent' is false),
        // we will be more conservative in order to avoid conflicting with the syntactic classifier.
        function getEncodedLexicalClassifications(text, lexState, syntacticClassifierAbsent) {
            var token = 0 /* SyntaxKind.Unknown */;
            var lastNonTriviaToken = 0 /* SyntaxKind.Unknown */;
            // Just a stack of TemplateHeads and OpenCurlyBraces, used to perform rudimentary (inexact)
            // classification on template strings. Because of the context free nature of templates,
            // the only precise way to classify a template portion would be by propagating the stack across
            // lines, just as we do with the end-of-line state. However, this is a burden for implementers,
            // and the behavior is entirely subsumed by the syntactic classifier anyway, so we instead
            // flatten any nesting when the template stack is non-empty and encode it in the end-of-line state.
            // Situations in which this fails are
            //  1) When template strings are nested across different lines:
            //          `hello ${ `world
            //          ` }`
            //
            //     Where on the second line, you will get the closing of a template,
            //     a closing curly, and a new template.
            //
            //  2) When substitution expressions have curly braces and the curly brace falls on the next line:
            //          `hello ${ () => {
            //          return "world" } } `
            //
            //     Where on the second line, you will get the 'return' keyword,
            //     a string literal, and a template end consisting of '} } `'.
            var templateStack = [];
            var _a = getPrefixFromLexState(lexState), prefix = _a.prefix, pushTemplate = _a.pushTemplate;
            text = prefix + text;
            var offset = prefix.length;
            if (pushTemplate) {
                templateStack.push(15 /* SyntaxKind.TemplateHead */);
            }
            scanner.setText(text);
            var endOfLineState = 0 /* EndOfLineState.None */;
            var spans = [];
            // We can run into an unfortunate interaction between the lexical and syntactic classifier
            // when the user is typing something generic.  Consider the case where the user types:
            //
            //      Foo<number
            //
            // From the lexical classifier's perspective, 'number' is a keyword, and so the word will
            // be classified as such.  However, from the syntactic classifier's tree-based perspective
            // this is simply an expression with the identifier 'number' on the RHS of the less than
            // token.  So the classification will go back to being an identifier.  The moment the user
            // types again, number will become a keyword, then an identifier, etc. etc.
            //
            // To try to avoid this problem, we avoid classifying contextual keywords as keywords
            // when the user is potentially typing something generic.  We just can't do a good enough
            // job at the lexical level, and so well leave it up to the syntactic classifier to make
            // the determination.
            //
            // In order to determine if the user is potentially typing something generic, we use a
            // weak heuristic where we track < and > tokens.  It's a weak heuristic, but should
            // work well enough in practice.
            var angleBracketStack = 0;
            do {
                token = scanner.scan();
                if (!ts.isTrivia(token)) {
                    handleToken();
                    lastNonTriviaToken = token;
                }
                var end = scanner.getTextPos();
                pushEncodedClassification(scanner.getTokenPos(), end, offset, classFromKind(token), spans);
                if (end >= text.length) {
                    var end_1 = getNewEndOfLineState(scanner, token, ts.lastOrUndefined(templateStack));
                    if (end_1 !== undefined) {
                        endOfLineState = end_1;
                    }
                }
            } while (token !== 1 /* SyntaxKind.EndOfFileToken */);
            function handleToken() {
                switch (token) {
                    case 43 /* SyntaxKind.SlashToken */:
                    case 68 /* SyntaxKind.SlashEqualsToken */:
                        if (!noRegexTable[lastNonTriviaToken] && scanner.reScanSlashToken() === 13 /* SyntaxKind.RegularExpressionLiteral */) {
                            token = 13 /* SyntaxKind.RegularExpressionLiteral */;
                        }
                        break;
                    case 29 /* SyntaxKind.LessThanToken */:
                        if (lastNonTriviaToken === 79 /* SyntaxKind.Identifier */) {
                            // Could be the start of something generic.  Keep track of that by bumping
                            // up the current count of generic contexts we may be in.
                            angleBracketStack++;
                        }
                        break;
                    case 31 /* SyntaxKind.GreaterThanToken */:
                        if (angleBracketStack > 0) {
                            // If we think we're currently in something generic, then mark that that
                            // generic entity is complete.
                            angleBracketStack--;
                        }
                        break;
                    case 130 /* SyntaxKind.AnyKeyword */:
                    case 150 /* SyntaxKind.StringKeyword */:
                    case 147 /* SyntaxKind.NumberKeyword */:
                    case 133 /* SyntaxKind.BooleanKeyword */:
                    case 151 /* SyntaxKind.SymbolKeyword */:
                        if (angleBracketStack > 0 && !syntacticClassifierAbsent) {
                            // If it looks like we're could be in something generic, don't classify this
                            // as a keyword.  We may just get overwritten by the syntactic classifier,
                            // causing a noisy experience for the user.
                            token = 79 /* SyntaxKind.Identifier */;
                        }
                        break;
                    case 15 /* SyntaxKind.TemplateHead */:
                        templateStack.push(token);
                        break;
                    case 18 /* SyntaxKind.OpenBraceToken */:
                        // If we don't have anything on the template stack,
                        // then we aren't trying to keep track of a previously scanned template head.
                        if (templateStack.length > 0) {
                            templateStack.push(token);
                        }
                        break;
                    case 19 /* SyntaxKind.CloseBraceToken */:
                        // If we don't have anything on the template stack,
                        // then we aren't trying to keep track of a previously scanned template head.
                        if (templateStack.length > 0) {
                            var lastTemplateStackToken = ts.lastOrUndefined(templateStack);
                            if (lastTemplateStackToken === 15 /* SyntaxKind.TemplateHead */) {
                                token = scanner.reScanTemplateToken(/* isTaggedTemplate */ false);
                                // Only pop on a TemplateTail; a TemplateMiddle indicates there is more for us.
                                if (token === 17 /* SyntaxKind.TemplateTail */) {
                                    templateStack.pop();
                                }
                                else {
                                    ts.Debug.assertEqual(token, 16 /* SyntaxKind.TemplateMiddle */, "Should have been a template middle.");
                                }
                            }
                            else {
                                ts.Debug.assertEqual(lastTemplateStackToken, 18 /* SyntaxKind.OpenBraceToken */, "Should have been an open brace");
                                templateStack.pop();
                            }
                        }
                        break;
                    default:
                        if (!ts.isKeyword(token)) {
                            break;
                        }
                        if (lastNonTriviaToken === 24 /* SyntaxKind.DotToken */) {
                            token = 79 /* SyntaxKind.Identifier */;
                        }
                        else if (ts.isKeyword(lastNonTriviaToken) && ts.isKeyword(token) && !canFollow(lastNonTriviaToken, token)) {
                            // We have two keywords in a row.  Only treat the second as a keyword if
                            // it's a sequence that could legally occur in the language.  Otherwise
                            // treat it as an identifier.  This way, if someone writes "private var"
                            // we recognize that 'var' is actually an identifier here.
                            token = 79 /* SyntaxKind.Identifier */;
                        }
                }
            }
            return { endOfLineState: endOfLineState, spans: spans };
        }
        return { getClassificationsForLine: getClassificationsForLine, getEncodedLexicalClassifications: getEncodedLexicalClassifications };
    }
    ts.createClassifier = createClassifier;
    /// We do not have a full parser support to know when we should parse a regex or not
    /// If we consider every slash token to be a regex, we could be missing cases like "1/2/3", where
    /// we have a series of divide operator. this list allows us to be more accurate by ruling out
    /// locations where a regexp cannot exist.
    var noRegexTable = ts.arrayToNumericMap([
        79 /* SyntaxKind.Identifier */,
        10 /* SyntaxKind.StringLiteral */,
        8 /* SyntaxKind.NumericLiteral */,
        9 /* SyntaxKind.BigIntLiteral */,
        13 /* SyntaxKind.RegularExpressionLiteral */,
        108 /* SyntaxKind.ThisKeyword */,
        45 /* SyntaxKind.PlusPlusToken */,
        46 /* SyntaxKind.MinusMinusToken */,
        21 /* SyntaxKind.CloseParenToken */,
        23 /* SyntaxKind.CloseBracketToken */,
        19 /* SyntaxKind.CloseBraceToken */,
        110 /* SyntaxKind.TrueKeyword */,
        95 /* SyntaxKind.FalseKeyword */,
    ], function (token) { return token; }, function () { return true; });
    function getNewEndOfLineState(scanner, token, lastOnTemplateStack) {
        switch (token) {
            case 10 /* SyntaxKind.StringLiteral */: {
                // Check to see if we finished up on a multiline string literal.
                if (!scanner.isUnterminated())
                    return undefined;
                var tokenText = scanner.getTokenText();
                var lastCharIndex = tokenText.length - 1;
                var numBackslashes = 0;
                while (tokenText.charCodeAt(lastCharIndex - numBackslashes) === 92 /* CharacterCodes.backslash */) {
                    numBackslashes++;
                }
                // If we have an odd number of backslashes, then the multiline string is unclosed
                if ((numBackslashes & 1) === 0)
                    return undefined;
                return tokenText.charCodeAt(0) === 34 /* CharacterCodes.doubleQuote */ ? 3 /* EndOfLineState.InDoubleQuoteStringLiteral */ : 2 /* EndOfLineState.InSingleQuoteStringLiteral */;
            }
            case 3 /* SyntaxKind.MultiLineCommentTrivia */:
                // Check to see if the multiline comment was unclosed.
                return scanner.isUnterminated() ? 1 /* EndOfLineState.InMultiLineCommentTrivia */ : undefined;
            default:
                if (ts.isTemplateLiteralKind(token)) {
                    if (!scanner.isUnterminated()) {
                        return undefined;
                    }
                    switch (token) {
                        case 17 /* SyntaxKind.TemplateTail */:
                            return 5 /* EndOfLineState.InTemplateMiddleOrTail */;
                        case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
                            return 4 /* EndOfLineState.InTemplateHeadOrNoSubstitutionTemplate */;
                        default:
                            return ts.Debug.fail("Only 'NoSubstitutionTemplateLiteral's and 'TemplateTail's can be unterminated; got SyntaxKind #" + token);
                    }
                }
                return lastOnTemplateStack === 15 /* SyntaxKind.TemplateHead */ ? 6 /* EndOfLineState.InTemplateSubstitutionPosition */ : undefined;
        }
    }
    function pushEncodedClassification(start, end, offset, classification, result) {
        if (classification === 8 /* ClassificationType.whiteSpace */) {
            // Don't bother with whitespace classifications.  They're not needed.
            return;
        }
        if (start === 0 && offset > 0) {
            // We're classifying the first token, and this was a case where we prepended text.
            // We should consider the start of this token to be at the start of the original text.
            start += offset;
        }
        var length = end - start;
        if (length > 0) {
            // All our tokens are in relation to the augmented text.  Move them back to be
            // relative to the original text.
            result.push(start - offset, length, classification);
        }
    }
    function convertClassificationsToResult(classifications, text) {
        var entries = [];
        var dense = classifications.spans;
        var lastEnd = 0;
        for (var i = 0; i < dense.length; i += 3) {
            var start = dense[i];
            var length_1 = dense[i + 1];
            var type = dense[i + 2];
            // Make a whitespace entry between the last item and this one.
            if (lastEnd >= 0) {
                var whitespaceLength_1 = start - lastEnd;
                if (whitespaceLength_1 > 0) {
                    entries.push({ length: whitespaceLength_1, classification: ts.TokenClass.Whitespace });
                }
            }
            entries.push({ length: length_1, classification: convertClassification(type) });
            lastEnd = start + length_1;
        }
        var whitespaceLength = text.length - lastEnd;
        if (whitespaceLength > 0) {
            entries.push({ length: whitespaceLength, classification: ts.TokenClass.Whitespace });
        }
        return { entries: entries, finalLexState: classifications.endOfLineState };
    }
    function convertClassification(type) {
        switch (type) {
            case 1 /* ClassificationType.comment */: return ts.TokenClass.Comment;
            case 3 /* ClassificationType.keyword */: return ts.TokenClass.Keyword;
            case 4 /* ClassificationType.numericLiteral */: return ts.TokenClass.NumberLiteral;
            case 25 /* ClassificationType.bigintLiteral */: return ts.TokenClass.BigIntLiteral;
            case 5 /* ClassificationType.operator */: return ts.TokenClass.Operator;
            case 6 /* ClassificationType.stringLiteral */: return ts.TokenClass.StringLiteral;
            case 8 /* ClassificationType.whiteSpace */: return ts.TokenClass.Whitespace;
            case 10 /* ClassificationType.punctuation */: return ts.TokenClass.Punctuation;
            case 2 /* ClassificationType.identifier */:
            case 11 /* ClassificationType.className */:
            case 12 /* ClassificationType.enumName */:
            case 13 /* ClassificationType.interfaceName */:
            case 14 /* ClassificationType.moduleName */:
            case 15 /* ClassificationType.typeParameterName */:
            case 16 /* ClassificationType.typeAliasName */:
            case 9 /* ClassificationType.text */:
            case 17 /* ClassificationType.parameterName */:
                return ts.TokenClass.Identifier;
            default:
                return undefined; // TODO: GH#18217 Debug.assertNever(type);
        }
    }
    /** Returns true if 'keyword2' can legally follow 'keyword1' in any language construct. */
    function canFollow(keyword1, keyword2) {
        if (!ts.isAccessibilityModifier(keyword1)) {
            // Assume any other keyword combination is legal.
            // This can be refined in the future if there are more cases we want the classifier to be better at.
            return true;
        }
        switch (keyword2) {
            case 136 /* SyntaxKind.GetKeyword */:
            case 149 /* SyntaxKind.SetKeyword */:
            case 134 /* SyntaxKind.ConstructorKeyword */:
            case 124 /* SyntaxKind.StaticKeyword */:
                return true; // Allow things like "public get", "public constructor" and "public static".
            default:
                return false; // Any other keyword following "public" is actually an identifier, not a real keyword.
        }
    }
    function getPrefixFromLexState(lexState) {
        // If we're in a string literal, then prepend: "\
        // (and a newline).  That way when we lex we'll think we're still in a string literal.
        //
        // If we're in a multiline comment, then prepend: /*
        // (and a newline).  That way when we lex we'll think we're still in a multiline comment.
        switch (lexState) {
            case 3 /* EndOfLineState.InDoubleQuoteStringLiteral */:
                return { prefix: "\"\\\n" };
            case 2 /* EndOfLineState.InSingleQuoteStringLiteral */:
                return { prefix: "'\\\n" };
            case 1 /* EndOfLineState.InMultiLineCommentTrivia */:
                return { prefix: "/*\n" };
            case 4 /* EndOfLineState.InTemplateHeadOrNoSubstitutionTemplate */:
                return { prefix: "`\n" };
            case 5 /* EndOfLineState.InTemplateMiddleOrTail */:
                return { prefix: "}\n", pushTemplate: true };
            case 6 /* EndOfLineState.InTemplateSubstitutionPosition */:
                return { prefix: "", pushTemplate: true };
            case 0 /* EndOfLineState.None */:
                return { prefix: "" };
            default:
                return ts.Debug.assertNever(lexState);
        }
    }
    function isBinaryExpressionOperatorToken(token) {
        switch (token) {
            case 41 /* SyntaxKind.AsteriskToken */:
            case 43 /* SyntaxKind.SlashToken */:
            case 44 /* SyntaxKind.PercentToken */:
            case 39 /* SyntaxKind.PlusToken */:
            case 40 /* SyntaxKind.MinusToken */:
            case 47 /* SyntaxKind.LessThanLessThanToken */:
            case 48 /* SyntaxKind.GreaterThanGreaterThanToken */:
            case 49 /* SyntaxKind.GreaterThanGreaterThanGreaterThanToken */:
            case 29 /* SyntaxKind.LessThanToken */:
            case 31 /* SyntaxKind.GreaterThanToken */:
            case 32 /* SyntaxKind.LessThanEqualsToken */:
            case 33 /* SyntaxKind.GreaterThanEqualsToken */:
            case 102 /* SyntaxKind.InstanceOfKeyword */:
            case 101 /* SyntaxKind.InKeyword */:
            case 127 /* SyntaxKind.AsKeyword */:
            case 34 /* SyntaxKind.EqualsEqualsToken */:
            case 35 /* SyntaxKind.ExclamationEqualsToken */:
            case 36 /* SyntaxKind.EqualsEqualsEqualsToken */:
            case 37 /* SyntaxKind.ExclamationEqualsEqualsToken */:
            case 50 /* SyntaxKind.AmpersandToken */:
            case 52 /* SyntaxKind.CaretToken */:
            case 51 /* SyntaxKind.BarToken */:
            case 55 /* SyntaxKind.AmpersandAmpersandToken */:
            case 56 /* SyntaxKind.BarBarToken */:
            case 74 /* SyntaxKind.BarEqualsToken */:
            case 73 /* SyntaxKind.AmpersandEqualsToken */:
            case 78 /* SyntaxKind.CaretEqualsToken */:
            case 70 /* SyntaxKind.LessThanLessThanEqualsToken */:
            case 71 /* SyntaxKind.GreaterThanGreaterThanEqualsToken */:
            case 72 /* SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken */:
            case 64 /* SyntaxKind.PlusEqualsToken */:
            case 65 /* SyntaxKind.MinusEqualsToken */:
            case 66 /* SyntaxKind.AsteriskEqualsToken */:
            case 68 /* SyntaxKind.SlashEqualsToken */:
            case 69 /* SyntaxKind.PercentEqualsToken */:
            case 63 /* SyntaxKind.EqualsToken */:
            case 27 /* SyntaxKind.CommaToken */:
            case 60 /* SyntaxKind.QuestionQuestionToken */:
            case 75 /* SyntaxKind.BarBarEqualsToken */:
            case 76 /* SyntaxKind.AmpersandAmpersandEqualsToken */:
            case 77 /* SyntaxKind.QuestionQuestionEqualsToken */:
                return true;
            default:
                return false;
        }
    }
    function isPrefixUnaryExpressionOperatorToken(token) {
        switch (token) {
            case 39 /* SyntaxKind.PlusToken */:
            case 40 /* SyntaxKind.MinusToken */:
            case 54 /* SyntaxKind.TildeToken */:
            case 53 /* SyntaxKind.ExclamationToken */:
            case 45 /* SyntaxKind.PlusPlusToken */:
            case 46 /* SyntaxKind.MinusMinusToken */:
                return true;
            default:
                return false;
        }
    }
    function classFromKind(token) {
        if (ts.isKeyword(token)) {
            return 3 /* ClassificationType.keyword */;
        }
        else if (isBinaryExpressionOperatorToken(token) || isPrefixUnaryExpressionOperatorToken(token)) {
            return 5 /* ClassificationType.operator */;
        }
        else if (token >= 18 /* SyntaxKind.FirstPunctuation */ && token <= 78 /* SyntaxKind.LastPunctuation */) {
            return 10 /* ClassificationType.punctuation */;
        }
        switch (token) {
            case 8 /* SyntaxKind.NumericLiteral */:
                return 4 /* ClassificationType.numericLiteral */;
            case 9 /* SyntaxKind.BigIntLiteral */:
                return 25 /* ClassificationType.bigintLiteral */;
            case 10 /* SyntaxKind.StringLiteral */:
                return 6 /* ClassificationType.stringLiteral */;
            case 13 /* SyntaxKind.RegularExpressionLiteral */:
                return 7 /* ClassificationType.regularExpressionLiteral */;
            case 7 /* SyntaxKind.ConflictMarkerTrivia */:
            case 3 /* SyntaxKind.MultiLineCommentTrivia */:
            case 2 /* SyntaxKind.SingleLineCommentTrivia */:
                return 1 /* ClassificationType.comment */;
            case 5 /* SyntaxKind.WhitespaceTrivia */:
            case 4 /* SyntaxKind.NewLineTrivia */:
                return 8 /* ClassificationType.whiteSpace */;
            case 79 /* SyntaxKind.Identifier */:
            default:
                if (ts.isTemplateLiteralKind(token)) {
                    return 6 /* ClassificationType.stringLiteral */;
                }
                return 2 /* ClassificationType.identifier */;
        }
    }
    /* @internal */
    function getSemanticClassifications(typeChecker, cancellationToken, sourceFile, classifiableNames, span) {
        return convertClassificationsToSpans(getEncodedSemanticClassifications(typeChecker, cancellationToken, sourceFile, classifiableNames, span));
    }
    ts.getSemanticClassifications = getSemanticClassifications;
    function checkForClassificationCancellation(cancellationToken, kind) {
        // We don't want to actually call back into our host on every node to find out if we've
        // been canceled.  That would be an enormous amount of chattyness, along with the all
        // the overhead of marshalling the data to/from the host.  So instead we pick a few
        // reasonable node kinds to bother checking on.  These node kinds represent high level
        // constructs that we would expect to see commonly, but just at a far less frequent
        // interval.
        //
        // For example, in checker.ts (around 750k) we only have around 600 of these constructs.
        // That means we're calling back into the host around every 1.2k of the file we process.
        // Lib.d.ts has similar numbers.
        switch (kind) {
            case 261 /* SyntaxKind.ModuleDeclaration */:
            case 257 /* SyntaxKind.ClassDeclaration */:
            case 258 /* SyntaxKind.InterfaceDeclaration */:
            case 256 /* SyntaxKind.FunctionDeclaration */:
            case 226 /* SyntaxKind.ClassExpression */:
            case 213 /* SyntaxKind.FunctionExpression */:
            case 214 /* SyntaxKind.ArrowFunction */:
                cancellationToken.throwIfCancellationRequested();
        }
    }
    /* @internal */
    function getEncodedSemanticClassifications(typeChecker, cancellationToken, sourceFile, classifiableNames, span) {
        var spans = [];
        sourceFile.forEachChild(function cb(node) {
            // Only walk into nodes that intersect the requested span.
            if (!node || !ts.textSpanIntersectsWith(span, node.pos, node.getFullWidth())) {
                return;
            }
            checkForClassificationCancellation(cancellationToken, node.kind);
            // Only bother calling into the typechecker if this is an identifier that
            // could possibly resolve to a type name.  This makes classification run
            // in a third of the time it would normally take.
            if (ts.isIdentifier(node) && !ts.nodeIsMissing(node) && classifiableNames.has(node.escapedText)) {
                var symbol = typeChecker.getSymbolAtLocation(node);
                var type = symbol && classifySymbol(symbol, ts.getMeaningFromLocation(node), typeChecker);
                if (type) {
                    pushClassification(node.getStart(sourceFile), node.getEnd(), type);
                }
            }
            node.forEachChild(cb);
        });
        return { spans: spans, endOfLineState: 0 /* EndOfLineState.None */ };
        function pushClassification(start, end, type) {
            var length = end - start;
            ts.Debug.assert(length > 0, "Classification had non-positive length of ".concat(length));
            spans.push(start);
            spans.push(length);
            spans.push(type);
        }
    }
    ts.getEncodedSemanticClassifications = getEncodedSemanticClassifications;
    function classifySymbol(symbol, meaningAtPosition, checker) {
        var flags = symbol.getFlags();
        if ((flags & 2885600 /* SymbolFlags.Classifiable */) === 0 /* SymbolFlags.None */) {
            return undefined;
        }
        else if (flags & 32 /* SymbolFlags.Class */) {
            return 11 /* ClassificationType.className */;
        }
        else if (flags & 384 /* SymbolFlags.Enum */) {
            return 12 /* ClassificationType.enumName */;
        }
        else if (flags & 524288 /* SymbolFlags.TypeAlias */) {
            return 16 /* ClassificationType.typeAliasName */;
        }
        else if (flags & 1536 /* SymbolFlags.Module */) {
            // Only classify a module as such if
            //  - It appears in a namespace context.
            //  - There exists a module declaration which actually impacts the value side.
            return meaningAtPosition & 4 /* SemanticMeaning.Namespace */ || meaningAtPosition & 1 /* SemanticMeaning.Value */ && hasValueSideModule(symbol) ? 14 /* ClassificationType.moduleName */ : undefined;
        }
