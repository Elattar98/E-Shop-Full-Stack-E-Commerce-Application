
      import {createRequire as __cjsCompatRequire} from 'module';
      const require = __cjsCompatRequire(import.meta.url);
      const __ESM_IMPORT_META_URL__ = import.meta.url;
    
import {
  removeLockFile
} from "./chunk-R3C7RFJ4.js";
import {
  Deferred,
  DirectPackageJsonUpdater,
  DtsProcessing,
  IGNORED_ENTRY_POINT,
  INCOMPATIBLE_ENTRY_POINT,
  NGCC_BACKUP_EXTENSION,
  NGCC_DIRECTORY,
  NGCC_PROPERTY_EXTENSION,
  NGCC_TIMED_OUT_EXIT_CODE,
  NO_ENTRY_POINT,
  SUPPORTED_FORMAT_PROPERTIES,
  computeTaskDependencies,
  getBlockedTasks,
  getCreateCompileFn,
  getEntryPointFormat,
  getEntryPointInfo,
  getImportsOfUmdModule,
  getMaxNumberOfWorkers,
  getPathMappingsFromTsConfig,
  getSharedSetup,
  isEntryPoint,
  isRelativePath,
  isRequireCall,
  isWildcardReexportStatement,
  loadJson,
  loadSecondaryEntryPointInfoForApfV14,
  parseStatementForUmdModule,
  resolveFileWithPostfixes,
  sendMessageToWorker,
  sortTasksByPriority,
  stringifyTask
} from "./chunk-S2H6ZNBD.js";
import {
  LogLevel
} from "./chunk-E7NQQTT7.js";
import {
  absoluteFrom,
  getFileSystem
} from "./chunk-TOKOIIBI.js";
import {
  __require
} from "./chunk-XYNRD7NE.js";

// bazel-out/k8-fastbuild/bin/packages/compiler-cli/ngcc/src/dependencies/commonjs_dependency_host.mjs
import ts from "typescript";

// bazel-out/k8-fastbuild/bin/packages/compiler-cli/ngcc/src/dependencies/module_resolver.mjs
var ModuleResolver = class {
  constructor(fs, pathMappings, relativeExtensions = ["", ".js", "/index.js"]) {
    this.fs = fs;
    this.relativeExtensions = relativeExtensions;
    this.pathMappings = pathMappings ? this.processPathMappings(pathMappings) : [];
  }
  resolveModuleImport(moduleName, fromPath) {
    if (isRelativePath(moduleName)) {
      return this.resolveAsRelativePath(moduleName, fromPath);
    } else {
      return this.pathMappings.length && this.resolveByPathMappings(moduleName, fromPath) || this.resolveAsEntryPoint(moduleName, fromPath);
    }
  }
  processPathMappings(pathMappings) {
    const baseUrl = this.fs.resolve(pathMappings.baseUrl);
    return Object.keys(pathMappings.paths).map((pathPattern) => {
      const matcher = splitOnStar(pathPattern);
      const templates = pathMappings.paths[pathPattern].map(splitOnStar);
      return { matcher, templates, baseUrl };
    });
  }
  resolveAsRelativePath(moduleName, fromPath) {
    const resolvedPath = resolveFileWithPostfixes(this.fs, this.fs.resolve(this.fs.dirname(fromPath), moduleName), this.relativeExtensions);
    return resolvedPath && new ResolvedRelativeModule(resolvedPath);
  }
  resolveByPathMappings(moduleName, fromPath) {
    const mappedPaths = this.findMappedPaths(moduleName);
    if (mappedPaths.length > 0) {
      const packagePath = this.findPackagePath(fromPath);
      if (packagePath !== null) {
        for (const mappedPath of mappedPaths) {
          if (this.isEntryPoint(mappedPath)) {
            return new ResolvedExternalModule(mappedPath);
          }
          const nonEntryPointImport = this.resolveAsRelativePath(mappedPath, fromPath);
          if (nonEntryPointImport !== null) {
            return isRelativeImport(packagePath, mappedPath) ? nonEntryPointImport : new ResolvedDeepImport(mappedPath);
          }
        }
      }
    }
    return null;
  }
  resolveAsEntryPoint(moduleName, fromPath) {
    let folder = fromPath;
    while (!this.fs.isRoot(folder)) {
      folder = this.fs.dirname(folder);
      if (folder.endsWith("node_modules")) {
        folder = this.fs.dirname(folder);
      }
      const modulePath = this.fs.resolve(folder, "node_modules", moduleName);
      if (this.isEntryPoint(modulePath)) {
        return new ResolvedExternalModule(modulePath);
      } else if (this.resolveAsRelativePath(modulePath, fromPath)) {
        return new ResolvedDeepImport(modulePath);
      }
    }
    return null;
  }
  isEntryPoint(modulePath) {
    if (this.fs.exists(this.fs.join(modulePath, "package.json"))) {
      return true;
    }
    const packagePath = this.findPackagePath(modulePath);
    if (packagePath === null) {
      return false;
    }
    const packagePackageJson = loadJson(this.fs, this.fs.join(packagePath, "package.json"));
    const entryPointInfoForApfV14 = loadSecondaryEntryPointInfoForApfV14(this.fs, packagePackageJson, packagePath, modulePath);
    return entryPointInfoForApfV14 !== null;
  }
  findMappedPaths(moduleName) {
    const matches = this.pathMappings.map((mapping) => this.matchMapping(moduleName, mapping));
    let bestMapping;
    let bestMatch;
    for (let index = 0; index < this.pathMappings.length; index++) {
      const mapping = this.pathMappings[index];
      const match = matches[index];
      if (match !== null) {
        if (!mapping.matcher.hasWildcard) {
          bestMatch = match;
          bestMapping = mapping;
          break;
        }
        if (!bestMapping || mapping.matcher.prefix > bestMapping.matcher.prefix) {
          bestMatch = match;
          bestMapping = mapping;
        }
      }
    }
    return bestMapping !== void 0 && bestMatch !== void 0 ? this.computeMappedTemplates(bestMapping, bestMatch) : [];
  }
  matchMapping(path, mapping) {
    const { prefix, postfix, hasWildcard } = mapping.matcher;
    if (hasWildcard) {
      return path.startsWith(prefix) && path.endsWith(postfix) ? path.substring(prefix.length, path.length - postfix.length) : null;
    } else {
      return path === prefix ? "" : null;
    }
  }
  computeMappedTemplates(mapping, match) {
    return mapping.templates.map((template) => this.fs.resolve(mapping.baseUrl, template.prefix + match + template.postfix));
  }
  findPackagePath(path) {
    let folder = path;
    while (!this.fs.isRoot(folder)) {
      folder = this.fs.dirname(folder);
      if (this.fs.exists(this.fs.join(folder, "package.json"))) {
        return folder;
      }
    }
    return null;
  }
};
var ResolvedExternalModule = class {
  constructor(entryPointPath) {
    this.entryPointPath = entryPointPath;
  }
};
var ResolvedRelativeModule = class {
  constructor(modulePath) {
    this.modulePath = modulePath;
  }
};
var ResolvedDeepImport = class {
  constructor(importPath) {
    this.importPath = importPath;
  }
};
function splitOnStar(str) {
  const [prefix, postfix] = str.split("*", 2);
  return { prefix, postfix: postfix || "", hasWildcard: postfix !== void 0 };
}
function isRelativeImport(from, to) {
  return to.startsWith(from) && !to.includes("node_modules");
}

// bazel-out/k8-fastbuild/bin/packages/compiler-cli/ngcc/src/dependencies/dependency_host.mjs
function createDependencyInfo() {
  return { dependencies: /* @__PURE__ */ new Set(), missing: /* @__PURE__ */ new Set(), deepImports: /* @__PURE__ */ new Set() };
}
var DependencyHostBase = class {
  constructor(fs, moduleResolver) {
    this.fs = fs;
    this.moduleResolver = moduleResolver;
  }
  collectDependencies(entryPointPath, { dependencies, missing, deepImports }) {
    const resolvedFile = resolveFileWithPostfixes(this.fs, entryPointPath, this.moduleResolver.relativeExtensions);
    if (resolvedFile !== null) {
      const alreadySeen = /* @__PURE__ */ new Set();
      this.recursively