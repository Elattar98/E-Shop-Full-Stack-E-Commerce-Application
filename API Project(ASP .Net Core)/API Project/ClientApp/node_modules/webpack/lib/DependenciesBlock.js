ag): void {\n    if (tag.name === _PLACEHOLDER_TAG) {\n      if (!tag.children || tag.children.length == 0) {\n        const exText = new xml.Text(tag.attrs['name'] || '...');\n        tag.children = [new xml.Tag(_EXAMPLE_TAG, {}, [exText])];\n      }\n    } else if (tag.children) {\n      tag.children.forEach(node => node.visit(this));\n    }\n  }\n\n  visitText(text: xml.Text): void {}\n  visitDeclaration(decl: xml.Declaration): void {}\n  visitDoctype(doctype: xml.Doctype): void {}\n}\n\n// XMB/XTB placeholders can only contain A-Z, 0-9 and _\nexport function toPublicName(internalName: string): string {\n  return internalName.toUpperCase().replace(/[^A-Z0-9_]/g, '_');\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as i18n from '../../../i18n/i18n_ast';\nimport {toPublicName} from '../../../i18n/serializers/xmb';\nimport * as html from '../../../ml_parser/ast';\nimport * as o from '../../../output/output_ast';\nimport * as t from '../../r3_ast';\n\n/* Closure variables holding messages must be named `MSG_[A-Z0-9]+` */\nconst CLOSURE_TRANSLATION_VAR_PREFIX = 'MSG_';\n\n/**\n * Prefix for non-`goog.getMsg` i18n-related vars.\n * Note: the prefix uses lowercase characters intentionally due to a Closure behavior that\n * considers variables like `I18N_0` as constants and throws an error when their value changes.\n */\nexport const TRANSLATION_VAR_PREFIX = 'i18n_';\n\n/** Name of the i18n attributes **/\nexport const I18N_ATTR = 'i18n';\nexport const I18N_ATTR_PREFIX = 'i18n-';\n\n/** Prefix of var expressions used in ICUs */\nexport const I18N_ICU_VAR_PREFIX = 'VAR_';\n\n/** Prefix of ICU expressions for post processing */\nexport const I18N_ICU_MAPPING_PREFIX = 'I18N_EXP_';\n\n/** Placeholder wrapper for i18n expressions **/\nexport const I18N_PLACEHOLDER_SYMBOL = 'ï¿½';\n\nexport function isI18nAttribute(name: string): boolean {\n  return name === I18N_ATTR || name.startsWith(I18N_ATTR_PREFIX);\n}\n\nexport function isI18nRootNode(meta?: i18n.I18nMeta): meta is i18n.Message {\n  return meta instanceof i18n.Message;\n}\n\nexport function isSingleI18nIcu(meta?: i18n.I18nMeta): boolean {\n  return isI18nRootNode(meta) && meta.nodes.length === 1 && meta.nodes[0] instanceof i18n.Icu;\n}\n\nexport function hasI18nMeta(node: t.Node&{i18n?: i18n.I18nMeta}): boolean {\n  return !!node.i18n;\n}\n\nexport function hasI18nAttrs(element: html.Element): boolean {\n  return element.a