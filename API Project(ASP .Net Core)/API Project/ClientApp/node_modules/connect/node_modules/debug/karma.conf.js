am tNode\n * @param lView\n */\nexport function toDebugNodes(tNode: ITNode|null, lView: LView): DebugNode[] {\n  if (tNode) {\n    const debugNodes: DebugNode[] = [];\n    let tNodeCursor: ITNode|null = tNode;\n    while (tNodeCursor) {\n      debugNodes.push(buildDebugNode(tNodeCursor, lView));\n      tNodeCursor = tNodeCursor.next;\n    }\n    return debugNodes;\n  } else {\n    return [];\n  }\n}\n\nexport function buildDebugNode(tNode: ITNode, lView: LView): DebugNode {\n  const rawValue = lView[tNode.index];\n  const native = unwrapRNode(rawValue);\n  const factories: Type<any>[] = [];\n  const instances: any[] = [];\n  const tView = lView[TVIEW];\n  for (let i = tNode.directiveStart; i < tNode.directiveEnd; i++) {\n    const def = tView.data[i] as DirectiveDef<any>;\n    factories.push(def.type);\n    instances.push(lView[i]);\n  }\n  return {\n    html: toHtml(native),\n    type: toTNodeTypeAsString(tNode.type),\n    tNode,\n    native: native as any,\n    children: toDebugNodes(tNode.child, lView),\n    factories,\n    instances,\n    injector: buildNodeInjectorDebug(tNode, tView, lView),\n    get injectorResolutionPath() {\n      return (tNode as TNode).debugNodeInjectorPath(lView);\n    },\n  };\n}\n\nfunction buildNodeInjectorDebug(tNode: ITNode, tView: ITView, lView: LView): NodeInjectorDebug {\n  const viewProviders: Type<any>[] = [];\n  for (let i = (tNode as TNode).providerIndexStart_; i < (tNode as TNode).providerIndexEnd_; i++) {\n    viewProviders.push(tView.data[i] as Type<any>);\n  }\n  const providers: Type<any>[] = [];\n  for (let i = (tNode as TNode).providerIndexEnd_; i < (tNode as TNode).directiveEnd; i++) {\n    providers.push(tView.data[i] as Type<any>);\n  }\n  const nodeInjector