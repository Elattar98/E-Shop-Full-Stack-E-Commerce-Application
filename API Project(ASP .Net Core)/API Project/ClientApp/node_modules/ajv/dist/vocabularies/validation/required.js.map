 more details.\n *\n * @codeGenApi\n */\nexport function ɵɵsetComponentScope(\n    type: ComponentType<any>, directives: Type<any>[]|(() => Type<any>[]),\n    pipes: Type<any>[]|(() => Type<any>[])): void {\n  const def = (type.ɵcmp as ComponentDef<any>);\n  def.directiveDefs = () =>\n      (typeof directives === 'function' ? directives() : directives).map(extractDirectiveDef) as\n      DirectiveDefList;\n  def.pipeDefs = () =>\n      (typeof pipes === 'function' ? pipes() : pipes).map(getPipeDef) as PipeDefList;\n}\n\nexport function extractDirectiveDef(type: Type<any>): DirectiveDef<any>|ComponentDef<any>|null {\n  return getComponentDef(type) || getDirectiveDef(type);\n}\n\nfunction nonNull<T>(value: T|null): value is T {\n  return value !== null;\n}\n\nexport const autoRegisterModuleById: {[id: string]: NgModuleType} = {};\n\n/**\n * @codeGenApi\n */\nexport function ɵɵdefineNgModule<T>(def: {\n  /** Token representing the module. Used by DI. */\n  type: T;\n\n  /** List of components to bootstrap. */\n  bootstrap?: Type<any>[] | (() => Type<any>[]);\n\n  /** List of components, directives, and pipes declared by this module. */\n  declarations?: Type<any>[] | (() => Type<any>[]);\n\n  /** List of modules or `ModuleWithProviders` imported by this module. */\n  imports?: Type<any>[] | (() => Type<any>[]);\n\n  /**\n   * List of modules, `ModuleWithProviders`, components, directives, or pipes exported by this\n   * module.\n   */\n  exports?: Type<any>[] | (() => Type<any>[]);\n\n  /** The set of schemas that declare elements to be allowed in the NgModule. */\n  schemas?: SchemaMetadata[] | null;\n\n  /** Unique ID for the module that is used with `getModuleFactory`. */\n  id?: string | null;\n}): unknown {\n  return noSideEffects(() => {\n    const res: NgModuleDef<T> = {\n      type: def.type,\n      bootstrap: def.bootstrap || EMPTY_ARRAY,\n      declarations: def.declarations || EMPTY_ARRAY,\n      imports: def.imports || EMPTY_ARRAY,\n      exports: def.exports || EMPTY_ARRAY,\n      transitiveCompileScopes: null,\n      schemas: def.schemas || null,\n      id: def.id || null,\n    };\n    if (def.id != null) {\n      autoRegisterModuleById[def.id!] = def.type as unknown as NgModuleType;\n    }\n    return res;\n  });\n}\n\n/**\n * Adds the module metadata that is necessary to compute the module's transitive scope to an\n * existing module definition.\n *\n * Scope metadata of modules is not used in production builds, so calls to this function can be\n * marked pure to tree-shake it from the bundle, allowing for all referenced declarations\n * to become eligible for tree-shaking as well.\n *\n * @codeGenApi\n */\nexport function ɵɵsetNgModuleScope(type: any, scope: {\n  /** List of components, directives, and pipes declared by this module. */\n  declarations?: Type<any>[]|(() => Type<any>[]);\n\n  /** List of modules or `ModuleWithProviders` importe