apTestInZone(args[0]);
            return originalJestFn.apply(this, args);
        };
    });
    Zone.patchJestObject = function patchJestObject(Timer, isModern = false) {
        // check whether currently the test is inside fakeAsync()
        function isPatchingFakeTimer() {
            const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');
            return !!fakeAsyncZoneSpec;
        }
        // check whether the current function is inside `test/it` or other methods
        // such as `describe/beforeEach`
        function isInTestFunc() {
            const proxyZoneSpec = Zone.current.get('ProxyZoneSpec');
            return proxyZoneSpec && proxyZoneSpec.isTestFunc;
        }
        if (Timer[api.symbol('fakeTimers')]) {
            return;
        }
        Timer[api.symbol('fakeTimers')] = true;
        // patch jest fakeTimer internal method to make sure no console.warn print out
        api.patchMethod(Timer, '_checkFakeTimers', delegate => {
            return function (self, args) {
                if (isPatchingFakeTimer()) {
                    return true;
                }
                else {
                    return delegate.apply(self, args);
                }
            };
        });
        // patch useFakeTimers(), set useFakeTimersCalled flag, and make test auto run into fakeAsync
        api.patchMethod(Timer, 'useFakeTimers', delegate => {
            return function (self, args) {
                Zone[api.symbol('useFakeTimersCalled')] = true;
                if (isModern || isInTestFunc()) {
                    return delegate.apply(self, args);
                }
                return self;
            };
        });
        // patch useRealTimers(), unset useFakeTimers flag
        api.patchMethod(Timer, 'useRealTimers', delegate => {
            return function (self, args) {
                Zone[api.symbol('useFakeTimersCalled')] = false;
                if (isModern || isInTestFunc()) {
                    return delegate.apply(self, args);
                }
                return self;
            };
        });
        // patch setSystemTime(), call setCurrentRealTime() in the fakeAsyncTest
        api.patchMethod(Timer, 'setSystemTime', delegate => {
            return function (self, args) {
                const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');
                if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {
                    fakeAsyncZoneSpec.setFakeBaseSystemTime(args[0]);
                }
                else {
                    return delegate.apply(self, args);
                }
            };
        });
        // patch getSystemTime(), call getCurrentRealTime() in the fakeAsyncTest
        api.patchMethod(Timer, 'getRealSystemTime', delegate => {
            return function (self, args) {
                const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');
                if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {
                    return fakeAsyncZoneSpec.getRealSystemTime();
                }
                else {
                    return delegate.apply(self, args);
                }
            };
        });
        // patch runAllTicks(), run all microTasks inside fakeAsync
        api.patchMethod(Timer, 'runAllTicks', delegate => {
            return function (self, args) {
                const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');
                if (fakeAsyncZoneSpec) {
                    fakeAsyncZoneSpec.flushMicrotasks();
                }
                else {
                    return delegate.apply(self, args);
                }
            };
        });
        // patch runAllTimers(), run all macroTasks inside fakeAsync
        api.patchMethod(Timer, 'runAllTimers', delegate => {
            return function (self, args) {
                const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');
                if (fakeAsyncZoneSpec) {
                    fakeAsyncZoneSpec.flush(100, true);
                }
                else {
                    return delegate.apply(self, args);
                }
            };
        });
        // patch advanceTimersByTime(), call tick() in the fakeAsyncTest
        api.patchMethod(Timer, 'advanceTimersByTime', delegate => {
            return function (self, args) {
                const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');
                if (fakeAsyncZoneSpec) {
                    fakeAsyncZoneSpec.tick(args[0]);
                }
                else {
                    return delegate.apply(self, args);
                }
            };
        });
        // patch runOnlyPendingTimers(), call flushOnlyPendingTimers() in the fakeAsyncTest
        api.patchMethod(Timer, 'runOnlyPendingTimers', delegate => {
            return function (self, args) {
                const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');
                if (fakeAsyncZoneSpec) {
                    fakeAsyncZoneSpec.flushOnlyPendingTimers();
                }
                else {
                    return delegate.apply(self, args);
                }
            };
        });
        // patch advanceTimersToNextTimer(), call tickToNext() in the fakeAsyncTest
        api.patchMethod(Timer, 'advanceTimersToNextTimer', delegate => {
            return function (self, args) {
                const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');
                if (fakeAsyncZoneSpec) {
                    fakeAsyncZoneSpec.tickToNext(args[0]);
                }
                else {
                    return delegate.apply(self, args);
                }
            };
        });
        // patch clearAllTimers(), call removeAllTimers() in the fakeAsyncTest
        api.patchMethod(Timer, 'clearAllTimers', delegate => {
            return function (self, args) {
                const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');
                if (fakeAsyncZoneSpec) {
                    fakeAsyncZoneSpec.removeAllTimers();
                }
                else {
                    return delegate.apply(self, args);
                }
            };
        });
        // patch getTimerCount(), call getTimerCount() in the fakeAsyncTest
        api.patchMethod(Timer, 'getTimerCount', delegate => {
            return function (self, args) {
                const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');
                if (fakeAsyncZoneSpec) {
                    return fakeAsyncZoneSpec.getTimerCount();
                }
                else {
                    return delegate.apply(self, args);
                }
            };
        });
    };
});

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
Zone.__load_patch('mocha', (global, Zone) => {
    const Mocha = global.Mocha;
    if (typeof Mocha === 'undefined') {
        // return if Mocha is not available, because now zone-testing
        // will load mocha patch with jasmine/jest patch
        return;
    }
    if (typeof Zone === 'undefined') {
        throw new Error('Missing Zone.js');
    }
    const ProxyZoneSpec = Zone['ProxyZoneSpec'];
    const SyncTestZoneSpec = Zone['SyncTestZoneSpec'];
