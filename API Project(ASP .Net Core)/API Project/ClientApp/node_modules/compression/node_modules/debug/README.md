ddForwardConfiguration$body$_EvaluateVisitor(configuration, node);
    },
    _addForwardConfiguration$body$_EvaluateVisitor(configuration, node) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.Configuration),
        $async$returnValue, $async$self = this, t2, t3, _i, variable, t4, t5, variableNodeWithSpan, t1, newValues, $async$temp1, $async$temp2, $async$temp3;
      var $async$_async_evaluate$_addForwardConfiguration$2 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = configuration._values;
              newValues = A.LinkedHashMap_LinkedHashMap$of(new A.UnmodifiableMapView(t1, type$.UnmodifiableMapView_String_ConfiguredValue), type$.String, type$.ConfiguredValue);
              t2 = node.configuration, t3 = t2.length, _i = 0;
            case 3:
              // for condition
              if (!(_i < t3)) {
                // goto after for
                $async$goto = 5;
                break;
              }
              variable = t2[_i];
              if (variable.isGuarded) {
                t4 = variable.name;
                t5 = t1.get$isEmpty(t1) ? null : t1.remove$1(0, t4);
                if (t5 != null && !t5.value.$eq(0, B.C__SassNull)) {
                  newValues.$indexSet(0, t4, t5);
                  // goto for update
                  $async$goto = 4;
                  break;
                }
              }
              t4 = variable.expression;
              variableNodeWithSpan = $async$self._async_evaluate$_expressionNode$1(t4);
              $async$temp1 = newValues;
              $async$temp2 = variable.name;
              $async$temp3 = A;
              $async$goto = 6;
              return A._asyncAwait(t4.accept$1($async$self), $async$_async_evaluate$_addForwardConfiguration$2);
            case 6:
              // returning from await.
              $async$temp1.$indexSet(0, $async$temp2, new $async$temp3.ConfiguredValue($async$self._async_evaluate$_withoutSlash$2($async$result, variableNodeWithSpan), variable.span, variableNodeWithSpan));
            case 4:
              // for update
              ++_i;
              // goto for condition
              $async$goto = 3;
              break;
            case 5:
              // after for
              if (configuration instanceof A.ExplicitConfiguration || t1.get$isEmpty(t1)) {
                $async$returnValue = new A.ExplicitConfiguration(node, newValues);
                // goto return
                $async$goto = 1;
                break;
              } else {
                $async$returnValue = new A.Configuration(newValues);
                // goto return
                $async$goto = 1;
                break;
              }
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$_async_evaluate$_addForwardConfiguration$2, $async$completer);
    },
    _async_evaluate$_removeUsedConfiguration$3$except(upstream, downstream, except) {
      var t1, t2, t3, t4, _i, $name;
      for (t1 = upstream._values, t2 = J.toList$0$ax(t1.get$keys(t1)), t3 = t2.length, t4 = downstream._values, _i = 0; _i < t2.length; t2.length === t3 || (0, A.throwConcurrentModificationError)(t2), ++_i) {
        $name = t2[_i];
        if (except.contains$1(0, $name))
          continue;
        if (!t4.containsKey$1($name))
          if (!t1.get$isEmpty(t1))
            t1.remove$1(0, $name);
      }
    },
    _async_evaluate$_assertConfigurationIsEmpty$2$nameInError(configuration, nameInError) {
      var t1, entry;
      if (!(configuration instanceof A.ExplicitConfiguration))
        return;
      t1 = configuration._values;
      if (t1.get$isEmpty(t1))
        return;
      t1 = t1.get$entries(t1);
      entry = t1.get$first(t1);
      t1 = nameInError ? "$" + A.S(entry.key) + string$.x20was_n : string$.This_v;
      throw A.wrapException(this._async_evaluate$_exception$2(t1, entry.value.configurationSpan));
    },
    _async_evaluate$_assertConfigurationIsEmpty$1(configuration) {
      return this._async_evaluate$_assertConfigurationIsEmpty$2$nameInError(configuration, false);
    },
    visitFunctionRule$1(node) {
      return this.visitFunctionRule$body$_EvaluateVisitor(node);
    },
    visitFunctionRule$body$_EvaluateVisitor(node) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.nullable_Value),
        $async$returnValue, $async$self = this, t1, t2, t3, t4, index, t5;
      var $async$visitFunctionRule$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self._async_evaluate$_environment;
              t2 = t1.closure$0();
              t3 = $async$self._async_evaluate$_inDependency;
              t4 = t1._async_environment$_functions;
              index = t4.length - 1;
              t5 = node.name;
              t1._async_environment$_functionIndices.$indexSet(0, t5, index);
              J.$indexSet$ax(t4[index], t5, new A.UserDefinedCallable(node, t2, t3, type$.UserDefinedCallable_AsyncEnvironment));
              $async$returnValue = null;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$visitFunctionRule$1, $async$completer);
    },
    visitIfRule$1(node) {
      return this.visitIfRule$body$_EvaluateVisitor(node);
    },
    visitIfRule$body$_EvaluateVisitor(node) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.nullable_Value),
        $async$returnValue, $async$self = this, t1, t2, _i, clauseToCheck, _box_0;
      var $async$visitIfRule$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              _box_0 = {};
              _box_0.clause = node.lastClause;
              t1 = node.clauses, t2 = t1.length, _i = 0;
            case 3:
              // for condition
              if (!(_i < t2)) {
                // goto after for
                $async$goto = 5;
                break;
              }
              clauseToCheck = t1[_i];
              $async$goto = 6;
              return A._asyncAwait(clauseToCheck.expression.accept$1($async$self), $async$visitIfRule$1);
            case 6:
              // returning from await.
              if ($async$result.get$isTruthy()) {
                _box_0.clause = clauseToCheck;
                // goto after for
                $async$goto = 5;
                break;
              }
            case 4:
              // for update
              ++_i;
              // goto for condition
              $async$goto = 3;
              break;
            case 5:
              // after for
              t1 = _box_0.clause;
              if (t1 == null) {
                $async$returnValue = null;
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = 7;
              return A._asyncAwait($async$self._async_evaluate$_environment.scope$1$3$semiGlobal$when(new A._EvaluateVisitor_visitIfRule_closure0(_box_0, $async$self), true, t1.hasDeclarations, type$.nullable_Value), $async$visitIfRule$1);
            case 7:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$visitIfRule$1, $async$completer);
    },
    visitImportRule$1(node) {
      return this.visitImportRule$body$_EvaluateVisitor(node);
    },
    visitImportRule$body$_EvaluateVisitor(node) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.nullable_Value),
        $async$returnValue, $async$self = this, t1, t2, t3, _i, $import;
      var $async$visitImportRule$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = node.imports, t2 = t1.length, t3 = type$.StaticImport, _i = 0;
            case 3:
              // for condition
              if (!(_i < t2)) {
                // goto after for
                $async$goto = 5;
                break;
              }
              $import = t1[_i];
              $async$goto = $import instanceof A.DynamicImport ? 6 : 8;
              break;
            case 6:
              // then
              $async$goto = 9;
              return A._asyncAwait($async$self._async_evaluate$_visitDynamicImport$1($import), $async$visitImportRule$1);
            case 9:
              // returning from await.
              // goto join
              $async$goto = 7;
              break;
            case 8:
              // else
              $async$goto = 10;
              return A._asyncAwait($async$self._visitStaticImport$1(t3._as($import)), $async$visitImportRule$1);
            case 10:
              // returning from await.
            case 7:
              // join
            case 4:
              // for update
              ++_i;
              // goto for condition
              $async$goto = 3;
              break;
            case 5:
              // after for
              $async$returnValue = null;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$visitImportRule$1, $async$completer);
    },
    _async_evaluate$_visitDynamicImport$1($import) {
      return this._async_evaluate$_withStackFrame$1$3("@import", $import, new A._EvaluateVisitor__visitDynamicImport_closure0(this, $import), type$.void);
    },
    _async_evaluate$_loadStylesheet$4$baseUrl$forImport(url, span, baseUrl, forImport) {
      return this._loadStylesheet$body$_EvaluateVisitor(url, span, baseUrl, forImport);
    },
    _async_evaluate$_loadStylesheet$3$baseUrl(url, span, baseUrl) {
      return this._async_evaluate$_loadStylesheet$4$baseUrl$forImport(url, span, baseUrl, false);
    },
    _async_evaluate$_loadStylesheet$3$forImport(url, span, forImport) {
      return this._async_evaluate$_loadStylesheet$4$baseUrl$forImport(url, span, null, forImport);
    },
    _loadStylesheet$body$_EvaluateVisitor(url, span, baseUrl, forImport) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$._LoadedStylesheet),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, importCache, tuple, isDependency, stylesheet, result, error, stackTrace, error0, stackTrace0, message, t1, t2, t3, t4, exception, message0, $async$exception;
      var $async$_async_evaluate$_loadStylesheet$4$baseUrl$forImport = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              baseUrl = baseUrl;
              $async$handler = 4;
              $async$self._async_evaluate$_importSpan = span;
              importCache = $async$self._async_evaluate$_importCache;
              $async$goto = importCache != null ? 7 : 9;
              break;
            case 7:
              // then
              if (baseUrl == null)
                baseUrl = $async$self._async_evaluate$_assertInModule$2($async$self._async_evaluate$__stylesheet, "_stylesheet").span.file.url;
              $async$goto = 10;
              return A._asyncAwait(J.canonicalize$4$baseImporter$baseUrl$forImport$x(importCache, A.Uri_parse(url), $async$self._async_evaluate$_importer, baseUrl, forImport), $async$_async_evaluate$_loadStylesheet$4$baseUrl$forImport);
            case 10:
              // returning from await.
              tuple = $async$result;
              $async$goto = tuple != null ? 11 : 12;
              break;
            case 11:
              // then
              isDependency = $async$self._async_evaluate$_inDependency || tuple.item1 !== $async$self._async_evaluate$_importer;
              t1 = tuple.item1;
              t2 = tuple.item2;
              t3 = tuple.item3;
              t4 = $async$self._async_evaluate$_quietDeps && isDependency;
              $async$goto = 13;
              return A._asyncAwait(importCache.importCanonical$4$originalUrl$quiet(t1, t2, t3, t4), $async$_async_evaluate$_loadStylesheet$4$baseUrl$forImport);
            case 13:
              // returning from await.
              stylesheet = $async$result;
              if (stylesheet != null) {
                $async$self._async_evaluate$_loadedUrls.add$1(0, tuple.item2);
                t1 = tuple.item1;
                $async$returnValue = new A._LoadedStylesheet0(stylesheet, t1, isDependency);
                $async$next = [1];
                // goto finally
                $async$goto = 5;
                break;
              }
            case 12:
              // join
              // goto join
              $async$goto = 8;
              break;
            case 9:
              // else
              t1 = baseUrl;
              $async$goto = 14;
              return A._asyncAwait($async$self._async_evaluate$_importLikeNode$3(url, t1 == null ? $async$self._async_evaluate$_assertInModule$2($async$self._async_evaluate$__stylesheet, "_stylesheet").span.file.url : t1, forImport), $async$_async_evaluate$_loadStylesheet$4$baseUrl$forImport);
            case 14:
              // returning from await.
              result = $async$result;
              if (result != null) {
                t1 = $async$self._async_evaluate$_loadedUrls;
                A.NullableExtension_andThen(result.stylesheet.span.file.url, t1.get$add(t1));
                $async$returnValue = result;
                $async$next = [1];
                // goto finally
                $async$goto = 5;
                break;
              }
            case 8:
              // join
              if (B.JSString_methods.startsWith$1(url, "package:") && true)
                throw A.wrapException(string$.x22packa);
              else
                throw A.wrapException("Can't find stylesheet to import.");
              $async$next.push(6);
              // goto finally
              $async$goto = 5;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$currentError;
              t1 = A.unwrapException($async$exception);
              if (t1 instanceof A.SassException) {
                error = t1;
                stackTrace = A.getTraceFromException($async$exception);
                t1 = error;                                                                                                                                                                                                                                                                                                                                                                                                                                                                               import { Observable } from '../Observable';
import { argsArgArrayOrObject } from '../util/argsArgArrayOrObject';
import { from } from './from';
import { identity } from '../util/identity';
import { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';
import { popResultSelector, popScheduler } from '../util/args';
import { createObject } from '../util/createObject';
import { createOperatorSubscriber } from '../operators/OperatorSubscriber';
import { executeSchedule } from '../util/executeSchedule';
export function combineLatest(...args) {
    const scheduler = popScheduler(args);
    const resultSelector = popResultSelector(args);
    const { args: observables, keys } = argsArgArrayOrObject(args);
    if (observables.length === 0) {
        return from([], scheduler);
    }
    const result = new Observable(combineLatestInit(observables, scheduler, keys
        ?
            (values) => createObject(keys, values)
        :
            identity));
    return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}
export function combineLatestInit(observables, scheduler, valueTransform = identity) {
    return (subscriber) => {
        maybeSchedule(scheduler, () => {
            const { length } = observables;
            const values = new Array(length);
            let active = length;
            let remainingFirstValues = length;
            for (let i = 0; i < length; i++) {
                maybeSchedule(scheduler, () => {
                    const source = from(observables[i], scheduler)