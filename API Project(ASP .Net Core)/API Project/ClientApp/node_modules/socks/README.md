 *         `useCaptureOrIndx <  0` `subscription = LView[CLEANUP][-useCaptureOrIndx]`\n   *\n   * If it's an output subscription or query list destroy hook:\n   * 1st index is: output unsubscribe function / query list destroy function\n   * 2nd index is: index of function context in LView.cleanupInstances[]\n   *               `tView.cleanup[i+0].call(lView[CLEANUP][tView.cleanup[i+1]])`\n   */\n  cleanup: any[]|null;\n\n  /**\n   * A list of element indices for child components that will need to be\n   * refreshed when the current view has finished its check. These indices have\n   * already been adjusted for the HEADER_OFFSET.\n   *\n   */\n  components: number[]|null;\n\n  /**\n   * A collection of queries tracked in a given view.\n   */\n  queries: TQueries|null;\n\n  /**\n   * An array of indices pointing to directives with content queries alongside with the\n   * corresponding query index. Each entry in this array is a tuple of:\n   * - index of the first content query index declared by a given directive;\n   * - index of a directive.\n   *\n   * We are storing those indexes so we can refresh content queries as part of a view refresh\n   * process.\n   */\n  contentQueries: number[]|null;\n\n  /**\n   * Set of schemas that declare elements to be allowed inside the view.\n   */\n  schemas: SchemaMetadata[]|null;\n\n  /**\n   * Array of constants for the view. Includes attribute arrays, local definition arrays etc.\n   * Used for directive matching, attribute bindings, local definitions and more.\n   */\n  consts: TConstants|null;\n\n  /**\n   * Indicates that there was an error before we managed to complete the first create pass of the\n   * view. This means that the view is likely corrupted and we should try to recover it.\n   */\n  incompleteFirstPass: boolean;\n}\n\nexport const enum RootContextFlags {\n  Empty = 0b00,\n  DetectChanges = 0b01,\n  FlushPlayers = 0b10\n}\n\n\n/**\n * RootContext contains information which is shared for all components which\n * were bootstrapped with {@link renderComponent}.\n */\nexport interface RootContext<T = unknown> {\n  /**\n   * A function used for scheduling change detection in the future. Usually\n   * this is `requestAnimationFrame`.\n   */\n  scheduler: (workFn: () => void) => void;\n\n  /**\n   * A promise which is resolved when all components are considered clean (not dirty).\n   *\n   * This promise is overwritten every time a first call to {@link markDirty} is invoked.\n   */\n  clean: Promise<null>;\n\n  /**\n   * RootComponents - The components that were instantiated by the call to\n   * {@link renderComponent}.\n   */\n  components: T[];\n\n  /**\n   * The player flushing handler to kick off all animations\n   */\n  playerHandler: PlayerHandler|null;\n\n  /**\n   * What render-related operations to run once a scheduler has been set\n   */\n  flags: RootContextFlags;\n}\n\n/** Single hook callback function. */\nexport type HookFn = () => void;\n\n/**\n * Information necessary to call a hook. E.g. the callback that\n * needs to invoked and the index at which to find its context.\n */\nexport type HookEntry = number|HookFn;\n\n/**\n * Array of hooks that should be executed for a view and their directive indices.\n *\n * For each node of the view, the following data is stored:\n * 1) Node index (optional)\n * 2) A series of number/function pairs where:\n *  - even indices are directive indices\n *  - odd indices are hook functions\n *\n * Special cases:\n *  - a negative directive index flags an init hook (ngOnInit, ngAfterContentInit, ngAfterViewInit)\n */\nexport type HookData = HookEntry[];\n\n/**\n * Array of destroy hooks that should be executed for a view and their directive indices.\n *\n * The array is set up as a series of number/function or number/(number|function)[]:\n * - Even indices represent the context with which hooks should be called.\n * - Odd indices are the hook functions themselves. If a value at an odd index is an array,\n *   it represents the destroy hooks of a `multi` provider where:\n *     - Even indices represent the index of the provider for which we've registered a destroy hook,\n *       inside of the `multi` provider array.\n *     - Odd indices are the destroy hook functions.\n * For example:\n * LView: `[0, 1, 2, AService, 4, [BService, CService, DService]]`\n * destroyHooks: `[3, AService.ngOnDestroy, 5, [0, BService.ngOnDestroy, 2, DService.ngOnDestroy]]`\n *\n * In the example above `AService` is a type provider with an `ngOnDestroy`, whereas `BService`,\n * `CService` and `DService` are part of a `multi` provider where only `BService` and `DService`\n * have an `ngOnDestroy` hook.\n */\nexport type DestroyHookData = (HookEntry|HookData)[];\n\n/**\n * Static data that corresponds to the instance-specific data array on an LView.\n *\n * Each node's static data is stored in tData at the same index that it's stored\n * in the data array.  Any nodes that do not have static data store a null value in\n * tData to avoid a sparse array.\n *\n * Each pipe's definition is stored here at the same index as its pipe instance in\n * the data array.\n *\n * Each host property's name is stored here at the same index as its value in the\n * data array.\n *\n * Each property binding name is stored here at the same index as its value in\n * the data array. If the binding is an interpolation, the static string values\n * are stored parallel to the dynamic values. Example:\n *\n * id=\"prefix {{ v0 }} a {{ v1 }} b {{ v2 }} suffix\"\n *\n * LView       |   TView.data\n *------------------------\n *  v0 value   |   'a'\n *  v1 value   |   'b'\n *  v2 value   |   id � prefix � suffix\n *\n * Injector bloom filters are also stored here.\n */\nexport type TData = (TNode|PipeDef<any>|DirectiveDef<any>|ComponentDef<any>|number|TStylingRange|\n                     TStylingKey|ProviderToken<any>|TI18n|I18nUpdateOpCodes|TIcu|null|string)[];\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n\n/**\n * Human readable version of the `LView`.\n *\n * `LView` is a data structure used internally to keep track of views. The `LView` is designed for\n * efficiency and so at times it is difficult to read or write tests which assert on its values. For\n * this reason when `ngDevMode` is true we patch a `LView.debug` property which points to\n * `LViewDebug` for easier debugging and test writing. It is the intent of `LViewDebug` to be used\n * in tests.\n */\nexport interface LViewDebug<T = unknown> {\n  /**\n   * Flags associated with the `LView` unpacked into a more readable state.\n   *\n   * See `LViewFlags` for the flag meanings.\n   */\n  readonly flags: {\n    initPhaseState: number,\n    creationMode: boolean,\n    firstViewPass: boolean,\n    checkAlways: boolean,\n    dirty: boolean,\n    attached: boolean,\n    destroyed: boolean,\n    isRoot: boolean,\n    indexWithinInitPhase: number,\n  };\n\n  /**\n   * Associated TView\n   */\n  readonly tView: TView;\n\n  /**\n   * Parent view (or container)\n   */\n  readonly parent: LViewDebug|LContainerDebug|null;\n\n  /**\n   * Next sibling to the `LView`.\n   */\n  readonly next: LViewDebug|LContainerDebug|null;\n\n  /**\n   * The context used for evaluation of the `LView`\n   *\n   * (Usually the component)\n   */\n  readonly context: T;\n\n  /**\n   * Hierarchical tree of nodes.\n   */\n  readonly nodes: DebugNode[];\n\n  /**\n   * Template structure (no instance data).\n   * (Shows how TNodes are connected)\n   */\n  readonly template: string;\n\n  /**\n   * HTML representation of the `LView`.\n   *\n   * This is only approximate to actual HTML as child `LView`s are removed.\n   */\n  readonly html: string;\n\n  /**\n   * The host element to which this `LView` is attached.\n   */\n  readonly hostHTML: string|null;\n\n  /**\n   * Child `LView`s\n   */\n  readonly childViews: Array<LViewDebug|LContainerDebug>;\n\n  /**\n   * Sub range of `LView` containing decls (DOM elements).\n   */\n  readonly decls: LViewDebugRange;\n\n  /**\n   * Sub range of `LView` containing vars (bindings).\n   */\n  readonly vars: LViewDebugRange;\n\n  /**\n   * Sub range of `LView` containing expando (used by DI).\n   */\n  readonly expando: LViewDebugRange;\n}\n\n/**\n * Human readable version of the `LContainer`\n *\n * `LContainer` is a data structure used internally to keep track of child views. The `LContainer`\n * is designed for efficiency and so at times it is difficult to read or write tests which assert on\n * its values. For this reason when `ngDevMode` is true we patch a `LContainer.debug` property which\n * points to `LContainerDebug` for easier debugging and test writing. It is the intent of\n * `LContainerDebug` to be used in tests.\n */\nexport interface LContainerDebug {\n  readonly native: RComment;\n  /**\n   * Child `LView`s.\n   */\n  readonly views: LViewDebug[];\n  readonly parent: LViewDebug|null;\n  readonly movedViews: LView[]|null;\n  readonly host: RElement|RComment|LView;\n  readonly next: LViewDebug|LContainerDebug|null;\n  readonly hasTransplantedViews: boolean;\n}\n\n\n\n/**\n * `LView` is subdivided to ranges where the actual data is stored. Some of these ranges such as\n * `decls` and `vars` are known at compile time. Other such as `i18n` and `expando` are runtime only\n * concepts.\n */\nexport interface LViewDebugRange {\n  /**\n   * The starting index in `LView` where the range begins. (Inclusive)\n   */\n  start: number;\n\n  /**\n   * The ending index in `LView` where the range ends. (Exclusive)\n   */\n  end: number;\n\n  /**\n   * The length of the range\n   */\n  length: number;\n\n  /**\n   * The merged content of the range. `t` contains data from `TView.data` and `l` contains `LView`\n   * data at an index.\n   */\n  content: LViewDebugRangeContent[];\n}\n\n/**\n * For convenience the static and instance portions of `TView` and `LView` are merged into a single\n * object in `LViewRange`.\n */\nexport interface LViewDebugRangeContent {\n  /**\n   * Index into original `LView` or `TView.data`.\n   */\n  index: number;\n\n  /**\n   * Value from the `TView.data[index]` location.\n   */\n  t: any;\n\n  /**\n   * Value from the `LView[index]` location.\n   */\n  l: any;\n}\n\n\n/**\n * A logical node which comprise into `LView`s.\n *\n */\nexport interface DebugNode {\n  /**\n   * HTML representation of the node.\n   */\n  html: string|null;\n\n  /**\n   * Associated `TNode`\n   */\n  tNode: TNode;\n\n  /**\n   * Human readable node type.\n   */\n  type: string;\n\n  /**\n   * DOM native node.\n   */\n  native: Node;\n\n  /**\n   * Child nodes\n   */\n  children: DebugNode[];\n\n  /**\n   * A list of Component/Directive types which need to be instantiated an this location.\n   */\n  factories: Type<unknown>[];\n\n  /**\n   * A list of Component/Directive instances which were instantiated an this location.\n   */\n  instances: unknown[];\n\n  /**\n   * NodeInjector information.\n   */\n  injector: NodeInjectorDebug;\n\n  /**\n   * Injector resolution path.\n   */\n  injectorResolutionPath: any;\n}\n\nexport interface NodeInjectorDebug {\n  /**\n   * Instance bloom. Does the current injector have a provider with a given bloom mask.\n   */\n  bloom: string;\n\n\n  /**\n   * Cumulative bloom. Do any of the above injectors have a provider with a given bloom mask.\n   */\n  cumulativeBloom: string;\n\n  /**\n   * A list of providers associated with this injector.\n   */\n  providers: (Type<unknown>|DirectiveDef<unknown>|ComponentDef<unknown>)[];\n\n  /**\n   * A list of providers associated with this injector visible to the view of the component only.\n   */\n  viewProviders: Type<unknown>[];\n\n\n  /**\n   * Location of the parent `TNode`.\n   */\n  parentInjectorIndex: number;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {TNode} from './node';\nimport {RComment, RElement} from './renderer_dom';\nimport {HOST, LView, NEXT, PARENT, T_HOST, TRANSPLANTED_VIEWS_TO_REFRESH} from './view';\n\n\n\n/**\n * Special location which allows easy identification of type. If we have an array which was\n * retrieved from the `LView` and that array has `true` at `TYPE` location, we know it is\n * `LContainer`.\n */\nexport const TYPE = 1;\n\n/**\n * Below are constants for LContainer indices to help us look up LContainer members\n * without having to remember the specific indices.\n * Uglify will inline these when minifying so there shouldn't be a cost.\n */\n\n/**\n * Flag to signify that this `LContainer` may have transplanted views which need to be change\n * detected. (see: `LView[DECLARATION_COMPONENT_VIEW])`.\n *\n * This flag, once set, is never unset for the `LContainer`. This means that when unset we can skip\n * a lot of work in `refreshEmbeddedViews`. But when set we still need to verify\n * that the `MOVED_VIEWS` are transplanted and on-push.\n */\nexport const HAS_TRANSPLANTED_VIEWS = 2;\n\n// PARENT, NEXT, TRANSPLANTED_VIEWS_TO_REFRESH are indices 3, 4, and 5\n// As we already have these constants in LView, we don't need to re-create them.\n\n// T_HOST is index 6\n// We already have this constants in LView, we don't need to re-create it.\n\nexport const NATIVE = 7;\nexport const VIEW_REFS = 8;\nexport const MOVED_VIEWS = 9;\n\n\n/**\n * Size of LContainer's header. Represents the index after which all views in the\n * container will be inserted. We need to keep a record of current views so we know\n * which views are already in the DOM (and don't need to be re-added) and so we can\n * remove views from the DOM when they are no longer required.\n */\nexport const CONTAINER_HEADER_OFFSET = 10;\n\n/**\n * The state associated with a container.\n *\n * This is an array so that its structure is closer to LView. This helps\n * when traversing the view tree (which is a mix of containers and component\n * views), so we can jump to viewOrContainer[NEXT] in the same way regardless\n * of type.\n */\nexport interface LContainer extends Array<any> {\n  /**\n   * The host element of this LContainer.\n   *\n   * The host could be an LView if this container is on a component node.\n   * In that case, the component LView is its HOST.\n   */\n  readonly[HOST]: RElement|RComment|LView;\n\n  /**\n   * This is a type field which allows us to differentiate `LContainer` from `StylingContext` in an\n   * efficient way. The value is always set to `true`\n   */\n  [TYPE]: true;\n\n  /**\n   * Flag to signify that this `LContainer` may have transplanted views which need to be change\n   * detected. (see: `LView[DECLARATION_COMPONENT_VIEW])`.\n   *\n   * This flag, once set, is never unset for the `LContainer`.\n   */\n  [HAS_TRANSPLANTED_VIEWS]: boolean;\n\n  /**\n   * Access to the parent view is necessary so we can propagate back\n   * up from inside a container to parent[NEXT].\n   */\n  [PARENT]: LView;\n\n  /**\n   * This allows us to jump from a container to a sibling container or component\n   * view with the same parent, so we can remove listeners efficiently.\n   */\n  [NEXT]: LView|LContainer|null;\n\n  /**\n   * The number of direct transplanted views which need a refresh or have descendants themselves\n   * that need a refresh but have not marked their ancestors as Dirty. This tells us that during\n   * change detection we should still descend to find those children to refresh, even if the parents\n   * are not `Dirty`/`CheckAlways`.\n   */\n  [TRANSPLANTED_VIEWS_TO_REFRESH]: number;\n\n  /**\n   * A collection of views created based on the underlying `<ng-template>` element but inserted into\n   * a different `LContainer`. We need to track views created from a given declaration point since\n   * queries collect matches from the embedded view declaration point and _not_ the insertion point.\n   */\n  [MOVED_VIEWS]: LView[]|null;\n\n  /**\n   * Pointer to the `TNode` which represents the host of the container.\n   */\n  [T_HOST]: TNode;\n\n  /** The comment element that serves as an anchor for this LContainer. */\n  readonly[NATIVE]:\n      RComment;  // TODO(misko): remove as this value can be gotten by unwrapping `[HOST]`\n\n  /**\n   * Array of `ViewRef`s used by any `ViewContainerRef`s that point to this container.\n   *\n   * This is lazily initialized by `ViewContainerRef` when the first view is inserted.\n   *\n   * NOTE: This is stored as `any[]` because render3 should really not be aware of `ViewRef` and\n   * doing so creates circular dependency.\n   */\n  [VIEW_REFS]: unknown[]|null;\n}\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {LContainer, TYPE} from './container';\nimport {ComponentDef, DirectiveDef} from './definition';\nimport {TNode, TNodeFlags} from './node';\nimport {RNode} from './renderer_dom';\nimport {FLAGS, LView, LViewFlags} from './view';\n\n\n/**\n * True if `value` is `LView`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nexport function isLView(value: RNode|LView|LContainer|{}|null): value is LView {\n  return Array.isArray(value) && typeof value[TYPE] === 'object';\n}\n\n/**\n * True if `value` is `LContainer`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nexport function isLContainer(value: RNode|LView|LContainer|{}|null): value is LContainer {\n  return Array.isArray(value) && value[TYPE] === true;\n}\n\nexport function isContentQueryHost(tNode: TNode): boolean {\n  return (tNode.flags & TNodeFlags.hasContentQuery) !== 0;\n}\n\nexport function isComponentHost(tNode: TNode): boolean {\n  return (tNode.flags & TNodeFlags.isComponentHost) === TNodeFlags.isComponentHost;\n}\n\nexport function isDirectiveHost(tNode: TNode): boolean {\n  return (tNode.flags & TNodeFlags.isDirectiveHost) === TNodeFlags.isDirectiveHost;\n}\n\nexport function isComponentDef<T>(def: DirectiveDef<T>): def is ComponentDef<T> {\n  return (def as ComponentDef<T>).template !== null;\n}\n\nexport function isRootView(target: LView): boolean {\n  return (target[FLAGS] & LViewFlags.IsRoot) !== 0;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDefined, assertEqual, assertNumber, throwError} from '../util/assert';\n\nimport {getComponentDef, getNgModuleDef} from './definition';\nimport {LContainer} from './interfaces/container';\nimport {DirectiveDef} from './interfaces/definition';\nimport {TIcu} from './interfaces/i18n';\nimport {NodeInjectorOffset} from './interfaces/injector';\nimport {TNode} from './interfaces/node';\nimport {isLContainer, isLView} from './interfaces/type_checks';\nimport {DECLARATION_COMPONENT_VIEW, HEADER_OFFSET, LView, T_HOST, TVIEW, TView} from './interfaces/view';\n\n// [Assert functions do not constraint type when they are guarded by a truthy\n// expression.](https://github.com/microsoft/TypeScript/issues/37295)\n\n\nexport function assertTNodeForLView(tNode: TNode, lView: LView) {\n  assertTNodeForTView(tNode, lView[TVIEW]);\n}\n\nexport function assertTNodeForTView(tNode: TNode, tView: TView) {\n  assertTNode(tNode);\n  tNode.hasOwnProperty('tView_') &&\n      assertEqual(\n          (tNode as any as {tView_: TView}).tView_, tView,\n          'This TNode does not belong to this TView.');\n}\n\nexport function assertTNode(tNode: TNode) {\n  assertDefined(tNode, 'TNode must be defined');\n  if (!(tNode && typeof tNode === 'object' && tNode.hasOwnProperty('directiveStylingLast'))) {\n    throwError('Not of type TNode, got: ' + tNode);\n  }\n}\n\n\nexport function assertTIcu(tIcu: TIcu) {\n  assertDefined(tIcu, 'Expected TIcu to be defined');\n  if (!(typeof tIcu.currentCaseLViewIndex === 'number')) {\n    throwError('Object is not of TIcu type.');\n  }\n}\n\nexport function assertComponentType(\n    actual: any,\n    msg: string = 'Type passed in is not ComponentType, it does not have \\'ɵcmp\\' property.') {\n  if (!getComponentDef(actual)) {\n    throwError(msg);\n  }\n}\n\nexport function assertNgModuleType(\n    actual: any,\n    msg: string = 'Type passed in is not NgModuleType, it does not have \\'ɵmod\\' property.') {\n  if (!getNgModuleDef(actual)) {\n    throwError(msg);\n  }\n}\n\nexport function assertCurrentTNodeIsParent(isParent: boolean) {\n  assertEqual(isParent, true, 'currentTNode should be a parent');\n}\n\nexport function assertHasParent(tNode: TNode|null) {\n  assertDefined(tNode, 'currentTNode should exist!');\n  assertDefined(tNode!.parent, 'currentTNode should have a parent');\n}\n\nexport function assertDataNext(lView: LView, index: number, arr?: any[]) {\n  if (arr == null) arr = lView;\n  assertEqual(\n      arr.length, index, `index ${index} expected to be at the end of arr (length ${arr.length})`);\n}\n\nexport function assertLContainer(value: any): asserts value is LContainer {\n  assertDefined(value, 'LContainer must be defined');\n  assertEqual(isLContainer(value), true, 'Expecting LContainer');\n}\n\nexport function assertLViewOrUndefined(value: any): asserts value is LView|null|undefined {\n  value && assertEqual(isLView(value), true, 'Expecting LView or undefined or null');\n}\n\nexport function assertLView(value: any): asserts value is LView {\n  assertDefined(value, 'LView must be defined');\n  assertEqual(isLView(value), true, 'Expecting LView');\n}\n\nexport function assertFirstCreatePass(tView: TView, errMessage?: string) {\n  assertEqual(\n      tView.firstCreatePass, true, errMessage || 'Should only be called in first create pass.');\n}\n\nexport function assertFirstUpdatePass(tView: TView, errMessage?: string) {\n  assertEqual(\n      tView.firstUpdatePass, true, errMessage || 'Should only be called in first update pass.');\n}\n\n/**\n * This is a basic sanity check that an object is probably a directive def. DirectiveDef is\n * an interface, so we can't do a direct instanceof check.\n */\nexport function assertDirectiveDef<T>(obj: any): asserts obj is DirectiveDef<T> {\n  if (obj.type === undefined || obj.selectors == undefined || obj.inputs === undefined) {\n    throwError(\n        `Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`);\n  }\n}\n\nexport function assertIndexInDeclRange(lView: LView, index: number) {\n  const tView = lView[1];\n  assertBetween(HEADER_OFFSET, tView.bindingStartIndex, index);\n}\n\nexport function assertIndexInVarsRange(lView: LView, index: number) {\n  const tView = lView[1];\n  assertBetween(tView.bindingStartIndex, tView.expandoStartIndex, index);\n}\n\nexport function assertIndexInExpandoRange(lView: LView, index: number) {\n  const tView = lView[1];\n  assertBetween(tView.expandoStartIndex, lView.length, index);\n}\n\nexport function assertBetween(lower: number, upper: number, index: number) {\n  if 