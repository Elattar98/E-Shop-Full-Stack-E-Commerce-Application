uctions/change_detection.ts","../../../../../../packages/core/src/render3/instructions/template.ts","../../../../../../packages/core/src/render3/instructions/storage.ts","../../../../../../packages/core/src/render3/instructions/property.ts","../../../../../../packages/core/src/render3/instructions/element.ts","../../../../../../packages/core/src/render3/instructions/element_container.ts","../../../../../../packages/core/src/render3/instructions/get_current_view.ts","../../../../../../packages/core/src/util/lang.ts","../../../../../../packages/core/src/render3/instructions/listener.ts","../../../../../../packages/core/src/render3/instructions/namespace.ts","../../../../../../packages/core/src/render3/instructions/next_context.ts","../../../../../../packages/core/src/render3/instructions/projection.ts","../../../../../../packages/core/src/render3/instructions/property_interpolation.ts","../../../../../../packages/core/src/render3/styling/style_binding_list.ts","../../../../../../packages/core/src/render3/styling/styling_parser.ts","../../../../../../packages/core/src/render3/instructions/styling.ts","../../../../../../packages/core/src/render3/instructions/text.ts","../../../../../../packages/core/src/render3/instructions/text_interpolation.ts","../../../../../../packages/core/src/render3/instructions/class_map_interpolation.ts","../../../../../../packages/core/src/render3/instructions/style_map_interpolation.ts","../../../../../../packages/core/src/render3/instructions/style_prop_interpolation.ts","../../../../../../packages/core/src/render3/instructions/host_property.ts","../../../../../../packages/core/src/util/ng_i18n_closure_mode.ts","../../../../../../packages/core/src/i18n/locale_en.ts","../../../../../../packages/core/src/i18n/locale_data_api.ts","../../../../../../packages/core/src/i18n/localization.ts","../../../../../../packages/core/src/render3/interfaces/i18n.ts","../../../../../../packages/core/src/render3/i18n/i18n_locale_id.ts","../../../../../../packages/core/src/render3/node_manipulation_i18n.ts","../../../../../../packages/core/src/render3/i18n/i18n_insert_before_index.ts","../../../../../../packages/core/src/render3/i18n/i18n_util.ts","../../../../../../packages/core/src/render3/i18n/i18n_apply.ts","../../../../../../packages/core/src/render3/instructions/i18n_icu_container_visitor.ts","../../../../../../packages/core/src/render3/i18n/i18n_debug.ts","../../../../../../packages/core/src/render3/i18n/i18n_parse.ts","../../../../../../packages/core/src/render3/i18n/i18n_postprocess.ts","../../../../../../packages/core/src/render3/instructions/i18n.ts","../../../../../../packages/core/src/render3/instructions/all.ts","../../../../../../packages/core/src/render3/di_setup.ts","../../../../../../packages/core/src/render3/features/providers_feature.ts","../../../../../../packages/core/src/linker/ng_module_factory.ts","../../../../../../packages/core/src/render3/ng_module_ref.ts","../../../../../../packages/core/src/render3/features/standalone_feature.ts","../../../../../../packages/core/src/render3/util/discovery_utils.ts","../../../../../../packages/core/src/render3/metadata.ts","../../../../../../packages/core/src/render3/pure_function.ts","../../../../../../packages/core/src/render3/pipe.ts","../../../../../../packages/core/src/event_emitter.ts","../../../../../../packages/core/src/linker/query_list.ts","../../../../../../packages/core/src/linker/template_ref.ts","../../../../../../packages/core/src/linker/view_container_ref.ts","../../../../../../packages/core/src/render3/interfaces/definition.ts","../../../../../../packages/core/src/render3/interfaces/query.ts","../../../../../../packages/core/src/render3/query.ts","../../../../../../packages/core/src/render3/view_engine_compatibility_prebound.ts","../../../../../../packages/core/src/render3/index.ts","../../../../../../packages/core/src/render3/jit/environment.ts","../../../../../../packages/core/src/render3/jit/module_patch.ts","../../../../../../packages/core/src/render3/jit/util.ts","../../../../../../packages/core/src/render3/jit/module.ts","../../../../../../packages/core/testing/src/metadata_overrider.ts","../../../../../../packages/core/testing/src/resolvers.ts","../../../../../../packages/core/testing/src/r3_test_bed_compiler.ts","../../../../../../packages/core/testing/src/test_bed_common.ts","../../../../../../packages/core/testing/src/r3_test_bed.ts","../../../../../../packages/core/testing/src/test_bed.ts","../../../../../../packages/core/testing/src/test_hooks.ts","../../../../../../packages/core/testing/src/testing.ts","../../../../../../packages/core/testing/public_api.ts","../../../../../../packages/core/testing/index.ts","../../../../../../packages/core/testing/testing.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Wraps a test function in an asynchronous test zone. The test will automatically\n * complete when all asynchronous calls within this zone are done. Can be used\n * to wrap an {@link inject} call.\n *\n * Example:\n *\n * ```\n * it('...', waitForAsync(inject([AClass], (object) => {\n *   object.doSomething.then(() => {\n *     expect(...);\n *   })\n * });\n * ```\n *\n * @publicApi\n */\nexport function waitForAsync(fn: Function): (done: any) => any {\n  const _Zone: any = typeof Zone !== 'undefined' ? Zone : null;\n  if (!_Zone) {\n    return function() {\n      return Promise.reject(\n          'Zone is needed for the waitForAsync() test helper but could not be found. ' +\n          'Please make sure that your environment includes zone.js');\n    };\n  }\n  const asyncTest = _Zone && _Zone[_Zone.__symbol__('asyncTest')];\n  if (typeof asyncTest === 'function') {\n    return asyncTest(fn);\n  }\n  return function() {\n    return Promise.reject(\n        'zone-testing.js is needed for the async() test helper but could not be found. ' +\n        'Please make sure that your environment includes zone.js/testing');\n  };\n}\n\n/**\n * @deprecated use `waitForAsync()`, (expected removal in v12)\n * @see {@link waitForAsync}\n * @publicApi\n * */\nexport function async(fn: Function): (done: any) => any {\n  return waitForAsync(fn);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ChangeDetectorRef, ComponentRef, DebugElement, ElementRef, getDebugNode, NgZone, RendererFactory2} from '@angular/core';\n\n\n/**\n * Fixture for debugging and testing a component.\n *\n * @publicApi\n */\nexport class ComponentFixture<T> {\n  /**\n   * The DebugElement associated with the root element of this component.\n   */\n  debugElement: DebugElement;\n\n  /**\n   * The instance of the root component class.\n   */\n  componentInstance: T;\n\n  /**\n   * The native element at the root of the component.\n   */\n  nativeElement: any;\n\n  /**\n   * The ElementRef for the element at the root of the component.\n   */\n  elementRef: ElementRef;\n\n  /**\n   * The ChangeDetectorRef for the component\n   */\n  changeDetectorRef: ChangeDetectorRef;\n\n  private _renderer: RendererFactory2|null|undefined;\n  private _isStable: boolean = true;\n  private _isDestroyed: boolean = false;\n  private _resolve: ((result: any) => void)|null = null;\n  private _promise: Promise<any>|null = null;\n  private _onUnstableSubscription: any /** TODO #9100 */ = null;\n  private _onStableSubscription: any /** TODO #9100 */ = null;\n  private _onMicrotaskEmptySubscription: any /** TODO #9100 */ = null;\n  private _onErrorSubscription: any /** TODO #9100 */ = null;\n\n  constructor(\n      public componentRef: ComponentRef<T>, public ngZone: NgZone|null,\n      private _autoDetect: boolean) {\n    this.changeDetectorRef = componentRef.changeDetectorRef;\n    this.elementRef = componentRef.location;\n    this.debugElement = <DebugElement>getDebugNode(this.elementRef.nativeElement);\n    this.componentInstance = componentRef.instance;\n    this.nativeElement = this.elementRef.nativeElement;\n    this.componentRef = componentRef;\n    this.ngZone = ngZone;\n\n    if (ngZone) {\n      // Create subscriptions outside the NgZone so that the callbacks run oustide\n      // of NgZone.\n      ngZone.runOutsideAngular(() => {\n        this._onUnstableSubscription = ngZone.onUnstable.subscribe({\n          next: () => {\n            this._isStable = false;\n          }\n        });\n        this._onMicrotaskEmptySubscription = ngZone.onMicrotaskEmpty.subscribe({\n          next: () => {\n            if (this._autoDetect) {\n              // Do a change detection run with checkNoChanges set to true to check\n              // there are no changes on the second run.\n              this.detectChanges(true);\n            }\n          }\n        });\n        this._onStableSubscription = ngZone.onStable.subscribe({\n          next: () => {\n            this._isStable = true;\n            // Check whether there is a pending whenStable() completer to resolve.\n            if (this._promise !== null) {\n              // If so check whether there are no pending macrotasks before resolving.\n              // Do this check in the next tick so that ngZone gets a chance to update the state of\n              // pending macrotasks.\n              scheduleMicroTask(() => {\n                if (!ngZone.hasPendingMacrotasks) {\n                  if (this._promise !== null) {\n                    this._resolve!(true);\n                    this._resolve = null;\n                    this._promise = null;\n                  }\n                }\n              });\n            }\n          }\n        });\n\n        this._onErrorSubscription = ngZone.onError.subscribe({\n          next: (error: any) => {\n            throw error;\n          }\n        });\n      });\n    }\n  }\n\n  private _tick(checkNoChanges: boolean) {\n    this.changeDetectorRef.detectChanges();\n    if (checkNoChanges) {\n      this.checkNoChanges();\n    }\n  }\n\n  /**\n   * Trigger a change detection cycle for the component.\n   */\n  detectChanges(checkNoChanges: boolean = true): void {\n    if (this.ngZone != null) {\n      // Run the change detection inside the NgZone so that any async tasks as part of the change\n      // detection are captured by the zone and can be waited for in isStable.\n      this.ngZone.run(() => {\n        this._tick(checkNoChanges);\n      });\n    } else {\n      // Running without zone. Just do the change detection.\n      this._tick(checkNoChanges);\n    }\n  }\n\n  /**\n   * Do a change detection run to make sure there were no changes.\n   */\n  checkNoChanges(): void {\n    this.changeDetectorRef.checkNoChanges();\n  }\n\n  /**\n   * Set whether the fixture should autodetect changes.\n   *\n   * Also runs detectChanges once so that any existing change is detected.\n   */\n  autoDetectChanges(autoDetect: boolean = true) {\n    if (this.ngZone == null) {\n      throw new Error('Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set');\n    }\n    this._autoDetect = autoDetect;\n    this.detectChanges();\n  }\n\n  /**\n   * Return whether the fixture is currently stable or has async tasks that have not been completed\n   * yet.\n   */\n  isStable(): boolean {\n    return this._isStable && !this.ngZone!.hasPendingMacrotasks;\n  }\n\n  /**\n   * Get a promise that resolves when the fixture is stable.\n   *\n   * This can be used to resume testing after events have triggered asynchronous activity or\n   * asynchronous change detection.\n   */\n  whenStable(): Promise<any> {\n    if (this.isStable()) {\n      return Promise.resolve(false);\n    } else if (this._promise !== null) {\n      return this._promise;\n    } else {\n      this._promise = new Promise(res => {\n        this._resolve = res;\n      });\n      return this._promise;\n    }\n  }\n\n\n  private _getRenderer() {\n    if (this._renderer === undefined) {\n      this._renderer = this.componentRef.injector.get(RendererFactory2, null);\n    }\n    return this._renderer as RendererFactory2 | null;\n  }\n\n  /**\n   * Get a promise that resolves when the ui state is stable following animations.\n   */\n  whenRenderingDone()