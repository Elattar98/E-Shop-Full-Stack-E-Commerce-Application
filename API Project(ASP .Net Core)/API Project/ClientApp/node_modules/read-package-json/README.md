{\n  /** Which renderer factory to use. */\n  rendererFactory?: RendererFactory;\n\n  /** A custom sanitizer instance */\n  sanitizer?: Sanitizer;\n\n  /** A custom animation player handler */\n  playerHandler?: PlayerHandler;\n\n  /**\n   * Host element on which the component will be bootstrapped. If not specified,\n   * the component definition's `tag` is used to query the existing DOM for the\n   * element to bootstrap.\n   */\n  host?: RElement|string;\n\n  /** Module injector for the component. If unspecified, the injector will be NULL_INJECTOR. */\n  injector?: Injector;\n\n  /**\n   * List of features to be applied to the created component. Features are simply\n   * functions that decorate a component with a certain behavior.\n   *\n   * Typically, the features in this list are features that cannot be added to the\n   * other features list in the component definition because they rely on other factors.\n   *\n   * Example: `LifecycleHooksFeature` is a function that adds lifecycle hook capabilities\n   * to root components in a tree-shakable way. It cannot be added to the component\n   * features list because there's no way of knowing when the component will be used as\n   * a root component.\n   */\n  hostFeatures?: HostFeature[];\n\n  /**\n   * A function which is used to schedule change detection work in the future.\n   *\n   * When marking components as dirty, it is necessary to schedule the work of\n   * change detection in the future. This is done to coalesce multiple\n   * {@link markDirty} calls into a single changed detection processing.\n   *\n   * The default value of the scheduler is the `requestAnimationFrame` function.\n   *\n   * It is also useful to override this function for testing purposes.\n   */\n  scheduler?: (work: () => void) => void;\n}\n\n/** See CreateComponentOptions.hostFeatures */\ntype HostFeature = (<T>(component: T, componentDef: ComponentDef<T>) => void);\n\n// TODO: A hack to not pull in the NullInjector from @angular/core.\nexport const NULL_INJECTOR: Injector = {\n  get: (token: any, notFoundValue?: any) => {\n    throwProviderNotFoundError(token, 'NullInjector');\n  }\n};\n\n/**\n * Creates the root component view and the root component node.\n *\n * @param rNode Render host element.\n * @param def ComponentDef\n * @param rootView The parent view where the host node is stored\n * @param rendererFactory Factory to be used for creating child renderers.\n * @param hostRenderer The current renderer\n * @param sanitizer The sanitizer, if provided\n *\n * @returns Component view created\n */\nexport function createRootComponentView(\n    rNode: RElement|null, def: ComponentDef<any>, rootView: LView, rendererFactory: RendererFactory,\n    hostRenderer: Renderer, sanitizer?: Sanitizer|null): LView {\n  const tView = rootView[TVIEW];\n  const index = HEADER_OFFSET;\n  ngDevMode && assertIndexInRange(rootView, index);\n  rootView[index] = rNode;\n  // '#host' is added here as we don't know the real host DOM name (we don't want to read it) and at\n  // the same time we want to communicate the debug `TNode` that this is a special `TNode`\n  // representing a host element.\n  const tNode: TElementNode = getOrCreateTNode(tView, index, TNodeType.Element, '#host', null);\n  const mergedAttrs = tNode.mergedAttrs = def.hostAttrs;\n  if (mergedAttrs !== null) {\n    computeStaticStyling(tNode, mergedAttrs, true);\n    if (rNode !== null) {\n      setUpAttributes(hostRenderer, rNode, mergedAttrs);\n      if (tNode.classes !== null) {\n        writeDirectClass(hostRenderer, rNode, tNode.classes);\n      }\n      if (tNode.styles !== null) {\n        writeDirectStyle(hostRenderer, rNode, tNode.styles);\n      }\n    }\n  }\n\n  const viewRenderer = rendererFactory.createRenderer(rNode, def);\n  const componentView = createLView(\n      rootView, getOrCreateTComponentView(def), null,\n      def.onPush ? LViewFlags.Dirty : LViewFlags.CheckAlways, rootView[index], tNode,\n      rendererFactory, viewRenderer, sanitizer || null, null, null);\n\n  if (tView.firstCreatePass) {\n    diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, rootView), tView, def.type);\n    markAsComponentHost(tView, tNode);\n    initTNodeFlags(tNode, rootView.length, 1);\n  }\n\n  addToViewTree(rootView, componentView);\n\n  // Store component view at node index, with node as the HOST\n  return rootView[index] = componentView;\n}\n\n/**\n * Creates a root component and sets it up with features and host bindings.Shared by\n * renderComponent() and ViewContainerRef.createComponent().\n */\nexport function createRootComponent<T>(\n    componentView: LView, componentDef: ComponentDef<T>, rootLView: LView, rootContext: RootContext,\n    hostFeatures: HostFeature[