f']
            }], routerLink: [{
                type: Input
            }], onClick: [{
                type: HostListener,
                args: ['click',
                    ['$event.button', '$event.ctrlKey', '$event.shiftKey', '$event.altKey', '$event.metaKey']]
            }] } });

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 *
 * @description
 *
 * Tracks whether the linked route of an element is currently active, and allows you
 * to specify one or more CSS classes to add to the element when the linked route
 * is active.
 *
 * Use this directive to create a visual distinction for elements associated with an active route.
 * For example, the following code highlights the word "Bob" when the router
 * activates the associated route:
 *
 * ```
 * <a routerLink="/user/bob" routerLinkActive="active-link">Bob</a>
 * ```
 *
 * Whenever the URL is either '/user' or '/user/bob', the "active-link" class is
 * added to the anchor tag. If the URL changes, the class is removed.
 *
 * You can set more than one class using a space-separated string or an array.
 * For example:
 *
 * ```
 * <a routerLink="/user/bob" routerLinkActive="class1 class2">Bob</a>
 * <a routerLink="/user/bob" [routerLinkActive]="['class1', 'class2']">Bob</a>
 * ```
 *
 * To add the classes only when the URL matches the link exactly, add the option `exact: true`:
 *
 * ```
 * <a routerLink="/user/bob" routerLinkActive="active-link" [routerLinkActiveOptions]="{exact:
 * true}">Bob</a>
 * ```
 *
 * To directly check the `isActive` status of the link, assign the `RouterLinkActive`
 * instance to a template variable.
 * For example, the following checks the status without assigning any CSS classes:
 *
 * ```
 * <a routerLink="/user/bob" routerLinkActive #rla="routerLinkActive">
 *   Bob {{ rla.isActive ? '(already open)' : ''}}
 * </a>
 * ```
 *
 * You can apply the `RouterLinkActive` directive to an ancestor of linked elements.
 * For example, the following sets the active-link class on the `<div>`  parent tag
 * when the URL is either '/user/jim' or '/user/bob'.
 *
 * ```
 * <div routerLinkActive="active-link" [routerLinkActiveOptions]="{exact: true}">
 *   <a routerLink="/user/jim">Jim</a>
 *   <a routerLink="/user/bob">Bob</a>
 * </div>
 * ```
 *
 * The `RouterLinkActive` directive can also be used to set the aria-current attribute
 * to provide an alternative distinction for active elements to visually impaired users.
 *
 * For example, the following code adds the 'active' class to the Home Page link when it is
 * indeed active and in such case also sets its aria-current attribute to 'page':
 *
 * ```
 * <a routerLink="/" routerLinkActive="active" ariaCurrentWhenActive="page">Home Page</a>
 * ```
 *
 * @ngModule RouterModule
 *
 * @publicApi
 */
class RouterLinkActive {
    constructor(router, element, renderer, cdr, link, linkWithHref) {
        this.router = router;
        this.element = element;
        this.renderer = renderer;
        this.cdr = cdr;
        this.link = link;
        this.linkWithHref = linkWithHref;
        this.classes = [];
        this.isActive = false;
        /**
         * Options to configure how to determine if the router link is active.
         *
         * These options are passed to the `Router.isActive()` function.
         *
         * @see Router.isActive
         */
        this.routerLinkActiveOptions = { exact: false };
        /**
         *
         * You can use the output `isActiveChange` to get notified each time the link becomes
         * active or inactive.
         *
         * Emits:
         * true  -> Route is active
         * false -> Route is inactive
         *
         * ```
         * <a
         *  routerLink="/user/bob"
         *  routerLinkActive="active-link"
         *  (isActiveChange)="this.onRouterLinkActive($event)">Bob</a>
         * ```
         */
        this.isActiveChange = new EventEmitter();
        this.routerEventsSubscription = router.events.subscribe((s) => {
            if (s instanceof NavigationEnd) {
                this.update();
            }
        });
    }
    /** @nodoc */
    ngAfterContentInit() {
        // `of(null)` is used to force subscribe body to execute once immediately (like `startWith`).
        of(this.links.changes, this.linksWithHrefs.changes, of(null)).pipe(mergeAll()).subscribe(_ => {
            this.update();
            this.subscribeToEachLinkOnChanges();
        });
    }
    subscribeToEachLinkOnChanges() {
        var _a;
        (_a = this.linkInputChangesSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        const allLinkChanges = [...this.links.toArray(), ...this.linksWithHrefs.toArray(), this.link, this.linkWithHref]
            .filter((link) => !!link)
            .map(link => link.onChanges);
        this.linkInputChangesSubscription = from(allLinkChanges).pipe(mergeAll()).subscribe(link => {
            if (this.isActive !== this.isLinkActive(this.router)(link)) {
                this.update();
            }
        });
    }
    set routerLinkActive(data) {
        const classes = Array.isArray(data) ? data : data.split(' ');
        this.classes = classes.filter(c => !!c);
    }
    /** @nodoc */
    ngOnChanges(changes) {
        this.update();
    }
    /** @nodoc */
    ngOnDestroy() {
        var _a;
        this.routerEventsSubscription.unsubscribe();
        (_a = this.linkInputChangesSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
    }
    update() {
        if (!this.links || !this.linksWithHrefs || !this.router.navigated)
            return;
        Promise.resolve().then(() => {
            const hasActiveLinks = this.hasActiveLinks();
            if (this.isActive !== hasActiveLinks) {
                this.isActive = hasActiveLinks;
                this.cdr.markForCheck();
                this.classes.forEach((c) => {
                    if (hasActiveLinks) {
                        this.renderer.addClass(this.element.nativeElement, c);
                    }
                    else {
                        this.renderer.removeClass(this.element.nativeElement, c);
                    }
                });
                if (hasActiveLinks && this.ariaCurrentWhenActive !== undefined) {
                    this.renderer.setAttribute(this.element.nativeElement, 'aria-current', this.ariaCurrentWhenActive.toString());
                }
                else {
                    this.renderer.removeAttribute(this.element.nativeElement, 'aria-current');
                }
                // Emit on isActiveChange after classes are updated
                this.isActiveChange.emit(hasActiveLinks);
            }
        });
    }
    isLinkActive(router) {
        const options = isActiveMatchOptions(this.routerLinkActiveOptions) ?
            this.routerLinkActiveOptions :
            // While the types should disallow `undefined` here, it's possible without strict inputs
            (this.routerLinkActiveOptions.exact || false);
        return (link) => link.urlTree ? router.isActive(link.urlTree, options) : false;
    }
    hasActiveLinks() {
        const isActiveCheckFn = this.isLinkActive(this.router);
        return this.link && isActiveCheckFn(this.link) ||
            this.linkWithHref && isActiveCheckFn(this.linkWithHref) ||
            this.links.some(isActiveCheckFn) || this.linksWithHrefs.some(isActiveCheckFn);
    }
}
RouterLinkActive.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: RouterLinkActive, deps: [{ token: Router }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i0.ChangeDetectorRef }, { token: RouterLink, optional: true }, { token: RouterLinkWithHref, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
RouterLinkActive.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.1.0", type: RouterLinkActive, selector: "[routerLinkActive]", inputs: { routerLinkActiveOptions: "routerLinkActiveOptions", ariaCurrentWhenActive: "ariaCurrentWhenActive", routerLinkActive: "routerLinkActive" }, outputs: { isActiveChange: "isActiveChange" }, queries: [{ propertyName: "links", predicate: RouterLink, descendants: true }, { propertyName: "linksWithHrefs", predicate: RouterLinkWithHref, descendants: true }], exportAs: ["routerLinkActive"], usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: RouterLinkActive, decorators: [{
            type: Directive,
            args: [{
                    selector: '[routerLinkActive]',
                    exportAs: 'routerLinkActive',
                }]
        }], ctorParameters: function () {
        return [{ type: Router }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }, { type: RouterLink, decorators: [{
                        type: Optional
                    }] }, { type: RouterLinkWithHref, decorators: [{
                        type: Optional
                    }] }];
    }, propDecorators: { links: [{
                type: ContentChildren,
                args: [RouterLink, { descendants: true }]
            }], linksWithHrefs: [{
                type: ContentChildren,
                args: [RouterLinkWithHref, { descendants: true }]
            }], routerLinkActiveOptions: [{
                type: Input
            }], ariaCurrentWhenActive: [{
                type: Input
            }], isActiveChange: [{
                type: Output
            }], routerLinkActive: [{
                type: Input
            }] } });
/**
 * Use instead of `'paths' in options` to be compatible with property renaming
 */
function isActiveMatchOptions(options) {
    return !!options.paths;
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Provides a strategy for setting the page title after a router navigation.
 *
 * The built-in implementation traverses the router state snapshot and finds the deepest primary
 * outlet with `title` property. Given the `Routes` below, navigating to
 * `/base/child(popup:aux)` would result in the document title being set to "child".
 * ```
 * [
 *   {path: 'base', title: 'base', children: [
 *     {path: 'child', title: 'child'},
 *   ],
 *   {path: 'aux', outlet: 'popup', title: 'popupTitle'}
 * ]
 * ```
 *
 * This class can be used as a base class for custom title strategies. That is, you can create your
 * own class that extends the `TitleStrategy`. Note that in the above example, the `title`
 * from the named outlet is never used. However, a custom strategy might be implemented to
 * incorporate titles in named outlets.
 *
 * @publicApi
 * @see [Page title guide](guide/router#setting-the-page-title)
 */
class TitleStrategy {
    /**
     * @returns The `title` of the deepest primary route.
     */
    buildTitle(snapshot) {
        var _a;
        let pageTitle;
        let route = snapshot.root;
        while (route !== undefined) {
            pageTitle = (_a = this.getResolvedTitleForRoute(route)) !== null && _a !== void 0 ? _a : pageTitle;
            route = route.children.find(child => child.outlet === PRIMARY_OUTLET);
        }
        return pageTitle;
    }
    /**
     * Given an `ActivatedRouteSnapshot`, returns the final value of the
     * `Route.title` property, which can either be a static string or a resolved value.
     */
    getResolvedTitleForRoute(snapshot) {
        return snapshot.data[RouteTitle];
    }
}
TitleStrategy.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: TitleStrategy, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
TitleStrategy.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: TitleStrategy, providedIn: 'root', useFactory: () => inject(DefaultTitleStrategy) });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: TitleStrategy, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root', useFactory: () => inject(DefaultTitleStrategy) }]
        }] });
/**
 * The default `TitleStrategy` used by the router that updates the title using the `Title` service.
 */
class DefaultTitleStrategy extends TitleStrategy {
    constructor(title) {
        super();
        this.title = title;
    }
    /**
     * Sets the title of the browser to the given value.
     *
     * @param title The `pageTitle` from the deepest primary route.
     */
    updateTitle(snapshot) {
        const title = this.buildTitle(snapshot);
        if (title !== undefined) {
            this.title.setTitle(title);
        }
    }
}
DefaultTitleStrategy.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: DefaultTitleStrategy, deps: [{ token: i1.Title }], target: i0.ɵɵFactoryTarget.Injectable });
DefaultTitleStrategy.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: DefaultTitleStrategy, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: DefaultTitleStrategy, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: i1.Title }]; } });

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @description
 *
 * Provides a preloading strategy.
 *
 * @publicApi
 */
class PreloadingStrategy {
}
/**
 * @description
 *
 * Provides a preloading strategy that preloads all modules as quickly as possible.
 *
 * ```
 * RouterModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})
 * ```
 *
 * @publicApi
 */
class PreloadAllModules {
    preload(route, fn) {
        return fn().pipe(catchError(() => of(null)));
    }
}
PreloadAllModules.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: PreloadAllModules, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
PreloadAllModules.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: PreloadAllModules, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: PreloadAllModules, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });
/**
 * @description
 *
 * Provides a preloading strategy that does not preload any modules.
 *
 * This strategy is enabled by default.
 *
 * @publicApi
 */
class NoPreloading {
    preload(route, fn) {
        return of(null);
    }
}
NoPreloading.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: NoPreloading, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
NoPreloading.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: NoPreloading, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: NoPreloading, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });
/**
 * The preloader optimistically loads all router configurations to
 * make navigations into lazily-loaded sections of the application faster.
 *
 * The preloader runs in the background. When the router bootstraps, the preloader
 * starts listening to all navigation events. After every such event, the preloader
 * will check if any configurations can be loaded lazily.
 *
 * If a route is protected by `canLoad` guards, the preloaded will not load it.
 *
 * @publicApi
 */
class RouterPreloader {
    constructor(router, compiler, injector, preloadingStrategy, loader) {
        this.router = router;
        this.injector = injector;
        this.preloadingStrategy = preloadingStrategy;
        this.loader = loader;
    }
    setUpPreloading() {
        this.subscription =
            this.router.events
                .pipe(filter((e) => e instanceof NavigationEnd), concatMap(() => this.preload()))
                .subscribe(() => { });
    }
    preload() {
        return this.processRoutes(this.injector, this.router.config);
    }
    /** @nodoc */
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
    processRoutes(injector, routes) {
        var _a, _b, _c;
        const res = [];
        for (const route of routes) {
            if (route.providers && !route._injector) {
                route._injector =
                    createEnvironmentInjector(route.providers, injector, `Route: ${route.path}`);
            }
            const injectorForCurrentRoute = (_a = route._injector) !== null && _a !== void 0 ? _a : injector;
            const injectorForChildren = (_b = route._loadedInjector) !== null && _b !== void 0 ? _b : injectorForCurrentRoute;
            if ((route.loadChildren && !route._loadedRoutes) ||
                (route.loadComponent && !route._loadedComponent)) {
                res.push(this.preloadConfig(injectorForCurrentRoute, route));
            }
            else if (route.children || route._loadedRoutes) {
                res.push(this.processRoutes(injectorForChildren, ((_c = route.children) !== null && _c !== void 0 ? _c : route._loadedRoutes)));
            }
        }
        return from(res).pipe(mergeAll());
    }
    preloadConfig(injector, route) {
        return this.preloadingStrategy.preload(route, () => {
            let loadedChildren$;
            if (route.loadChildren && route.canLoad === undefined) {
                loadedChildren$ = this.loader.loadChildren(injector, route);
            }
            else {
                loadedChildren$ = of(null);
            }
            const recursiveLoadChildren$ = loadedChildren$.pipe(mergeMap((config) => {
                var _a;
                if (config === null) {
                    return of(void 0);
                }
                route._loadedRoutes = config.routes;
                route._loadedInjector = config.injector;
                // If the loaded config was a module, use that as the module/module injector going
                // forward. Otherwise, continue using the current module/module injector.
                return this.processRoutes((_a = config.injector) !== null && _a !== void 0 ? _a : injector, config.routes);
            }));
            if (route.loadComponent && !route._loadedComponent) {
                const loadComponent$ = this.loader.loadComponent(route);
                return from([recursiveLoadChildren$, loadComponent$]).pipe(mergeAll());
            }
            else {
                return recursiveLoadChildren$;
            }
        });
    }
}
RouterPreloader.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: RouterPreloader, deps: [{ token: Router }, { token: i0.Compiler }, { token: i0.EnvironmentInjector }, { token: PreloadingStrategy }, { token: RouterConfigLoader }], target: i0.ɵɵFactoryTarget.Injectable });
RouterPreloader.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: RouterPreloader });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: RouterPreloader, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: Router }, { type: i0.Compiler }, { type: i0.EnvironmentInjector }, { type: PreloadingStrategy }, { type: RouterConfigLoader }]; } });

const ROUTER_SCROLLER = new InjectionToken('');
class RouterScroller {
    constructor(router, 
    /** @docsNotRequired */ viewportScroller, options = {}) {
        this.router = router;
        this.viewportScroller = viewportScroller;
        this.options = options;
        this.lastId = 0;
        this.lastSource = 'imperative';
        this.restoredId = 0;
        this.store = {};
        // Default both options to 'disabled'
        options.scrollPositionRestoration = options.scrollPositionRestoration || 'disabled';
        options.anchorScrolling = options.anchorScrolling || 'disabled';
    }
    init() {
        // we want to disable the automatic scrolling because having two places
        // responsible for scrolling results race conditions, especially given
        // that browser don't implement this behavior consistently
        if (this.options.scrollPositionRestoration !== 'disabled') {
            this.viewportScroller.setHistoryScrollRestoration('manual');
        }
        this.routerEventsSubscription = this.createScrollEvents();
        this.scrollEventsSubscription = this.consumeScrollEvents();
    }
    createScrollEvents() {
        return this.router.events.subscribe(e => {
            if (e instanceof NavigationStart) {
                // store the scroll position of the current stable navigations.
                this.store[this.lastId] = this.viewportScroller.getScrollPosition();
                this.lastSource = e.navigationTrigger;
                this.restoredId = e.restoredState ? e.restoredState.navigationId : 0;
            }
            else if (e instanceof NavigationEnd) {
                this.lastId = e.id;
                this.scheduleScrollEvent(e, this.router.parseUrl(e.urlAfterRedirects).fragment);
            }
        });
    }
    consumeScrollEvents() {
        return this.router.events.subscribe(e => {
            if (!(e instanceof Scroll))
                return;
            // a popstate event. The pop state event will always ignore anchor scrolling.
            if (e.position) {
                if (this.options.scrollPositionRestoration === 'top') {
                    this.viewportScroller.scrollToPosition([0, 0]);
                }
                else if (this.options.scrollPositionRestoration === 'enabled') {
                    this.viewportScroller.scrollToPosition(e.position);
                }
                // imperative navigation "forward"
            }
            else {
                if (e.anchor && this.options.anchorScrolling === 'enabled') {
                    this.viewportScroller.scrollToAnchor(e.anchor);
                }
                else if (this.options.scrollPositionRestoration !== 'disabled') {
                    this.viewportScroller.scrollToPosition([0, 0]);
                }
            }
        });
    }
    scheduleScrollEvent(routerEvent, anchor) {
        this.router.triggerEvent(new Scroll(routerEvent, this.lastSource === 'popstate' ? this.store[this.restoredId] : null, anchor));
    }
    /** @nodoc */
    ngOnDestroy() {
        if (this.routerEventsSubscription) {
            this.routerEventsSubscription.unsubscribe();
        }
        if (this.scrollEventsSubscription) {
            this.scrollEventsSubscription.unsubscribe();
        }
    }
}
RouterScroller.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: RouterScroller, deps: "invalid", target: i0.ɵɵFactoryTarget.Injectable });
RouterScroller.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: RouterScroller });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: RouterScroller, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: Router }, { type: i3.ViewportScroller }, { type: undefined }]; } });

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const NG_DEV_MODE = typeof ngDevMode === 'undefined' || ngDevMode;
/**
 * The directives defined in the `RouterModule`.
 */
const ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive, ɵEmptyOutletComponent];
/**
 * A [DI token](guide/glossary/#di-token) for the router service.
 *
 * @publicApi
 */
const ROUTER_CONFIGURATION = new InjectionToken(NG_DEV_MODE ? 'router config' : 'ROUTER_CONFIGURATION', {
    providedIn: 'root',
    factory: () => ({}),
});
/**
 * @docsNotRequired
 */
const ROUTER_FORROOT_GUARD = new InjectionToken(NG_DEV_MODE ? 'router duplicate forRoot guard' : 'ROUTER_FORROOT_GUARD');
const ROUTER_PRELOADER = new InjectionToken(NG_DEV_MODE ? 'router preloader' : '');
const ROUTER_PROVIDERS = [
    Location,
    { provide: UrlSerializer, useClass: DefaultUrlSerializer },
    {
        provide: Router,
        useFactory: setupRouter,
        deps: [
            UrlSerializer, ChildrenOutletContexts, Location, Injector, Compiler, ROUTES, TitleStrategy,
            ROUTER_CONFIGURATION, [UrlHandlingStrategy, new Optional()],
            [RouteReuseStrategy, new Optional()]
        ]
    },
    ChildrenOutletContexts,
    { provide: ActivatedRoute, useFactory: rootRoute, deps: [Router] },
    RouterConfigLoader,
];
function routerNgProbeToken() {
    return new NgProbeToken('Router', Router);
}
/**
 * @description
 *
 * Adds directives and providers for in-app navigation among views defined in an application.
 * Use the Angular `Router` service to declaratively specify application states and manage state
 * transitions.
 *
 * You can import this NgModule multiple times, once for each lazy-loaded bundle.
 * However, only one `Router` service can be active.
 * To ensure this, there are two ways to register routes when importing this module:
 *
 * * The `forRoot()` method creates an `NgModule` that contains all the directives, the given
 * routes, and the `Router` service itself.
 * * The `forChild()` method creates an `NgModule` that contains all the directives and the given
 * routes, but does not include the `Router` service.
 *
 * @see [Routing and Navigation guide](guide/router) for an
 * overview of how the `Router` service should be used.
 *
 * @publicApi
 */
class RouterModule {
    // Note: We are injecting the Router so it gets created eagerly...
    constructor(guard, router) { }
    /**
     * Creates and configures a module with all the router providers and directives.
     * Optionally sets up an application listener to perform an initial navigation.
     *
     * When registering the NgModule at the root, import as follows:
     *
     * ```
     * @NgModule({
     *   imports: [RouterModule.forRoot(ROUTES)]
     * })
     * class MyNgModule {}
     * ```
     *
     * @param routes An array of `Route` objects that define the navigation paths for the application.
     * @param config An `ExtraOptions` configuration object that controls how navigation is performed.
     * @return The new `NgModule`.
     *
     */
    static forRoot(routes, config) {
        return {
            ngModule: RouterModule,
            providers: [
                ROUTER_PROVIDERS,
                NG_DEV_MODE ? ((config === null || config === void 0 ? void 0 : config.enableTracing) ? provideTracing() : []) : [],
                provideRoutes(routes),
                {
                    provide: ROUTER_FORROOT_GUARD,
                    useFactory: provideForRootGuard,
                    deps: [[Router, new Optional(), new SkipSelf()]]
                },
                { provide: ROUTER_CONFIGURATION, useValue: config ? config : {} },
                (config === null || config === void 0 ? void 0 : config.useHash) ? provideHashLocationStrategy() : providePathLocationStrategy(),
                provideRouterScroller(),
                (config === null || config === void 0 ? void 0 : config.preloadingStrategy) ? providePreloading(config.preloadingStrategy) : [],
                { provide: NgProbeToken, multi: true, useFactory: routerNgProbeToken },
                (config === null || config === void 0 ? void 0 : config.initialNavigation) ? provideInitialNavigation(config) : [],
                provideRouterInitializer(),
            ],
        };
    }
    /**
     * Creates a module with all the router directives and a provider registering routes,
     * without creating a new Router service.
     * When registering for submodules and lazy-loaded submodules, create the NgModule as follows:
     *
     * ```
     * @NgModule({
     *   imports: [RouterModule.forChild(ROUTES)]
     * })
     * class MyNgModule {}
     * ```
     *
     * @param routes An array of `Route` objects that define the navigation paths for the submodule.
     * @return The new NgModule.
     *
     */
    static forChild(routes) {
        return { ngModule: RouterModule, providers: [provideRoutes(routes)] };
    }
}
RouterModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: RouterModule, deps: [{ token: ROUTER_FORROOT_GUARD, optional: true }, { token: Router, optional: true }], target: i0.ɵɵFactoryTarget.NgModule });
RouterModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.1.0", ngImport: i0, type: RouterModule, declarations: [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive, ɵEmptyOutletComponent], exports: [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive, ɵEmptyOutletComponent] });
RouterModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: RouterModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: RouterModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: ROUTER_DIRECTIVES,
                    exports: ROUTER_DIRECTIVES,
                }]
        }], ctorParameters: function () {
        return [{ type: undefined, decorators: [{
                        type: Optional
                    }, {
                        type: Inject,
                        args: [ROUTER_FORROOT_GUARD]
                    }] }, { type: Router, decorators: [{
                        type: Optional
                    }] }];
    } });
function provideRouterScroller() {
    return {
        provide: ROUTER_SCROLLER,
        useFactory: () => {
            const router = inject(Router);
            const viewportScroller = inject(ViewportScroller);
            const config = inject(ROUTER_CONFIGURATION);
            if (config.scrollOffset) {
                viewportScroller.setOffset(config.scrollOffset);
            }
            return new RouterScroller(router, viewportScroller, config);
        },
    };
}
function provideHashLocationStrategy() {
    return { provide: LocationStrategy, useClass: HashLocationStrategy };
}
function providePathLocationStrategy() {
    return { provide: LocationStrategy, useClass: PathLocationStrategy };
}
function provideForRootGuard(router) {
    if (NG_DEV_MODE && router) {
        throw new ɵRuntimeError(4007 /* RuntimeErrorCode.FOR_ROOT_CALLED_TWICE */, `RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead.`);
    }
    return 'guarded';
}
/**
 * Registers a [DI provider](guide/glossary#provider) for a set of routes.
 * @param routes The route configuration to provide.
 *
 * @usageNotes
 *
 * ```
 * @NgModule({
 *   imports: [RouterModule.forChild(ROUTES)],
 *   providers: [provideRoutes(EXTRA_ROUTES)]
 * })
 * class MyNgModule {}
 * ```
 *
 * @publicApi
 */
function provideRoutes(routes) {
    return [
        { provide: ANALYZE_FOR_ENTRY_COMPONENTS, multi: true, useValue: routes },
        { provide: ROUTES, multi: true, useValue: routes },
    ];
}
function setupRouter(urlSerializer, contexts, location, injector, compiler, config, titleStrategy, opts = {}, urlHandlingStrategy, routeReuseStrategy) {
    const router = new Router(null, urlSerializer, contexts, location, injector, compiler, flatten(config));
    if (urlHandlingStrategy) {
        router.urlHandlingStrategy = urlHandlingStrategy;
    }
    if (routeReuseStrategy) {
        router.routeReuseStrategy = routeReuseStrategy;
    }
    router.titleStrategy = titleStrategy;
    assignExtraOptionsToRouter(opts, router);
    return router;
}
function assignExtraOptionsToRouter(opts, router) {
    if (opts.errorHandler) {
        router.errorHandler = opts.errorHandler;
    }
    if (opts.malformedUriErrorHandler) {
        router.malformedUriErrorHandler = opts.malformedUriErrorHandler;
    }
    if (opts.onSameUrlNavigation) {
        router.onSameUrlNavigation = opts.onSameUrlNavigation;
    }
    if (opts.paramsInheritanceStrategy) {
        router.paramsInheritanceStrategy = opts.paramsInheritanceStrategy;
    }
    if (opts.relativeLinkResolution) {
        router.relativeLinkResolution = opts.relativeLinkResolution;
    }
    if (opts.urlUpdateStrategy) {
        router.urlUpdateStrategy = opts.urlUpdateStrategy;
    }
    if (opts.canceledNavigationResolution) {
        router.canceledNavigationResolution = opts.canceledNavigationResolution;
    }
}
function rootRoute(router) {
    return router.routerState.root;
}
function getBootstrapListener() {
    const injector = inject(Injector);
    return (bootstrappedComponentRef) => {
        var _a, _b;
        const ref = injector.get(ApplicationRef);
        if (bootstrappedComponentRef !== ref.components[0]) {
            return;
        }
        const router = injector.get(Router);
        const bootstrapDone = injector.get(BOOTSTRAP_DONE);
        // Default case
        if (injector.get(INITIAL_NAVIGATION, null, InjectFlags.Optional) === null) {
            router.initialNavigation();
        }
        (_a = injector.get(ROUTER_PRELOADER, null, InjectFlags.Optional)) === null || _a === void 0 ? void 0 : _a.setUpPreloading();
        (_b = injector.get(ROUTER_SCROLLER, null, InjectFlags.Optional)) === null || _b === void 0 ? void 0 : _b.init();
        router.resetRootComponentType(ref.componentTypes[0]);
        bootstrapDone.next();
        bootstrapDone.complete();
    };
}
// TODO(atscott): This should not be in the public API
/**
 * A [DI token](guide/glossary/#di-token) for the router initializer that
 * is called after the app is bootstrapped.
 *
 * @publicApi
 */
const ROUTER_INITIALIZER = new InjectionToken(NG_DEV_MODE ? 'Router Initializer' : '');
function provideInitialNavigation(config) {
    return [
        config.initialNavigation === 'disabled' ? provideDisabledInitialNavigation() : [],
        config.initialNavigation === 'enabledBlocking' ? provideEnabledBlockingInitialNavigation() : [],
    ];
}
function provideRouterInitializer() {
    return [
        // ROUTER_INITIALIZER token should be removed. It's public API but shouldn't be. We can just
        // have `getBootstrapListener` directly attached to APP_BOOTSTRAP_LISTENER.
        { provide: ROUTER_INITIALIZER, useFactory: getBootstrapListener },
        { provide: APP_BOOTSTRAP_LISTENER, multi: true, useExisting: ROUTER_INITIALIZER },
    ];
}
/**
 * A subject used to indicate that the bootstrapping phase is done. When initial navigation is
 * `enabledBlocking`, the first navigation waits until bootstrapping is finished before continuing
 * to the activation phase.
 */
const BOOTSTRAP_DONE = new InjectionToken(NG_DEV_MODE ? 'bootstrap done indicator' : '', {
    factory: () => {
        return new Subject();
    }
});
function provideEnabledBlockingInitialNavigation() {
    return [
        { provide: INITIAL_NAVIGATION, useValue: 'enabledBlocking' },
        {
            provide: APP_INITIALIZER,
            multi: true,
            deps: [Injector],
            useFactory: (injector) => {
                const locationInitialized = injector.get(LOCATION_INITIALIZED, Promise.resolve(null));
                let initNavigation = false;
                /**
                 * Performs the given action once the router finishes its next/current navigation.
                 *
                 * If the navigation is canceled or errors without a redirect, the navigation is considered
                 * complete. If the `NavigationEnd` event emits, the navigation is also considered complete.
                 */
                function afterNextNavigation(action) {
                    const router = injector.get(Router);
                    router.events
                        .pipe(filter((e) => e instanceof NavigationEnd || e instanceof NavigationCancel ||
                        e instanceof NavigationError), map(e => {
                        if (e instanceof NavigationEnd) {
                            // Navigation assumed to succeed if we get `ActivationStart`
                            return true;
                        }
                        const redirecting = e instanceof NavigationCancel ?
                            (e.code === 0 /* NavigationCancellationCode.Redirect */ ||
                                e.code === 1 /* NavigationCancellationCode.SupersededByNewNavigation */) :
                            false;
                        return redirecting ? null : false;
                    }), filter((result) => result !== null), take(1))
                        .subscribe(() => {
                        action();
                    });
                }
                return () => {
                    return locationInitialized.then(() => {
                        return new Promise(resolve => {
                            const router = injector.get(Router);
                            const bootstrapDone = injector.get(BOOTSTRAP_DONE);
                            afterNextNavigation(() => {
                                // Unblock APP_INITIALIZER in case the initial navigation was canceled or errored
                                // without a redirect.
                                resolve(true);
                                initNavigation = true;
                            });
                            router.afterPreactivation = () => {
                                // Unblock APP_INITIALIZER once we get to `afterPreactivation`. At this point, we
                                // assume activation will complete successfully (even though this is not
                                // guaranteed).
                                resolve(true);
                                // only the initial navigation should be delayed until bootstrapping is done.
                                if (!initNavigation) {
                                    return bootstrapDone.closed ? of(void 0) : bootstrapDone;
                                    // subsequent navigations should not be delayed
                                }
                                else {
                                    return of(void 0);
                                }
                            };
                            router.initialNavigation();
                        });
                    });
                };
            }
        },
    ];
}
const INITIAL_NAVIGATION = new InjectionToken(NG_DEV_MODE ? 'initial navigation' : '');
function provideDisabledInitialNavigation() {
    return [
        {
            provide: APP_INITIALIZER,
            multi: true,
            useFactory: () => {
                const router = inject(Router);
                return () => {
                    router.setUpLocationChangeListener();
                };
            }
        },
        { provide: INITIAL_NAVIGATION, useValue: 'disabled' }
    ];
}
function provideTracing() {
    if (NG_DEV_MODE) {
        return [{
                provide: ENVIRONMENT_INITIALIZER,
                multi: true,
                useFactory: () => {
                    const router = inject(Router);
                    return () => router.events.subscribe((e) => {
                        var _a, _b;
                        // tslint:disable:no-console
                        (_a = console.group) === null || _a === void 0 ? void 0 : _a.call(console, `Router Event: ${e.constructor.name}`);
                        console.log(stringifyEvent(e));
                        console.log(e);
                        (_b = console.groupEnd) === null || _b === void 0 ? void 0 : _b.call(console);
                        // tslint:enable:no-console
                    });
                }
            }];
    }
    else {
        return [];
    }
}
function providePreloading(preloadingStrategy) {
    return [
        RouterPreloader,
        { provide: ROUTER_PRELOADER, useExisting: RouterPreloader },
        { provide: PreloadingStrategy, useExisting: preloadingStrategy },
    ];
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @publicApi
 */
const VERSION = new Version('14.1.0');

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// This file only reexports content of the `src` folder. Keep it that way.

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Generated bundle index. Do not edit.
 */

export { ActivatedRoute, ActivatedRouteSnapshot, ActivationEnd, ActivationStart, BaseRouteReuseStrategy, ChildActivationEnd, ChildActivationStart, ChildrenOutletContexts, DefaultTitleStrategy, DefaultUrlSerializer, GuardsCheckEnd, GuardsCheckStart, NavigationCancel, NavigationEnd, NavigationError, NavigationStart, NoPreloading, OutletContext, PRIMARY_OUTLET, PreloadAllModules, PreloadingStrategy, ROUTER_CONFIGURATION, ROUTER_INITIALIZER, ROUTES, ResolveEnd, ResolveStart, RouteConfigLoadEnd, RouteConfigLoadStart, RouteReuseStrategy, Router, RouterEvent, RouterLink, RouterLinkActive, RouterLinkWithHref, RouterModule, RouterOutlet, RouterPreloader, RouterState, RouterStateSnapshot, RoutesRecognized, Scroll, TitleStrategy, UrlHandlingStrategy, UrlSegment, UrlSegmentGroup, UrlSerializer, UrlTree, VERSION, convertToParamMap, createUrlTreeFromSnapshot, provideRoutes, ɵEmptyOutletComponent, ROUTER_PROVIDERS as ɵROUTER_PROVIDERS, assignExtraOptionsToRouter as ɵassignExtraOptionsToRouter, flatten as ɵflatten, providePreloading as ɵprovidePreloading };
//# sourceMappingURL=router.mjs.map
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                AsyncTestZoneSpec(namePrefix, trackPendingRequestAnimationFrame, macroTaskOptions) {
                if (trackPendingRequestAnimationFrame === void 0) { trackPendingRequestAnimationFrame = false; }
                this.trackPendingRequestAnimationFrame = trackPendingRequestAnimationFrame;
                this.macroTaskOptions = macroTaskOptions;
                this._scheduler = new Scheduler();
                this._microtasks = [];
                this._lastError = null;
                this._uncaughtPromiseErrors = Promise[Zone.__symbol__('uncaughtPromiseErrors')];
                this.pendingPeriodicTimers = [];
                this.pendingTimers = [];
                this.patchDateLocked = false;
                this.properties = { 'FakeAsyncTestZoneSpec': this };
                this.name = 'fakeAsyncTestZone for ' + namePrefix;
                // in case user can't access the construction of FakeAsyncTestSpec
                // user can also define macroTaskOptions by define a global variable.
                if (!this.macroTaskOptions) {
                    this.macroTaskOptions = global[Zone.__symbol__('FakeAsyncTestMacroTask')];
                }
            }
            FakeAsyncTestZoneSpec.assertInZone = function () {
                if (Zone.current.get('FakeAsyncTestZoneSpec') == null) {
                    throw new Error('The code should be running in the fakeAsync zone to call this function');
                }
            };
            FakeAsyncTestZoneSpec.prototype._fnAndFlush = function (fn, completers) {
                var _this = this;
                return function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    fn.apply(global, args);
                    if (_this._lastError === null) { // Success
                        if (completers.onSuccess != null) {
                            completers.onSuccess.apply(global);
                        }
                        // Flush microtasks only on success.
                        _this.flushMicrotasks();
                    }
                    else { // Failure
                        if (completers.onError != null) {
                            completers.onError.apply(global);
                        }
                    }
                    // Return true if there were no errors, false otherwise.
                    return _this._lastError === null;
                };
            };
            FakeAsyncTestZoneSpec._removeTimer = function (timers, id) {
                var index = timers.indexOf(id);
                if (index > -1) {
                    timers.splice(index, 1);
                }
            };
            FakeAsyncTestZoneSpec.prototype._dequeueTimer = function (id) {
                var _this = this;
                return function () {
                    FakeAsyncTestZoneSpec._removeTimer(_this.pendingTimers, id);
                };
            };
            FakeAsyncTestZoneSpec.prototype._requeuePeriodicTimer = function (fn, interval, args, id) {
                var _this = this;
                return function () {
                    // Requeue the timer callback if it's not been canceled.
                    if (_this.pendingPeriodicTimers.indexOf(id) !== -1) {
                        _this._scheduler.scheduleFunction(fn, interval, { args: args, isPeriodic: true, id: id, isRequeuePeriodic: true });
                    }
                };
            };
            FakeAsyncTestZoneSpec.prototype._dequeuePeriodicTimer = function (id) {
                var _this = this;
                return function () {
                    FakeAsyncTestZoneSpec._removeTimer(_this.pendingPeriodicTimers, id);
                };
            };
            FakeAsyncTestZoneSpec.prototype._setTimeout = function (fn, delay, args, isTimer) {
                if (isTimer === void 0) { isTimer = true; }
                var removeTimerFn = this._dequeueTimer(Scheduler.nextId);
                // Queue the callback and dequeue the timer on success and error.
                var cb = this._fnAndFlush(fn, { onSuccess: removeTimerFn, onError: removeTimerFn });
                var id = this._scheduler.scheduleFunction(cb, delay, { args: args, isRequestAnimationFrame: !isTimer });
                if (isTimer) {
                    this.pendingTimers.push(id);
                }
                return id;
            };
            FakeAsyncTestZoneSpec.prototype._clearTimeout = function (id) {
                FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);
                this._scheduler.removeScheduledFunctionWithId(id);
            };
            FakeAsyncTestZoneSpec.prototype._setInterval = function (fn, interval, args) {
                var id = Scheduler.nextId;
                var completers = { onSuccess: null, onError: this._dequeuePeriodicTimer(id) };
                var cb = this._fnAndFlush(fn, completers);
                // Use the callback created above to requeue on success.
                completers.onSuccess = this._requeuePeriodicTimer(cb, interval, args, id);
                // Queue the callback and dequeue the periodic timer only on error.
                this._scheduler.scheduleFunction(cb, interval, { args: args, isPeriodic: true });
                this.pendingPeriodicTimers.push(id);
                return id;
            };
            FakeAsyncTestZoneSpec.prototype._clearInterval = function (id) {
                FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);
                this._scheduler.removeScheduledFunctionWithId(id);
            };
            FakeAsyncTestZoneSpec.prototype._resetLastErrorAndThrow = function () {
                var error = this._lastError || this._uncaughtPromiseErrors[0];
                this._uncaughtPromiseErrors.length = 0;
                this._lastError = null;
                throw error;
            };
            FakeAsyncTestZoneSpec.prototype.getCurrentTickTime = function () {
                return this._scheduler.getCurrentTickTime();
            };
            FakeAsyncTestZoneSpec.prototype.getFakeSystemTime = function () {
                return this._scheduler.getFakeSystemTime();
            };
            FakeAsyncTestZoneSpec.prototype.setFakeBaseSystemTime = function (realTime) {
                this._scheduler.setFakeBaseSystemTime(realTime);
            };
            FakeAsyncTestZoneSpec.prototype.getRealSystemTime = function () {
                return this._scheduler.getRealSystemTime();
            };
            FakeAsyncTestZoneSpec.patchDate = function () {
                if (!!global[Zone.__symbol__('disableDatePatching')]) {
                    // we don't want to patch global Date
                    // because in some case, global Date
                    // is already being patched, we need to provide
                    // an option to let user still use their
                    // own version of Date.
                    return;
                }
                if (global['Date'] === FakeDate) {
                    // already patched
                    return;
                }
                global['Date'] = FakeDate;
                FakeDate.prototype = OriginalDate.prototype;
                // try check and reset timers
                // because jasmine.clock().install() may
                // have replaced the global timer
                FakeAsyncTestZoneSpec.checkTimerPatch();
            };
            FakeAsyncTestZoneSpec.resetDate = function () {
                if (global['Date'] === FakeDate) {
                    global['Date'] = OriginalDate;
                }
            };
            FakeAsyncTestZoneSpec.checkTimerPatch = function () {
                if (global.setTimeout !== timers.setTimeout) {
                    global.setTimeout = timers.setTimeout;
                    global.clearTimeout = timers.clearTimeout;
                }
                if (global.setInterval !== timers.setInterval) {
                    global.setInterval = timers.setInterval;
                    global.clearInterval = timers.clearInterval;
                }
            };
            FakeAsyncTestZoneSpec.prototype.lockDatePatch = function () {
                this.patchDateLocked = true;
                FakeAsyncTestZoneSpec.patchDate();
            };
            FakeAsyncTestZoneSpec.prototype.unlockDatePatch = function () {
                this.patchDateLocked = false;
                FakeAsyncTestZoneSpec.resetDate();
            };
            FakeAsyncTestZoneSpec.prototype.tickToNext = function (steps, doTick, tickOptions) {
                if (steps === void 0) { steps = 1; }
                if (tickOptions === void 0) { tickOptions = { processNewMacroTasksSynchronously: true }; }
                if (steps <= 0) {
                    return;
                }
                FakeAsyncTestZoneSpec.assertInZone();
                this.flushMicrotasks();
                this._scheduler.tickToNext(steps, doTick, tickOptions);
                if (this._lastError !== null) {
                    this._resetLastErrorAndThrow();
                }
            };
            FakeAsyncTestZoneSpec.prototype.tick = function (millis, doTick, tickOptions) {
                if (millis === void 0) { millis = 0; }
                if (tickOptions === void 0) { tickOptions = { processNewMacroTasksSynchronously: true }; }
                FakeAsyncTestZoneSpec.assertInZone();
                this.flushMicrotasks();
                this._scheduler.tick(millis, doTick, tickOptions);
                if (this._lastError !== null) {
                    this._resetLastErrorAndThrow();
                }
            };
            FakeAsyncTestZoneSpec.prototype.flushMicrotasks = function () {
                var _this = this;
                FakeAsyncTestZoneSpec.assertInZone();
                var flushErrors = function () {
                    if (_this._lastError !== null || _this._uncaughtPromiseErrors.length) {
                        // If there is an error stop processing the microtask queue and rethrow the error.
                        _this._resetLastErrorAndThrow();
                    }
                };
                while (this._microtasks.length > 0) {
                    var microtask = this._microtasks.shift();
                    microtask.func.apply(microtask.target, microtask.args);
                }
                flushErrors();
            };
            FakeAsyncTestZoneSpec.prototype.flush = function (limit, flushPeriodic, doTick) {
                FakeAsyncTestZoneSpec.assertInZone();
                this.flushMicrotasks();
                var elapsed = this._scheduler.flush(limit, flushPeriodic, doTick);
                if (this._lastError !== null) {
                    this._resetLastErrorAndThrow();
                }
                return elapsed;
            };
            FakeAsyncTestZoneSpec.prototype.flushOnlyPendingTimers = function (doTick) {
                FakeAsyncTestZoneSpec.assertInZone();
                this.flushMicrotasks();
                var elapsed = this._scheduler.flushOnlyPendingTimers(doTick);
                if (this._lastError !== null) {
                    this._resetLastErrorAndThrow();
                }
                return elapsed;
            };
            FakeAsyncTestZoneSpec.prototype.removeAllTimers = function () {
                FakeAsyncTestZoneSpec.assertInZone();
                this._scheduler.removeAll();
                this.pendingPeriodicTimers = [];
                this.pendingTimers = [];
            };
            FakeAsyncTestZoneSpec.prototype.getTimerCount = function () {
                return this._scheduler.getTimerCount() + this._microtasks.length;
            };
            FakeAsyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {
                switch (task.type) {
                    case 'microTask':
                        var args = task.data && task.data.args;
                        // should pass additional arguments to callback if have any
                        // currently we know process.nextTick will have such additional
                        // arguments
                        var additionalArgs = void 0;
                        if (args) {
                            var callbackIndex = task.data.cbIdx;
                            if (typeof args.length === 'number' && args.length > callbackIndex + 1) {
                                additionalArgs = Array.prototype.slice.call(args, callbackIndex + 1);
                            }
                        }
                        this._microtasks.push({
                            func: task.invoke,
                            args: additionalArgs,
                            target: task.data && task.data.target
                        });
                        break;
                    case 'macroTask':
                        switch (task.source) {
                            case 'setTimeout':
                                task.data['handleId'] = this._setTimeout(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));
                                break;
                            case 'setImmediate':
                                task.data['handleId'] = this._setTimeout(task.invoke, 0, Array.prototype.slice.call(task.data['args'], 1));
                                break;
                            case 'setInterval':
                                task.data['handleId'] = this._setInterval(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));
                                break;
                            case 'XMLHttpRequest.send':
                                throw new Error('Cannot make XHRs from within a fake async test. Request URL: ' +
                                    task.data['url']);
                            case 'requestAnimationFrame':
                            case 'webkitRequestAnimationFrame':
                            case 'mozRequestAnimationFrame':
                                // Simulate a requestAnimationFrame by using a setTimeout with 16 ms.
                                // (60 frames per second)
                                task.data['handleId'] = this._setTimeout(task.invoke, 16, task.data['args'], this.trackPendingRequestAnimationFrame);
                                break;
                            default:
                                // user can define which macroTask they want to support by passing
                                // macroTaskOptions
                                var macroTaskOption = this.findMacroTaskOption(task);
                                if (macroTaskOption) {
                                    var args_1 = task.data && task.data['args'];
                                    var delay = args_1 && args_1.length > 1 ? args_1[1] : 0;
                                    var callbackArgs = macroTaskOption.callbackArgs ? macroTaskOption.callbackArgs : args_1;
                                    if (!!macroTaskOption.isPeriodic) {
                                        // periodic macroTask, use setInterval to simulate
                                        task.data['handleId'] = this._setInterval(task.invoke, delay, callbackArgs);
                                        task.data.isPeriodic = true;
                                    }
                                    else {
                                        // not periodic, use setTimeout to simulate
                                        task.data['handleId'] = this._setTimeout(task.invoke, delay, callbackArgs);
                                    }
                                    break;
                                }
                                throw new Error('Unknown macroTask scheduled in fake async test: ' + task.source);
                        }
                        break;
                    case 'eventTask':
                        task = delegate.scheduleTask(target, task);
                        break;
                }
                return task;
            };
            FakeAsyncTestZoneSpec.prototype.onCancelTask = function (delegate, current, target, task) {
                switch (task.source) {
                    case 'setTimeout':
                    case 'requestAnimationFrame':
                    case 'webkitRequestAnimationFrame':
                    case 'mozRequestAnimationFrame':
                        return this._clearTimeout(task.data['handleId']);
                    case 'setInterval':
                        return this._clearInterval(task.data['handleId']);
                    default:
                        // user can define which macroTask they want to support by passing
                        // macroTaskOptions
                        var macroTaskOption = this.findMacroTaskOption(task);
                        if (macroTaskOption) {
                            var handleId = task.data['handleId'];
                            return macroTaskOption.isPeriodic ? this._clearInterval(handleId) :
                                this._clearTimeout(handleId);
                        }
                        return delegate.cancelTask(target, task);
                }
            };
            FakeAsyncTestZoneSpec.prototype.onInvoke = function (delegate, current, target, callback, applyThis, applyArgs, source) {
                try {
                    FakeAsyncTestZoneSpec.patchDate();
                    return delegate.invoke(target, callback, applyThis, applyArgs, source);
                }
                finally {
                    if (!this.patchDateLocked) {
                        FakeAsyncTestZoneSpec.resetDate();
                    }
                }
            };
            FakeAsyncTestZoneSpec.prototype.findMacroTaskOption = function (task) {
                if (!this.macroTaskOptions) {
                    return null;
                }
                for (var i = 0; i < this.macroTaskOptions.length; i++) {
                    var macroTaskOption = this.macroTaskOptions[i];
                    if (macroTaskOption.source === task.source) {
                        return macroTaskOption;
                    }
                }
                return null;
            };
            FakeAsyncTestZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {
                this._lastError = error;
                return false; // Don't propagate error to parent zone.
            };
            return FakeAsyncTestZoneSpec;
        }());
        // Export the class so that new instances can be created with proper
        // constructor params.
        Zone['FakeAsyncTestZoneSpec'] = FakeAsyncTestZoneSpec;
    })(typeof window === 'object' && window || typeof self === 'object' && self || global);
    Zone.__load_patch('fakeasync', function (global, Zone, api) {
        var FakeAsyncTestZoneSpec = Zone && Zone['FakeAsyncTestZoneSpec'];
        function getProxyZoneSpec() {
            return Zone && Zone['ProxyZoneSpec'];
        }
        var _fakeAsyncTestZoneSpec = null;
        /**
         * Clears out the shared fake async zone for a test.
         * To be called in a global `beforeEach`.
         *
         * @experimental
         */
        function resetFakeAsyncZone() {
            if (_fakeAsyncTestZoneSpec) {
                _fakeAsyncTestZoneSpec.unlockDatePatch();
            }
            _fakeAsyncTestZoneSpec = null;
            // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.
            getProxyZoneSpec() && getProxyZoneSpec().assertPresent().resetDelegate();
        }
        /**
         * Wraps a function to be executed in the fakeAsync zone:
         * - microtasks are manually executed by calling `flushMicrotasks()`,
         * - timers are synchronous, `tick()` simulates the asynchronous passage of time.
         *
         * If there are any pending timers at the end of the function, an exception will be thrown.
         *
         * Can be used to wrap inject() calls.
         *
         * ## Example
         *
         * {@example core/testing/ts/fake_async.ts region='basic'}
         *
         * @param fn
         * @returns The function wrapped to be executed in the fakeAsync zone
         *
         * @experimental
         */
        function fakeAsync(fn) {
            // Not using an arrow function to preserve context passed from call site
            var fakeAsyncFn = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var ProxyZoneSpec = getProxyZoneSpec();
                if (!ProxyZoneSpec) {
                    throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' +
                        'Please make sure that your environment includes zone.js/plugins/proxy');
                }
                var proxyZoneSpec = ProxyZoneSpec.assertPresent();
                if (Zone.current.get('FakeAsyncTestZoneSpec')) {
                    throw new Error('fakeAsync() calls can not be nested');
                }
                try {
                    // in case jasmine.clock init a fakeAsyncTestZoneSpec
                    if (!_fakeAsyncTestZoneSpec) {
                        if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {
                            throw new Error('fakeAsync() calls can not be nested');
                        }
                        _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();
                    }
                    var res = void 0;
                    var lastProxyZoneSpec = proxyZoneSpec.getDelegate();
                    proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);
                    _fakeAsyncTestZoneSpec.lockDatePatch();
                    try {
                        res = fn.apply(this, args);
                        flushMicrotasks();
                    }
                    finally {
                        proxyZoneSpec.setDelegate(lastProxyZoneSpec);
                    }
                    if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {
                        throw new Error("".concat(_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length, " ") +
                            "periodic timer(s) still in the queue.");
                    }
                    if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {
                        throw new Error("".concat(_fakeAsyncTestZoneSpec.pendingTimers.length, " timer(s) still in the queue."));
                    }
                    return res;
                }
                finally {
                    resetFakeAsyncZone();
                }
            };
            fakeAsyncFn.isFakeAsync = true;
            return fakeAsyncFn;
        }
        function _getFakeAsyncZoneSpec() {
            if (_fakeAsyncTestZoneSpec == null) {
                _fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');
                if (_fakeAsyncTestZoneSpec == null) {
                    throw new Error('The code should be running in the fakeAsync zone to call this function');
                }
            }
            return _fakeAsyncTestZoneSpec;
        }
        /**
         * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.
         *
         * The microtasks queue is drained at the very start of this function and after any timer callback
         * has been executed.
         *
         * ## Example
         *
         * {@example core/testing/ts/fake_async.ts region='basic'}
         *
         * @experimental
         */
        function tick(millis, ignoreNestedTimeout) {
            if (millis === void 0) { millis = 0; }
            if (ignoreNestedTimeout === void 0) { ignoreNestedTimeout = false; }
            _getFakeAsyncZoneSpec().tick(millis, null, ignoreNestedTimeout);
        }
        /**
         * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by
         * draining the macrotask queue until it is empty. The returned value is the milliseconds
         * of time that would have been elapsed.
         *
         * @param maxTurns
         * @returns The simulated time elapsed, in millis.
         *
         * @experimental
         */
        function flush(maxTurns) {
            return _getFakeAsyncZoneSpec().flush(maxTurns);
        }
        /**
         * Discard all remaining periodic tasks.
         *
         * @experimental
         */
        function discardPeriodicTasks() {
            var zoneSpec = _getFakeAsyncZoneSpec();
            zoneSpec.pendingPeriodicTimers;
            zoneSpec.pendingPeriodicTimers.length = 0;
        }
        /**
         * Flush any pending microtasks.
         *
         * @experimental
         */
        function flushMicrotasks() {
            _getFakeAsyncZoneSpec().flushMicrotasks();
        }
        Zone[api.symbol('fakeAsyncTest')] =
            { resetFakeAsyncZone: resetFakeAsyncZone, flushMicrotasks: flushMicrotasks, discardPeriodicTasks: discardPeriodicTasks, tick: tick, flush: flush, fakeAsync: fakeAsync };
    }, true);
    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Promise for async/fakeAsync zoneSpec test
     * can support async operation which not supported by zone.js
     * such as
     * it ('test jsonp in AsyncZone', async() => {
     *   new Promise(res => {
     *     jsonp(url, (data) => {
     *       // success callback
     *       res(data);
     *     });
     *   }).then((jsonpResult) => {
     *     // get jsonp result.
     *
     *     // user will expect AsyncZoneSpec wait for
     *     // then, but because jsonp is not zone aware
     *     // AsyncZone will finish before then is called.
     *   });
     * });
     */
    Zone.__load_patch('promisefortest', function (global, Zone, api) {
        var symbolState = api.symbol('state');
        var UNRESOLVED = null;
        var symbolParentUnresolved = api.symbol('parentUnresolved');
        // patch Promise.prototype.then to keep an internal
        // number for tracking unresolved chained promise
        // we will decrease this number when the parent promise
        // being resolved/rejected and chained promise was
        // scheduled as a microTask.
        // so we can know such kind of chained promise still
        // not resolved in AsyncTestZone
        Promise[api.symbol('patchPromiseForTest')] = function patchPromiseForTest() {
            var oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];
            if (oriThen) {
                return;
            }
            oriThen = Promise[Zone.__symbol__('ZonePromiseThen')] = Promise.prototype.then;
            Promise.prototype.then = function () {
                var chained = oriThen.apply(this, arguments);
                if (this[symbolState] === UNRESOLVED) {
                    // parent promise is unresolved.
                    var asyncTestZoneSpec = Zone.current.get('AsyncTestZoneSpec');
                    if (asyncTestZoneSpec) {
                        asyncTestZoneSpec.unresolvedChainedPromiseCount++;
                        chained[symbolParentUnresolved] = true;
                    }
                }
                return chained;
            };
        };
        Promise[api.symbol('unPatchPromiseForTest')] = function unpatchPromiseForTest() {
            // restore origin then
            var oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];
            if (oriThen) {
                Promise.prototype.then = oriThen;
                Promise[Zone.__symbol__('ZonePromiseThen')] = undefined;
            }
        };
    });
}));
                                                                                                                                                                                                                                                                                                                                                       tInt64(sp + 8);\n                  const p = getInt64(sp + 16);\n                  const n = this.mem.getInt32(sp + 24, true);\n                  globalThis.fs.writeSync(fd, new Uint8Array(this._inst.exports.mem.buffer, p, n));\n                },\n                "runtime.resetMemoryDataView": (sp) => {\n                  sp >>>= 0;\n                  this.mem = new DataView(this._inst.exports.mem.buffer);\n                },\n                "runtime.nanotime1": (sp) => {\n                  sp >>>= 0;\n                  setInt64(sp + 8, (timeOrigin + performance.now()) * 1e6);\n                },\n                "runtime.walltime": (sp) => {\n                  sp >>>= 0;\n                  const msec = new Date().getTime();\n                  setInt64(sp + 8, msec / 1e3);\n                  this.mem.setInt32(sp + 16, msec % 1e3 * 1e6, true);\n                },\n                "runtime.scheduleTimeoutEvent": (sp) => {\n                  sp >>>= 0;\n                  const id = this._nextCallbackTimeoutID;\n                  this._nextCallbackTimeoutID++;\n                  this._scheduledTimeouts.set(id, setTimeout(() => {\n                    this._resume();\n                    while (this._scheduledTimeouts.has(id)) {\n                      console.warn("scheduleTimeoutEvent: missed timeout event");\n                      this._resume();\n                    }\n                  }, getInt64(sp + 8) + 1));\n                  this.mem.setInt32(sp + 16, id, true);\n                },\n                "runtime.clearTimeoutEvent": (sp) => {\n                  sp >>>= 0;\n                  const id = this.mem.getInt32(sp + 8, true);\n                  clearTimeout(this._scheduledTimeouts.get(id));\n                  this._scheduledTimeouts.delete(id);\n                },\n                "runtime.getRandomData": (sp) => {\n                  sp >>>= 0;\n                  crypto.getRandomValues(loadSlice(sp + 8));\n                },\n                "syscall/js.finalizeRef": (sp) => {\n                  sp >>>= 0;\n                  const id = this.mem.getUint32(sp + 8, true);\n                  this._goRefCounts[id]--;\n                  if (this._goRefCounts[id] === 0) {\n                    const v = this._values[id];\n                    this._values[id] = null;\n                    this._ids.delete(v);\n                    this._idPool.push(id);\n                  }\n                },\n                "syscall/js.stringVal": (sp) => {\n                  sp >>>= 0;\n                  storeValue(sp + 24, loadString(sp + 8));\n                },\n                "syscall/js.valueGet": (sp) => {\n                  sp >>>= 0;\n                  const result = Reflect.get(loadValue(sp + 8), loadString(sp + 16));\n                  sp = this._inst.exports.getsp() >>> 0;\n                  storeValue(sp + 32, result);\n                },\n                "syscall/js.valueSet": (sp) => {\n                  sp >>>= 0;\n                  Reflect.set(loadValue(sp + 8), loadString(sp + 16), loadValue(sp + 32));\n                },\n                "syscall/js.valueDelete": (sp) => {\n                  sp >>>= 0;\n                  Reflect.deleteProperty(loadValue(sp + 8), loadString(sp + 16));\n                },\n                "syscall/js.valueIndex": (sp) => {\n                  sp >>>= 0;\n                  storeValue(sp + 24, Reflect.get(loadValue(sp + 8), getInt64(sp + 16)));\n                },\n                "syscall/js.valueSetIndex": (sp) => {\n                  sp >>>= 0;\n                  Reflect.set(loadValue(sp + 8), getInt64(sp + 16), loadValue(sp + 24));\n                },\n                "syscall/js.valueCall": (sp) => {\n                  sp >>>= 0;\n                  try {\n                    const v = loadValue(sp + 8);\n                    const m = Reflect.get(v, loadString(sp + 16));\n                    const args = loadSliceOfValues(sp + 32);\n                    const result = Reflect.apply(m, v, args);\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 56, result);\n                    this.mem.setUint8(sp + 64, 1);\n                  } catch (err) {\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 56, err);\n                    this.mem.setUint8(sp + 64, 0);\n                  }\n                },\n                "syscall/js.valueInvoke": (sp) => {\n                  sp >>>= 0;\n                  try {\n                    const v = loadValue(sp + 8);\n                    const args = loadSliceOfValues(sp + 16);\n                    const result = Reflect.apply(v, void 0, args);\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 40, result);\n                    this.mem.setUint8(sp + 48, 1);\n                  } catch (err) {\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 40, err);\n                    this.mem.setUint8(sp + 48, 0);\n                  }\n                },\n                "syscall/js.valueNew": (sp) => {\n                  sp >>>= 0;\n                  try {\n                    const v = loadValue(sp + 8);\n                    const args = loadSliceOfValues(sp + 16);\n                    const result = Reflect.construct(v, args);\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 40, result);\n                    this.mem.setUint8(sp + 48, 1);\n                  } catch (err) {\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 40, err);\n                    this.mem.setUint8(sp + 48, 0);\n                  }\n                },\n                "syscall/js.valueLength": (sp) => {\n                  sp >>>= 0;\n                  setInt64(sp + 16, parseInt(loadValue(sp + 8).length));\n                },\n                "syscall/js.valuePrepareString": (sp) => {\n                  sp >>>= 0;\n                  const str = encoder.encode(String(loadValue(sp + 8)));\n                  storeValue(sp + 16, str);\n                  setInt64(sp + 24, str.length);\n                },\n                "syscall/js.valueLoadString": (sp) => {\n                  sp >>>= 0;\n                  const str = loadValue(sp + 8);\n                  loadSlice(sp + 16).set(str);\n                },\n                "syscall/js.valueInstanceOf": (sp) => {\n                  sp >>>= 0;\n                  this.mem.setUint8(sp + 24, loadValue(sp + 8) instanceof loadValue(sp + 16) ? 1 : 0);\n                },\n                "syscall/js.copyBytesToGo": (sp) => {\n                  sp >>>= 0;\n                  const dst = loadSlice(sp + 8);\n                  const src = loadValue(sp + 32);\n                  if (!(src instanceof Uint8Array || src instanceof Uint8ClampedArray)) {\n                    this.mem.setUint8(sp + 48, 0);\n                    return;\n                  }\n                  const toCopy = src.subarray(0, dst.length);\n                  dst.set(toCopy);\n                  setInt64(sp + 40, toCopy.length);\n                  this.mem.setUint8(sp + 48, 1);\n                },\n                "syscall/js.copyBytesToJS": (sp) => {\n                  sp >>>= 0;\n                  const dst = loadValue(sp + 8);\n                  const src = loadSlice(sp + 16);\n                  if (!(dst instanceof Uint8Array || dst instanceof Uint8ClampedArray)) {\n                    this.mem.setUint8(sp + 48, 0);\n                    return;\n                  }\n                  const toCopy = src.subarray(0, dst.length);\n                  dst.set(toCopy);\n                  setInt64(sp + 40, toCopy.length);\n                  this.mem.setUint8(sp + 48, 1);\n                },\n                "debug": (value) => {\n                  console.log(value);\n                }\n              }\n            };\n          }\n          async run(instance) {\n            if (!(instance instanceof WebAssembly.Instance)) {\n              throw new Error("Go.run: WebAssembly.Instance expected");\n            }\n            this._inst = instance;\n            this.mem = new DataView(this._inst.exports.mem.buffer);\n            this._values = [\n              NaN,\n              0,\n              null,\n              true,\n              false,\n              globalThis,\n              this\n            ];\n            this._goRefCounts = new Array(this._values.length).fill(Infinity);\n            this._ids = /* @__PURE__ */ new Map([\n              [0, 1],\n              [null, 2],\n              [true, 3],\n              [false, 4],\n              [globalThis, 5],\n              [this, 6]\n            ]);\n            this._idPool = [];\n            this.exited = false;\n            let offset = 4096;\n            const strPtr = (str) => {\n              const ptr = offset;\n              const bytes = encoder.encode(str + "\\0");\n              new Uint8Array(this.mem.buffer, offset, bytes.length).set(bytes);\n              offset += bytes.length;\n              if (offset % 8 !== 0) {\n                offset += 8 - offset % 8;\n              }\n              return ptr;\n            };\n            const argc = this.argv.length;\n            const argvPtrs = [];\n            this.argv.forEach((arg) => {\n              argvPtrs.push(strPtr(arg));\n            });\n            argvPtrs.push(0);\n            const keys = Object.keys(this.env).sort();\n            keys.forEach((key) => {\n              argvPtrs.push(strPtr(`${key}=${this.env[key]}`));\n            });\n            argvPtrs.push(0);\n            const argv = offset;\n            argvPtrs.forEach((ptr) => {\n              this.mem.setUint32(offset, ptr, true);\n              this.mem.setUint32(offset + 4, 0, true);\n              offset += 8;\n            });\n            const wasmMinDataAddr = 4096 + 8192;\n            if (offset >= wasmMinDataAddr) {\n              throw new Error("total length of command line and environment variables exceeds limit");\n            }\n            this._inst.exports.run(argc, argv);\n            if (this.exited) {\n              this._resolveExitPromise();\n            }\n            await this._exitPromise;\n          }\n          _resume() {\n            if (this.exited) {\n              throw new Error("Go program has already exited");\n            }\n            this._inst.exports.resume();\n            if (this.exited) {\n              this._resolveExitPromise();\n            }\n          }\n          _makeFuncWrapper(id) {\n            const go = this;\n            return function() {\n              const event = { id, this: this, args: arguments };\n              go._pendingEvent = event;\n              go._resume();\n              return event.result;\n            };\n          }\n        };\n      })();\n      onmessage = ({ data: wasm }) => {\n        let decoder = new TextDecoder();\n        let fs = globalThis.fs;\n        let stderr = "";\n        fs.writeSync = (fd, buffer) => {\n          if (fd === 1) {\n            postMessage(buffer);\n          } else if (fd === 2) {\n            stderr += decoder.decode(buffer);\n            let parts = stderr.split("\\n");\n            if (parts.length > 1)\n              console.log(parts.slice(0, -1).join("\\n"));\n            stderr = parts[parts.length - 1];\n          } else {\n            throw new Error("Bad write");\n          }\n          return buffer.length;\n        };\n        let stdin = [];\n        let resumeStdin;\n        let stdinPos = 0;\n        onmessage = ({ data }) => {\n          if (data.length > 0) {\n            stdin.push(data);\n            if (resumeStdin)\n              resumeStdin();\n          }\n        };\n        fs.read = (fd, buffer, offset, length, position, callback) => {\n          if (fd !== 0 || offset !== 0 || length !== buffer.length || position !== null) {\n            throw new Error("Bad read");\n          }\n          if (stdin.length === 0) {\n            resumeStdin = () => fs.read(fd, buffer, offset, length, position, callback);\n            return;\n          }\n          let first = stdin[0];\n          let count = Math.max(0, Math.min(length, first.length - stdinPos));\n          buffer.set(first.subarray(stdinPos, stdinPos + count), offset);\n          stdinPos += count;\n          if (stdinPos === first.length) {\n            stdin.shift();\n            stdinPos = 0;\n          }\n          callback(null, count);\n        };\n        let go = new globalThis.Go();\n        go.argv = ["", `--service=${"0.14.49"}`];\n        if (wasm instanceof WebAssembly.Module) {\n          WebAssembly.instantiate(wasm, go.importObject).then((instance) => go.run(instance));\n        } else {\n          WebAssembly.instantiate(wasm, go.importObject).then(({ instance }) => go.run(instance));\n        }\n      };\n      return (m) => onmessage(m);\n    })'}(postMessage)`], { type: "text/javascript" });
    worker = new Worker(URL.createObjectURL(blob));
  } else {
    let onmessage = ((postMessage) => {
      // Copyright 2018 The Go Authors. All rights reserved.
      // Use of this source code is governed by a BSD-style
      // license that can be found in the LICENSE file.
      let onmessage;
      let globalThis = {};
      for (let o = self; o; o = Object.getPrototypeOf(o))
        for (let k of Object.getOwnPropertyNames(o))
          if (!(k in globalThis))
            Object.defineProperty(globalThis, k, { get: () => self[k] });
      "use strict";
      (() => {
        const enosys = () => {
          const err = new Error("not implemented");
          err.code = "ENOSYS";
          return err;
        };
        if (!globalThis.fs) {
          let outputBuf = "";
          globalThis.fs = {
            constants: { O_WRONLY: -1, O_RDWR: -1, O_CREAT: -1, O_TRUNC: -1, O_APPEND: -1, O_EXCL: -1 },
            writeSync(fd, buf) {
              outputBuf += decoder.decode(buf);
              const nl = outputBuf.lastIndexOf("\n");
              if (nl != -1) {
                console.log(outputBuf.substr(0, nl));
                outputBuf = outputBuf.substr(nl + 1);
              }
              return buf.length;
            },
            write(fd, buf, offset, length, position, callback) {
              if (offset !== 0 || length !== buf.length || position !== null) {
                callback(enosys());
                return;
              }
              const n = this.writeSync(fd, buf);
              callback(null, n);
            },
            chmod(path, mode, callback) {
              callback(enosys());
            },
            chown(path, uid, gid, callback) {
              callback(enosys());
            },
            close(fd, callback) {
              callback(enosys());
            },
            fchmod(fd, mode, callback) {
              callback(enosys());
            },
            fchown(fd, uid, gid, callback) {
              callback(enosys());
            },
            fstat(fd, callback) {
              callback(enosys());
            },
            fsync(fd, callback) {
              callback(null);
            },
            ftruncate(fd, length, callback) {
              callback(enosys());
            },
            lchown(path, uid, gid, callback) {
              callback(enosys());
            },
            link(path, link, callback) {
              callback(enosys());
            },
            lstat(path, callback) {
              callback(enosys());
            },
            mkdir(path, perm, callback) {
              callback(enosys());
            },
            open(path, flags, mode, callback) {
              callback(enosys());
            },
            read(fd, buffer, offset, length, position, callback) {
              callback(enosys());
            },
            readdir(path, callback) {
              callback(enosys());
            },
            readlink(path, callback) {
              callback(enosys());
            },
            rename(from, to, callback) {
              callback(enosys());
            },
            rmdir(path, callback) {
              callback(enosys());
            },
            stat(path, callback) {
              callback(enosys());
            },
            symlink(path, link, callback) {
              callback(enosys());
            },
            truncate(path, length, callback) {
              callback(enosys());
            },
            unlink(path, callback) {
              callback(enosys());
            },
            utimes(path, atime, mtime, callback) {
              callback(enosys());
            }
          };
        }
        if (!globalThis.process) {
          globalThis.process = {
            getuid() {
              return -1;
            },
            getgid() {
              return -1;
            },
            geteuid() {
              return -1;
            },
            getegid() {
              return -1;
            },
            getgroups() {
              throw enosys();
            },
            pid: -1,
            ppid: -1,
            umask() {
              throw enosys();
            },
            cwd() {
              throw enosys();
            },
            chdir() {
              throw enosys();
            }
          };
        }
        if (!globalThis.crypto) {
          throw new Error("globalThis.crypto is not available, polyfill required (crypto.getRandomValues only)");
        }
        if (!globalThis.performance) {
          throw new Error("globalThis.performance is not available, polyfill required (performance.now only)");
        }
        if (!globalThis.TextEncoder) {
          throw new Error("globalThis.TextEncoder is not available, polyfill required");
        }
        if (!globalThis.TextDecoder) {
          throw new Error("globalThis.TextDecoder is not available, polyfill required");
        }
        const encoder = new TextEncoder("utf-8");
        const decoder = new TextDecoder("utf-8");
        globalThis.Go = class {
          constructor() {
            this.argv = ["js"];
            this.env = {};
            this.exit = (code) => {
              if (code !== 0) {
                console.warn("exit code:", code);
              }
            };
            this._exitPromise = new Promise((resolve) => {
              this._resolveExitPromise = resolve;
            });
            this._pendingEvent = null;
            this._scheduledTimeouts = /* @__PURE__ */ new Map();
            this._nextCallbackTimeoutID = 1;
            const setInt64 = (addr, v) => {
              this.mem.setUint32(addr + 0, v, true);
              this.mem.setUint32(addr + 4, Math.floor(v / 4294967296), true);
            };
            const getInt64 = (addr) => {
              const low = this.mem.getUint32(addr + 0, true);
              const high = this.mem.getInt32(addr + 4, true);
              return low + high * 4294967296;
            };
            const loadValue = (addr) => {
              const f = this.mem.getFloat64(addr, true);
              if (f === 0) {
                return void 0;
              }
              if (!isNaN(f)) {
                return f;
              }
              const id = this.mem.getUint32(addr, true);
              return this._values[id];
            };
            const storeValue = (addr, v) => {
              const nanHead = 2146959360;
              if (typeof v === "number" && v !== 0) {
                if (isNaN(v)) {
                  this.mem.setUint32(addr + 4, nanHead, true);
                  this.mem.setUint32(addr, 0, true);
                  return;
                }
                this.mem.setFloat64(addr, v, true);
                return;
              }
              if (v === void 0) {
                this.mem.setFloat64(addr, 0, true);
                return;
              }
              let id = this._ids.get(v);
              if (id === void 0) {
                id = this._idPool.pop();
                if (id === void 0) {
                  id = this._values.length;
                }
                this._values[id] = v;
                this._goRefCounts[id] = 0;
                this._ids.set(v, id);
              }
              this._goRefCounts[id]++;
              let typeFlag = 0;
              switch (typeof v) {
                case "object":
                  if (v !== null) {
                    typeFlag = 1;
                  }
                  break;
                case "string":
                  typeFlag = 2;
                  break;
                case "symbol":
                  typeFlag = 3;
                  break;
                case "function":
                  typeFlag = 4;
                  break;
              }
              this.mem.setUint32(addr + 4, nanHead | typeFlag, true);
              this.mem.setUint32(addr, id, true);
            };
            const loadSlice = (addr) => {
              const array = getInt64(addr + 0);
              const len = getInt64(addr + 8);
              return new Uint8Array(this._inst.exports.mem.buffer, array, len);
            };
            const loadSliceOfValues = (addr) => {
              const array = getInt64(addr + 0);
              const len = getInt64(addr + 8);
              const a = new Array(len);
              for (let i = 0; i < len; i++) {
                a[i] = loadValue(array + i * 8);
              }
              return a;
            };
            const loadString = (addr) => {
              const saddr = getInt64(addr + 0);
              const len = getInt64(addr + 8);
              return decoder.decode(new DataView(this._inst.exports.mem.buffer, saddr, len));
            };
            const timeOrigin = Date.now() - performance.now();
            this.importObject = {
              go: {
                "runtime.wasmExit": (sp) => {
                  sp >>>= 0;
                  const code = this.mem.getInt32(sp + 8, true);
                  this.exited = true;
                  delete this._inst;
                  delete this._values;
                  delete this._goRefCounts;
                  delete this._ids;
                  delete this._idPool;
                  this.exit(code);
                },
                "runtime.wasmWrite": (sp) => {
                  sp >>>= 0;
                  const fd = getInt64(sp + 8);
                  const p = getInt64(sp + 16);
                  const n = this.mem.getInt32(sp + 24, true);
                  globalThis.fs.writeSync(fd, new Uint8Array(this._inst.exports.mem.buffer, p, n));
                },
                "runtime.resetMemoryDataView": (sp) => {
                  sp >>>= 0;
                  this.mem = new DataView(this._inst.exports.mem.buffer);
                },
                "runtime.nanotime1": (sp) => {
                  sp >>>= 0;
                  setInt64(sp + 8, (timeOrigin + performance.now()) * 1e6);
                },
                "runtime.walltime": (sp) => {
                  sp >>>= 0;
                  const msec = new Date().getTime();
                  setInt64(sp + 8, msec / 1e3);
                  this.mem.setInt32(sp + 16, msec % 1e3 * 1e6, true);
                },
                "runtime.scheduleTimeoutEvent": (sp) => {
                  sp >>>= 0;
                  const id = this._nextCallbackTimeoutID;
                  this._nextCallbackTimeoutID++;
                  this._scheduledTimeouts.set(id, setTimeout(() => {
                    this._resume();
                    while (this._scheduledTimeouts.has(id)) {
                      console.warn("scheduleTimeoutEvent: missed timeout event");
                      this._resume();
                    }
                  }, getInt64(sp + 8) + 1));
                  this.mem.setInt32(sp + 16, id, true);
                },
                "runtime.clearTimeoutEvent": (sp) => {
                  sp >>>= 0;
                  const id = this.mem.getInt32(sp + 8, true);
                  clearTimeout(this._scheduledTimeouts.get(id));
                  this._scheduledTimeouts.delete(id);
                },
                "runtime.getRandomData": (sp) => {
                  sp >>>= 0;
                  crypto.getRandomValues(loadSlice(sp + 8));
                },
                "syscall/js.finalizeRef": (sp) => {
                  sp >>>= 0;
                  const id = this.mem.getUint32(sp + 8, true);
                  this._goRefCounts[id]--;
                  if (this._goRefCounts[id] === 0) {
                    const v = this._values[id];
                    this._values[id] = null;
                    this._ids.delete(v);
                    this._idPool.push(id);
                  }
                },
                "syscall/js.stringVal": (sp) => {
                  sp >>>= 0;
                  storeValue(sp + 24, loadString(sp + 8));
                },
                "syscall/js.valueGet": (sp) => {
                  sp >>>= 0;
                  const result = Reflect.get(loadValue(sp + 8), loadString(sp + 16));
                  sp = this._inst.exports.getsp() >>> 0;
                  storeValue(sp + 32, result);
                },
                "syscall/js.valueSet": (sp) => {
                  sp >>>= 0;
                  Reflect.set(loadValue(sp + 8), loadString(sp + 16), loadValue(sp + 32));
                },
                "syscall/js.valueDelete": (sp) => {
                  sp >>>= 0;
                  Reflect.deleteProperty(loadValue(sp + 8), loadString(sp + 16));
                },
                "syscall/js.valueIndex": (sp) => {
                  sp >>>= 0;
                  storeValue(sp + 24, Reflect.get(loadValue(sp + 8), getInt64(sp + 16)));
                },
                "syscall/js.valueSetIndex": (sp) => {
                  sp >>>= 0;
                  Reflect.set(loadValue(sp + 8), getInt64(sp + 16), loadValue(sp + 24));
                },
                "syscall/js.valueCall": (sp) => {
                  sp >>>= 0;
                  try {
                    const v = loadValue(sp + 8);
                    const m = Reflect.get(v, loadString(sp + 16));
                    const args = loadSliceOfValues(sp + 32);
                    const result = Reflect.apply(m, v, args);
                    sp = this._inst.exports.getsp() >>> 0;
                    storeValue(sp + 56, result);
                    this.mem.setUint8(sp + 64, 1);
                  } catch (err) {
                    sp = this._inst.exports.getsp() >>> 0;
                    storeValue(sp + 56, err);
                    this.mem.setUint8(sp + 64, 0);
                  }
                },
                "syscall/js.valueInvoke": (sp) => {
                  sp >>>= 0;
                  try {
                    const v = loadValue(sp + 8);
                    const args = loadSliceOfValues(sp + 16);
                    const result = Reflect.apply(v, void 0, args);
                    sp = this._inst.exports.getsp() >>> 0;
                    storeValue(sp + 40, result);
                    this.mem.setUint8(sp + 48, 1);
                  } catch (err) {
                    sp = this._inst.exports.getsp() >>> 0;
                    storeValue(sp + 40, err);
                    this.mem.setUint8(sp + 48, 0);
                  }
                },
                "syscall/js.valueNew": (sp) => {
                  sp >>>= 0;
                  try {
                    const v = loadValue(sp + 8);
                    const args = loadSliceOfValues(sp + 16);
                    const result = Reflect.construct(v, args);
                    sp = this._inst.exports.getsp() >>> 0;
                    storeValue(sp + 40, result);
                    this.mem.setUint8(sp + 48, 1);
                  } catch (err) {
                    sp = this._inst.exports.getsp() >>> 0;
                    storeValue(sp + 40, err);
                    this.mem.setUint8(sp + 48, 0);
                  }
                },
                "syscall/js.valueLength": (sp) => {
                  sp >>>= 0;
                  setInt64(sp + 16, parseInt(loadValue(sp + 8).length));
                },
                "syscall/js.valuePrepareString": (sp) => {
                  sp >>>= 0;
                  const str = encoder.encode(String(loadValue(sp + 8)));
                  storeValue(sp + 16, str);
                  setInt64(sp + 24, str.length);
                },
                "syscall/js.valueLoadString": (sp) => {
                  sp >>>= 0;
                  const str = loadValue(sp + 8);
                  loadSlice(sp + 16).set(str);
                },
                "syscall/js.valueInstanceOf": (sp) => {
                  sp >>>= 0;
                  this.mem.setUint8(sp + 24, loadValue(sp + 8) instanceof loadValue(sp + 16) ? 1 : 0);
                },
                "syscall/js.copyBytesToGo": (sp) => {
                  sp >>>= 0;
                  const dst = loadSlice(sp + 8);
                  const src = loadValue(sp + 32);
                  if (!(src instanceof Uint8Array || src instanceof Uint8ClampedArray)) {
                    this.mem.setUint8(sp + 48, 0);
                    return;
                  }
                  const toCopy = src.subarray(0, dst.length);
                  dst.set(toCopy);
                  setInt64(sp + 40, toCopy.length);
                  this.mem.setUint8(sp + 48, 1);
                },
                "syscall/js.copyBytesToJS": (sp) => {
                  sp >>>= 0;
                  const dst = loadValue(sp + 8);
                  const src = loadSlice(sp + 16);
                  if (!(dst instanceof Uint8Array || dst instanceof Uint8ClampedArray)) {
                    this.mem.setUint8(sp + 48, 0);
                    return;
                  }
                  const toCopy = src.subarray(0, dst.length);
                  dst.set(toCopy);
                  setInt64(sp + 40, toCopy.length);
                  this.mem.setUint8(sp + 48, 1);
                },
                "debug": (value) => {
                  console.log(value);
                }
              }
            };
          }
          async run(instance) {
            if (!(instance instanceof WebAssembly.Instance)) {
              throw new Error("Go.run: WebAssembly.Instance expected");
            }
            this._inst = instance;
            this.mem = new DataView(this._inst.exports.mem.buffer);
            this._values = [
              NaN,
              0,
              null,
              true,
              false,
              globalThis,
              this
            ];
            this._goRefCounts = new Array(this._values.length).fill(Infinity);
            this._ids = /* @__PURE__ */ new Map([
              [0, 1],
              [null, 2],
              [true, 3],
              [false, 4],
              [globalThis, 5],
              [this, 6]
            ]);
            this._idPool = [];
            this.exited = false;
            let offset = 4096;
            const strPtr = (str) => {
              const ptr = offset;
              const bytes = encoder.encode(str + "\0");
              new Uint8Array(this.mem.buffer, offset, bytes.length).set(bytes);
              offset += bytes.length;
              if (offset % 8 !== 0) {
                offset += 8 - offset % 8;
              }
              return ptr;
            };
            const argc = this.argv.length;
            const argvPtrs = [];
            this.argv.forEach((arg) => {
              argvPtrs.push(strPtr(arg));
            });
            argvPtrs.push(0);
            const keys = Object.keys(this.env).sort();
            keys.forEach((key) => {
              argvPtrs.push(strPtr(`${key}=${this.env[key]}`));
            });
            argvPtrs.push(0);
            const argv = offset;
            argvPtrs.forEach((ptr) => {
              this.mem.setUint32(offset, ptr, true);
              this.mem.setUint32(offset + 4, 0, true);
              offset += 8;
            });
            const wasmMinDataAddr = 4096 + 8192;
            if (offset >= wasmMinDataAddr) {
              throw new Error("total length of command line and environment variables exceeds limit");
            }
            this._inst.exports.run(argc, argv);
            if (this.exited) {
              this._resolveExitPromise();
            }
            await this._exitPromise;
          }
          _resume() {
            if (this.exited) {
              throw new Error("Go program has already exited");
            }
            this._inst.exports.resume();
            if (this.exited) {
              this._resolveExitPromise();
            }
          }
          _makeFuncWrapper(id) {
            const go = this;
            return function() {
              const event = { id, this: this, args: arguments };
              go._pendingEvent = event;
              go._resume();
              return event.result;
            };
          }
        };
      })();
      onmessage = ({ data: wasm }) => {
        let decoder = new TextDecoder();
        let fs = globalThis.fs;
        let stderr = "";
        fs.writeSync = (fd, buffer) => {
          if (fd === 1) {
            postMessage(buffer);
          } else if (fd === 2) {
            stderr += decoder.decode(buffer);
            let parts = stderr.split("\n");
            if (parts.length > 1)
              console.log(parts.slice(0, -1).join("\n"));
            stderr = parts[parts.length - 1];
          } else {
            throw new Error("Bad write");
          }
          return buffer.length;
        };
        let stdin = [];
        let resumeStdin;
        let stdinPos = 0;
        onmessage = ({ data }) => {
          if (data.length > 0) {
            stdin.push(data);
            if (resumeStdin)
              resumeStdin();
          }
        };
        fs.read = (fd, buffer, offset, length, position, callback) => {
          if (fd !== 0 || offset !== 0 || length !== buffer.length || position !== null) {
            throw new Error("Bad read");
          }
          if (stdin.length === 0) {
            resumeStdin = () => fs.read(fd, buffer, offset, length, position, callback);
            return;
          }
          let first = stdin[0];
          let count = Math.max(0, Math.min(length, first.length - stdinPos));
          buffer.set(first.subarray(stdinPos, stdinPos + count), offset);
          stdinPos += count;
          if (stdinPos === first.length) {
            stdin.shift();
            stdinPos = 0;
          }
          callback(null, count);
        };
        let go = new globalThis.Go();
        go.argv = ["", `--service=${"0.14.49"}`];
        if (wasm instanceof WebAssembly.Module) {
          WebAssembly.instantiate(wasm, go.importObject).then((instance) => go.run(instance));
        } else {
          WebAssembly.instantiate(wasm, go.importObject).then(({ instance }) => go.run(instance));
        }
      };
      return (m) => onmessage(m);
    })((data) => worker.onmessage({ data }));
    worker = {
      onmessage: null,
      postMessage: (data) => setTimeout(() => onmessage({ data })),
      terminate() {
      }
    };
  }
  worker.postMessage(wasm);
  worker.onmessage = ({ data }) => readFromStdout(data);
  let { readFromStdout, service } = createChannel({
    writeToStdin(bytes) {
      worker.postMessage(bytes);
    },
    isSync: false,
    isWriteUnavailable: true,
    esbuild: browser_exports
  });
  longLivedService = {
    build: (options) => new Promise((resolve, reject) => service.buildOrServe({
      callName: "build",
      refs: null,
      serveOptions: null,
      options,
      isTTY: false,
      defaultWD: "/",
      callback: (err, res) => err ? reject(err) : resolve(res)
    })),
    transform: (input, options) => new Promise((resolve, reject) => service.transform({
      callName: "transform",
      refs: null,
      input,
      options: options || {},
      isTTY: false,
      fs: {
        readFile(_, callback) {
          callback(new Error("Internal error"), null);
        },
        writeFile(_, callback) {
          callback(null);
        }
      },
      callback: (err, res) => err ? reject(err) : resolve(res)
    })),
    formatMessages: (messages, options) => new Promise((resolve, reject) => service.formatMessages({
      callName: "formatMessages",
      refs: null,
      messages,
      options,
      callback: (err, res) => err ? reject(err) : resolve(res)
    })),
    analyzeMetafile: (metafile, options) => new Promise((resolve, reject) => service.analyzeMetafile({
      callName: "analyzeMetafile",
      refs: null,
      metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
      options,
      callback: (err, res) => err ? reject(err) : resolve(res)
    }))
  };
};
var browser_default = browser_exports;
export {
  analyzeMetafile,
  analyzeMetafileSync,
  build,
  buildSync,
  browser_default as default,
  formatMessages,
  formatMessagesSync,
  initialize,
  serve,
  transform,
  transformSync,
  version
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ction(){var t=this.props,e=t.getComponent,r=t.specSelectors,n=t.getConfigs,i=e("Button"),o=e("Link"),s="loading"===r.loadingStatus(),u=["download-url-input"];"failed"===r.loadingStatus()&&u.push("failed"),s&&u.push("loading");var a=n().urls,c=[],f=null;if(a){var l=[];m()(a).call(a,(function(t,e){l.push(p.createElement("option",{key:e,value:t.url},t.name))})),c.push(p.createElement("label",{className:"select-label",htmlFor:"select"},p.createElement("span",null,"Select a definition"),p.createElement("select",{id:"select",disabled:s,onChange:this.onUrlSelect,value:a[this.state.selectedIndex].url},l)))}else f=this.downloadUrl,c.push(p.createElement("input",{className:u.join(" "),type:"text",onChange:this.onUrlChange,value:this.state.url,disabled:s})),c.push(p.createElement(i,{className:"download-url-button",onClick:this.downloadUrl},"Explore"));return p.createElement("div",{className:"topbar"},p.createElement("div",{className:"wrapper"},p.createElement("div",{className:"topbar-wrapper"},p.createElement(o,null,p.createElement("img",{height:"40",src:j,alt:"Swagger UI"})),p.createElement("form",{className:"download-url-wrapper",onSubmit:f},b()(c).call(c,(function(t,e){return(0,p.cloneElement)(t,{key:e})}))))))}}]),r}(p.Component);var Br=r(15163),Pr=function(t,e){try{return Tr.load(t)}catch(t){return e&&e.errActions.newThrownErr(new Error(t)),{}}},Qr="configs_update",Fr="configs_toggle";function Gr(t,e){return{type:Qr,payload:w()({},t,e)}}function Wr(t){return{type:Fr,payload:t}}var qr,Hr=function(){return function(t){var e=t.getConfigs,r=t.authActions;if(e().persistAuthorization){var n=localStorage.getItem("authorized");n&&r.restoreAuthorization({authorized:JSON.parse(n)})}}},Jr=function(t){return function(e){return(0,e.fn.fetch)(t)}},Zr=function(t,e){return function(r){var n=r.specActions;if(t)return n.downloadConfig(t).then(i,i);function i(r){r instanceof Error||r.status>=400?(n.updateLoadingStatus("failedConfig"),n.updateLoadingStatus("failedConfig"),n.updateUrl(""),console.error(r.statusText+" "+t.url),e(null)):e(Pr(r.text))}}},Vr=function(t,e){return t.getIn(A()(e)?e:[e])};const $r=(qr={},w()(qr,Qr,(function(t,e){return t.merge((0,J.fromJS)(e.payload))})),w()(qr,Fr,(function(t,e){var r=e.payload,n=t.get(r);return t.set(r,!n)})),qr);var Xr={getLocalConfig:function(){return Pr(Br)}};var Kr=r(44494),tn=r.n(Kr),en=r(7287),rn=r.n(en),nn=r(5872),on=r.n(nn),sn=console.error,un=function(t){return function(e){var r,n=t(),i=n.getComponent,o=n.fn,u=i("ErrorBoundary"),c=o.getDisplayName(e),l=function(t){f()(n,t);var r=h()(n);function n(){return s()(this,n),r.apply(this,arguments)}return a()(n,[{key:"render",value:function(){return p.createElement(u,{targetName:c,getComponent:i,fn:o},p.createElement(e,on()({},this.props,this.context)))}}]),n}(p.Component);return l.displayName="WithErrorBoundary(".concat(c,")"),(r=e).prototype&&r.prototype.isReactComponent&&(l.prototype.mapStateToProps=e.prototype.mapStateToProps),l}};const an=function(t){var e=t.name;return p.createElement("div",{className:"fallback"},"😱 ",p.createElement("i",null,"Could not render ","t"===e?"this component":e,", see the console."))};var cn=function(t){f()(r,t);var e=h()(r);function r(){var t,n;s()(this,r);for(var i=arguments.length,o=new Array(i),u=0;u<i;u++)o[u]=arguments[u];return(n=e.call.apply(e,_()(t=[this]).call(t,o))).state={hasError:!1,error:null},n}return a()(r,[{key:"componentDidCatch",value:function(t,e){this.props.fn.componentDidCatch(t,e)}},{key:"render",value:function(){var t=this.props,e=t.getComponent,r=t.targetName,n=t.children;if(this.state.hasError){var i=e("Fallback");return p.createElement(i,{name:r})}return n}}],[{key:"getDerivedStateFromError",value:function(t){return{hasError:!0,error:t}}}]),r}(p.Component);cn.defaultProps={targetName:"this component",getComponent:function(){return an},fn:{componentDidCatch:sn},children:null};const fn=cn;const ln=function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=t.componentList,r=void 0===e?[]:e,n=t.fullOverride,i=void 0!==n&&n;return function(t){var e,n,o=t.getSystem,s=i?r:_()(e=[]).call(e,["App","BaseLayout","VersionPragmaFilter","InfoContainer","ServersContainer","SchemesContainer","AuthorizeBtnContainer","FilterContainer","Operations","OperationContainer","parameters","responses","OperationServers","Models","ModelWrapper"],S()(r)),u=rn()(s,tn()(n=Array(s.length)).call(n,(function(t,e){return e.fn.withErrorBoundary(t)})));return{fn:{componentDidCatch:sn,withErrorBoundary:un(o)},components:{ErrorBoundary:fn,Fallback:an},wrapComponents:u}}},hn=[function(){return{components:{Topbar:Yr}}},function(){return{statePlugins:{spec:{actions:e,selectors:Xr},configs:{reducers:$r,actions:t,selectors:i}}}},function(){return{components:{StandaloneLayout:d}}},ln({fullOverride:!0,componentList:["Topbar","StandaloneLayout","onlineValidatorBadge"]})]})(),n=n.default})()}));
//# sourceMappingURL=swagger-ui-standalone-preset.js.map_ !function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.SwaggerUICore=t():e.SwaggerUICore=t()}(this,(function(){return(()=>{var e={6024:(e,t,n)=>{"use strict";n.d(t,{Z:()=>R});var r=n(4250),a=n.n(r),o=n(6349),s=n.n(o),l=n(4606),i=n.n(l),c=n(4555),u=n.n(c),p=n(4291),d=n.n(p),m=n(1885),h=n.n(m),f=n(1093),g=n.n(f),v=n(4883),y=n.n(v),E=n(8493),S=n.n(E),b=n(3942),C=n.n(b),x=n(6689),w=n.n(x);const _=require("react-immutable-pure-component");var A=n.n(_),k=n(8082),N=n.n(k),I=n(580),q=n.n(I),R=function(e){d()(r,e);var t=h()(r);function r(){var e,n;s()(this,r);for(var a=arguments.length,o=new Array(a),l=0;l<a;l++)o[l]=arguments[l];return n=t.call.apply(t,y()(e=[this]).call(e,o)),g()(u()(n),"getModelName",(function(e){return-1!==S()(e).call(e,"#/definitions/")?e.replace(/^.*#\/definitions\//,""):-1!==S()(e).call(e,"#/components/schemas/")?e.replace(/^.*#\/components\/schemas\//,""):void 0})),g()(u()(n),"getRefSchema",(function(e){return n.props.specSelectors.findDefinition(e)})),n}return i()(r,[{key:"render",value:function(){var e=this.props,t=e.getComponent,r=e.getConfigs,o=e.specSelectors,s=e.schema,l=e.required,i=e.name,c=e.isRef,u=e.specPath,p=e.displayName,d=e.includeReadOnly,m=e.includeWriteOnly,h=t("ObjectModel"),f=t("ArrayModel"),g=t("PrimitiveModel"),v="object",y=s&&s.get("$$ref");if(!i&&y&&(i=this.getModelName(y)),!s&&y&&(s=this.getRefSchema(i)),!s)return w().createElement("span",{className:"model model-title"},w().createElement("span",{className:"model-title__text"},p||i),w().createElement("img",{src:n(2517),height:"20px",width:"20px"}));var E=o.isOAS3()&&s.get("deprecated");switch(c=void 0!==c?c:!!y,v=s&&s.get("type")||v){case"object":return w().createElement(h,a()({className:"object"},this.props,{specPath:u,getConfigs:r,schema:s,name:i,deprecated:E,isRef:c,includeReadOnly:d,includeWriteOnly:m}));case"array":return w().createElement(f,a()({className:"array"},this.props,{getConfigs:r,schema:s,name:i,deprecated:E,required:l,includeReadOnly:d,includeWriteOnly:m}));default:return w().createElement(g,a()({},this.props,{getComponent:t,getConfigs:r,schema:s,name:i,deprecated:E,required:l}))}}}]),r}(A());g()(R,"propTypes",{schema:C()(N()).isRequired,getComponent:q().func.isRequired,getConfigs:q().func.isRequired,specSelectors:q().object.isRequired,name:q().string,displayName:q().string,isRef:q().bool,required:q().bool,expandDepth:q().number,depth:q().number,specPath:N().list.isRequired,includeReadOnly:q().bool,includeWriteOnly:q().bool})},5623:(e,t,n)=>{"use strict";n.d(t,{Z:()=>k});var r=n(6768),a=n.n(r),o=n(6349),s=n.n(o),l=n(4606),i=n.n(l),c=n(4555),u=n.n(c),p=n(4291),d=n.n(p),m=n(1885),h=n.n(m),f=n(1093),g=n.n(f),v=n(7252),y=n.n(v),E=n(4883),S=n.n(E),b=n(6689),C=n.n(b),x=n(3883),w=n.n(x),_=(n(580),n(1890)),A=n(7504),k=function(e){d()(n,e);var t=h()(n);function n(e,r){var a;s()(this,n),a=t.call(this,e,r),g()(u()(a),"getDefinitionUrl",(function(){var e=a.props.specSelectors;return new(w())(e.url(),A.Z.location).toString()}));var o=(0,e.getConfigs)().validatorUrl;return a.state={url:a.getDefinitionUrl(),validatorUrl:void 0===o?"https://validator.swagger.io/validator":o},a}return i()(n,[{key:"UNSAFE_componentWillReceiveProps",value:function(e){var t=(0,e.getConfigs)().validatorUrl;this.setState({url:this.getDefinitionUrl(),validatorUrl:void 0===t?"https://validator.swagger.io/validator":t})}},{key:"render",value:function(){var e,t,n=(0,this.props.getConfigs)().spec,r=(0,_.Nm)(this.state.validatorUrl);return"object"===a()(n)&&y()(n).length?null:this.state.url&&(0,_.hW)(this.state.validatorUrl)&&(0,_.hW)(this.state.url)?C().createElement("span",{className:"float-right"},C().createElement("a",{target:"_blank",rel:"noopener noreferrer",href:S()(e="".concat(r,"/debug?url=")).call(e,encodeURIComponent(this.state.url))},C().createElement(N,{src:S()(t="".concat(r,"?url=")).call(t,encodeURIComponent(this.state.url)),alt:"Online validator badge"}))):null}}]),n}(C().Component),N=function(e){d()(n,e);var t=h()(n);function n(e){var r;return s()(this,n),(r=t.call(this,e)).state={loaded:!1,error:!1},r}return i()(n,[{key:"componentDidMount",value:function(){var e=this,t=new Image;t.onload=function(){e.setState({loaded:!0})},t.onerror=function(){e.setState({error:!0})},t.src=this.props.src}},{key:"UNSAFE_componentWillReceiveProps",value:function(e){var t=this;if(e.src!==this.props.src){var n=new Image;n.onload=function(){t.setState({loaded:!0})},n.onerror=function(){t.setState({error:!0})},n.src=e.src}}},{key:"render",value:function(){return this.state.error?C().createElement("img",{alt:"Error"}):this.state.loaded?C().createElement("img",{src:this.props.src,alt:this.props.alt}):null}}]),n}(C().Component)},2552:(e,t,n)=>{"use strict";n.d(t,{Z:()=>d,s:()=>m});var r=n(6689),a=n.n(r),o=(n(580),n(963));const s=require("remarkable/linkify"),l=require("dompurify");var i=n.n(l),c=n(9003),u=n.n(c);function p(e){var t=e.source,n=e.className,r=void 0===n?"":n,l=e.getConfigs;if("string"!=typeof t)return null;var i=new o.Remarkable({html:!0,typographer:!0,breaks:!0,linkTarget:"_blank"}).use(s.linkify);i.core.ruler.disable(["replacements","smartquotes"]);var c=l().useUnsafeMarkdown,p=i.render(t),d=m(p,{useUnsafeMarkdown:c});return t&&p&&d?a().createElement("div",{className:u()(r,"markdown"),dangerouslySetInnerHTML:{__html:d}}):null}i().addHook&&i().addHook("beforeSanitizeElements",(function(e){return e.href&&e.setAttribute("rel","noopener noreferrer"),e})),p.defaultProps={getConfigs:function(){return{useUnsafeMarkdown:!1}}};const d=p;function m(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=t.useUnsafeMarkdown,r=void 0!==n&&n,a=r,o=r?[]:["style","class"];return r&&!m.hasWarnedAboutDeprecation&&(console.warn("useUnsafeMarkdown display configuration parameter is deprecated since >3.26.0 and will be removed in v4.0.0."),m.hasWarnedAboutDeprecation=!0),i().sanitize(e,{ADD_ATTR:["target"],FORBID_TAGS:["style","form"],ALLOW_DATA_ATTR:a,FORBID_ATTR:o})}m.hasWarnedAboutDeprecation=!1},5308:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>d});var r,a=n(4235),o=n.n(a),s=n(874),l=n.n(s),i=n(1890),c=n(9595),u=n(5102),p={};const d=p;o()(r=l()(u).call(u)).call(r,(function(e){if("./index.js"!==e){var t=u(e);p[(0,i.Zl)(e)]=t.default?t.default:t}})),p.SafeRender=c.default},5812:(e,t,n)=>{"use strict";n.r(t),n.d(t,{SHOW_AUTH_POPUP:()=>m,AUTHORIZE:()=>h,LOGOUT:()=>f,PRE_AUTHORIZE_OAUTH2:()=>g,AUTHORIZE_OAUTH2:()=>v,VALIDATE:()=>y,CONFIGURE_AUTH:()=>E,RESTORE_AUTHORIZATION:()=>S,showDefinitions:()=>b,authorize:()=>C,authorizeWithPersistOption:()=>x,logout:()=>w,logoutWithPersistOption:()=>_,preAuthorizeImplicit:()=>A,authorizeOauth2:()=>k,authorizeOauth2WithPersistOption:()=>N,authorizePassword:()=>I,authorizeApplication:()=>q,authorizeAccessCodeWithFormParams:()=>R,authorizeAccessCodeWithBasicAuthentication:()=>P,authorizeRequest:()=>T,configureAuth:()=>O,restoreAuthorization:()=>M,persistAuthorizationIfNeeded:()=>j,authPopup:()=>V});var r=n(6768),a=n.n(r),o=n(8344),s=n.n(o),l=n(4994),i=n.n(l),c=n(3883),u=n.n(c),p=n(7504),d=n(1890),m="show_popup",h="authorize",f="logout",g="pre_authorize_oauth2",v="authorize_oauth2",y="validate",E="configure_auth",S="restore_authorization";function b(e){return{type:m,payload:e}}function C(e){return{type:h,payload:e}}var x=function(e){return function(t){var n=t.authActions;n.authorize(e),n.persistAuthorizationIfNeeded()}};function w(e){return{type:f,payload:e}}var _=function(e){return function(t){var n=t.authActions;n.logout(e),n.persistAuthorizationIfNeeded()}},A=function(e){return function(t){var n=t.authActions,r=t.errActions,a=e.auth,o=e.token,l=e.isValid,i=a.schema,c=a.name,u=i.get("flow");delete p.Z.swaggerUIRedirectOauth2,"accessCode"===u||l||r.newAuthErr({authId:c,source:"auth",level:"warning",message:"Authorization may be unsafe, passed state was changed in server Passed state wasn't returned from auth server"}),o.error?r.newAuthErr({authId:c,source:"auth",level:"error",message:s()(o)}):n.authorizeOauth2WithPersistOption({auth:a,token:o})}};function k(e){return{type:v,payload:e}}var N=function(e){return function(t){var n=t.authActions;n.authorizeOauth2(e),n.persistAuthorizationIfNeeded()}},I=function(e){return function(t){var n=t.authActions,r=e.schema,a=e.name,o=e.username,s=e.password,l=e.passwordType,c=e.clientId,u=e.clientSecret,p={grant_type:"password",scope:e.scopes.join(" "),username:o,password:s},m={};switch(l){case"request-body":!function(e,t,n){t&&i()(e,{client_id:t});n&&i()(e,{client_secret:n})}(p,c,u);break;case"basic":m.Authorization="Basic "+(0,d.r3)(c+":"+u);break;default:console.warn("Warning: invalid passwordType ".concat(l," was passed, not including client id and secret"))}return n.authorizeRequest({body:(0,d.GZ)(p),url:r.get("tokenUrl"),name:a,headers:m,query:{},auth:e})}};var q=function(e){return function(t){var n=t.authActions,r=e.schema,a=e.scopes,o=e.name,s=e.clientId,l=e.clientSecret,i={Authorization:"Basic "+(0,d.r3)(s+":"+l)},c={grant_type:"client_credentials",scope:a.join(" ")};return n.authorizeRequest({body:(0,d.GZ)(c),name:o,url:r.get("tokenUrl"),auth:e,headers:i})}},R=function(e){var t=e.auth,n=e.redirectUrl;return function(e){var r=e.authActions,a=t.schema,o=t.name,s=t.clientId,l=t.clientSecret,i=t.codeVerifier,c={grant_type:"authorization_code",code:t.code,client_id:s,client_secret:l,redirect_uri:n,code_verifier:i};return r.authorizeRequest({body:(0,d.GZ)(c),name:o,url:a.get("tokenUrl"),auth:t})}},P=function(e){var t=e.auth,n=e.redirectUrl;return function(e){var r=e.authActions,a=t.schema,o=t.name,s=t.clientId,l=t.clientSecret,i=t.codeVerifier,c={Authorization:"Basic "+(0,d.r3)(s+":"+l)},u={grant_type:"authorization_code",code:t.code,client_id:s,redirect_uri:n,code_verifier:i};return r.authorizeRequest({body:(0,d.GZ)(u),name:o,url:a.get("tokenUrl"),auth:t,headers:c})}},T=function(e){return function(t){var n,r=t.fn,o=t.getConfigs,l=t.authActions,c=t.errActions,p=t.oas3Selectors,d=t.specSelectors,m=t.authSelectors,h=e.body,f=e.query,g=void 0===f?{}:f,v=e.headers,y=void 0===v?{}:v,E=e.name,S=e.url,b=e.auth,C=(m.getConfigs()||{}).additionalQueryStringParams;if(d.isOAS3()){var x=p.serverEffectiveValue(p.selectedServer());n=u()(S,x,!0)}else n=u()(S,d.url(),!0);"object"===a()(C)&&(n.query=i()({},n.query,C));var w=n.toString(),_=i()({Accept:"application/json, text/plain, */*","Content-Type":"application/x-www-form-urlencoded","X-Requested-With":"XMLHttpRequest"},y);r.fetch({url:w,method:"post",headers:_,query:g,body:h,requestInterceptor:o().requestInterceptor,responseInterceptor:o().responseInterceptor}).then((function(e){var t=JSON.parse(e.data),n=t&&(t.error||""),r=t&&(t.parseError||"");e.ok?n||r?c.newAuthErr({authId:E,level:"error",source:"auth",message:s()(t)}):l.authorizeOauth2WithPersistOption({auth:b,token:t}):c.newAuthErr({authId:E,level:"error",source:"auth",message:e.statusText})})).catch((function(e){var t=new Error(e).message;if(e.response&&e.response.data){var n=e.response.data;try{var r="string"==typeof n?JSON.parse(n):n;r.error&&(t+=", error: ".concat(r.error)),r.error_description&&(t+=", description: ".concat(r.error_description))}catch(e){}}c.newAuthErr({authId:E,level:"error",source:"auth",message:t})}))}};function O(e){return{type:E,payload:e}}function M(e){return{type:S,payload:e}}var j=function(){return function(e){var t=e.authSelectors;if((0,e.getConfigs)().persistAuthorization){var n=t.authorized();localStorage.setItem("authorized",s()(n.toJS()))}}},V=function(e,t){return function(){p.Z.swaggerUIRedirectOauth2=t,p.Z.open(e)}}},3705:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>m,preauthorizeBasic:()=>h,preauthorizeApiKey:()=>f});var r=n(1093),a=n.n(r),o=n(593),s=n.n(o),l=n(4883),i=n.n(l),c=n(3962),u=n(5812),p=n(35),d=n(8302);function m(){return{afterLoad:function(e){this.rootInjects=this.rootInjects||{},this.rootInjects.initOAuth=e.authActions.configureAuth,this.rootInjects.preauthorizeApiKey=s()(f).call(f,null,e),this.rootInjects.preauthorizeBasic=s()(h).call(h,null,e)},statePlugins:{auth:{reducers:c.default,actions:u,selectors:p},spec:{wrapActions:d}}}}function h(e,t,n,r){var o,s=e.authActions.authorize,l=e.specSelectors,c=l.specJson,u=(0,l.isOAS3)()?["components","securitySchemes"]:["securityDefinitions"],p=c().getIn(i()(o=[]).call(o,u,[t]));return p?s(a()({},t,{value:{username:n,password:r},schema:p.toJS()})):null}function f(e,t,n){var r,o=e.authActions.authorize,s=e.specSelectors,l=s.specJson,c=(0,s.isOAS3)()?["components","securitySchemes"]:["securityDefinitions"],u=l().getIn(i()(r=[]).call(r,c,[t]));return u?o(a()({},t,{value:n,schema:u.toJS()})):null}},3962:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>f});var r,a=n(1093),o=n.n(a),s=n(8030),l=n.n(s),i=n(4235),c=n.n(i),u=n(4994),p=n.n(u),d=n(5572),m=n(1890),h=n(5812);const f=(r={},o()(r,h.SHOW_AUTH_POPUP,(function(e,t){var n=t.payload;return e.set("showDefinitions",n)})),o()(r,h.AUTHORIZE,(function(e,t){var n,r=t.payload,a=(0,d.fromJS)(r),o=e.get("authorized")||(0,d.Map)();return c()(n=a.entrySeq()).call(n,(function(t){var n=l()(t,2),r=n[0],a=n[1];if(!(0,m.Wl)(a.getIn))return e.set("authorized",o);var s=a.getIn(["schema","type"]);if("apiKey"===s||"http"===s)o=o.set(r,a);else if("basic"===s){var i=a.getIn(["value","username"]),c=a.getIn(["value","password"]);o=(o=o.setIn([r,"value"],{username:i,header:"Basic "+(0,m.r3)(i+":"+c)})).setIn([r,"schema"],a.get("schema"))}})),e.set("authorized",o)})),o()(r,h.AUTHORIZE_OAUTH2,(function(e,t){var n,r=t.payload,a=r.auth,o=r.token;a.token=p()({},o),n=(0,d.fromJS)(a);var s=e.get("authorized")||(0,d.Map)();return s=s.set(n.get("name"),n),e.set("authorized",s)})),o()(r,h.LOGOUT,(function(e,t){var n=t.payload,r=e.get("authorized").withMutations((function(e){c()(n).call(n,(function(t){e.delete(t)}))}));return e.set("authorized",r)})),o()(r,h.CONFIGURE_AUTH,(function(e,t){var n=t.payload;return e.set("configs",n)})),o()(r,h.RESTORE_AUTHORIZATION,(function(e,t){var n=t.payload;return e.set("authorized",(0,d.fromJS)(n.authorized))})),r)},35:(e,t,n)=>{"use strict";n.r(t),n.d(t,{shownDefinitions:()=>S,definitionsToAuthorize:()=>b,getDefinitionsByNames:()=>C,definitionsForRequirements:()=>x,authorized:()=>w,isAuthorized:()=>_,getConfigs:()=>A});var r=n(8030),a=n.n(r),o=n(4235),s=n.n(o),l=n(9998),i=n.n(l),c=n(5626),u=n.n(c),p=n(8493),d=n.n(p),m=n(3942),h=n.n(m),f=n(7252),g=n.n(f),v=n(6814),y=n(5572),E=function(e){return e},S=(0,v.createSelector)(E,(function(e){return e.get("showDefinitions")})),b=(0,v.createSelector)(E,(function(){return function(e){var t,n=e.specSelectors.securityDefinitions()||(0,y.Map)({}),r=(0,y.List)();return s()(t=n.entrySeq()).call(t,(function(e){var t=a()(e,2),n=t[0],o=t[1],s=(0,y.Map)();s=s.set(n,o),r=r.push(s)})),r}})),C=function(e,t){return function(e){var n,r=e.specSelectors;console.warn("WARNING: getDefinitionsByNames is deprecated and will be removed in the next major version.");var o=r.securityDefinitions(),l=(0,y.List)();return s()(n=t.valueSeq()).call(n,(function(e){var t,n=(0,y.Map)();s()(t=e.entrySeq()).call(t,(function(e){var t,r,l=a()(e,2),i=l[0],c=l[1],u=o.get(i);"oauth2"===u.get("type")&&c.size&&(t=u.get("scopes"),s()(r=t.keySeq()).call(r,(function(e){c.contains(e)||(t=t.delete(e))})),u=u.set("allowedScopes",t));n=n.set(i,u)})),l=l.push(n)})),l}},x=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:(0,y.List)();return function(e){var n=e.authSelectors.definitionsToAuthorize()||(0,y.List)();return i()(n).call(n,(function(e){return u()(t).call(t,(function(t){return t.get(e.keySeq().first())}))}))}},w=(0,v.createSelector)(E,(function(e){return e.get("authorized")||(0,y.Map)()})),_=function(e,t){return function(e){var n,r=e.authSelectors.authorized();return y.List.isList(t)?!!i()(n=t.toJS()).call(n,(function(e){var t,n;return-1===d()(t=h()(n=g()(e)).call(n,(function(e){return!!r.get(e)}))).call(t,!1)})).length:null}},A=(0,v.createSelector)(E,(function(e){return e.get("configs")}))},8302:(e,t,n)=>{"use strict";n.r(t),n.d(t,{execute:()=>o});var r=n(67),a=n.n(r),o=function(e,t){var n=t.authSelectors,r=t.specSelectors;return function(t){var o=t.path,s=t.method,l=t.operation,i=t.extras,c={authorized:n.authorized()&&n.authorized().toJS(),definitions:r.securityDefinitions()&&r.securityDefinitions().toJS(),specSecurity:r.security()&&r.security().toJS()};return e(a()({path:o,method:s,operation:l,securities:c},i))}}},714:(e,t,n)=>{"use strict";n.r(t),n.d(t,{UPDATE_CONFIGS:()=>o,TOGGLE_CONFIGS:()=>s,update:()=>l,toggle:()=>i,loaded:()=>c});var r=n(1093),a=n.n(r),o="configs_update",s="configs_toggle";function l(e,t){return{type:o,payload:a()({},e,t)}}function i(e){return{type:s,payload:e}}var c=function(){return function(e){var t=e.getConfigs,n=e.authActions;if(t().persistAuthorization){var r=localStorage.getItem("authorized");r&&n.restoreAuthorization({authorized:JSON.parse(r)})}}}},2256:(e,t,n)=>{"use strict";n.r(t),n.d(t,{parseYamlConfig:()=>o});var r=n(9793),a=n.n(r),o=function(e,t){try{return a().load(e)}catch(e){return t&&t.errActions.newThrownErr(new Error(e)),{}}}},1661:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>u});var r=n(5163),a=n(2256),o=n(714),s=n(2698),l=n(9018),i=n(7743),c={getLocalConfig:function(){return(0,a.parseYamlConfig)(r)}};function u(){return{statePlugins:{spec:{actions:s,selectors:c},configs:{reducers:i.default,actions:o,selectors:l}}}}},7743:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>i});var r,a=n(1093),o=n.n(a),s=n(5572),l=n(714);const i=(r={},o()(r,l.UPDATE_CONFIGS,(function(e,t){return e.merge((0,s.fromJS)(t.payload))})),o()(r,l.TOGGLE_CONFIGS,(function(e,t){var n=t.payload,r=e.get(n);return e.set(n,!r)})),r)},9018:(e,t,n)=>{"use strict";n.r(t),n.d(t,{get:()=>o});var r=n(7104),a=n.n(r),o=function(e,t){return e.getIn(a()(t)?t:[t])}},2698:(e,t,n)=>{"use strict";n.r(t),n.d(t,{downloadConfig:()=>a,getConfigByUrl:()=>o});var r=n(2256),a=function(e){return function(t){return(0,t.fn.fetch)(e)}},o=function(e,t){return function(n){var a=n.specActions;if(e)return a.downloadConfig(e).then(o,o);function o(n){n instanceof Error||n.status>=400?(a.updateLoadingStatus("failedConfig"),a.updateLoadingStatus("failedConfig"),a.updateUrl(""),console.error(n.statusText+" "+e.url),t(null)):t((0,r.parseYamlConfig)(n.text))}}}},1970:(e,t,n)=>{"use strict";n.r(t),n.d(t,{setHash:()=>r});var r=function(e){return e?history.pushState(null,null,"#".concat(e)):window.location.hash=""}},4980:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>s});var r=n(2179),a=n(877),o=n(4584);function s(){return[r.default,{statePlugins:{configs:{wrapActions:{loaded:function(e,t){return function(){e.apply(void 0,arguments);var n=decodeURIComponent(window.location.hash);t.layoutActions.parseDeepLinkHash(n)}}}}},wrapComponents:{operation:a.default,OperationTag:o.default}}]}},2179:(e,t,n)=>{"use strict";n.r(t),n.d(t,{clearScrollTo:()=>R,default:()=>P,parseDeepLinkHash:()=>N,readyToScroll:()=>I,scrollTo:()=>k,scrollToElement:()=>q,show:()=>A});var r=n(1093),a=n.n(r),o=n(8030),s=n.n(o),l=n(7104),i=n.n(l),c=n(4883),u=n.n(c),p=n(600),d=n.n(p),m=n(3942),h=n.n(m),f=n(8493),g=n.n(f),v=n(1970);const y=require("zenscroll");var E,S=n.n(y),b=n(1890),C=n(5572),x=n.n(C),w="layout_scroll_to",_="layout_clear_scroll",A=function(e,t){var n=t.getConfigs,r=t.layoutSelectors;return function(){for(var t=arguments.length,a=new Array(t),o=0;o<t;o++)a[o]=arguments[o];if(e.apply(void 0,a),n().deepLinking)try{var l=a[0],c=a[1];l=i()(l)?l:[l];var p=r.urlHashArrayFromIsShownKey(l);if(!p.length)return;var d,m=s()(p,2),h=m[0],f=m[1];if(!c)return(0,v.setHash)("/");if(2===p.length)(0,v.setHash)((0,b.oJ)(u()(d="/".concat(encodeURIComponent(h),"/")).call(d,encodeURIComponent(f))));else 1===p.length&&(0,v.setHash)((0,b.oJ)("/".concat(encodeURIComponent(h))))}catch(e){console.error(e)}}},k=function(e){return{type:w,payload:i()(e)?e:[e]}},N=function(e){return function(t){var n=t.layoutActions,r=t.layoutSelectors;if((0,t.getConfigs)().deepLinking&&e){var a,o=d()(e).call(e,1);"!"===o[0]&&(o=d()(o).call(o,1)),"/"===o[0]&&(o=d()(o).call(o,1));var l=h()(a=o.split("/")).call(a,(function(e){return e||""})),i=r.isShownKeyFromUrlHashArray(l),c=s()(i,3),u=c[0],p=c[1],m=void 0===p?"":p,f=c[2],v=void 0===f?"":f;if("operations"===u){var y=r.isShownKeyFromUrlHashArray([m]);g()(m).call(m,"_")>-1&&(console.warn("Warning: escaping deep link whitespace with `_` will be unsupported in v4.0, use `%20` instead."),n.show(h()(y).call(y,(function(e){return e.replace(/_/g," ")})),!0)),n.show(y,!0)}(g()(m).call(m,"_")>-1||g()(v).call(v,"_")>-1)&&(console.warn("Warning: escaping deep link whitespace with `_` will be unsupported in v4.0, use `%20` instead."),n.show(h()(i).call(i,(function(e){return e.replace(/_/g," ")})),!0)),n.show(i,!0),n.scrollTo(i)}}},I=function(e,t){return function(n){var r=n.layoutSelectors.getScrollToKey();x().is(r,(0,C.fromJS)(e))&&(n.layoutActions.scrollToElement(t),n.layoutActions.clearScrollTo())}},q=function(e,t){return function(n){try{t=t||n.fn.getScrollParent(e),S().createScroller(t).to(e)}catch(e){console.error(e)}}},R=function(){return{type:_}};const P={fn:{getScrollParent:function(e,t){var n=document.documentElement,r=getComputedStyle(e),a="absolute"===r.position,o=t?/(auto|scroll|hidden)/:/(auto|scroll)/;if("fixed"===r.position)return n;for(var s=e;s=s.parentElement;)if(r=getComputedStyle(s),(!a||"static"!==r.position)&&o.test(r.overflow+r.overflowY+r.overflowX))return s;return n}},statePlugins:{layout:{actions:{scrollToElement:q,scrollTo:k,clearScrollTo:R,readyToScroll:I,parseDeepLinkHash:N},selectors:{getScrollToKey:function(e){return e.get("scrollToKey")},isShownKeyFromUrlHashArray:function(e,t){var n=s()(t,2),r=n[0],a=n[1];return a?["operations",r,a]:r?["operations-tag",r]:[]},urlHashArrayFromIsShownKey:function(e,t){var n=s()(t,3),r=n[0],a=n[1],o=n[2];return"operations"==r?[a,o]:"operations-tag"==r?[a]:[]}},reducers:(E={},a()(E,w,(function(e,t){return e.set("scrollToKey",x().fromJS(t.payload))})),a()(E,_,(function(e){return e.delete("scrollToKey")})),E),wrapActions:{show:A}}}}},4584:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>E});var r=n(6349),a=n.n(r),o=n(4606),s=n.n(o),l=n(4555),i=n.n(l),c=n(4291),u=n.n(c),p=n(1885),d=n.n(p),m=n(1093),h=n.n(m),f=n(4883),g=n.n(f),v=n(6689),y=n.n(v);n(580);const E=function(e,t){return function(n){u()(o,n);var r=d()(o);function o(){var e,n;a()(this,o);for(var s=arguments.length,l=new Array(s),c=0;c<s;c++)l[c]=arguments[c];return n=r.call.apply(r,g()(e=[this]).call(e,l)),h()(i()(n),"onLoad",(function(e){var r=["operations-tag",n.props.tag];t.layoutActions.readyToScroll(r,e)})),n}return s()(o,[{key:"render",value:function(){return y().createElement("span",{ref:this.onLoad},y().createElement(e,this.props))}}]),o}(y().Component)}},877:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>E});var r=n(6349),a=n.n(r),o=n(4606),s=n.n(o),l=n(4555),i=n.n(l),c=n(4291),u=n.n(c),p=n(1885),d=n.n(p),m=n(1093),h=n.n(m),f=n(4883),g=n.n(f),v=n(6689),y=n.n(v);n(8082);const E=function(e,t){return function(n){u()(o,n);var r=d()(o);function o(){var e,n;a()(this,o);for(var s=arguments.length,l=new Array(s),c=0;c<s;c++)l[c]=arguments[c];return n=r.call.apply(r,g()(e=[this]).call(e,l)),h()(i()(n),"onLoad",(function(e){var r=n.props.operation,a=r.toObject(),o=a.tag,s=a.operationId,l=r.toObject().isShownKey;l=l||["operations",o,s],t.layoutActions.readyToScroll(l,e)})),n}return s()(o,[{key:"render",value:function(){return y().createElement("span",{ref:this.onLoad},y().createElement(e,this.props))}}]),o}(y().Component)}},8011:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>g});var r=n(4994),a=n.n(r),o=n(9478),s=n.n(o),l=n(4883),i=n.n(l),c=n(8493),u=n.n(c),p=n(8344),d=n.n(p),m=n(6814),h=n(5572),f=n(7504);function g(e){var t=e.fn;return{statePlugins:{spec:{actions:{download:function(e){return function(n){var r=n.errActions,o=n.specSelectors,l=n.specActions,c=n.getConfigs,u=t.fetch,p=c();function d(t){if(t instanceof Error||t.status>=400)return l.updateLoadingStatus("failed"),r.newThrownErr(a()(new Error((t.message||t.statusText)+" "+e),{source:"fetch"})),void(!t.status&&t instanceof Error&&function(){try{var t;if("URL"in f.Z?t=new(s())(e):(t=document.createElement("a")).href=e,"https:"!==t.protocol&&"https:"===f.Z.location.protocol){var n=a()(new Error("Possible mixed-content issue? The page was loaded over https:// but a ".concat(t.protocol,"// URL was specified. Check that you are not attempting to load mixed content.")),{source:"fetch"});return void r.newThrownErr(n)}if(t.origin!==f.Z.location.origin){var o,l=a()(new Error(i()(o="Possible cross-origin (CORS) issue? The URL origin (".concat(t.origin,") does not match the page (")).call(o,f.Z.location.origin,"). Check the server returns the correct 'Access-Control-Allow-*' headers.")),{source:"fetch"});r.newThrownErr(l)}}catch(e){return}}());l.updateLoadingStatus("success"),l.updateSpec(t.text),o.url()!==e&&l.updateUrl(e)}e=e||o.url(),l.updateLoadingStatus("loading"),r.clear({source:"fetch"}),u({url:e,loadSpec:!0,requestInterceptor:p.requestInterceptor||function(e){return e},responseInterceptor:p.responseInterceptor||function(e){return e},credentials:"same-origin",headers:{Accept:"application/json,*/*"}}).then(d,d)}},updateLoadingStatus:function(e){var t,n=[null,"loading","failed","success","failedConfig"];-1===u()(n).call(n,e)&&console.error(i()(t="Error: ".concat(e," is not one of ")).call(t,d()(n)));return{type:"spec_update_loading_status",payload:e}}},reducers:{spec_update_loading_status:function(e,t){return"string"==typeof t.payload?e.set("loadingStatus",t.payload):e}},selectors:{loadingStatus:(0,m.createSelector)((function(e){return e||(0,h.Map)()}),(function(e){return e.get("loadingStatus")||null}))}}}}}},4966:(e,t,n)=>{"use strict";n.r(t),n.d(t,{NEW_THROWN_ERR:()=>a,NEW_THROWN_ERR_BATCH:()=>o,NEW_SPEC_ERR:()=>s,NEW_SPEC_ERR_BATCH:()=>l,NEW_AUTH_ERR:()=>i,CLEAR:()=>c,CLEAR_BY:()=>u,newThrownErr:()=>p,newThrownErrBatch:()=>d,newSpecErr:()=>m,newSpecErrBatch:()=>h,newAuthErr:()=>f,clear:()=>g,clearBy:()=>v});var r=n(41),a="err_new_thrown_err",o="err_new_thrown_err_batch",s="err_new_spec_err",l="err_new_spec_err_batch",i="err_new_auth_err",c="err_clear",u="err_clear_by";function p(e){return{type:a,payload:(0,r.serializeError)(e)}}function d(e){return{type:o,payload:e}}function m(e){return{type:s,payload:e}}function h(e){return{type:l,payload:e}}function f(e){return{type:i,payload:e}}function g(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return{type:c,payload:e}}function v(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:function(){return!0};return{type:u,payload:e}}},2860:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>u});var r=n(9998),a=n.n(r),o=n(3942),s=n.n(o);const l=require("lodash/reduce");var i=n.n(l),c=[n(2392),n(1835)];function u(e){var t,n={jsSpec:{}},r=i()(c,(function(e,t){try{var r=t.transform(e,n);return a()(r).call(r,(function(e){return!!e}))}catch(t){return console.error("Transformer error:",t),e}}),e);return s()(t=a()(r).call(r,(function(e){return!!e}))).call(t,(function(e){return!e.get("line")&&e.get("path"),e}))}},2392:(e,t,n)=>{"use strict";n.r(t),n.d(t,{transform:()=>p});var r=n(3942),a=n.n(r),o=n(8493),s=n.n(o),l=n(600),i=n.n(l),c=n(66),u=n.n(c);function p(e){return a()(e).call(e,(function(e){var t,n="is not of a type(s)",r=s()(t=e.get("message")).call(t,n);if(r>-1){var a,o,l=i()(a=e.get("message")).call(a,r+n.length).split(",");return e.set("message",i()(o=e.get("message")).call(o,0,r)+function(e){return u()(e).call(e,(function(e,t,n,r){return n===r.length-1&&r.length>1?e+"or "+t:r[n+1]&&r.length>2?e+t+", ":r[n+1]?e+t+" ":e+t}),"should be a")}(l))}return e}))}},1835:(e,t,n)=>{"use strict";n.r(t),n.d(t,{transform:()=>r});n(3942),n(8493),n(1712),n(5572);function r(e,t){t.jsSpec;return e}},7793:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>s});var r=n(3527),a=n(4966),o=n(7667);function s(e){return{statePlugins:{err:{reducers:(0,r.default)(e),actions:a,selectors:o}}}}},3527:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>E});var r=n(1093),a=n.n(r),o=n(4994),s=n.n(o),l=n(3942),i=n.n(l),c=n(4883),u=n.n(c),p=n(9998),d=n.n(p),m=n(7834),h=n.n(m),f=n(4966),g=n(5572),v=n(2860),y={line:0,level:"error",message:"Unknown error"};function E(){var e;return e={},a()(e,f.NEW_THROWN_ERR,(function(e,t){var n=t.payload,r=s()(y,n,{type:"thrown"});return e.update("errors",(function(e){return(e||(0,g.List)()).push((0,g.fromJS)(r))})).update("errors",(function(e){return(0,v.default)(e)}))})),a()(e,f.NEW_THROWN_ERR_BATCH,(function(e,t){var n=t.payload;return n=i()(n).call(n,(function(e){return(0,g.fromJS)(s()(y,e,{type:"thrown"}))})),e.update("errors",(function(e){var t;return u()(t=e||(0,g.List)()).call(t,(0,g.fromJS)(n))})).update("errors",(function(e){return(0,v.default)(e)}))})),a()(e,f.NEW_SPEC_ERR,(function(e,t){var n=t.payload,r=(0,g.fromJS)(n);return r=r.set("type","spec"),e.update("errors",(function(e){return(e||(0,g.List)()).push((0,g.fromJS)(r)).sortBy((function(e){return e.get("line")}))})).update("errors",(function(e){return(0,v.default)(e)}))})),a()(e,f.NEW_SPEC_ERR_BATCH,(function(e,t){var n=t.payload;return n=i()(n).call(n,(function(e){return(0,g.fromJS)(s()(y,e,{type:"spec"}))})),e.update("errors",(function(e){var t;return u()(t=e||(0,g.List)()).call(t,(0,g.fromJS)(n))})).update("errors",(function(e){return(0,v.default)(e)}))})),a()(e,f.NEW_AUTH_ERR,(function(e,t){var n=t.payload,r=(0,g.fromJS)(s()({},n));return r=r.set("type","auth"),e.update("errors",(function(e){return(e||(0,g.List)()).push((0,g.fromJS)(r))})).update("errors",(function(e){return(0,v.default)(e)}))})),a()(e,f.CLEAR,(function(e,t){var n,r=t.payload;if(!r||!e.get("errors"))return e;var a=d()(n=e.get("errors")).call(n,(function(e){var t;return h()(t=e.keySeq()).call(t,(function(t){var n=e.get(t),a=r[t];return!a||n!==a}))}));return e.merge({errors:a})})),a()(e,f.CLEAR_BY,(function(e,t){var n,r=t.payload;if(!r||"function"!=typeof r)return e;var a=d()(n=e.get("errors")).call(n,(function(e){return r(e)}));return e.merge({errors:a})})),e}},7667:(e,t,n)=>{"use strict";n.r(t),n.d(t,{allErrors:()=>o,lastError:()=>s});var r=n(5572),a=n(6814),o=(0,a.createSelector)((function(e){return e}),(function(e){return e.get("errors",(0,r.List)())})),s=(0,a.createSelector)(o,(function(e){return e.last()}))},9978:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>a});var r=n(4309);function a(){return{fn:{opsFilter:r.default}}}},4309:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>l});var r=n(9998),a=n.n(r),o=n(8493),s=n.n(o);function l(e,t){return a()(e).call(e,(function(e,n){return-1!==s()(n).call(n,t)}))}},5474:(e,t,n)=>{"use strict";n.r(t),n.d(t,{UPDATE_LAYOUT:()=>a,UPDATE_FILTER:()=>o,UPDATE_MODE:()=>s,SHOW:()=>l,updateLayout:()=>i,updateFilter:()=>c,show:()=>u,changeMode:()=>p});var r=n(1890),a="layout_update_layout",o="layout_update_filter",s="layout_update_mode",l="layout_show";function i(e){return{type:a,payload:e}}function c(e){return{type:o,payload:e}}function u(e){var t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];return e=(0,r.AF)(e),{type:l,payload:{thing:e,shown:t}}}function p(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";return e=(0,r.AF)(e),{type:s,payload:{thing:e,mode:t}}}},6821:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>l});var r=n(5672),a=n(5474),o=n(4400),s=n(8989);function l(){return{statePlugins:{layout:{reducers:r.default,actions:a,selectors:o},spec:{wrapSelectors:s}}}}},5672:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>u});var r,a=n(1093),o=n.n(a),s=n(4883),l=n.n(s),i=n(5572),c=n(5474);const u=(r={},o()(r,c.UPDATE_LAYOUT,(function(e,t){return e.set("layout",t.payload)})),o()(r,c.UPDATE_FILTER,(function(e,t){return e.set("filter",t.payload)})),o()(r,c.SHOW,(function(e,t){var n=t.payload.shown,r=(0,i.fromJS)(t.payload.thing);return e.update("shown",(0,i.fromJS)({}),(function(e){return e.set(r,n)}))})),o()(r,c.UPDATE_MODE,(function(e,t){var n,r=t.payload.thing,a=t.payload.mode;return e.setIn(l()(n=["modes"]).call(n,r),(a||"")+"")})),r)},4400:(e,t,n)=>{"use strict";n.r(t),n.d(t,{current:()=>u,currentFilter:()=>p,isShown:()=>d,whatMode:()=>m,showSummary:()=>h});var r=n(6731),a=n.n(r),o=n(4883),s=n.n(o),l=n(6814),i=n(1890),c=n(5572),u=function(e){return e.get("layout")},p=function(e){return e.get("filter")},d=function(e,t,n){return t=(0,i.AF)(t),e.get("shown",(0,c.fromJS)({})).get((0,c.fromJS)(t),n)},m=function(e,t){var n,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return t=(0,i.AF)(t),e.getIn(s()(n=["modes"]).call(n,a()(t)),r)},h=(0,l.createSelector)((function(e){return e}),(function(e){return!d(e,"editor")}))},8989:(e,t,n)=>{"use strict";n.r(t),n.d(t,{taggedOperations:()=>l});var r=n(4883),a=n.n(r),o=n(600),s=n.n(o),l=function(e,t){return function(n){for(var r,o=arguments.length,l=new Array(o>1?o-1:0),i=1;i<o;i++)l[i-1]=arguments[i];var c=e.apply(void 0,a()(r=[n]).call(r,l)),u=t.getSystem(),p=u.fn,d=u.layoutSelectors,m=u.getConfigs,h=m(),f=h.maxDisplayedTags,g=d.currentFilter();return g&&!0!==g&&"true"!==g&&"false"!==g&&(c=p.opsFilter(c,g)),f&&!isNaN(f)&&f>=0&&(c=s()(c).call(c,0,f)),c}}},9150:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>o});var r=n(593),a=n.n(r);function o(e){var t=e.configs,n={debug:0,info:1,log:2,warn:3,error:4},r=function(e){return n[e]||-1},o=t.logLevel,s=r(o);function l(e){for(var t,n=arguments.length,a=new Array(n>1?n-1:0),o=1;o<n;o++)a[o-1]=arguments[o];r(e)>=s&&(t=console)[e].apply(t,a)}return l.warn=a()(l).call(l,null,"warn"),l.error=a()(l).call(l,null,"error"),l.info=a()(l).call(l,null,"info"),l.debug=a()(l).call(l,null,"debug"),{rootInjects:{log:l}}}},7002:(e,t,n)=>{"use strict";n.r(t),n.d(t,{UPDATE_SELECTED_SERVER:()=>r,UPDATE_REQUEST_BODY_VALUE:()=>a,UPDATE_REQUEST_BODY_VALUE_RETAIN_FLAG:()=>o,UPDATE_REQUEST_BODY_INCLUSION:()=>s,UPDATE_ACTIVE_EXAMPLES_MEMBER:()=>l,UPDATE_REQUEST_CONTENT_TYPE:()=>i,UPDATE_RESPONSE_CONTENT_TYPE:()=>c,UPDATE_SERVER_VARIABLE_VALUE:()=>u,SET_REQUEST_BODY_VALIDATE_ERROR:()=>p,CLEAR_REQUEST_BODY_VALIDATE_ERROR:()=>d,CLEAR_REQUEST_BODY_VALUE:()=>m,setSelectedServer:()=>h,setRequestBodyValue:()=>f,setRetainRequestBodyValueFlag:()=>g,setRequestBodyInclusion:()=>v,setActiveExamplesMember:()=>y,setRequestContentType:()=>E,setResponseContentType:()=>S,setServerVariableValue:()=>b,setRequestBodyValidateError:()=>C,clearRequestBodyValidateError:()=>x,initRequestBodyValidateError:()=>w,clearRequestBodyValue:()=>_});var r="oas3_set_servers",a="oas3_set_request_body_value",o="oas3_set_request_body_retain_flag",s="oas3_set_request_body_inclusion",l="oas3_set_active_examples_member",i="oas3_set_request_content_type",c="oas3_set_response_content_type",u="oas3_set_server_variable_value",p="oas3_set_request_body_validate_error",d="oas3_clear_request_body_validate_error",m="oas3_clear_request_body_value";function h(e,t){return{type:r,payload:{selectedServerUrl:e,namespace:t}}}function f(e){var t=e.value,n=e.pathMethod;return{type:a,payload:{value:t,pathMethod:n}}}var g=function(e){var t=e.value,n=e.pathMethod;return{type:o,payload:{value:t,pathMethod:n}}};function v(e){var t=e.value,n=e.pathMethod,r=e.name;return{type:s,payload:{value:t,pathMethod:n,name:r}}}function y(e){var t=e.name,n=e.pathMethod,r=e.contextType,a=e.contextName;return{type:l,payload:{name:t,pathMethod:n,contextType:r,contextName:a}}}function E(e){var t=e.value,n=e.pathMethod;return{type:i,payload:{value:t,pathMethod:n}}}function S(e){var t=e.value,n=e.path,r=e.method;return{type:c,payload:{value:t,path:n,method:r}}}function b(e){var t=e.server,n=e.namespace,r=e.key,a=e.val;return{type:u,payload:{server:t,namespace:n,key:r,val:a}}}var C=function(e){var t=e.path,n=e.method,r=e.validationErrors;return{type:p,payload:{path:t,method:n,validationErrors:r}}},x=function(e){var t=e.path,n=e.method;return{type:d,payload:{path:t,method:n}}},w=function(e){var t=e.pathMethod;return{type:d,payload:{path:t[0],method:t[1]}}},_=function(e){var t=e.pathMethod;return{type:m,payload:{pathMethod:t}}}},3723:(e,t,n)=>{"use strict";n.r(t),n.d(t,{definitionsToAuthorize:()=>E});var r=n(1093),a=n.n(r),o=n(8030),s=n.n(o),l=n(4883),i=n.n(l),c=n(4235),u=n.n(c),p=n(9998),d=n.n(p),m=n(66),h=n.n(m),f=n(6814),g=n(5572),v=n(7779);var y,E=(y=(0,f.createSelector)((function(e){return e}),(function(e){return e.specSelectors.securityDefinitions()}),(function(e,t){var n,r=(0,g.List)();return t?(u()(n=t.entrySeq()).call(n,(function(e){var t,n=s()(e,2),o=n[0],l=n[1],i=l.get("type");if("oauth2"===i&&u()(t=l.get("flows").entrySeq()).call(t,(function(e){var t=s()(e,2),n=t[0],i=t[1],c=(0,g.fromJS)({flow:n,authorizationUrl:i.get("authorizationUrl"),tokenUrl:i.get("tokenUrl"),scopes:i.get("scopes"),type:l.get("type"),description:l.get("description")});r=r.push(new g.Map(a()({},o,d()(c).call(c,(function(e){return void 0!==e})))))})),"http"!==i&&"apiKey"!==i||(r=r.push(new g.Map(a()({},o,l)))),"openIdConnect"===i&&l.get("openIdConnectData")){var c=l.get("openIdConnectData"),p=c.get("grant_types_supported")||["authorization_code","implicit"];u()(p).call(p,(function(e){var t,n=c.get("scopes_supported")&&h()(t=c.get("scopes_supported")).call(t,(function(e,t){return e.set(t,"")}),new g.Map),s=(0,g.fromJS)({flow:e,authorizationUrl:c.get("authorization_endpoint"),tokenUrl:c.get("token_endpoint"),scopes:n,type:"oauth2",openIdConnectUrl:l.get("openIdConnectUrl")});r=r.push(new g.Map(a()({},o,d()(s).call(s,(function(e){return void 0!==e})))))}))}})),r):r})),function(e,t){return function(){for(var n=t.getSystem().specSelectors.specJson(),r=arguments.length,a=new Array(r),o=0;o<r;o++)a[o]=arguments[o];if((0,v.isOAS3)(n)){var s,l=t.getState().getIn(["spec","resolvedSubtrees","components","securitySchemes"]);return y.apply(void 0,i()(s=[t,l]).call(s,a))}return e.apply(void 0,a)}})},3427:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>d});var r=n(4250),a=n.n(r),o=n(8030),s=n.n(o),l=n(3942),i=n.n(l),c=n(6689),u=n.n(c),p=(n(580),n(8082),n(5572));const d=function(e){var t,n=e.callbacks,r=e.getComponent,o=e.specPath,l=r("OperationContainer",!0);if(!n)return u().createElement("span",null,"No callbacks");var c=i()(t=n.entrySeq()).call(t,(function(t){var n,r=s()(t,2),c=r[0],d=r[1];return u().createElement("div",{key:c},u().createElement("h2",null,c),i()(n=d.entrySeq()).call(n,(function(t){var n,r=s()(t,2),d=r[0],m=r[1];return"$$ref"===d?null:u().createElement("div",{key:d},i()(n=m.entrySeq()).call(n,(function(t){var n=s()(t,2),r=n[0],i=n[1];if("$$ref"===r)return null;var m=(0,p.fromJS)({operation:i});return u().createElement(l,a()({},e,{op:m,key:r,tag:"",method:r,path:d,specPath:o.push(c,d,r),allowTryItOut:!1}))})))})))}));return u().createElement("div",null,c)}},6775:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>x});var r=n(6349),a=n.n(r),o=n(4606),s=n.n(o),l=n(4555),i=n.n(l),c=n(4291),u=n.n(c),p=n(1885),d=n.n(p),m=n(1093),h=n.n(m),f=n(4994),g=n.n(f),v=n(9998),y=n.n(v),E=n(3942),S=n.n(E),b=n(6689),C=n.n(b),x=(n(580),function(e){u()(n,e);var t=d()(n);function n(e,r){var o;a()(this,n),o=t.call(this,e,r),h()(i()(o),"onChange",(function(e){var t=o.props.onChange,n=e.target,r=n.value,a=n.name,s=g()({},o.state.value);a?s[a]=r:s=r,o.setState({value:s},(function(){return t(o.state)}))}));var s=o.props,l=s.name,c=s.schema,u=o.getValue();return o.state={name:l,schema:c,value:u},o}return s()(n,[{key:"getValue",value:function(){var e=this.props,t=e.name,n=e.authorized;return n&&n.getIn([t,"value"])}},{key:"render",value:function(){var e,t,n=this.props,r=n.schema,a=n.getComponent,o=n.errSelectors,s=n.name,l=a("Input"),i=a("Row"),c=a("Col"),u=a("authError"),p=a("Markdown",!0),d=a("JumpToPath",!0),m=(r.get("scheme")||"").toLowerCase(),h=this.getValue(),f=y()(e=o.allErrors()).call(e,(function(e){return e.get("authId")===s}));if("basic"===m){var g,v=h?h.get("username"):null;return C().createElement("div",null,C().createElement("h4",null,C().createElement("code",null,s||r.get("name")),"  (http, Basic)",C().createElement(d,{path:["securityDefinitions",s]})),v&&C().createElement("h6",null,"Authorized"),C().createElement(i,null,C().createElement(p,{source:r.get("description")})),C().createElement(i,null,C().createElement("label",null,"Username:"),v?C().createElement("code",null," ",v," "):C().createElement(c,null,C().createElement(l,{type:"text",required:"required",name:"username","aria-label":"auth-basic-username",onChange:this.onChange,autoFocus:!0}))),C().createElement(i,null,C().createElement("label",null,"Password:"),v?C().createElement("code",null," ****** "):C().createElement(c,null,C().createElement(l,{autoComplete:"new-password",name:"password",type:"password","aria-label":"auth-basic-password",onChange:this.onChange}))),S()(g=f.valueSeq()).call(g,(function(e,t){return C().createElement(u,{error:e,key:t})})))}return"bearer"===m?C().createElement("div",null,C().createElement("h4",null,C().createElement("code",null,s||r.get("name")),"  (http, Bearer)",C().createElement(d,{path:["securityDefinitions",s]})),h&&C().createElement("h6",null,"Authorized"),C().createElement(i,null,C().createElement(p,{source:r.get("description")})),C().createElement(i,null,C().createElement("label",null,"Value:"),h?C().createElement("code",null," ****** "):C().createElement(c,null,C().createElement(l,{type:"text","aria-label":"auth-bearer-value",onChange:this.onChange,autoFocus:!0}))),S()(t=f.valueSeq()).call(t,(function(e,t){return C().createElement(u,{error:e,key:t})}))):C().createElement("div",null,C().createElement("em",null,C().createElement("b",null,s)," HTTP authentication: unsupported scheme ","'".concat(m,"'")))}}]),n}(C().Component))},6467:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>p});var r=n(3427),a=n(2458),o=n(5757),s=n(6617),l=n(9928),i=n(5327),c=n(6775),u=n(6796);const p={Callbacks:r.default,HttpAuth:c.default,RequestBody:a.default,Servers:s.default,ServersContainer:l.default,RequestBodyEditor:i.default,OperationServers:u.default,operationLink:o.default}},5757:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>y});var r=n(6349),a=n.n(r),o=n(4606),s=n.n(o),l=n(4291),i=n.n(l),c=n(1885),u=n.n(c),p=n(8344),d=n.n(p),m=n(3942),h=n.n(m),f=n(6689),g=n.n(f),v=(n(580),n(8082),function(e){i()(n,e);var t=u()(n);function n(){return a()(this,n),t.apply(this,arguments)}return s()(n,[{key:"render",value:function(){var e=this.props,t=e.link,n=e.name,r=(0,e.getComponent)("Markdown",!0),a=t.get("operationId")||t.get("operationRef"),o=t.get("parameters")&&t.get("parameters").toJS(),s=t.get("description");return g().createElement("div",{className:"operation-link"},g().createElement("div",{className:"description"},g().createElement("b",null,g().createElement("code",null,n)),s?g().createElement(r,{source:s}):null),g().createElement("pre",null,"Operation `",a,"`",g().createElement("br",null),g().createElement("br",null),"Parameters ",function(e,t){var n;if("string"!=typeof t)return"";return h()(n=t.split("\n")).call(n,(function(t,n){return n>0?Array(e+1).join(" ")+t:t})).join("\n")}(0,d()(o,null,2))||"{}",g().createElement("br",null)))}}]),n}(f.Component));const y=v},6796:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>b});var r=n(67),a=n.n(r),o=n(6349),s=n.n(o),l=n(4606),i=n.n(l),c=n(4555),u=n.n(c),p=n(4291),d=n.n(p),m=n(1885),h=n.n(m),f=n(1093),g=n.n(f),v=n(4883),y=n.n(v),E=n(6689),S=n.n(E),b=(n(580),n(8082),function(e){d()(n,e);var t=h()(n);function n(){var e,r;s()(this,n);for(var o=arguments.length,l=new Array(o),i=0;i<o;i++)l[i]=arguments[i];return r=t.call.apply(t,y()(e=[this]).call(e,l)),g()(u()(r),"setSelectedServer",(function(e){var t,n=r.props,a=n.path,o=n.method;return r.forceUpdate(),r.props.setSelectedServer(e,y()(t="".concat(a,":")).call(t,o))})),g()(u()(r),"setServerVariableValue",(function(e){var t,n=r.props,o=n.path,s=n.method;return r.forceUpdate(),r.props.setServerVari                                                                                                                                                                                                                                                                                                                                                                                                                                                                           export type Platform = 'browser' | 'node' | 'neutral';
export type Format = 'iife' | 'cjs' | 'esm';
export type Loader = 'js' | 'jsx' | 'ts' | 'tsx' | 'css' | 'json' | 'text' | 'base64' | 'file' | 'dataurl' | 'binary' | 'copy' | 'default';
export type LogLevel = 'verbose' | 'debug' | 'info' | 'warning' | 'error' | 'silent';
export type Charset = 'ascii' | 'utf8';
export type Drop = 'console' | 'debugger';

interface CommonOptions {
  /** Documentation: https://esbuild.github.io/api/#sourcemap */
  sourcemap?: boolean | 'linked' | 'inline' | 'external' | 'both';
  /** Documentation: https://esbuild.github.io/api/#legal-comments */
  legalComments?: 'none' | 'inline' | 'eof' | 'linked' | 'external';
  /** Documentation: https://esbuild.github.io/api/#source-root */
  sourceRoot?: string;
  /** Documentation: https://esbuild.github.io/api/#sources-content */
  sourcesContent?: boolean;

  /** Documentation: https://esbuild.github.io/api/#format */
  format?: Format;
  /** Documentation: https://esbuild.github.io/api/#global-name */
  globalName?: string;
  /** Documentation: https://esbuild.github.io/api/#target */
  target?: string | string[];
  /** Documentation: https://esbuild.github.io/api/#supported */
  supported?: Record<string, boolean>;

  /** Documentation: https://esbuild.github.io/api/#mangle-props */
  mangleProps?: RegExp;
  /** Documentation: https://esbuild.github.io/api/#mangle-props */
  reserveProps?: RegExp;
  /** Documentation: https://esbuild.github.io/api/#mangle-props */
  mangleQuoted?: boolean;
  /** Documentation: https://esbuild.github.io/api/#mangle-props */
  mangleCache?: Record<string, string | false>;
  /** Documentation: https://esbuild.github.io/api/#drop */
  drop?: Drop[];
  /** Documentation: https://esbuild.github.io/api/#minify */
  minify?: boolean;
  /** Documentation: https://esbuild.github.io/api/#minify */
  minifyWhitespace?: boolean;
  /** Documentation: https://esbuild.github.io/api/#minify */
  minifyIdentifiers?: boolean;
  /** Documentation: https://esbuild.github.io/api/#minify */
  minifySyntax?: boolean;
  /** Documentation: https://esbuild.github.io/api/#charset */
  charset?: Charset;
  /** Documentation: https://esbuild.github.io/api/#tree-shaking */
  treeShaking?: boolean;
  /** Documentation: https://esbuild.github.io/api/#ignore-annotations */
  ignoreAnnotations?: boolean;

  /** Documentation: https://esbuild.github.io/api/#jsx */
  jsx?: 'transform' | 'preserve';
  /** Documentation: https://esbuild.github.io/api/#jsx-factory */
  jsxFactory?: string;
  /** Documentation: https://esbuild.github.io/api/#jsx-fragment */
  jsxFragment?: string;

  /** Documentation: https://esbuild.github.io/api/#define */
  define?: { [key: string]: string };
  /** Documentation: https://esbuild.github.io/api/#pure */
  pure?: string[];
  /** Documentation: https://esbuild.github.io/api/#keep-names */
  keepNames?: boolean;

  /** Documentation: https://esbuild.github.io/api/#color */
  color?: boolean;
  /** Documentation: https://esbuild.github.io/api/#log-level */
  logLevel?: LogLevel;
  /** Documentation: https://esbuild.github.io/api/#log-limit */
  logLimit?: number;
  /** Documentation: https://esbuild.github.io/api/#log-override */
  logOverride?: Record<string, LogLevel>;
}

export interface BuildOptions extends CommonOptions {
  /** Documentation: https://esbuild.github.io/api/#bundle */
  bundle?: boolean;
  /** Documentation: https://esbuild.github.io/api/#splitting */
  splitting?: boolean;
  /** Documentation: https://esbuild.github.io/api/#preserve-symlinks */
  preserveSymlinks?: boolean;
  /** Documentation: https://esbuild.github.io/api/#outfile */
  outfile?: string;
  /** Documentation: https://esbuild.github.io/api/#metafile */
  metafile?: boolean;
  /** Documentation: https://esbuild.github.io/api/#outdir */
  outdir?: string;
  /** Documentation: https://esbuild.github.io/api/#outbase */
  outbase?: string;
  /** Documentation: https://esbuild.github.io/api/#platform */
  platform?: Platform;
  /** Documentation: https://esbuild.github.io/api/#external */
  external?: string[];
  /** Documentation: https://esbuild.github.io/api/#loader */
  loader?: { [ext: string]: Loader };
  /** Documentation: https://esbuild.github.io/api/#resolve-extensions */
  resolveExtensions?: string[];
  /** Documentation: https://esbuild.github.io/api/#main-fields */
  mainFields?: string[];
  /** Documentation: https://esbuild.github.io/api/#conditions */
  conditions?: string[];
  /** Documentation: https://esbuild.github.io/api/#write */
  write?: boolean;
  /** Documentation: https://esbuild.github.io/api/#allow-overwrite */
  allowOverwrite?: boolean;
  /** Documentation: https://esbuild.github.io/api/#tsconfig */
  tsconfig?: string;
  /** Documentation: https://esbuild.github.io/api/#out-extension */
  outExtension?: { [ext: string]: string };
  /** Documentation: https://esbuild.github.io/api/#public-path */
  publicPath?: string;
  /** Documentation: https://esbuild.github.io/api/#entry-names */
  entryNames?: string;
  /** Documentation: https://esbuild.github.io/api/#chunk-names */
  chunkNames?: string;
  /** Documentation: https://esbuild.github.io/api/#asset-names */
  assetNames?: string;
  /** Documentation: https://esbuild.github.io/api/#inject */
  inject?: string[];
  /** Documentation: https://esbuild.github.io/api/#banner */
  banner?: { [type: string]: string };
  /** Documentation: https://esbuild.github.io/api/#footer */
  footer?: { [type: string]: string };
  /** Documentation: https://esbuild.github.io/api/#incremental */
  incremental?: boolean;
  /** Documentation: https://esbuild.github.io/api/#entry-points */
  entryPoints?: string[] | Record<string, string>;
  /** Documentation: https://esbuild.github.io/api/#stdin */
  stdin?: StdinOptions;
  /** Documentation: https://esbuild.github.io/plugins/ */
  plugins?: Plugin[];
  /** Documentation: https://esbuild.github.io/api/#working-directory */
  absWorkingDir?: string;
  /** Documentation: https://esbuild.github.io/api/#node-paths */
  nodePaths?: string[]; // The "NODE_PATH" variable from Node.js
  /** Documentation: https://esbuild.github.io/api/#watch */
  watch?: boolean | WatchMode;
}

export interface WatchMode {
  onRebuild?: (error: BuildFailure | null, result: BuildResult | null) => void;
}

export interface StdinOptions {
  contents: string;
  resolveDir?: string;
  sourcefile?: string;
  loader?: Loader;
}

export interface Message {
  id: string;
  pluginName: string;
  text: string;
  location: Location | null;
  notes: Note[];

  /**
   * Optional user-specified data that is passed through unmodified. You can
   * use this to stash the original error, for example.
   */
  detail: any;
}

export interface Note {
  text: string;
  location: Location | null;
}

export interface Location {
  file: string;
  namespace: string;
  /** 1-based */
  line: number;
  /** 0-based, in bytes */
  column: number;
  /** in bytes */
  length: number;
  lineText: string;
  suggestion: string;
}

export interface OutputFile {
  path: string;
  /** "text" as bytes */
  contents: Uint8Array;
  /** "contents" as text */
  text: string;
}

export interface BuildInvalidate {
  (): Promise<BuildIncremental>;
  dispose(): void;
}

export interface BuildIncremental extends BuildResult {
  rebuild: BuildInvalidate;
}

export interface BuildResult {
  errors: Message[];
  warnings: Message[];
  /** Only when "write: false" */
  outputFiles?: OutputFile[];
  /** Only when "incremental: true" */
  rebuild?: BuildInvalidate;
  /** Only when "watch: true" */
  stop?: () => void;
  /** Only when "metafile: true" */
  metafile?: Metafile;
  /** Only when "mangleCache" is present */
  mangleCache?: Record<string, string | false>;
}

export interface BuildFailure extends Error {
  errors: Message[];
  warnings: Message[];
}

/** Documentation: https://esbuild.github.io/api/#serve-arguments */
export interface ServeOptions {
  port?: number;
  host?: string;
  servedir?: string;
  onRequest?: (args: ServeOnRequestArgs) => void;
}

export interface ServeOnRequestArgs {
  remoteAddress: string;
  method: string;
  path: string;
  status: number;
  /** The time to generate the response, not to send it */
  timeInMS: number;
}

/** Documentation: https://esbuild.github.io/api/#serve-return-values */
export interface ServeResult {
  port: number;
  host: string;
  wait: Promise<void>;
  stop: () => void;
}

export interface TransformOptions extends CommonOptions {
  tsconfigRaw?: string | {
    compilerOptions?: {
      jsxFactory?: string,
      jsxFragmentFactory?: string,
      useDefineForClassFields?: boolean,
      importsNotUsedAsValues?: 'remove' | 'preserve' | 'error',
      preserveValueImports?: boolean,
    },
  };

  sourcefile?: string;
  loader?: Loader;
  banner?: string;
  footer?: string;
}

export interface TransformResult {
  code: string;
  map: string;
  warnings: Message[];
  /** Only when "mangleCache" is present */
  mangleCache?: Record<string, string | false>;
}

export interface TransformFailure extends Error {
  errors: Message[];
  warnings: Message[];
}

export interface Plugin {
  name: string;
  setup: (build: PluginBuild) => (void | Promise<void>);
}

export interface PluginBuild {
  initialOptions: BuildOptions;
  resolve(path: string, options?: ResolveOptions): Promise<ResolveResult>;

  onStart(callback: () =>
    (OnStartResult | null | void | Promise<OnStartResult | null | void>)): void;
  onEnd(callback: (result: BuildResult) =>
    (void | Promise<void>)): void;
  onResolve(options: OnResolveOptions, callback: (args: OnResolveArgs) =>
    (OnResolveResult | null | undefined | Promise<OnResolveResult | null | undefined>)): void;
  onLoad(options: OnLoadOptions, callback: (args: OnLoadArgs) =>
    (OnLoadResult | null | undefined | Promise<OnLoadResult | null | undefined>)): void;

  // This is a full copy of the esbuild library in case you need it
  esbuild: {
    serve: typeof serve,
    build: typeof build,
    buildSync: typeof buildSync,
    transform: typeof transform,
    transformSync: typeof transformSync,
    formatMessages: typeof formatMessages,
    formatMessagesSync: typeof formatMessagesSync,
    analyzeMetafile: typeof analyzeMetafile,
    analyzeMetafileSync: typeof analyzeMetafileSync,
    initialize: typeof initialize,
    version: typeof version,
  };
}

export interface ResolveOptions {
  pluginName?: string;
  importer?: string;
  namespace?: string;
  resolveDir?: string;
  kind?: ImportKind;
  pluginData?: any;
}

export interface ResolveResult {
  errors: Message[];
  warnings: Message[];

  path: string;
  external: boolean;
  sideEffects: boolean;
  namespace: string;
  suffix: string;
  pluginData: any;
}

export interface OnStartResult {
  errors?: PartialMessage[];
  warnings?: PartialMessage[];
}

export interface OnResolveOptions {
  filter: RegExp;
  namespace?: string;
}

export interface OnResolveArgs {
  path: string;
  importer: string;
  namespace: string;
  resolveDir: string;
  kind: ImportKind;
  pluginData: any;
}

export type ImportKind =
  | 'entry-point'

  // JS
  | 'import-statement'
  | 'require-call'
  | 'dynamic-import'
  | 'require-resolve'

  // CSS
  | 'import-rule'
  | 'url-token'

export interface OnResolveResult {
  pluginName?: string;

  errors?: PartialMessage[];
  warnings?: PartialMessage[];

  path?: string;
  external?: boolean;
  sideEffects?: boolean;
  namespace?: string;
  suffix?: string;
  pluginData?: any;

  watchFiles?: string[];
  watchDirs?: string[];
}

export interface OnLoadOptions {
  filter: RegExp;
  namespace?: string;
}

export interface OnLoadArgs {
  path: string;
  namespace: string;
  suffix: string;
  pluginData: any;
}

export interface OnLoadResult {
  pluginName?: string;

  errors?: PartialMessage[];
  warnings?: PartialMessage[];

  contents?: string | Uint8Array;
  resolveDir?: string;
  loader?: Loader;
  pluginData?: any;

  watchFiles?: string[];
  watchDirs?: string[];
}

export interface PartialMessage {
  id?: string;
  pluginName?: string;
  text?: string;
  location?: Partial<Location> | null;
  notes?: PartialNote[];
  detail?: any;
}

export interface PartialNote {
  text?: string;
  location?: Partial<Location> | null;
}

export interface Metafile {
  inputs: {
    [path: string]: {
      bytes: number
      imports: {
        path: string
        kind: ImportKind
      }[]
    }
  }
  outputs: {
    [path: string]: {
      bytes: number
      inputs: {
        [path: string]: {
          bytesInOutput: number
        }
      }
      imports: {
        path: string
        kind: ImportKind
      }[]
      exports: string[]
      entryPoint?: string
    }
  }
}

export interface FormatMessagesOptions {
  kind: 'error' | 'warning';
  color?: boolean;
  terminalWidth?: number;
}

export interface AnalyzeMetafileOptions {
  color?: boolean;
  verbose?: boolean;
}

/**
 * This function invokes the "esbuild" command-line tool for you. It returns a
 * promise that either resolves with a "BuildResult" object or rejects with a
 * "BuildFailure" object.
 *
 * - Works in node: yes
 * - Works in browser: yes
 *
 * Documentation: https://esbuild.github.io/api/#build-api
 */
export declare function build(options: BuildOptions & { write: false }): Promise<BuildResult & { outputFiles: OutputFile[] }>;
export declare function build(options: BuildOptions & { incremental: true, metafile: true }): Promise<BuildIncremental & { metafile: Metafile }>;
export declare function build(options: BuildOptions & { incremental: true }): Promise<BuildIncremental>;
export declare function build(options: BuildOptions & { metafile: true }): Promise<BuildResult & { metafile: Metafile }>;
export declare function build(options: BuildOptions): Promise<BuildResult>;

/**
 * This function is similar to "build" but it serves the resulting files over
 * HTTP on a localhost address with the specified port.
 *
 * - Works in node: yes
 * - Works in browser: no
 *
 * Documentation: https://esbuild.github.io/api/#serve
 */
export declare function serve(serveOptions: ServeOptions, buildOptions: BuildOptions): Promise<ServeResult>;

/**
 * This function transforms a single JavaScript file. It can be used to minify
 * JavaScript, convert TypeScript/JSX to JavaScript, or convert newer JavaScript
 * to older JavaScript. It returns a promise that is either resolved with a
 * "TransformResult" object or rejected with a "TransformFailure" object.
 *
 * - Works in node: yes
 * - Works in browser: yes
 *
 * Documentation: https://esbuild.github.io/api/#transform-api
 */
export declare function transform(input: string, options?: TransformOptions): Promise<TransformResult>;

/**
 * Converts log messages to formatted message strings suitable for printing in
 * the terminal. This allows you to reuse the built-in behavior of esbuild's
 * log message formatter. This is a batch-oriented API for efficiency.
 *
 * - Works in node: yes
 * - Works in browser: yes
 */
export declare function formatMessages(messages: PartialMessage[], options: FormatMessagesOptions): Promise<string[]>;

/**
 * Pretty-prints an analysis of the metafile JSON to a string. This is just for
 * convenience to be able to match esbuild's pretty-printing exactly. If you want
 * to customize it, you can just inspect the data in the metafile yourself.
 *
 * - Works in node: yes
 * - Works in browser: yes
 *
 * Documentation: https://esbuild.github.io/api/#analyze
 */
export declare function analyzeMetafile(metafile: Metafile | string, options?: AnalyzeMetafileOptions): Promise<string>;

/**
 * A synchronous version of "build".
 *
 * - Works in node: yes
 * - Works in browser: no
 *
 * Documentation: https://esbuild.github.io/api/#build-api
 */
export declare function buildSync(options: BuildOptions & { write: false }): BuildResult & { outputFiles: OutputFile[] };
export declare function buildSync(options: BuildOptions): BuildResult;

/**
 * A synchronous version of "transform".
 *
 * - Works in node: yes
 * - Works in browser: no
 *
 * Documentation: https://esbuild.github.io/api/#transform-api
 */
export declare function transformSync(input: string, options?: TransformOptions): TransformResult;

/**
 * A synchronous version of "formatMessages".
 *
 * - Works in node: yes
 * - Works in browser: no
 */
export declare function formatMessagesSync(messages: PartialMessage[], options: FormatMessagesOptions): string[];

/**
 * A synchronous version of "analyzeMetafile".
 *
 * - Works in node: yes
 * - Works in browser: no
 *
 * Documentation: https://esbuild.github.io/api/#analyze
 */
export declare function analyzeMetafileSync(metafile: Metafile | string, options?: AnalyzeMetafileOptions): string;

/**
 * This configures the browser-based version of esbuild. It is necessary to
 * call this first and wait for the returned promise to be resolved before
 * making other API calls when using esbuild in the browser.
 *
 * - Works in node: yes
 * - Works in browser: yes ("options" is required)
 *
 * Documentation: https://esbuild.github.io/api/#running-in-the-browser
 */
export declare function initialize(options: InitializeOptions): Promise<void>;

export interface InitializeOptions {
  /**
   * The URL of the "esbuild.wasm" file. This must be provided when running
   * esbuild in the browser.
   */
  wasmURL?: string

  /**
   * The result of calling "new WebAssembly.Module(buffer)" where "buffer"
   * is a typed array or ArrayBuffer containing the binary code of the
   * "esbuild.wasm" file.
   *
   * You can use this as an alternative to "wasmURL" for environments where it's
   * not possible to download the WebAssembly module.
   */
  wasmModule?: WebAssembly.Module

  /**
   * By default esbuild runs the WebAssembly-based browser API in a web worker
   * to avoid blocking the UI thread. This can be disabled by setting "worker"
   * to false.
   */
  worker?: boolean
}

export let version: string;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      'use strict';
/**
 * @license Angular v14.2.0-next.0
 * (c) 2010-2022 Google LLC. https://angular.io/
 * License: MIT
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
Zone.__load_patch('jasmine', (global, Zone, api) => {
    const __extends = function (d, b) {
        for (const p in b)
            if (b.hasOwnProperty(p))
                d[p] = b[p];
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
    };
    // Patch jasmine's describe/it/beforeEach/afterEach functions so test code always runs
    // in a testZone (ProxyZone). (See: angular/zone.js#91 & angular/angular#10503)
    if (!Zone)
        throw new Error('Missing: zone.js');
    if (typeof jest !== 'undefined') {
        // return if jasmine is a light implementation inside jest
        // in this case, we are running inside jest not jasmine
        return;
    }
    if (typeof jasmine == 'undefined' || jasmine['__zone_patch__']) {
        return;
    }
    jasmine['__zone_patch__'] = true;
    const SyncTestZoneSpec = Zone['SyncTestZoneSpec'];
    const ProxyZoneSpec = Zone['ProxyZoneSpec'];
    if (!SyncTestZoneSpec)
        throw new Error('Missing: SyncTestZoneSpec');
    if (!ProxyZoneSpec)
        throw new Error('Missing: ProxyZoneSpec');
    const ambientZone = Zone.current;
    const symbol = Zone.__symbol__;
    // whether patch jasmine clock when in fakeAsync
    const disablePatchingJasmineClock = global[symbol('fakeAsyncDisablePatchingClock')] === true;
    // the original variable name fakeAsyncPatchLock is not accurate, so the name will be
    // fakeAsyncAutoFakeAsyncWhenClockPatched and if this enablePatchingJasmineClock is false, we also
    // automatically disable the auto jump into fakeAsync feature
    const enableAutoFakeAsyncWhenClockPatched = !disablePatchingJasmineClock &&
        ((global[symbol('fakeAsyncPatchLock')] === true) ||
            (global[symbol('fakeAsyncAutoFakeAsyncWhenClockPatched')] === true));
    const ignoreUnhandledRejection = global[symbol('ignoreUnhandledRejection')] === true;
    if (!ignoreUnhandledRejection) {
        const globalErrors = jasmine.GlobalErrors;
        if (globalErrors && !jasmine[symbol('GlobalErrors')]) {
            jasmine[symbol('GlobalErrors')] = globalErrors;
            jasmine.GlobalErrors = function () {
                const instance = new globalErrors();
                const originalInstall = instance.install;
                if (originalInstall && !instance[symbol('install')]) {
                    instance[symbol('install')] = originalInstall;
                    instance.install = function () {
                        const isNode = typeof process !== 'undefined' && !!process.on;
                        // Note: Jasmine checks internally if `process` and `process.on` is defined. Otherwise,
                        // it installs the browser rejection handler through the `global.addEventListener`.
                        // This code may be run in the browser environment where `process` is not defined, and
                        // this will lead to a runtime exception since Webpack 5 removed automatic Node.js
                        // polyfills. Note, that events are named differently, it's `unhandledRejection` in
                        // Node.js and `unhandledrejection` in the browser.
                        const originalHandlers = isNode ? process.listeners('unhandledRejection') :
                            global.eventListeners('unhandledrejection');
                        const result = originalInstall.apply(this, arguments);
                        isNode ? process.removeAllListeners('unhandledRejection') :
                            global.removeAllListeners('unhandledrejection');
                        if (originalHandlers) {
                            originalHandlers.forEach(handler => {
                                if (isNode) {
                                    process.on('unhandledRejection', handler);
                                }
                                else {
                                    global.addEventListener('unhandledrejection', handler);
                                }
                            });
                        }
                        return result;
                    };
                }
                return instance;
            };
        }
    }
    // Monkey patch all of the jasmine DSL so that each function runs in appropriate zone.
    const jasmineEnv = jasmine.getEnv();
    ['describe', 'xdescribe', 'fdescribe'].forEach(methodName => {
        let originalJasmineFn = jasmineEnv[methodName];
        jasmineEnv[methodName] = function (description, specDefinitions) {
            return originalJasmineFn.call(this, description, wrapDescribeInZone(description, specDefinitions));
        };
    });
    ['it', 'xit', 'fit'].forEach(methodName => {
        let originalJasmineFn = jasmineEnv[methodName];
        jasmineEnv[symbol(methodName)] = originalJasmineFn;
        jasmineEnv[methodName] = function (description, specDefinitions, timeout) {
            arguments[1] = wrapTestInZone(specDefinitions);
            return originalJasmineFn.apply(this, arguments);
        };
    });
    ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(methodName => {
        let originalJasmineFn = jasmineEnv[methodName];
        jasmineEnv[symbol(methodName)] = originalJasmineFn;
        jasmineEnv[methodName] = function (specDefinitions, timeout) {
            arguments[0] = wrapTestInZone(specDefinitions);
            return originalJasmineFn.apply(this, arguments);
        };
    });
    if (!disablePatchingJasmineClock) {
        // need to patch jasmine.clock().mockDate and jasmine.clock().tick() so
        // they can work properly in FakeAsyncTest
        const originalClockFn = (jasmine[symbol('clock')] = jasmine['clock']);
        jasmine['clock'] = function () {
            const clock = originalClockFn.apply(this, arguments);
            if (!clock[symbol('patched')]) {
                clock[symbol('patched')] = symbol('patched');
                const originalTick = (clock[symbol('tick')] = clock.tick);
                clock.tick = function () {
                    const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');
                    if (fakeAsyncZoneSpec) {
                        return fakeAsyncZoneSpec.tick.apply(fakeAsyncZoneSpec, arguments);
                    }
                    return originalTick.apply(this, arguments);
                };
                const originalMockDate = (clock[symbol('mockDate')] = clock.mockDate);
                clock.mockDate = function () {
                    const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');
                    if (fakeAsyncZoneSpec) {
                        const dateTime = arguments.length > 0 ? arguments[0] : new Date();
                        return fakeAsyncZoneSpec.setFakeBaseSystemTime.apply(fakeAsyncZoneSpec, dateTime && typeof dateTime.getTime === 'function' ? [dateTime.getTime()] :
                            arguments);
                    }
                    return originalMockDate.apply(this, arguments);
                };
                // for auto go into fakeAsync feature, we need the flag to enable it
                if (enableAutoFakeAsyncWhenClockPatched) {
                    ['install', 'uninstall'].forEach(methodName => {
                        const originalClockFn = (clock[symbol(methodName)] = clock[methodName]);
                        clock[methodName] = function () {
                            const FakeAsyncTestZoneSpec = Zone['FakeAsyncTestZoneSpec'];
                            if (FakeAsyncTestZoneSpec) {
                                jasmine[symbol('clockInstalled')] = 'install' === methodName;
                                return;
                            }
                            return originalClockFn.apply(this, arguments);
                        };
                    });
                }
            }
            return clock;
        };
    }
    // monkey patch createSpyObj to make properties enumerable to true
    if (!jasmine[Zone.__symbol__('createSpyObj')]) {
        const originalCreateSpyObj = jasmine.createSpyObj;
        jasmine[Zone.__symbol__('createSpyObj')] = originalCreateSpyObj;
        jasmine.createSpyObj = function () {
            const args = Array.prototype.slice.call(arguments);
            const propertyNames = args.length >= 3 ? args[2] : null;
            let spyObj;
            if (propertyNames) {
                const defineProperty = Object.defineProperty;
                Object.defineProperty = function (obj, p, attributes) {
                    return defineProperty.call(this, obj, p, Object.assign(Object.assign({}, attributes), { configurable: true, enumerable: true }));
                };
                try {
                    spyObj = originalCreateSpyObj.apply(this, args);
                }
                finally {
                    Object.defineProperty = defineProperty;
                }
            }
            else {
                spyObj = originalCreateSpyObj.apply(this, args);
            }
            return spyObj;
        };
    }
    /**
     * Gets a function wrapping the body of a Jasmine `describe` block to execute in a
     * synchronous-only zone.
     */
    function wrapDescribeInZone(description, describeBody) {
        return function () {
            // Create a synchronous-only zone in which to run `describe` blocks in order to raise an
            // error if any asynchronous operations are attempted inside of a `describe`.
            const syncZone = ambientZone.fork(new SyncTestZoneSpec(`jasmine.describe#${description}`));
            return syncZone.run(describeBody, this, arguments);
        };
    }
    function runInTestZone(testBody, applyThis, queueRunner, done) {
        const isClockInstalled = !!jasmine[symbol('clockInstalled')];
        queueRunner.testProxyZoneSpec;
        const testProxyZone = queueRunner.testProxyZone;
        if (isClockInstalled && enableAutoFakeAsyncWhenClockPatched) {
            // auto run a fakeAsync
            const fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];
            if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {
                testBody = fakeAsyncModule.fakeAsync(testBody);
            }
        }
        if (done) {
            return testProxyZone.run(testBody, applyThis, [done]);
        }
        else {
            return testProxyZone.run(testBody, applyThis);
        }
    }
    /**
     * Gets a function wrapping the body of a Jasmine `it/beforeEach/afterEach` block to
     * execute in a ProxyZone zone.
     * This will run in `testProxyZone`. The `testProxyZone` will be reset by the `ZoneQueueRunner`
     */
    function wrapTestInZone(testBody) {
        // The `done` callback is only passed through if the function expects at least one argument.
        // Note we have to make a function with correct number of arguments, otherwise jasmine will
        // think that all functions are sync or async.
        return (testBody && (testBody.length ? function (done) {
            return runInTestZone(testBody, this, this.queueRunner, done);
        } : function () {
            return runInTestZone(testBody, this, this.queueRunner);
        }));
    }
    const QueueRunner = jasmine.QueueRunner;
    jasmine.QueueRunner = (function (_super) {
        __extends(ZoneQueueRunner, _super);
        function ZoneQueueRunner(attrs) {
            if (attrs.onComplete) {
                attrs.onComplete = (fn => () => {
                    // All functions are done, clear the test zone.
                    this.testProxyZone = null;
                    this.testProxyZoneSpec = null;
                    ambientZone.scheduleMicroTask('jasmine.onComplete', fn);
                })(attrs.onComplete);
            }
            const nativeSetTimeout = global[Zone.__symbol__('setTimeout')];
            const nativeClearTimeout = global[Zone.__symbol__('clearTimeout')];
            if (nativeSetTimeout) {
                // should run setTimeout inside jasmine outside of zone
                attrs.timeout = {
                    setTimeout: nativeSetTimeout ? nativeSetTimeout : global.setTimeout,
                    clearTimeout: nativeClearTimeout ? nativeClearTimeout : global.clearTimeout
                };
            }
            // create a userContext to hold the queueRunner itself
            // so we can access the testProxy in it/xit/beforeEach ...
            if (jasmine.UserContext) {
                if (!attrs.userContext) {
                    attrs.userContext = new jasmine.UserContext();
                }
                attrs.userContext.queueRunner = this;
            }
            else {
                if (!attrs.userContext) {
                    attrs.userContext = {};
                }
                attrs.userContext.queueRunner = this;
            }
            // patch attrs.onException
            const onException = attrs.onException;
            attrs.onException = function (error) {
                if (error &&
                    error.message ===
                        'Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.') {
                    // jasmine timeout, we can make the error message more
                    // reasonable to tell what tasks are pending
                    const proxyZoneSpec = this && this.testProxyZoneSpec;
                    if (proxyZoneSpec) {
                        const pendingTasksInfo = proxyZoneSpec.getAndClearPendingTasksInfo();
                        try {
                            // try catch here in case error.message is not writable
                            error.message += pendingTasksInfo;
                        }
                        catch (err) {
                        }
                    }
                }
                if (onException) {
                    onException.call(this, error);
                }
            };
            _super.call(this, attrs);
        }
        ZoneQueueRunner.prototype.execute = function () {
            let zone = Zone.current;
            let isChildOfAmbientZone = false;
            while (zone) {
                if (zone === ambientZone) {
                    isChildOfAmbientZone = true;
                    break;
                }
                zone = zone.parent;
            }
            if (!isChildOfAmbientZone)
                throw new Error('Unexpected Zone: ' + Zone.current.name);
            Error.stackTraceLimit = Infinity;
            new Error().stack;
            // This is the zone which will be used for running individual tests.
            // It will be a proxy zone, so that the tests function can retroactively install
            // different zones.
            // Example:
            //   - In beforeEach() do childZone = Zone.current.fork(...);
            //   - In it() try to do fakeAsync(). The issue is that because the beforeEach forked the
            //     zone outside of fakeAsync it will be able to escape the fakeAsync rules.
            //   - Because ProxyZone is parent fo `childZone` fakeAsync can retroactively add
            //     fakeAsync behavior to the childZone.
            this.testProxyZoneSpec = new ProxyZoneSpec();
            this.testProxyZone = ambientZone.fork(this.testProxyZoneSpec);
            if (!Zone.currentTask) {
                // if we are not running in a task then if someone would register a
                // element.addEventListener and then calling element.click() the
                // addEventListener callback would think that it is the top most task and would
                // drain the microtask queue on element.click() which would be incorrect.
                // For this reason we always force a task when running jasmine tests.
                Zone.current.scheduleMicroTask('jasmine.execute().forceTask', () => QueueRunner.prototype.execute.call(this));
            }
            else {
                _super.prototype.execute.call(this);
            }
        };
        return ZoneQueueRunner;
    })(QueueRunner);
});
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                {"version":3,"file":"router.mjs","sources":["../../../../../../packages/router/src/shared.ts","../../../../../../packages/router/src/utils/collection.ts","../../../../../../packages/router/src/url_tree.ts","../../../../../../packages/router/src/create_url_tree.ts","../../../../../../packages/router/src/events.ts","../../../../../../packages/router/src/utils/tree.ts","../../../../../../packages/router/src/router_state.ts","../../../../../../packages/router/src/create_router_state.ts","../../../../../../packages/router/src/navigation_canceling_error.ts","../../../../../../packages/router/src/router_outlet_context.ts","../../../../../../packages/router/src/directives/router_outlet.ts","../../../../../../packages/router/src/components/empty_outlet.ts","../../../../../../packages/router/src/utils/config.ts","../../../../../../packages/router/src/operators/activate_routes.ts","../../../../../../packages/router/src/utils/preactivation.ts","../../../../../../packages/router/src/utils/type_guards.ts","../../../../../../packages/router/src/operators/prioritized_guard_value.ts","../../../../../../packages/router/src/operators/check_guards.ts","../../../../../../packages/router/src/utils/config_matching.ts","../../../../../../packages/router/src/apply_redirects.ts","../../../../../../packages/router/src/operators/apply_redirects.ts","../../../../../../packages/router/src/recognize.ts","../../../../../../packages/router/src/operators/recognize.ts","../../../../../../packages/router/src/operators/resolve_data.ts","../../../../../../packages/router/src/operators/switch_tap.ts","../../../../../../packages/router/src/route_reuse_strategy.ts","../../../../../../packages/router/src/router_config_loader.ts","../../../../../../packages/router/src/url_handling_strategy.ts","../../../../../../packages/router/src/router.ts","../../../../../../packages/router/src/directives/router_link.ts","../../../../../../packages/router/src/directives/router_link_active.ts","../../../../../../packages/router/src/page_title_strategy.ts","../../../../../../packages/router/src/router_preloader.ts","../../../../../../packages/router/src/router_scroller.ts","../../../../../../packages/router/src/router_module.ts","../../../../../../packages/router/src/version.ts","../../../../../../packages/router/src/private_export.ts","../../../../../../packages/router/src/index.ts","../../../../../../packages/router/public_api.ts","../../../../../../packages/router/index.ts","../../../../../../packages/router/router.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Route, UrlMatchResult} from './models';\nimport {UrlSegment, UrlSegmentGroup} from './url_tree';\n\n\n/**\n * The primary routing outlet.\n *\n * @publicApi\n */\nexport const PRIMARY_OUTLET = 'primary';\n\n/**\n * A collection of matrix and query URL parameters.\n * @see `convertToParamMap()`\n * @see `ParamMap`\n *\n * @publicApi\n */\nexport type Params = {\n  [key: string]: any;\n};\n\n/**\n * A map that provides access to the required and optional parameters\n * specific to a route.\n * The map supports retrieving a single value with `get()`\n * or multiple values with `getAll()`.\n *\n * @see [URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams)\n *\n * @publicApi\n */\nexport interface ParamMap {\n  /**\n   * Reports whether the map contains a given parameter.\n   * @param name The parameter name.\n   * @returns True if the map contains the given parameter, false otherwise.\n   */\n  has(name: string): boolean;\n  /**\n   * Retrieves a single value for a parameter.\n   * @param name The parameter name.\n   * @return The parameter's single value,\n   * or the first value if the parameter has multiple values,\n   * or `null` when there is no such parameter.\n   */\n  get(name: string): string|null;\n  /**\n   * Retrieves multiple values for a parameter.\n   * @param name The parameter name.\n   * @return An array containing one or more values,\n   * or an empty array if there is no such parameter.\n   *\n   */\n  getAll(name: string): string[];\n\n  /** Names of the parameters in the map. */\n  readonly keys: string[];\n}\n\nclass ParamsAsMap implements ParamMap {\n  private params: Params;\n\n  constructor(params: Params) {\n    this.params = params || {};\n  }\n\n  has(name: string): boolean {\n    return Object.prototype.hasOwnProperty.call(this.params, name);\n  }\n\n  get(name: string): string|null {\n    if (this.has(name)) {\n      const v = this.params[name];\n      return Array.isArray(v) ? v[0] : v;\n    }\n\n    return null;\n  }\n\n  getAll(name: string): string[] {\n    if (this.has(name)) {\n      const v = this.params[name];\n      return Array.isArray(v) ? v : [v];\n    }\n\n    return [];\n  }\n\n  get keys(): string[] {\n    return Object.keys(this.params);\n  }\n}\n\n/**\n * Converts a `Params` instance to a `ParamMap`.\n * @param params The instance to convert.\n * @returns The new map instance.\n *\n * @publicApi\n */\nexport function convertToParamMap(params: Params): ParamMap {\n  return new ParamsAsMap(params);\n}\n\n// Matches the route configuration (`route`) against the actual URL (`segments`).\nexport function defaultUrlMatcher(\n    segments: UrlSegment[], segmentGroup: UrlSegmentGroup, route: Route): UrlMatchResult|null {\n  const parts = route.path!.split('/');\n\n  if (parts.length > segments.length) {\n    // The actual URL is shorter than the config, no match\n    return null;\n  }\n\n  if (route.pathMatch === 'full' &&\n      (segmentGroup.hasChildren() || parts.length < segments.length)) {\n    // The config is longer than the actual URL but we are looking for a full match, return null\n    return null;\n  }\n\n  const posParams: {[key: string]: UrlSegment} = {};\n\n  // Check each config part against the actual URL\n  for (let index = 0; index < parts.length; index++) {\n    const part = parts[index];\n    const segment = segments[index];\n    const isParameter = part.startsWith(':');\n    if (isParameter) {\n      posParams[part.substring(1)] = segment;\n    } else if (part !== segment.path) {\n      // The actual URL part does not match the config, no match\n      return null;\n    }\n  }\n\n  return {consumed: segments.slice(0, parts.length), posParams};\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ɵisObservable as isObservable, ɵisPromise as isPromise} from '@angular/core';\nimport {from, Observable, of} from 'rxjs';\n\nimport {Params} from '../shared';\n\nexport function shallowEqualArrays(a: any[], b: any[]): boolean {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; ++i) {\n    if (!shallowEqual(a[i], b[i])) return false;\n  }\n  return true;\n}\n\nexport function shallowEqual(a: Params, b: Params): boolean {\n  // While `undefined` should never be possible, it would sometimes be the case in IE 11\n  // and pre-chromium Edge. The check below accounts for this edge case.\n  const k1 = a ? Object.keys(a) : undefined;\n  const k2 = b ? Object.keys(b) : undefined;\n  if (!k1 || !k2 || k1.length != k2.length) {\n    return false;\n  }\n  let key: string;\n  for (let i = 0; i < k1.length; i++) {\n    key = k1[i];\n    if (!equalArraysOrString(a[key], b[key])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Test equality for arrays of strings or a string.\n */\nexport function equalArraysOrString(a: string|string[], b: string|string[]) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) return false;\n    const aSorted = [...a].sort();\n    const bSorted = [...b].sort();\n    return aSorted.every((val, index) => bSorted[index] === val);\n  } else {\n    return a === b;\n  }\n}\n\n/**\n * Flattens single-level nested arrays.\n */\nexport function flatten<T>(arr: T[][]): T[] {\n  return Array.prototype.concat.apply([], arr);\n}\n\n/**\n * Return the last element of an array.\n */\nexport function last<T>(a: T[]): T|null {\n  return a.length > 0 ? a[a.length - 1] : null;\n}\n\n/**\n * Verifys all booleans in an array are `true`.\n */\nexport function and(bools: boolean[]): boolean {\n  return !bools.some(v => !v);\n}\n\nexport function forEach<K, V>(map: {[key: string]: V}, callback: (v: V, k: string) => void): void {\n  for (const prop in map) {\n    if (map.hasOwnProperty(prop)) {\n      callback(map[prop], prop);\n    }\n  }\n}\n\nexport function wrapIntoObservable<T>(value: T|Promise<T>|Observable<T>): Observable<T> {\n  if (isObservable(value)) {\n    return value;\n  }\n\n  if (isPromise(value)) {\n    // Use `Promise.resolve()` to wrap promise-like instances.\n    // Required ie when a Resolver returns a AngularJS `$q` promise to correctly trigger the\n    // change detection.\n    return from(Promise.resolve(value));\n  }\n\n  return of(value);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ɵRuntimeError as RuntimeError} from '@angular/core';\n\nimport {RuntimeErrorCode} from './errors';\nimport {convertToParamMap, ParamMap, Params, PRIMARY_OUTLET} from './shared';\nimport {equalArraysOrString, forEach, shallowEqual} from './utils/collection';\n\nconst NG_DEV_MODE = typeof ngDevMode === 'undefined' || ngDevMode;\n\nexport function createEmptyUrlTree() {\n  return new UrlTree(new UrlSegmentGroup([], {}), {}, null);\n}\n\n/**\n * A set of options which specify how to determine if a `UrlTree` is active, given the `UrlTree`\n * for the current router state.\n *\n * @publicApi\n * @see Router.isActive\n */\nexport interface IsActiveMatchOptions {\n  /**\n   * Defines the strategy for comparing the matrix parameters of two `UrlTree`s.\n   *\n   * The matrix parameter matching is dependent on the strategy for matching the\n   * segments. That is, if the `paths` option is set to `'subset'`, only\n   * the matrix parameters of the matching segments will be compared.\n   *\n   * - `'exact'`: Requires that matching segments also have exact matrix parameter\n   * matches.\n   * - `'subset'`: The matching segments in the router's active `UrlTree` may contain\n   * extra matrix parameters, but those that exist in the `UrlTree` in question must match.\n   * - `'ignored'`: When comparing `UrlTree`s, matrix params will be ignored.\n   */\n  matrixParams: 'exact'|'subset'|'ignored';\n  /**\n   * Defines the strategy for comparing the query parameters of two `UrlTree`s.\n   *\n   * - `'exact'`: the query parameters must match exactly.\n   * - `'subset'`: the active `UrlTree` may contain extra parameters,\n   * but must match the key and value of any that exist in the `UrlTree` in question.\n   * - `'ignored'`: When comparing `UrlTree`s, query params will be ignored.\n   */\n  queryParams: 'exact'|'subset'|'ignored';\n  /**\n   * Defines the strategy for comparing the `UrlSegment`s of the `UrlTree`s.\n   *\n   * - `'exact'`: all segments in each `UrlTree` must match.\n   * - `'subset'`: a `UrlTree` will be determined to be active if it\n   * is a subtree of the active route. That is, the active route may contain extra\n   * segments, but must at least have all the segments of the `UrlTree` in question.\n   */\n  paths: 'exact'|'subset';\n  /**\n   * - `'exact'`: indicates that the `UrlTree` fragments must be equal.\n   * - `'ignored'`: the fragments will not be compared when determining if a\n   * `UrlTree` is active.\n   */\n  fragment: 'exact'|'ignored';\n}\n\ntype ParamMatchOptions = 'exact'|'subset'|'ignored';\n\ntype PathCompareFn =\n    (container: UrlSegmentGroup, containee: UrlSegmentGroup, matrixParams: ParamMatchOptions) =>\n        boolean;\ntype ParamCompareFn = (container: Params, containee: Params) => boolean;\n\nconst pathCompareMap: Record<IsActiveMatchOptions['paths'], PathCompareFn> = {\n  'exact': equalSegmentGroups,\n  'subset': containsSegmentGroup,\n};\nconst paramCompareMap: Record<ParamMatchOptions, ParamCompareFn> = {\n  'exact': equalParams,\n  'subset': containsParams,\n  'ignored': () => true,\n};\n\nexport function containsTree(\n    container: UrlTree, containee: UrlTree, options: IsActiveMatchOptions): boolean {\n  return pathCompareMap[options.paths](container.root, containee.root, options.matrixParams) &&\n      paramCompareMap[options.queryParams](container.queryParams, containee.queryParams) &&\n      !(options.fragment === 'exact' && container.fragment !== containee.fragment);\n}\n\nfunction equalParams(container: Params, containee: Params): boolean {\n  // TODO: This does not handle array params correctly.\n  return shallowEqual(container, containee);\n}\n\nfunction equalSegmentGroups(\n    container: UrlSegmentGroup, containee: UrlSegmentGroup,\n    matrixParams: ParamMatchOptions): boolean {\n  if (!equalPath(container.segments, containee.segments)) return false;\n  if (!matrixParamsMatch(container.segments, containee.segments, matrixParams)) {\n    return false;\n  }\n  if (container.numberOfChildren !== containee.numberOfChildren) return false;\n  for (const c in containee.children) {\n    if (!container.children[c]) return false;\n    if (!equalSegmentGroups(container.children[c], containee.children[c], matrixParams))\n      return false;\n  }\n  return true;\n}\n\nfunction containsParams(container: Params, containee: Params): boolean {\n  return Object.keys(containee).length <= Object.keys(container).length &&\n      Object.keys(containee).every(key => equalArraysOrString(container[key], containee[key]));\n}\n\nfunction containsSegmentGroup(\n    container: UrlSegmentGroup, containee: UrlSegmentGroup,\n    matrixParams: ParamMatchOptions): boolean {\n  return containsSegmentGroupHelper(container, containee, containee.segments, matrixParams);\n}\n\nfunction containsSegmentGroupHelper(\n    container: UrlSegmentGroup, containee: UrlSegmentGroup, containeePaths: UrlSegment[],\n    matrixParams: ParamMatchOptions): boolean {\n  if (container.segments.length > containeePaths.length) {\n    const current = container.segments.slice(0, containeePaths.length);\n    if (!equalPath(current, containeePaths)) return false;\n    if (containee.hasChildren()) return false;\n    if (!matrixParamsMatch(current, containeePaths, matrixParams)) return false;\n    return true;\n\n  } else if (container.segments.length === containeePaths.length) {\n    if (!equalPath(container.segments, containeePaths)) return false;\n    if (!matrixParamsMatch(container.segments, containeePaths, matrixParams)) return false;\n    for (const c in containee.children) {\n      if (!container.children[c]) return false;\n      if (!containsSegmentGroup(container.children[c], containee.children[c], matrixParams)) {\n        return false;\n      }\n    }\n    return true;\n\n  } else {\n    const current = containeePaths.slice(0, container.segments.length);\n    const next = containeePaths.slice(container.segments.length);\n    if (!equalPath(container.segments, current)) return false;\n    if (!matrixParamsMatch(container.segments, current, matrixParams)) return false;\n    if (!container.children[PRIMARY_OUTLET]) return false;\n    return containsSegmentGroupHelper(\n        container.children[PRIMARY_OUTLET], containee, next, matrixParams);\n  }\n}\n\nfunction matrixParamsMatch(\n    containerPaths: UrlSegment[], containeePaths: UrlSegment[], options: ParamMatchOptions) {\n  return containeePaths.every((containeeSegment, i) => {\n    return paramCompareMap[options](containerPaths[i].parameters, containeeSegment.parameters);\n  });\n}\n\n/**\n * @description\n *\n * Represents the parsed URL.\n *\n * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a\n * serialized tree.\n * UrlTree is a data structure that provides a lot of affordances in dealing with URLs\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree =\n *       router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');\n *     const f = tree.fragment; // return 'fragment'\n *     const q = tree.queryParams; // returns {debug: 'true'}\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'\n *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'\n *     g.children['support'].segments; // return 1 segment 'help'\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport class UrlTree {\n  /** @internal */\n  // TODO(issue/24571): remove '!'.\n  _queryParamMap!: ParamMap;\n\n  /** @internal */\n  constructor(\n      /** The root segment group of the URL tree */\n      public root: UrlSegmentGroup,\n      /** The query params of the URL */\n      public queryParams: Params,\n      /** The fragment of the URL */\n      public fragment: string|null) {}\n\n  get queryParamMap(): ParamMap {\n    if (!this._queryParamMap) {\n      this._queryParamMap = convertToParamMap(this.queryParams);\n    }\n    return this._queryParamMap;\n  }\n\n  /** @docsNotRequired */\n  toString(): string {\n    return DEFAULT_SERIALIZER.serialize(this);\n  }\n}\n\n/**\n * @description\n *\n * Represents the parsed URL segment group.\n *\n * See `UrlTree` for more information.\n *\n * @publicApi\n */\nexport class UrlSegmentGroup {\n  /** @internal */\n  _sourceSegment?: UrlSegmentGroup;\n  /** @internal */\n  _segmentIndexShift?: number;\n  /**\n   * @internal\n   *\n   * Used only in dev mode to detect if application relies on `relativeLinkResolution: 'legacy'`\n   * Should be removed in when `relativeLinkResolution` is removed.\n   */\n  _segmentIndexShiftCorrected?: number;\n  /** The parent node in the url tree */\n  parent: UrlSegmentGroup|null = null;\n\n  constructor(\n      /** The URL segments of this group. See `UrlSegment` for more information */\n      public segments: UrlSegment[],\n      /** The list of children of this group */\n      public children: {[key: string]: UrlSegmentGroup}) {\n    forEach(children, (v: any, k: any) => v.parent = this);\n  }\n\n  /** Whether the segment has child segments */\n  hasChildren(): boolean {\n    return this.numberOfChildren > 0;\n  }\n\n  /** Number of child segments */\n  get numberOfChildren(): number {\n    return Object.keys(this.children).length;\n  }\n\n  /** @docsNotRequired */\n  toString(): string {\n    return serializePaths(this);\n  }\n}\n\n\n/**\n * @description\n *\n * Represents a single URL segment.\n *\n * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix\n * parameters associated with the segment.\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree = router.parseUrl('/team;id=33');\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments;\n *     s[0].path; // returns 'team'\n *     s[0].parameters; // returns {id: 33}\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport class UrlSegment {\n  /** @internal */\n  // TODO(issue/24571): remove '!'.\n  _parameterMap!: ParamMap;\n\n  constructor(\n      /** The path part of a URL segment */\n      public path: string,\n\n      /** The matrix parameters associated with a segment */\n      public parameters: {[name: string]: string}) {}\n\n  get parameterMap(): ParamMap {\n    if (!this._parameterMap) {\n      this._parameterMap = convertToParamMap(this.parameters);\n    }\n    return this._parameterMap;\n  }\n\n  /** @docsNotRequired */\n  toString(): string {\n    return serializePath(this);\n  }\n}\n\nexport function equalSegments(as: UrlSegment[], bs: UrlSegment[]): boolean {\n  return equalPath(as, bs) && as.every((a, i) => shallowEqual(a.parameters, bs[i].parameters));\n}\n\nexport function equalPath(as: UrlSegment[], bs: UrlSegment[]): boolean {\n  if (as.length !== bs.length) return false;\n  return as.every((a, i) => a.path === bs[i].path);\n}\n\nexport function mapChildrenIntoArray<T>(\n    segment: UrlSegmentGroup, fn: (v: UrlSegmentGroup, k: string) => T[]): T[] {\n  let res: T[] = [];\n  forEach(segment.children, (child: UrlSegmentGroup, childOutlet: string) => {\n    if (childOutlet === PRIMARY_OUTLET) {\n      res = res.concat(fn(child, childOutlet));\n    }\n  });\n  forEach(segment.children, (child: UrlSegmentGroup, childOutlet: string) => {\n    if (childOutlet !== PRIMARY_OUTLET) {\n      res = res.concat(fn(child, childOutlet));\n    }\n  });\n  return res;\n}\n\n\n/**\n * @description\n *\n * Serializes and deserializes a URL string into a URL tree.\n *\n * The url serialization strategy is customizable. You can\n * make all URLs case insensitive by providing a custom UrlSerializer.\n *\n * See `DefaultUrlSerializer` for an example of a URL serializer.\n *\n * @publicApi\n */\nexport abstract class UrlSerializer {\n  /** Parse a url into a `UrlTree` */\n  abstract parse(url: string): UrlTree;\n\n  /** Converts a `UrlTree` into a url */\n  abstract serialize(tree: UrlTree): string;\n}\n\n/**\n * @description\n *\n * A default implementation of the `UrlSerializer`.\n *\n * Example URLs:\n *\n * ```\n * /inbox/33(popup:compose)\n * /inbox/33;open=true/messages/44\n * ```\n *\n * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the\n * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to\n * specify route specific parameters.\n *\n * @publicApi\n */\nexport class DefaultUrlSerializer implements UrlSerializer {\n  /** Parses a url into a `UrlTree` */\n  parse(url: string): UrlTree {\n    const p = new UrlParser(url);\n    return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());\n  }\n\n  /** Converts a `UrlTree` into a url */\n  serialize(tree: UrlTree): string {\n    const segment = `/${serializeSegment(tree.root, true)}`;\n    const query = serializeQueryParams(tree.queryParams);\n    const fragment =\n        typeof tree.fragment === `string` ? `#${encodeUriFragment(tree.fragment)}` : '';\n\n    return `${segment}${query}${fragment}`;\n  }\n}\n\nconst DEFAULT_SERIALIZER = new DefaultUrlSerializer();\n\nexport function serializePaths(segment: UrlSegmentGroup): string {\n  return segment.segments.map(p => serializePath(p)).join('/');\n}\n\nfunction serializeSegment(segment: UrlSegmentGroup, root: boolean): string {\n  if (!segment.hasChildren()) {\n    return serializePaths(segment);\n  }\n\n  if (root) {\n    const primary = segment.children[PRIMARY_OUTLET] ?\n        serializeSegment(segment.children[PRIMARY_OUTLET], false) :\n        '';\n    const children: string[] = [];\n\n    forEach(segment.children, (v: UrlSegmentGroup, k: string) => {\n      if (k !== PRIMARY_OUTLET) {\n        children.push(`${k}:${serializeSegment(v, false)}`);\n      }\n    });\n\n    return children.length > 0 ? `${primary}(${children.join('//')})` : primary;\n\n  } else {\n    const children = mapChildrenIntoArray(segment, (v: UrlSegmentGroup, k: string) => {\n      if (k === PRIMARY_OUTLET) {\n        return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];\n      }\n\n      return [`${k}:${serializeSegment(v, false)}`];\n    });\n\n    // use no parenthesis if the only child is a primary outlet route\n    if (Object.keys(segment.children).length === 1 && segment.children[PRIMARY_OUTLET] != null) {\n      return `${serializePaths(segment)}/${children[0]}`;\n    }\n\n    return `${serializePaths(segment)}/(${children.join('//')})`;\n  }\n}\n\n/**\n * Encodes a URI string with the default encoding. This function will only ever be called from\n * `encodeUriQuery` or `encodeUriSegment` as it's the base set of encodings to be used. We need\n * a custom encoding because encodeURIComponent is too aggressive and encodes stuff that doesn't\n * have to be encoded per https://url.spec.whatwg.org.\n */\nfunction encodeUriString(s: string): string {\n  return encodeURIComponent(s)\n      .replace(/%40/g, '@')\n      .replace(/%3A/gi, ':')\n      .replace(/%24/g, '$')\n      .replace(/%2C/gi, ',');\n}\n\n/**\n * This function should be used to encode both keys and values in a query string key/value. In\n * the following URL, you need to call encodeUriQuery on \"k\" and \"v\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n */\nexport function encodeUriQuery(s: string): string {\n  return encodeUriString(s).replace(/%3B/gi, ';');\n}\n\n/**\n * This function should be used to encode a URL fragment. In the following URL, you need to call\n * encodeUriFragment on \"f\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n */\nexport function encodeUriFragment(s: string): string {\n  return encodeURI(s);\n}\n\n/**\n * This function should be run on any URI segment as well as the key and value in a key/value\n * pair for matrix params. In the following URL, you need to call encodeUriSegment on \"html\",\n * \"mk\", and \"mv\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n */\nexport function encodeUriSegment(s: string): string {\n  return encodeUriString(s).replace(/\\(/g, '%28').replace(/\\)/g, '%29').replace(/%26/gi, '&');\n}\n\nexport function decode(s: string): string {\n  return decodeURIComponent(s);\n}\n\n// Query keys/values should have the \"+\" replaced first, as \"+\" in a query string is \" \".\n// decodeURIComponent function will not decode \"+\" as a space.\nexport function decodeQuery(s: string): string {\n  return decode(s.replace(/\\+/g, '%20'));\n}\n\nexport function serializePath(path: UrlSegment): string {\n  return `${encodeUriSegment(path.path)}${serializeMatrixParams(path.parameters)}`;\n}\n\nfunction serializeMatrixParams(params: {[key: string]: string}): string {\n  return Object.keys(params)\n      .map(key => `;${encodeUriSegment(key)}=${encodeUriSegment(params[key])}`)\n      .join('');\n}\n\nfunction serializeQueryParams(params: {[key: string]: any}): string {\n  const strParams: string[] =\n      Object.keys(params)\n          .map((name) => {\n            const value = params[name];\n            return Array.isArray(value) ?\n                value.map(v => `${encodeUriQuery(name)}=${encodeUriQuery(v)}`).join('&') :\n                `${encodeUriQuery(name)}=${encodeUriQuery(value)}`;\n          })\n          .filter(s => !!s);\n\n  return strParams.length ? `?${strParams.join('&')}` : '';\n}\n\nconst SEGMENT_RE = /^[^\\/()?;=#]+/;\nfunction matchSegments(str: string): string {\n  const match = str.match(SEGMENT_RE);\n  return match ? match[0] : '';\n}\n\nconst QUERY_PARAM_RE = /^[^=?&#]+/;\n// Return the name of the query param at the start of the string or an empty string\nfunction matchQueryParams(str: string): string {\n  const match = str.match(QUERY_PARAM_RE);\n  return match ? match[0] : '';\n}\n\nconst QUERY_PARAM_VALUE_RE = /^[^&#]+/;\n// Return the value of the query param at the start of the string or an empty string\nfunction matchUrlQueryParamValue(str: string): string {\n  const match = str.match(QUERY_PARAM_VALUE_RE);\n  return match ? match[0] : '';\n}\n\nclass UrlParser {\n  private remaining: string;\n\n  constructor(private url: string) {\n    this.remaining = url;\n  }\n\n  parseRootSegment(): UrlSegmentGroup {\n    this.consumeOptional('/');\n\n    if (this.remaining === '' || this.peekStartsWith('?') || this.peekStartsWith('#')) {\n      return new UrlSegmentGroup([], {});\n    }\n\n    // The root segment group never has segments\n    return new UrlSegmentGroup([], this.parseChildren());\n  }\n\n  parseQueryParams(): Params {\n    const params: Params = {};\n    if (this.consumeOptional('?')) {\n      do {\n        this.parseQueryParam(params);\n      } while (this.consumeOptional('&'));\n    }\n    return params;\n  }\n\n  parseFragment(): string|null {\n    return this.consumeOptional('#') ? decodeURIComponent(this.remaining) : null;\n  }\n\n  private parseChildren(): {[outlet: string]: UrlSegmentGroup} {\n    if (this.remaining === '') {\n      return {};\n    }\n\n    this.consumeOptional('/');\n\n    const segments: UrlSegment[] = [];\n    if (!this.peekStartsWith('(')) {\n      segments.push(this.parseSegment());\n    }\n\n    while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {\n      this.capture('/');\n      segments.push(this.parseSegment());\n    }\n\n    let children: {[outlet: string]: UrlSegmentGroup} = {};\n    if (this.peekStartsWith('/(')) {\n      this.capture('/');\n      children = this.parseParens(true);\n    }\n\n    let res: {[outlet: string]: UrlSegmentGroup} = {};\n    if (this.peekStartsWith('(')) {\n      res = this.parseParens(false);\n    }\n\n    if (segments.length > 0 || Object.keys(children).length > 0) {\n      res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);\n    }\n\n    return res;\n  }\n\n  // parse a segment with its matrix parameters\n  // ie `name;k1=v1;k2`\n  private parseSegment(): UrlSegment {\n    const path = matchSegments(this.remaining);\n    if (path === '' && this.peekStartsWith(';')) {\n      throw new RuntimeError(\n          RuntimeErrorCode.EMPTY_PATH_WITH_PARAMS,\n          NG_DEV_MODE && `Empty path url segment cannot have parameters: '${this.remaining}'.`);\n    }\n\n    this.capture(path);\n    return new UrlSegment(decode(path), this.parseMatrixParams());\n  }\n\n  private parseMatrixParams(): {[key: string]: string} {\n    const params: {[key: string]: string} = {};\n    while (this.consumeOptional(';')) {\n      this.parseParam(params);\n    }\n    return params;\n  }\n\n  private parseParam(params: {[key: string]: string}): void {\n    const key = matchSegments(this.remaining);\n    if (!key) {\n      return;\n    }\n    this.capture(key);\n    let value: any = '';\n    if (this.consumeOptional('=')) {\n      const valueMatch = matchSegments(this.remaining);\n      if (valueMatch) {\n        value = valueMatch;\n        this.capture(value);\n      }\n    }\n\n    params[decode(key)] = decode(value);\n  }\n\n  // Parse a single query parameter `name[=value]`\n  private parseQueryParam(params: Params): void {\n    const key = matchQueryParams(this.remaining);\n    if (!key) {\n      return;\n    }\n    this.capture(key);\n    let value: any = '';\n    if (this.consumeOptional('=')) {\n      const valueMatch = matchUrlQueryParamValue(this.remaining);\n      if (valueMatch) {\n        value = valueMatch;\n        this.capture(value);\n      }\n    }\n\n    const decodedKey = decodeQuery(key);\n    const decodedVal = decodeQuery(value);\n\n    if (params.hasOwnProperty(decodedKey)) {\n      // Append to existing values\n      let currentVal = params[decodedKey];\n      if (!Array.isArray(currentVal)) {\n        currentVal = [currentVal];\n        params[decodedKey] = currentVal;\n      }\n      currentVal.push(decodedVal);\n    } else {\n      // Create a new value\n      params[decodedKey] = decodedVal;\n    }\n  }\n\n  // parse `(a/b//outlet_name:c/d)`\n  private parseParens(allowPrimary: boolean): {[outlet: string]: UrlSegmentGroup} {\n    const segments: {[key: string]: UrlSegmentGroup} = {};\n    this.capture('(');\n\n    while (!this.consumeOptional(')') && this.remaining.length > 0) {\n      const path = matchSegments(this.remaining);\n\n      const next = this.remaining[path.length];\n\n      // if is is not one of these characters, then the segment was unescaped\n      // or the group was not closed\n      if (next !== '/' && next !== ')' && next !== ';') {\n        throw new RuntimeError(\n            RuntimeErrorCode.UNPARSABLE_URL, NG_DEV_MODE && `Cannot parse url '${this.url}'`);\n      }\n\n      let outletName: string = undefined!;\n      if (path.indexOf(':') > -1) {\n        outletName = path.slice(0, path.indexOf(':'));\n        this.capture(outletName);\n        this.capture(':');\n      } else if (allowPrimary) {\n        outletName = PRIMARY_OUTLET;\n      }\n\n      const children = this.parseChildren();\n      segments[outletName] = Object.keys(children).length === 1 ? children[PRIMARY_OUTLET] :\n                                                                  new UrlSegmentGroup([], children);\n      this.consumeOptional('//');\n    }\n\n    return segments;\n  }\n\n  private peekStartsWith(str: string): boolean {\n    return this.remaining.startsWith(str);\n  }\n\n  // Consumes the prefix when it is present and returns whether it has been consumed\n  private consumeOptional(str: string): boolean {\n    if (this.peekStartsWith(str)) {\n      this.remaining = this.remaining.substring(str.length);\n      return true;\n    }\n    return false;\n  }\n\n  private capture(str: string): void {\n    if (!this.consumeOptional(str)) {\n      throw new RuntimeError(\n          RuntimeErrorCode.UNEXPECTED_VALUE_IN_URL, NG_DEV_MODE && `Expected \"${str}\".`);\n    }\n  }\n}\n\nexport function createRoot(rootCandidate: UrlSegmentGroup) {\n  return rootCandidate.segments.length > 0 ?\n      new UrlSegmentGroup([], {[PRIMARY_OUTLET]: rootCandidate}) :\n      rootCandidate;\n}\n\n/**\n * Recursively merges primary segment children into their parents and also drops empty children\n * (those which have no segments and no children themselves). The latter prevents serializing a\n * group into something like `/a(aux:)`, where `aux` is an empty child segment.\n */\nexport function squashSegmentGroup(segmentGroup: UrlSegmentGroup): UrlSegmentGroup {\n  const newChildren = {} as any;\n  for (const childOutlet of Object.keys(segmentGroup.children)) {\n    const child = segmentGroup.children[childOutlet];\n    const childCandidate = squashSegmentGroup(child);\n    // don't add empty children\n    if (childCandidate.segments.length > 0 || childCandidate.hasChildren()) {\n      newChildren[childOutlet] = childCandidate;\n    }\n  }\n  const s = new UrlSegmentGroup(segmentGroup.segments, newChildren);\n  return mergeTrivialChildren(s);\n}\n\n/**\n * When possible, merges the primary outlet child into the parent `UrlSegmentGroup`.\n *\n * When a segment group has only one child which is a primary outlet, merges that child into the\n * parent. That is, the child segment group's segments are merged into the `s` and the child's\n * children become the children of `s`. Think of this like a 'squash', merging the child segment\n * group into the parent.\n */\nfunction mergeTrivialChildren(s: UrlSegmentGroup): UrlSegmentGroup {\n  if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {\n    const c = s.children[PRIMARY_OUTLET];\n    return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);\n  }\n\n  return s;\n}\n\nexport function isUrlTree(v: any): v is UrlTree {\n  return v instanceof UrlTree;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ɵRuntimeError as RuntimeError} from '@angular/core';\n\nimport {RuntimeErrorCode} from './errors';\nimport {ActivatedRoute, ActivatedRouteSnapshot} from './router_state';\nimport {Params, PRIMARY_OUTLET} from './shared';\nimport {createRoot, squashSegmentGroup, UrlSegment, UrlSegmentGroup, UrlTree} from './url_tree';\nimport {forEach, last, shallowEqual} from './utils/collection';\n\nconst NG_DEV_MODE = typeof ngDevMode === 'undefined' || ngDevMode;\n\n/**\n * Creates a `UrlTree` relative to an `ActivatedRouteSnapshot`.\n *\n * @publicApi\n *\n *\n * @param relativeTo The `ActivatedRouteSnapshot` to apply the commands to\n * @param commands An array of URL fragments with which to construct the new URL tree.\n * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\n * segments, followed by the parameters for each segment.\n * The fragments are applied to the one provided in the `relativeTo` parameter.\n * @param queryParams The query parameters for the `UrlTree`. `null` if the `UrlTree` does not have\n *     any query parameters.\n * @param fragment The fragment for the `UrlTree`. `null` if the `UrlTree` does not have a fragment.\n *\n * @usageNotes\n *\n * ```\n * // create /team/33/user/11\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, 'user', 11]);\n *\n * // create /team/33;expand=true/user/11\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {expand: true}, 'user', 11]);\n *\n * // you can collapse static segments like this (this works only with the first passed-in value):\n * createUrlTreeFromSnapshot(snapshot, ['/team/33/user', userId]);\n *\n * // If the first segment can contain slashes, and you do not want the router to split it,\n * // you can do the following:\n * createUrlTreeFromSnapshot(snapshot, [{segmentPath: '/one/two'}]);\n *\n * // create /team/33/(user/11//right:chat)\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {outlets: {primary: 'user/11', right:\n * 'chat'}}], null, null);\n *\n * // remove the right secondary node\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n *\n * // For the examples below, assume the current URL is for the `/team/33/user/11` and the\n * `ActivatedRouteSnapshot` points to `user/11`:\n *\n * // navigate to /team/33/user/11/details\n * createUrlTreeFromSnapshot(snapshot, ['details']);\n *\n * // navigate to /team/33/user/22\n * createUrlTreeFromSnapshot(snapshot, ['../22']);\n *\n * // navigate to /team/44/user/22\n * createUrlTreeFromSnapshot(snapshot, ['../../team/44/user/22']);\n * ```\n */\nexport function createUrlTreeFromSnapshot(\n    relativeTo: ActivatedRouteSnapshot, commands: any[], queryParams: Params|null = null,\n    fragment: string|null = null): UrlTree {\n  const relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeTo);\n  return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, queryParams, fragment);\n}\n\nfunction createSegmentGroupFromRoute(route: ActivatedRouteSnapshot): UrlSegmentGroup {\n  let targetGroup: UrlSegmentGroup|undefined;\n\n  function createSegmentGroupFromRouteRecursive(currentRoute: ActivatedRouteSnapshot) {\n    const childOutlets: {[outlet: string]: UrlSegmentGroup} = {};\n    for (const childSnapshot of currentRoute.children) {\n      const root = createSegmentGroupFromRouteRecursive(childSnapshot);\n      childOutlets[childSnapshot.outlet] = root;\n    }\n    const segmentGroup = new UrlSegmentGroup(currentRoute.url, childOutlets);\n    if (currentRoute === route) {\n      targetGroup = segmentGroup;\n    }\n    return segmentGroup;\n  }\n  const rootCandidate = createSegmentGroupFromRouteRecursive(route.root);\n  const rootSegmentGroup = createRoot(rootCandidate);\n\n  return targetGroup ?? rootSegmentGroup;\n}\n\nexport function createUrlTreeFromSegmentGroup(\n    relativeTo: UrlSegmentGroup, commands: any[], queryParams: Params|null,\n    fragment: string|null): UrlTree {\n  let root = relativeTo;\n  while (root.parent) {\n    root = root.parent;\n  }\n  // There are no commands so the `UrlTree` goes to the same path as the one created from the\n  // `UrlSegmentGroup`. All we need to do is update the `queryParams` and `fragment` without\n  // applying any other logic.\n  if (commands.length === 0) {\n    return tree(root, root, root, queryParams, fragment);\n  }\n\n  const nav = computeNavigation(commands);\n\n  if (nav.toRoot()) {\n    return tree(root, root, new UrlSegmentGroup([], {}), queryParams, fragment);\n  }\n\n  const position = findStartingPositionForTargetGroup(nav, root, relativeTo);\n  const newSegmentGroup = position.processChildren ?\n      updateSegmentGroupChildren(position.segmentGroup, position.index, nav.commands) :\n      updateSegmentGroup(position.segmentGroup, position.index, nav.commands);\n  return tree(root, position.segmentGroup, newSegmentGroup, queryParams, fragment);\n}\n\nexport function createUrlTree(\n    route: ActivatedRoute, urlTree: UrlTree, commands: any[], queryParams: Params|null,\n    fragment: string|null): UrlTree {\n  if (commands.length === 0) {\n    return tree(urlTree.root, urlTree.root, urlTree.root, queryParams, fragment);\n  }\n\n  const nav = computeNavigation(commands);\n\n  if (nav.toRoot()) {\n    return tree(urlTree.root, urlTree.root, new UrlSegmentGroup([], {}), queryParams, fragment);\n  }\n\n  function createTreeUsingPathIndex(lastPathIndex: number) {\n    const startingPosition =\n        findStartingPosition(nav, urlTree, route.snapshot?._urlSegment, lastPathIndex);\n\n    const segmentGroup = startingPosition.processChildren ?\n        updateSegmentGroupChildren(\n            startingPosition.segmentGroup, startingPosition.index, nav.commands) :\n        updateSegmentGroup(startingPosition.segmentGroup, startingPosition.index, nav.commands);\n    return tree(urlTree.root, startingPosition.segmentGroup, segmentGroup, queryParams, fragment);\n  }\n  // Note: The types should disallow `snapshot` from being `undefined` but due to test mocks, this\n  // may be the case. Since we try to access it at an earlier point before the refactor to add the\n  // warning for `relativeLinkResolution: 'legacy'`, this may cause failures in tests where it\n  // didn't before.\n  const result = createTreeUsingPathIndex(route.snapshot?._lastPathIndex);\n\n  // Check if application is relying on `relativeLinkResolution: 'legacy'`\n  if (typeof ngDevMode === 'undefined' || !!ngDevMode) {\n    const correctedResult = createTreeUsingPathIndex(route.snapshot?._correctedLastPathIndex);\n    if (correctedResult.toString() !== result.toString()) {\n      console.warn(\n          `relativeLinkResolution: 'legacy' is deprecated and will be removed in a future version of Angular. The link to ${\n              result.toString()} will change to ${\n              correctedResult.toString()} if the code is not updated before then.`);\n    }\n  }\n\n  return result;\n}\n\nfunction isMatrixParams(command: any): boolean {\n  return typeof command === 'object' && command != null && !command.outlets && !command.segmentPath;\n}\n\n/**\n * Determines if a given command has an `outlets` map. When we encounter a command\n * with an outlets k/v map, we need to apply each outlet individually to the existing segment.\n */\nfunction isCommandWithOutlets(command: any): command is {outlets: {[key: string]: any}} {\n  return typeof command === 'object' && command != null && command.outlets;\n}\n\nfunction tree(\n    oldRoot: UrlSegmentGroup, oldSegmentGroup: UrlSegmentGroup, newSegmentGroup: UrlSegmentGroup,\n    queryParams: Params|null, fragment: string|null): UrlTree {\n  let qp: any = {};\n  if (queryParams) {\n    forEach(queryParams, (value: any, name: any) => {\n      qp[name] = Array.isArray(value) ? value.map((v: any) => `${v}`) : `${value}`;\n    });\n  }\n\n  let rootCandidate: UrlSegmentGroup;\n  if (oldRoot === oldSegmentGroup) {\n    rootCandidate = newSegmentGroup;\n  } else {\n    rootCandidate = replaceSegment(oldRoot, oldSegmentGroup, newSegmentGroup);\n  }\n\n  const newRoot = createRoot(squashSegmentGroup(rootCandidate));\n  return new UrlTree(newRoot, qp, fragment);\n}\n\n/**\n * Replaces the `oldSegment` which is located in some child of the `current` with the `newSegment`.\n * This also has the effect of creating new `UrlSegmentGroup` copies to update references. This\n * shouldn't be necessary but the fallback logic for an invalid ActivatedRoute in the creation uses\n * the Router's current url tree. If we don't create new segment groups, we end up modifying that\n * value.\n */\nfunction replaceSegment(\n    current: UrlSegmentGroup, oldSegment: UrlSegmentGroup,\n    newSegment: UrlSegmentGroup): UrlSegmentGroup {\n  const children: {[key: string]: UrlSegmentGroup} = {};\n  forEach(current.children, (c: UrlSegmentGroup, outletName: string) => {\n    if (c === oldSegment) {\n      children[outletName] = newSegment;\n    } else {\n      children[outletName] = replaceSegment(c, oldSegment, newSegment);\n    }\n  });\n  return new UrlSegmentGroup(current.segments, children);\n}\n\nclass Navigation {\n  constructor(\n      public isAbsolute: boolean, public numberOfDoubleDots: number, public commands: any[]) {\n    if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {\n      throw new RuntimeError(\n          RuntimeErrorCode.ROOT_SEGMENT_MATRIX_PARAMS,\n          NG_DEV_MODE && 'Root segment cannot have matrix parameters');\n    }\n\n    const cmdWithOutlet = commands.find(isCommandWithOutlets);\n    if (cmdWithOutlet && cmdWithOutlet !== last(commands)) {\n      throw new RuntimeError(\n          RuntimeErrorCode.MISPLACED_OUTLETS_COMMAND,\n          NG_DEV_MODE && '{outlets:{}} has to be the last command');\n    }\n  }\n\n  public toRoot(): boolean {\n    return this.isAbsolute && this.commands.length === 1 && this.commands[0] == '/';\n  }\n}\n\n/** Transforms commands to a normalized `Navigation` */\nfunction computeNavigation(commands: any[]): Navigation {\n  if ((typeof commands[0] === 'string') && commands.length === 1 && commands[0] === '/') {\n    return new Navigation(true, 0, commands);\n  }\n\n  let numberOfDoubleDots = 0;\n  let isAbsolute = false;\n\n  const res: any[] = commands.reduce((res, cmd, cmdIdx) => {\n    if (typeof cmd === 'object' && cmd != null) {\n      if (cmd.outlets) {\n        const outlets: {[k: string]: any} = {};\n        forEach(cmd.outlets, (commands: any, name: string) => {\n          outlets[name] = typeof commands === 'string' ? commands.split('/') : commands;\n        });\n        return [...res, {outlets}];\n      }\n\n      if (cmd.segmentPath) {\n        return [...res, cmd.segmentPath];\n      }\n    }\n\n    if (!(typeof cmd === 'string')) {\n      return [...res, cmd];\n    }\n\n    if (cmdIdx === 0) {\n      cmd.split('/').forEach((urlPart, partIndex) => {\n        if (partIndex == 0 && urlPart === '.') {\n          // skip './a'\n        } else if (partIndex == 0 && urlPart === '') {  //  '/a'\n          isAbsolute = true;\n        } else if (urlPart === '..') {  //  '../a'\n          numberOfDoubleDots++;\n        } else if (urlPart != '') {\n          res.push(urlPart);\n        }\n      });\n\n      return res;\n    }\n\n    return [...res, cmd];\n  }, []);\n\n  return new Navigation(isAbsolute, numberOfDoubleDots, res);\n}\n\nclass Position {\n  constructor(\n      public segmentGroup: UrlSegmentGroup, public processChildren: boolean, public index: number) {\n  }\n}\n\nfunction findStartingPositionForTargetGroup(\n    nav: Navigation, root: UrlSegmentGroup, target: UrlSegmentGroup): Position {\n  if (nav.isAbsolute) {\n    return new Position(root, true, 0);\n  }\n\n  if (!target) {\n    // `NaN` is used only to maintain backwards compatibility with incorrectly mocked\n    // `ActivatedRouteSnapshot` in tests. In prior versions of this code, the position here was\n    // determined based on an internal property that was rarely mocked, resulting in `NaN`. In\n    // reality, this code path should _never_ be touched since `target` is not allowed to be falsey.\n    return new Position(root, false, NaN);\n  }\n  if (target.parent === null) {\n    return new Position(target, true, 0);\n  }\n\n  const modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;\n  const index = target.segments.length - 1 + modifier;\n  return createPositionApplyingDoubleDots(target, index, nav.numberOfDoubleDots);\n}\n\nfunction findStartingPosition(\n    nav: Navigation, tree: UrlTree, segmentGroup: UrlSegmentGroup,\n    lastPathIndex: number): Position {\n  if (nav.isAbsolute) {\n    return new Position(tree.root, true, 0);\n  }\n\n  if (lastPathIndex === -1) {\n    // Pathless ActivatedRoute has _lastPathIndex === -1 but should not process children\n    // see issue #26224, #13011, #35687\n    // However, if the ActivatedRoute is the root we should process children like above.\n    const processChildren = segmentGroup === tree.root;\n    return new Position(segmentGroup, processChildren, 0);\n  }\n\n  const modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;\n  const index = lastPathIndex + modifier;\n  return createPositionApplyingDoubleDots(segmentGroup, index, nav.numberOfDoubleDots);\n}\n\nfunction createPositionApplyingDoubleDots(\n    group: UrlSegmentGroup, index: number, numberOfDoubleDots: number): Position {\n  let g = group;\n  let ci = index;\n  let dd = numberOfDoubleDots;\n  while (dd > ci) {\n    dd -= ci;\n    g = g.parent!;\n    if (!g) {\n      throw new RuntimeError(\n          RuntimeErrorCode.INVALID_DOUBLE_DOTS, NG_DEV_MODE && 'Invalid number of \\'../\\'');\n    }\n    ci = g.segments.length;\n  }\n  return new Position(g, false, ci - dd);\n}\n\nfunction getOutlets(commands: unknown[]): {[k: string]: unknown[]|string} {\n  if (isCommandWithOutlets(commands[0])) {\n    return commands[0].outlets;\n  }\n\n  return {[PRIMARY_OUTLET]: commands};\n}\n\nfunction updateSegmentGroup(\n    segmentGroup: UrlSegmentGroup, startIndex: number, commands: any[]): UrlSegmentGroup {\n  if (!segmentGroup) {\n    segmentGroup = new UrlSegmentGroup([], {});\n  }\n  if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n    return updateSegmentGroupChildren(segmentGroup, startIndex, commands);\n  }\n\n  const m = prefixedWith(segmentGroup, startIndex, commands);\n  const slicedCommands = commands.slice(m.commandIndex);\n  if (m.match && m.pathIndex < segmentGroup.segments.length) {\n    const g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});\n    g.children[PRIMARY_OUTLET] =\n        new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);\n    return updateSegmentGroupChildren(g, 0, slicedCommands);\n  } else if (m.match && slicedCommands.length === 0) {\n    return new UrlSegmentGroup(segmentGroup.segments, {});\n  } else if (m.match && !segmentGroup.hasChildren()) {\n    return createNewSegmentGroup(segmentGroup, startIndex, commands);\n  } else if (m.match) {\n    return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);\n  } else {\n    return createNewSegmentGroup(segmentGroup, startIndex, commands);\n  }\n}\n\nfunction updateSegmentGroupChildren(\n    segmentGroup: UrlSegmentGroup, startIndex: number, commands: any[]): UrlSegmentGroup {\n  if (commands.length === 0) {\n    return new UrlSegmentGroup(segmentGroup.segments, {});\n  } else {\n    const outlets = getOutlets(commands);\n    const children: {[key: string]: UrlSegmentGroup} = {};\n\n    forEach(outlets, (commands, outlet) => {\n      if (typeof commands === 'string') {\n        commands = [commands];\n      }\n      if (commands !== null) {\n        children[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands);\n      }\n    });\n\n    forEach(segmentGroup.children, (child: UrlSegmentGroup, childOutlet: string) => {\n      if (outlets[childOutlet] === undefined) {\n        children[childOutlet] = child;\n      }\n    });\n    return new UrlSegmentGroup(segmentGroup.segments, children);\n  }\n}\n\nfunction prefixedWith(segmentGroup: UrlSegmentGroup, startIndex: number, commands: any[]) {\n  let currentCommandIndex = 0;\n  let currentPathIndex = startIndex;\n\n  const noMatch = {match: false, pathIndex: 0, commandIndex: 0};\n  while (currentPathIndex < segmentGroup.segments.length) {\n    if (currentCommandIndex >= commands.length) return noMatch;\n    const path = segmentGroup.segments[currentPathIndex];\n    const command = commands[currentCommandIndex];\n    // Do not try to consume command as part of the prefixing if it has outlets because it can\n    // contain outlets other than the one being processed. Consuming the outlets command would\n    // result in other outlets being ignored.\n    if (isCommandWithOutlets(command)) {\n      break;\n    }\n    const curr = `${command}`;\n    const next =\n        currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;\n\n    if (currentPathIndex > 0 && curr === undefined) break;\n\n    if (curr && next && (typeof next === 'object') && next.outlets === undefined) {\n      if (!compare(curr, next, path)) return noMatch;\n      currentCommandIndex += 2;\n    } else {\n      if (!compare(curr, {}, path)) return noMatch;\n      currentCommandIndex++;\n    }\n    currentPathIndex++;\n  }\n\n  return {match: true, pathIndex: currentPathIndex, commandIndex: currentCommandIndex};\n}\n\nfunction createNewSegmentGroup(\n    segmentGroup: UrlSegmentGroup, startIndex: number, commands: any[]): UrlSegmentGroup {\n  const paths = segmentGroup.segments.slice(0, startIndex);\n\n  let i = 0;\n  while (i < commands.length) {\n    const command = commands[i];\n    if (isCommandWithOutlets(command)) {\n      const children = createNewSegmentChildren(command.outlets);\n      return new UrlSegmentGroup(paths, children);\n    }\n\n    // if we start with an object literal, we need to reuse the path part from the segment\n    if (i === 0 && isMatrixParams(commands[0])) {\n      const p = segmentGroup.segments[startIndex];\n      paths.push(new UrlSegment(p.path, stringify(commands[0])));\n      i++;\n      continue;\n    }\n\n    const curr = isCommandWithOutlets(command) ? command.outlets[PRIMARY_OUTLET] : `${command}`;\n    const next = (i < commands.length - 1) ? commands[i + 1] : null;\n    if (curr && next && isMatrixParams(next)) {\n      paths.push(new UrlSegment(curr, stringify(next)));\n      i += 2;\n    } else {\n      paths.push(new UrlSegment(curr, {}));\n      i++;\n    }\n  }\n  return new UrlSegmentGroup(paths, {});\n}\n\nfunction createNewSegmentChildren(outlets: {[name: string]: unknown[]|string}):\n    {[outlet: string]: UrlSegmentGroup} {\n  const children: {[outlet: string]: UrlSegmentGroup} = {};\n  forEach(outlets, (commands, outlet) => {\n    if (typeof commands === 'string') {\n      commands = [commands];\n    }\n    if (commands !== null) {\n      children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);\n    }\n  });\n  return children;\n}\n\nfunction stringify(params: {[key: string]: any}): {[key: string]: string} {\n  const res: {[key: string]: string} = {};\n  forEach(params, (v: any, k: string) => res[k] = `${v}`);\n  return res;\n}\n\nfunction compare(path: string, params: {[key: string]: any}, segment: UrlSegment): boolean {\n  return path == segment.path && shallowEqual(params, segment.parameters);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Route} from './models';\nimport {ActivatedRouteSnapshot, RouterStateSnapshot} from './router_state';\n\n/**\n * Identifies the call or event that triggered a navigation.\n *\n * * 'imperative': Triggered by `router.navigateByUrl()` or `router.navigate()`.\n * * 'popstate' : Triggered by a `popstate` event.\n * * 'hashchange'-: Triggered by a `hashchange` event.\n *\n * @publicApi\n */\nexport type NavigationTrigger = 'imperative'|'popstate'|'hashchange';\n\n/**\n * Identifies the type of a router event.\n *\n * @publicApi\n */\nexport const enum EventType {\n  NavigationStart,\n  NavigationEnd,\n  NavigationCancel,\n  NavigationError,\n  RoutesRecognized,\n  ResolveStart,\n  ResolveEnd,\n  GuardsCheckStart,\n  GuardsCheckEnd,\n  RouteConfigLoadStart,\n  RouteConfigLoadEnd,\n  ChildActivationStart,\n  ChildActivationEnd,\n  ActivationStart,\n  ActivationEnd,\n  Scroll,\n}\n\n/**\n * Base for events the router goes through, as opposed to events tied to a specific\n * route. Fired one time for any given navigation.\n *\n * The following code shows how a class subscribes to router events.\n *\n * ```ts\n * import {Event, RouterEvent, Router} from '@angular/router';\n *\n * class MyService {\n *   constructor(public router: Router) {\n *     router.events.pipe(\n *        filter((e: Event): e is RouterEvent => e instanceof RouterEvent)\n *     ).subscribe((e: RouterEvent) => {\n *       // Do something\n *     });\n *   }\n * }\n * ```\n *\n * @see `Event`\n * @see [Router events summary](guide/router-reference#router-events)\n * @publicApi\n */\nexport class RouterEvent {\n  constructor(\n      /** A unique ID that the router assigns to every router navigation. */\n      public id: number,\n      /** The URL that is the destination for this navigation. */\n      public url: string) {}\n}\n\n/**\n * An event triggered when a navigation starts.\n *\n * @publicApi\n */\nexport class NavigationStart extends RouterEvent {\n  readonly type = EventType.NavigationStart;\n\n  /**\n   * Identifies the call or event that triggered the navigation.\n   * An `imperative` trigger is a call to `router.navigateByUrl()` or `router.navigate()`.\n   *\n   * @see `NavigationEnd`\n   * @see `NavigationCancel`\n   * @see `NavigationError`\n   */\n  navigationTrigger?: NavigationTrigger;\n\n  /**\n   * The navigation state that was previously supplied to the `pushState` call,\n   * when the navigation is triggered by a `popstate` event. Otherwise null.\n   *\n   * The state object is defined by `NavigationExtras`, and contains any\n   * developer-defined state value, as well as a unique ID that\n   * the router assigns to every router transition/navigation.\n   *\n   * From the perspective of the router, the router never \"goes back\".\n   * When the user clicks on the back button in the browser,\n   * a new navigation ID is created.\n   *\n   * Use the ID in this previous-state object to differentiate between a newly created\n   * state and one returned to by a `popstate` event, so that you can restore some\n   * remembered state, such as scroll position.\n   *\n   */\n  restoredState?: {[k: string]: any, navigationId: number}|null;\n\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      navigationTrigger: NavigationTrigger = 'imperative',\n      /** @docsNotRequired */\n      restoredState: {[k: string]: any, navigationId: number}|null = null) {\n    super(id, url);\n    this.navigationTrigger = navigationTrigger;\n    this.restoredState = restoredState;\n  }\n\n  /** @docsNotRequired */\n  override toString(): string {\n    return `NavigationStart(id: ${this.id}, url: '${this.url}')`;\n  }\n}\n\n/**\n * An event triggered when a navigation ends successfully.\n *\n * @see `NavigationStart`\n * @see `NavigationCancel`\n * @see `NavigationError`\n *\n * @publicApi\n */\nexport class NavigationEnd extends RouterEvent {\n  readonly type = EventType.NavigationEnd;\n\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public urlAfterRedirects: string) {\n    super(id, url);\n  }\n\n  /** @docsNotRequired */\n  override toString(): string {\n    return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${\n        this.urlAfterRedirects}')`;\n  }\n}\n\n/**\n * A code for the `NavigationCancel` event of the `Router` to indicate the\n * reason a navigation failed.\n *\n * @publicApi\n */\nexport const enum NavigationCancellationCode {\n  /**\n   * A navigation failed because a guard returned a `UrlTree` to redirect.\n   */\n  Redirect,\n  /**\n   * A navigation failed because a more recent navigation started.\n   */\n  SupersededByNewNavigation,\n  /**\n   * A navigation failed because one of the resolvers completed without emiting a value.\n   */\n  NoDataFromResolver,\n  /**\n   * A navigation failed because a guard returned `false`.\n   */\n  GuardRejected,\n}\n\n/**\n * An event triggered when a navigation is canceled, directly or indirectly.\n * This can happen for several reasons including when a route guard\n * returns `false` or initiates a redirect by returning a `UrlTree`.\n *\n * @see `NavigationStart`\n * @see `NavigationEnd`\n * @see `NavigationError`\n *\n * @publicApi\n */\nexport class NavigationCancel extends RouterEvent {\n  readonly type = EventType.NavigationCancel;\n\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /**\n       * A description of why the navigation was cancelled. For debug purposes only. Use `code`\n       * instead for a stable cancellation reason that can be used in production.\n       */\n      public reason: string,\n      /**\n       * A code to indicate why the navigation was canceled. This cancellation code is stable for\n       * the reason and can be relied on whereas the `reason` string could change and should not be\n       * used in production.\n       */\n      readonly code?: NavigationCancellationCode) {\n    super(id, url);\n  }\n\n  /** @docsNotRequired */\n  override toString(): string {\n    return `NavigationCancel(id: ${this.id}, url: '${this.url}')`;\n  }\n}\n\n/**\n * An event triggered when a navigation fails due to an unexpected error.\n *\n * @see `NavigationStart`\n * @see `NavigationEnd`\n * @see `NavigationCancel`\n *\n * @publicApi\n */\nexport class NavigationError extends RouterEvent {\n  readonly type = EventType.NavigationError;\n\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public error: any,\n      /**\n       * The target of the navigation when the error occurred.\n       *\n       * Note that this can be `undefined` because an error could have occurred before the\n       * `RouterStateSnapshot` was created for the navigation.\n       */\n      readonly target?: RouterStateSnapshot) {\n    super(id, url);\n  }\n\n  /** @docsNotRequired */\n  override toString(): string {\n    return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`;\n  }\n}\n\n/**\n * An event triggered when routes are recognized.\n *\n * @publicApi\n */\nexport class RoutesRecognized extends RouterEvent {\n  readonly type = EventType.RoutesRecognized;\n\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public urlAfterRedirects: string,\n      /** @docsNotRequired */\n      public state: RouterStateSnapshot) {\n    super(id, url);\n  }\n\n  /** @docsNotRequired */\n  override toString(): string {\n    return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${\n        this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n\n/**\n * An event triggered at the start of the Guard phase of routing.\n *\n * @see `GuardsCheckEnd`\n *\n * @publicApi\n */\nexport class GuardsCheckStart extends RouterEvent {\n  readonly type = EventType.GuardsCheckStart;\n\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public urlAfterRedirects: string,\n      /** @docsNotRequired */\n      public state: RouterStateSnapshot) {\n    super(id, url);\n  }\n\n  override toString(): string {\n    return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${\n        this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n\n/**\n * An event triggered at the end of the Guard phase of routing.\n *\n * @see `GuardsCheckStart`\n *\n * @publicApi\n */\nexport class GuardsCheckEnd extends RouterEvent {\n  readonly type = EventType.GuardsCheckEnd;\n\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public urlAfterRedirects: string,\n      /** @docsNotRequired */\n      public state: RouterStateSnapshot,\n      /** @docsNotRequired */\n      public shouldActivate: boolean) {\n    super(id, url);\n  }\n\n  override toString(): string {\n    return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${\n        this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`;\n  }\n}\n\n/**\n * An event triggered at the start of the Resolve phase of routing.\n *\n * Runs in the \"resolve\" phase whether or not there is anything to resolve.\n * In future, may change to only run when there are things to be resolved.\n *\n * @see `ResolveEnd`\n *\n * @publicApi\n */\nexport class ResolveStart extends RouterEvent {\n  readonly type = EventType.ResolveStart;\n\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public urlAfterRedirects: string,\n      /** @docsNotRequired */\n      public state: RouterStateSnapshot) {\n    super(id, url);\n  }\n\n  override toString(): string {\n    return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${\n        this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n\n/**\n * An event triggered at the end of the Resolve phase of routing.\n * @see `ResolveStart`.\n *\n * @publicApi\n */\nexport class ResolveEnd extends RouterEvent {\n  readonly type = EventType.ResolveEnd;\n\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public urlAfterRedirects: string,\n      /** @docsNotRequired */\n      public state: RouterStateSnapshot) {\n    super(id, url);\n  }\n\n  override toString(): string {\n    return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${\n        this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n\n/**\n * An event triggered before lazy loading a route configuration.\n *\n * @see `RouteConfigLoadEnd`\n *\n * @publicApi\n */\nexport class RouteConfigLoadStart {\n  readonly type = EventType.RouteConfigLoadStart;\n\n  constructor(\n      /** @docsNotRequired */\n      public route: Route) {}\n  toString(): string {\n    return `RouteConfigLoadStart(path: ${this.route.path})`;\n  }\n}\n\n/**\n * An event triggered when a route has been lazy loaded.\n *\n * @see `RouteConfigLoadStart`\n *\n * @publicApi\n */\nexport class RouteConfigLoadEnd {\n  readonly type = EventType.RouteConfigLoadEnd;\n\n  constructor(\n      /** @docsNotRequired */\n      public route: Route) {}\n  toString(): string {\n    return `RouteConfigLoadEnd(path: ${this.route.path})`;\n  }\n}\n\n/**\n * An event triggered at the start of the child-activation\n * part of the Resolve phase of routing.\n * @see  `ChildActivationEnd`\n * @see `ResolveStart`\n *\n * @publicApi\n */\nexport class ChildActivationStart {\n  readonly type = EventType.ChildActivationStart;\n\n  constructor(\n      /** @docsNotRequired */\n      public snapshot: ActivatedRouteSnapshot) {}\n  toString(): string {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n    return `ChildActivationStart(path: '${path}')`;\n  }\n}\n\n/**\n * An event triggered at the end of the child-activation part\n * of the Resolve phase of routing.\n * @see `ChildActivationStart`\n * @see `ResolveStart`\n * @publicApi\n */\nexport class ChildActivationEnd {\n  readonly type = EventType.ChildActivationEnd;\n\n  constructor(\n      /** @docsNotRequired */\n      public snapshot: ActivatedRouteSnapshot) {}\n  toString(): string {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n    return `ChildActivationEnd(path: '${path}')`;\n  }\n}\n\n/**\n * An event triggered at the start of the activation part\n * of the Resolve phase of routing.\n * @see `ActivationEnd`\n * @see `ResolveStart`\n *\n * @publicApi\n */\nexport class ActivationStart {\n  readonly type = EventType.ActivationStart;\n\n  constructor(\n      /** @docsNotRequired */\n      public snapshot: ActivatedRouteSnapshot) {}\n  toString(): string {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n    return `ActivationStart(path: '${path}')`;\n  }\n}\n\n/**\n * An event triggered at the end of the activation part\n * of the Resolve phase of routing.\n * @see `ActivationStart`\n * @see `ResolveStart`\n *\n * @publicApi\n */\nexport class ActivationEnd {\n  readonly type = EventType.ActivationEnd;\n\n  constructor(\n      /** @docsNotRequired */\n      public snapshot: ActivatedRouteSnapshot) {}\n  toString(): string {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n    return `ActivationEnd(path: '${path}')`;\n  }\n}\n\n/**\n * An event triggered by scrolling.\n *\n * @publicApi\n */\nexport class Scroll {\n  readonly type = EventType.Scroll;\n\n  constructor(\n      /** @docsNotRequired */\n      readonly routerEvent: NavigationEnd,\n\n      /** @docsNotRequired */\n      readonly position: [number, number]|null,\n\n      /** @docsNotRequired */\n      readonly anchor: string|null) {}\n\n  toString(): string {\n    const pos = this.position ? `${this.position[0]}, ${this.position[1]}` : null;\n    return `Scroll(anchor: '${this.anchor}', position: '${pos}')`;\n  }\n}\n\n/**\n * Router events that allow you to track the lifecycle of the router.\n *\n * The events occur in the following sequence:\n *\n * * [NavigationStart](api/router/NavigationStart): Navigation starts.\n * * [RouteConfigLoadStart](api/router/RouteConfigLoadStart): Before\n * the router [lazy loads](/guide/router#lazy-loading) a route configuration.\n * * [RouteConfigLoadEnd](api/router/RouteConfigLoadEnd): After a route has been lazy loaded.\n * * [RoutesRecognized](api/router/RoutesRecognized): When the router parses the URL\n * and the routes are recognized.\n * * [GuardsCheckStart](api/router/GuardsCheckStart): When the router begins the *guards*\n * phase of routing.\n * * [ChildActivationStart](api/router/ChildActivationStart): When the router\n * begins activating a route's children.\n * * [ActivationStart](api/router/ActivationStart): When the router begins activating a route.\n * * [GuardsCheckEnd](api/router/GuardsCheckEnd): When the router finishes the *guards*\n * phase of routing successfully.\n * * [ResolveStart](api/router/ResolveStart): When the router begins the *resolve*\n * phase of routing.\n * * [ResolveEnd](api/router/ResolveEnd): When the router finishes the *resolve*\n * phase of routing successfully.\n * * [ChildActivationEnd](api/router/ChildActivationEnd): When the router finishes\n * activating a route's children.\n * * [ActivationEnd](api/router/ActivationEnd): When the router finishes activating a route.\n * * [NavigationEnd](api/router/NavigationEnd): When navigation ends successfully.\n * * [NavigationCancel](api/router/NavigationCancel): When navigation is canceled.\n * * [NavigationError](api/router/NavigationError): When navigation fails\n * due to an unexpected error.\n * * [Scroll](api/router/Scroll): When the user scrolls.\n *\n * @publicApi\n */\nexport type Event =\n    RouterEvent|NavigationStart|NavigationEnd|NavigationCancel|NavigationError|RoutesRecognized|\n    GuardsCheckStart|GuardsCheckEnd|RouteConfigLoadStart|RouteConfigLoadEnd|ChildActivationStart|\n    ChildActivationEnd|ActivationStart|ActivationEnd|Scroll|ResolveStart|ResolveEnd;\n\n\nexport function stringifyEvent(routerEvent: Event): string {\n  if (!('type' in routerEvent)) {\n    return `Unknown Router Event: ${routerEvent.constructor.name}`;\n  }\n  switch (routerEvent.type) {\n    case EventType.ActivationEnd:\n      return `ActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n    case EventType.ActivationStart:\n      return `ActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n    case EventType.ChildActivationEnd:\n      return `ChildActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n    case EventType.ChildActivationStart:\n      return `ChildActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n    case EventType.GuardsCheckEnd:\n      return `GuardsCheckEnd(id: ${routerEvent.id}, url: '${\n          routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${\n          routerEvent.state}, shouldActivate: ${routerEvent.shouldActivate})`;\n    case EventType.GuardsCheckStart:\n      return `GuardsCheckStart(id: ${routerEvent.id}, url: '${\n          routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${\n          routerEvent.state})`;\n    case EventType.NavigationCancel:\n      return `NavigationCancel(id: ${routerEvent.id}, url: '${routerEvent.url}')`;\n    case EventType.NavigationEnd:\n      return `NavigationEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${\n          routerEvent.urlAfterRedirects}')`;\n    case EventType.NavigationError:\n      return `NavigationError(id: ${routerEvent.id}, url: '${routerEvent.url}', error: ${\n          routerEvent.error})`;\n    case EventType.NavigationStart:\n      return `NavigationStart(id: ${routerEvent.id}, url: '${routerEvent.url}')`;\n    case EventType.ResolveEnd:\n      return `ResolveEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${\n          routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n    case EventType.ResolveStart:\n      return `ResolveStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${\n          routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n    case EventType.RouteConfigLoadEnd:\n      return `RouteConfigLoadEnd(path: ${routerEvent.route.path})`;\n    case EventType.RouteConfigLoadStart:\n      return `RouteConfigLoadStart(path: ${routerEvent.route.path})`;\n    case EventType.RoutesRecognized:\n      return `RoutesRecognized(id: ${routerEvent.id}, url: '${\n          routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${\n          routerEvent.state})`;\n    case EventType.Scroll:\n      const pos =\n          routerEvent.position ? `${routerEvent.position[0]}, ${routerEvent.position[1]}` : null;\n      return `Scroll(anchor: '${routerEvent.anchor}', position: '${pos}')`;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport class Tree<T> {\n  /** @internal */\n  _root: TreeNode<T>;\n\n  constructor(root: TreeNode<T>) {\n    this._root = root;\n  }\n\n  get root(): T {\n    return this._root.value;\n  }\n\n  /**\n   * @internal\n   */\n  parent(t: T): T|null {\n    const p = this.pathFromRoot(t);\n    return p.length > 1 ? p[p.length - 2] : null;\n  }\n\n  /**\n   * @internal\n   */\n  children(t: T): T[] {\n    const n = findNode(t, this._root);\n    return n ? n.children.map(t => t.value) : [];\n  }\n\n  /**\n   * @internal\n   */\n  firstChild(t: T): T|null {\n    const n = findNode(t, this._root);\n    return n && n.children.length > 0 ? n.children[0].value : null;\n  }\n\n  /**\n   * @internal\n   */\n  siblings(t: T): T[] {\n    const p = findPath(t, this._root);\n    if (p.length < 2) return [];\n\n    const c = p[p.length - 2].children.map(c => c.value);\n    return c.filter(cc => cc !== t);\n  }\n\n  /**\n   * @internal\n   */\n  pathFromRoot(t: T): T[] {\n    return findPath(t, this._root).map(s => s.value);\n  }\n}\n\n\n// DFS for the node matching the value\nfunction findNode<T>(value: T, node: TreeNode<T>): TreeNode<T>|null {\n  if (value === node.value) return node;\n\n  for (const child of node.children) {\n    const node = findNode(value, child);\n    if (node) return node;\n  }\n\n  return null;\n}\n\n// Return the path to the node with the given value using DFS\nfunction findPath<T>(value: T, node: TreeNode<T>): TreeNode<T>[] {\n  if (value === node.value) return [node];\n\n  for (const child of node.children) {\n    const path = findPath(value, child);\n    if (path.length) {\n      path.unshift(node);\n      return path;\n    }\n  }\n\n  return [];\n}\n\nexport class TreeNode<T> {\n  constructor(public value: T, public children: TreeNode<T>[]) {}\n\n  toString(): string {\n    return `TreeNode(${this.value})`;\n  }\n}\n\n// Return the list of T indexed by outlet name\nexport function nodeChildrenAsMap<T extends {outlet: string}>(node: TreeNode<T>|null) {\n  const map: {[outlet: string]: TreeNode<T>} = {};\n\n  if (node) {\n    node.children.forEach(child => map[child.value.outlet] = child);\n  }\n\n  return map;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '@angular/core';\nimport {BehaviorSubject, Observable} from 'rxjs';\nimport {map} from 'rxjs/operators';\n\nimport {Data, ResolveData, Route} from './models';\nimport {convertToParamMap, ParamMap, Params, PRIMARY_OUTLET} from './shared';\nimport {equalSegments, UrlSegment, UrlSegmentGroup, UrlTree} from './url_tree';\nimport {shallowEqual, shallowEqualArrays} from './utils/collection';\nimport {Tree, TreeNode} from './utils/tree';\n\n\n\n/**\n * Represents the state of the router as a tree of activated routes.\n *\n * @usageNotes\n *\n * Every node in the route tree is an `ActivatedRoute` instance\n * that knows about the \"consumed\" URL segments, the extracted parameters,\n * and the resolved data.\n * Use the `ActivatedRoute` properties to traverse the tree from any node.\n *\n * The following fragment shows how a component gets the root node\n * of the current state to establish its own route tree:\n *\n * ```\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const root: ActivatedRoute = state.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n * @see `ActivatedRoute`\n * @see [Getting route information](guide/router#getting-route-information)\n *\n * @publicApi\n */\nexport class RouterState extends Tree<ActivatedRoute> {\n  /** @internal */\n  constructor(\n      root: TreeNode<ActivatedRoute>,\n      /** The current snapshot of the router state */\n      public snapshot: RouterStateSnapshot) {\n    super(root);\n    setRouterState(<RouterState>this, root);\n  }\n\n  override toString(): string {\n    return this.snapshot.toString();\n  }\n}\n\nexport function createEmptyState(urlTree: UrlTree, rootComponent: Type<any>|null): RouterState {\n  const snapshot = createEmptyStateSnapshot(urlTree, rootComponent);\n  const emptyUrl = new BehaviorSubject([new UrlSegment('', {})]);\n  const emptyParams = new BehaviorSubject({});\n  const emptyData = new BehaviorSubject({});\n  const emptyQueryParams = new BehaviorSubject({});\n  const fragment = new BehaviorSubject('');\n  const activated = new ActivatedRoute(\n      emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent,\n      snapshot.root);\n  activated.snapshot = snapshot.root;\n  return new RouterState(new TreeNode<ActivatedRoute>(activated, []), snapshot);\n}\n\nexport function createEmptyStateSnapshot(\n    urlTree: UrlTree, rootComponent: Type<any>|null): RouterStateSnapshot {\n  const emptyParams = {};\n  const emptyData = {};\n  const emptyQueryParams = {};\n  const fragment = '';\n  const activated = new ActivatedRouteSnapshot(\n      [], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null,\n      urlTree.root, -1, {});\n  return new RouterStateSnapshot('', new TreeNode<ActivatedRouteSnapshot>(activated, []));\n}\n\n/**\n * Provides access to information about a route associated with a component\n * that is loaded in an outlet.\n * Use to traverse the `RouterState` tree and extract information from nodes.\n *\n * The following example shows how to construct a component using information from a\n * currently activated route.\n *\n * Note: the observables in this class only emit when the current and previous values differ based\n * on shallow equality. For example, changing deeply nested properties in resolved `data` will not\n * cause the `ActivatedRoute.data` `Observable` to emit a new value.\n *\n * {@example router/activated-route/module.ts region=\"activated-route\"\n *     header=\"activated-route.component.ts\"}\n *\n * @see [Getting route information](guide/router#getting-route-information)\n *\n * @publicApi\n */\nexport class ActivatedRoute {\n  /** The current snapshot of this route */\n  snapshot!: ActivatedRouteSnapshot;\n  /** @internal */\n  _futureSnapshot: ActivatedRouteSnapshot;\n  /** @internal */\n  _routerState!: RouterState;\n  /** @internal */\n  _paramMap!: Observable<ParamMap>;\n  /** @internal */\n  _queryParamMap!: Observable<ParamMap>;\n\n  /** @internal */\n  constructor(\n      /** An observable of the URL segments matched by this route. */\n      public url: Observable<UrlSegment[]>,\n      /** An observable of the matrix parameters scoped to this route. */\n      public params: Observable<Params>,\n      /** An observable of the query parameters shared by all the routes. */\n      public queryParams: Observable<Params>,\n      /** An observable of the URL fragment shared by all the routes. */\n      public fragment: Observable<string|null>,\n      /** An observable of the static and resolved data of this route. */\n      public data: Observable<Data>,\n      /** The outlet name of the route, a constant. */\n      public outlet: string,\n      /** The component of the route, a constant. */\n      public component: Type<any>|null, futureSnapshot: ActivatedRouteSnapshot) {\n    this._futureSnapshot = futureSnapshot;\n  }\n\n  /** The configuration used to match this route. */\n  get routeConfig(): Route|null {\n    return this._futureSnapshot.routeConfig;\n  }\n\n  /** The root of the router state. */\n  get root(): ActivatedRoute {\n    return this._routerState.root;\n  }\n\n  /** The parent of this route in the router state tree. */\n  get parent(): ActivatedRoute|null {\n    return this._routerState.parent(this);\n  }\n\n  /** The first child of this route in the router state tree. */\n  get firstChild(): ActivatedRoute|null {\n    return this._routerState.firstChild(this);\n  }\n\n  /** The children of this route in the router state tree. */\n  get children(): ActivatedRoute[] {\n    return this._routerState.children(this);\n  }\n\n  /** The path from the root of the router state tree to this route. */\n  get pathFromRoot(): ActivatedRoute[] {\n    return this._routerState.pathFromRoot(this);\n  }\n\n  /**\n   * An Observable that contains a map of the required and optional parameters\n   * specific to the route.\n   * The map supports retrieving single and multiple values from the same parameter.\n   */\n  get paramMap(): Observable<ParamMap> {\n    if (!this._paramMap) {\n      this._paramMap = this.params.pipe(map((p: Params): ParamMap => convertToParamMap(p)));\n    }\n    return this._paramMap;\n  }\n\n  /**\n   * An Observable that contains a map of the query parameters available to all routes.\n   * The map supports retrieving single and multiple values from the query parameter.\n   */\n  get queryParamMap(): Observable<ParamMap> {\n    if (!this._queryParamMap) {\n      this._queryParamMap =\n          this.queryParams.pipe(map((p: Params): ParamMap => convertToParamMap(p)));\n    }\n    return this._queryParamMap;\n  }\n\n  toString(): string {\n    return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})`;\n  }\n}\n\nexport type ParamsInheritanceStrategy = 'emptyOnly'|'always';\n\n/** @internal */\nexport type Inherited = {\n  params: Params,\n  data: Data,\n  resolve: Data,\n};\n\n/**\n * Returns the inherited params, data, and resolve for a given route.\n * By default, this only inherits values up to the nearest path-less or component-less route.\n * @internal\n */\nexport function inheritedParamsDataResolve(\n    route: ActivatedRouteSnapshot,\n    paramsInheritanceStrategy: ParamsInheritanceStrategy = 'emptyOnly'): Inherited {\n  const pathFromRoot = route.pathFromRoot;\n\n  let inheritingStartingFrom = 0;\n  if (paramsInheritanceStrategy !== 'always') {\n    inheritingStartingFrom = pathFromRoot.length - 1;\n\n    while (inheritingStartingFrom >= 1) {\n      const current = pathFromRoot[inheritingStartingFrom];\n      const parent = pathFromRoot[inheritingStartingFrom - 1];\n      // current route is an empty path => inherits its parent's params and data\n      if (current.routeConfig && current.routeConfig.path === '') {\n        inheritingStartingFrom--;\n\n        // parent is componentless => current route should inherit its params and data\n      } else if (!parent.component) {\n        inheritingStartingFrom--;\n\n      } else {\n        break;\n      }\n    }\n  }\n\n  return flattenInherited(pathFromRoot.slice(inheritingStartingFrom));\n}\n\n/** @internal */\nfunction flattenInherited(pathFromRoot: ActivatedRouteSnapshot[]): Inherited {\n  return pathFromRoot.reduce((res, curr) => {\n    const params = {...res.params, ...curr.params};\n    const data = {...res.data, ...curr.data};\n    const resolve =\n        {...curr.data, ...res.resolve, ...curr.routeConfig?.data, ...curr._resolvedData};\n    return {params, data, resolve};\n  }, {params: {}, data: {}, resolve: {}});\n}\n\n/**\n * @description\n *\n * Contains the information about a route associated with a component loaded in an\n * outlet at a particular moment in 