ePipe, value);
        }
        return value.slice(start, end);
    }
    supports(obj) {
        return typeof obj === 'string' || Array.isArray(obj);
    }
}
SlicePipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: SlicePipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
SlicePipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "14.1.0", ngImport: i0, type: SlicePipe, isStandalone: true, name: "slice", pure: false });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: SlicePipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'slice',
                    pure: false,
                    standalone: true,
                }]
        }] });

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * A collection of Angular pipes that are likely to be used in each and every application.
 */
const COMMON_PIPES = [
    AsyncPipe,
    UpperCasePipe,
    LowerCasePipe,
    JsonPipe,
    SlicePipe,
    DecimalPipe,
    PercentPipe,
    TitleCasePipe,
    CurrencyPipe,
    DatePipe,
    I18nPluralPipe,
    I18nSelectPipe,
    KeyValuePipe,
];

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// Note: This does not contain the location providers,
// as they need some platform specific implementations to work.
/**
 * Exports all the basic Angular directives and pipes,
 * such as `NgIf`, `NgForOf`, `DecimalPipe`, and so on.
 * Re-exported by `BrowserModule`, which is included automatically in the root
 * `AppModule` when you create a new app with the CLI `new` command.
 *
 * @publicApi
 */
class CommonModule {
}
CommonModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: CommonModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
CommonModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.1.0", ngImport: i0, type: CommonModule, imports: [NgClass, NgComponentOutlet, NgForOf, NgIf, NgTemplateOutlet, NgStyle, NgSwitch, NgSwitchCase, NgSwitchDefault, NgPlural, NgPluralCase, AsyncPipe, UpperCasePipe, LowerCasePipe, JsonPipe, SlicePipe, DecimalPipe, PercentPipe, TitleCasePipe, CurrencyPipe, DatePipe, I18nPluralPipe, I18nSelectPipe, KeyValuePipe], exports: [NgClass, NgComponentOutlet, NgForOf, NgIf, NgTemplateOutlet, NgStyle, NgSwitch, NgSwitchCase, NgSwitchDefault, NgPlural, NgPluralCase, AsyncPipe, UpperCasePipe, LowerCasePipe, JsonPipe, SlicePipe, DecimalPipe, PercentPipe, TitleCasePipe, CurrencyPipe, DatePipe, I18nPluralPipe, I18nSelectPipe, KeyValuePipe] });
CommonModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: CommonModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.1.0", ngImport: i0, type: CommonModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [COMMON_DIRECTIVES, COMMON_PIPES],
                    exports: [COMMON_DIRECTIVES, COMMON_PIPES],
                }]
        }] });

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const PLATFORM_BROWSER_ID = 'browser';
const PLATFORM_SERVER_ID = 'server';
const PLATFORM_WORKER_APP_ID = 'browserWorkerApp';
const PLATFORM_WORKER_UI_ID = 'browserWorkerUi';
/**
 * Returns whether a platform id represents a browser platform.
 * @publicApi
 */
function isPlatformBrowser(platformId) {
    return platformId === PLATFORM_BROWSER_ID;
}
/**
 * Returns whether a platform id represents a server platform.
 * @publicApi
 */
function isPlatformServer(platformId) {
    return platformId === PLATFORM_SERVER_ID;
}
/**
 * Returns whether a platform id represents a web worker app platform.
 * @publicApi
 */
function isPlatformWorkerApp(platformId) {
    return platformId === PLATFORM_WORKER_APP_ID;
}
/**
 * Returns whether a platform id represents a web worker UI platform.
 * @publicApi
 */
function isPlatformWorkerUi(platformId) {
    return platformId === PLATFORM_WORKER_UI_ID;
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @publicApi
 */
const VERSION = new Version('14.1.0');

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Defines a scroll position manager. Implemented by `BrowserViewportScroller`.
 *
 * @publicApi
 */
class ViewportScroller {
}
// De-sugared tree-shakable injection
// See #23917
/** @nocollapse */
ViewportScroller.ɵprov = ɵɵdefineInjectable({
    token: ViewportScroller,
    providedIn: 'root',
    factory: () => new BrowserViewportScroller(ɵɵinject(DOCUMENT), window)
});
/**
 * Manages the scroll position for a browser window.
 */
class BrowserViewportScroller {
    constructor(document, window) {
        this.document = document;
        this.window = window;
        this.offset = () => [0, 0];
    }
    /**
     * Configures the top offset used when scrolling to an anchor.
     * @param offset A position in screen coordinates (a tuple with x and y values)
     * or a function that returns the top offset position.
     *
     */
    setOffset(offset) {
        if (Array.isArray(offset)) {
            this.offset = () => offset;
        }
        else {
            this.offset = offset;
        }
    }
    /**
     * Retrieves the current scroll position.
     * @returns The position in screen coordinates.
     */
    getScrollPosition() {
        if (this.supportsScrolling()) {
            return [this.window.pageXOffset, this.window.pageYOffset];
        }
        else {
            return [0, 0];
        }
    }
    /**
     * Sets the scroll position.
     * @param position The new position in screen coordinates.
     */
    scrollToPosition(position) {
        if (this.supportsScrolling()) {
            this.window.scrollTo(position[0], position[1]);
        }
    }
    /**
     * Scrolls to an element and attempts to focus the element.
     *
     * Note that the function name here is misleading in that the target string may be an ID for a
     * non-anchor element.
     *
     * @param target The ID of an element or name of the anchor.
     *
     * @see https://html.spec.whatwg.org/#the-indicated-part-of-the-document
     * @see https://html.spec.whatwg.org/#scroll-to-fragid
     */
    scrollToAnchor(target) {
        if (!this.supportsScrolling()) {
            return;
        }
        const elSelected = findAnchorFromDocument(this.document, target);
        if (elSelected) {
            this.scrollToElement(elSelected);
            // After scrolling to the element, the spec dictates that we follow the focus steps for the
            // target. Rather than following the robust steps, simply attempt focus.
            //
            // @see https://html.spec.whatwg.org/#get-the-focusable-area
            // @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLOrForeignElement/focus
            // @see https://html.spec.whatwg.org/#focusable-area
            elSelected.focus();
        }
    }
    /**
     * Disables automatic scroll restoration provided by the browser.
     */
    setHistoryScrollRestoration(scrollRestoration) {
        if (this.supportScrollRestoration()) {
            const history = this.window.history;
            if (history && history.scrollRestoration) {
                history.scrollRestoration = scrollRestoration;
            }
        }
    }
    /**
     * Scrolls to an element using the native offset and the specified offset set on this scroller.
     *
     * The offset can be used when we know that there is a floating header and scrolling naively to an
     * element (ex: `scrollIntoView`) leaves the element hidden behind the floating header.
     */
    scrollToElement(el) {
        const rect = el.getBoundingClientRect();
        const left = rect.left + this.window.pageXOffset;
        const top = rect.top + this.window.pageYOffset;
        const offset = this.offset();
        this.window.scrollTo(left - offset[0], top - offset[1]);
    }
    /**
     * We only support scroll restoration when we can get a hold of window.
     * This means that we do not support this behavior when running in a web worker.
     *
     * Lifting this restriction right now would require more changes in the dom adapter.
     * Since webworkers aren't widely used, we will lift it once RouterScroller is
     * battle-tested.
     */
    supportScrollRestoration() {
        try {
            if (!this.supportsScrolling()) {
                return false;
            }
            // The `scrollRestoration` property could be on the `history` instance or its prototype.
            const scrollRestorationDescriptor = getScrollRestorationProperty(this.window.history) ||
                getScrollRestorationProperty(Object.getPrototypeOf(this.window.history));
            // We can write to the `scrollRestoration` property if it is a writable data field or it has a
            // setter function.
            return !!scrollRestorationDescriptor &&
                !!(scrollRestorationDescriptor.writable || scrollRestorationDescriptor.set);
        }
        catch {
            return false;
        }
    }
    supportsScrolling() {
        try {
            return !!this.window && !!this.window.scrollTo && 'pageXOffset' in this.window;
        }
        catch {
            return false;
        }
    }
}
function getScrollRestorationProperty(obj) {
    return Object.getOwnPropertyDescriptor(obj, 'scrollRestoration');
}
function findAnchorFromDocument(document, target) {
    const documentResult = document.getElementById(target) || document.getElementsByName(target)[0];
    if (documentResult) {
        return documentResult;
    }
    // `getElementById` and `getElementsByName` won't pierce through the shadow DOM so we
    // have to traverse the DOM manually and do the lookup through the shadow roots.
    if (typeof document.createTreeWalker === 'function' && document.body &&
        (document.body.createShadowRoot || document.body.attachShadow)) {
        const treeWalker = document.createTreeWalker(document.body, NodeFilter.SHOW_ELEMENT);
        let currentNode = treeWalker.currentNode;
        while (currentNode) {
            const shadowRoot = currentNode.shadowRoot;
            if (shadowRoot) {
                // Note that `ShadowRoot` doesn't support `getElementsByName`
                // so we have to fall back to `querySelector`.
                const result = shadowRoot.getElementById(target) || shadowRoot.querySelector(`[name="${target}"]`);
                if (result) {
                    return result;
                }
            }
            currentNode = treeWalker.nextNode();
        }
    }
    return null;
}
/**
 * Provides an empty implementation of the viewport scroller.
 */
class NullViewportScroller {
    /**
     * Empty implementation
     */
    setOffset(offset) { }
    /**
     * Empty implementation
     */
    getScrollPosition() {
        return [0, 0];
    }
    /**
     * Empty implementation
     */
    scrollToPosition(position) { }
    /**
     * Empty implementation
     */
    scrollToAnchor(anchor) { }
    /**
     * Empty implementation
     */
    setHistoryScrollRestoration(scrollRestoration) { }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * A wrapper around the `XMLHttpRequest` constructor.
 *
 * @publicApi
 */
class XhrFactory {
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// This file only reexports content of the `src` folder. Keep it that way.

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Generated bundle index. Do not edit.
 */

export { APP_BASE_HREF, AsyncPipe, CommonModule, CurrencyPipe, DATE_PIPE_DEFAULT_TIMEZONE, DOCUMENT, DatePipe, DecimalPipe, FormStyle, FormatWidth, HashLocationStrategy, I18nPluralPipe, I18nSelectPipe, JsonPipe, KeyValuePipe, LOCATION_INITIALIZED, Location, LocationStrategy, LowerCasePipe, NgClass, NgComponentOutlet, NgForOf, NgForOfContext, NgIf, NgIfContext, NgLocaleLocalization, NgLocalization, NgPlural, NgPluralCase, NgStyle, NgSwitch, NgSwitchCase, NgSwitchDefault, NgTemplateOutlet, NumberFormatStyle, NumberSymbol, PathLocationStrategy, PercentPipe, PlatformLocation, Plural, SlicePipe, TitleCasePipe, TranslationWidth, UpperCasePipe, VERSION, ViewportScroller, WeekDay, XhrFactory, formatCurrency, formatDate, formatNumber, formatPercent, getCurrencySymbol, getLocaleCurrencyCode, getLocaleCurrencyName, getLocaleCurrencySymbol, getLocaleDateFormat, getLocaleDateTimeFormat, getLocaleDayNames, getLocaleDayPeriods, getLocaleDirection, getLocaleEraNames, getLocaleExtraDayPeriodRules, getLocaleExtraDayPeriods, getLocaleFirstDayOfWeek, getLocaleId, getLocaleMonthNames, getLocaleNumberFormat, getLocaleNumberSymbol, getLocalePluralCase, getLocaleTimeFormat, getLocaleWeekEndRange, getNumberOfCurrencyDigits, isPlatformBrowser, isPlatformServer, isPlatformWorkerApp, isPlatformWorkerUi, registerLocaleData, BrowserPlatformLocation as ɵBrowserPlatformLocation, DomAdapter as ɵDomAdapter, NullViewportScroller as ɵNullViewportScroller, PLATFORM_BROWSER_ID as ɵPLATFORM_BROWSER_ID, PLATFORM_SERVER_ID as ɵPLATFORM_SERVER_ID, PLATFORM_WORKER_APP_ID as ɵPLATFORM_WORKER_APP_ID, PLATFORM_WORKER_UI_ID as ɵPLATFORM_WORKER_UI_ID, getDOM as ɵgetDOM, parseCookieValue as ɵparseCookieValue, setRootDomAdapter as ɵsetRootDomAdapter };
//# sourceMappingURL=common.mjs.map
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   n    return this._paramMap;\n  }\n\n  get queryParamMap(): ParamMap {\n    if (!this._queryParamMap) {\n      this._queryParamMap = convertToParamMap(this.queryParams);\n    }\n    return this._queryParamMap;\n  }\n\n  toString(): string {\n    const url = this.url.map(segment => segment.toString()).join('/');\n    const matched = this.routeConfig ? this.routeConfig.path : '';\n    return `Route(url:'${url}', path:'${matched}')`;\n  }\n}\n\n/**\n * @description\n *\n * Represents the state of the router at a moment in time.\n *\n * This is a tree of activated route snapshots. Every node in this tree knows about\n * the \"consumed\" URL segments, the extracted parameters, and the resolved data.\n *\n * The following example shows how a component is initialized with information\n * from the snapshot of the root node's state at the time of creation.\n *\n * ```\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const snapshot: RouterStateSnapshot = state.snapshot;\n *     const root: ActivatedRouteSnapshot = snapshot.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport class RouterStateSnapshot extends Tree<ActivatedRouteSnapshot> {\n  /** @internal */\n  constructor(\n      /** The url from which this snapshot was created */\n      public url: string, root: TreeNode<ActivatedRouteSnapshot>) {\n    super(root);\n    setRouterState(<RouterStateSnapshot>this, root);\n  }\n\n  override toString(): string {\n    return serializeNode(this._root);\n  }\n}\n\nfunction setRouterState<U, T extends {_routerState: U}>(state: U, node: TreeNode<T>): void {\n  node.value._routerState = state;\n  node.children.forEach(c => setRouterState(state, c));\n}\n\nfunction serializeNode(node: TreeNode<ActivatedRouteSnapshot>): string {\n  const c = node.children.length > 0 ? ` { ${node.children.map(serializeNode).join(', ')} } ` : '';\n  return `${node.value}${c}`;\n}\n\n/**\n * The expectation is that the activate route is created with the right set of parameters.\n * So we push new values into the observables only when they are not the initial values.\n * And we detect that by checking if the snapshot field is set.\n */\nexport function advanceActivatedRoute(route: ActivatedRoute): void {\n  if (route.snapshot) {\n    const currentSnapshot = route.snapshot;\n    const nextSnapshot = route._futureSnapshot;\n    route.snapshot = nextSnapshot;\n    if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {\n      (<any>route.queryParams).next(nextSnapshot.queryParams);\n    }\n    if (currentSnapshot.fragment !== nextSnapshot.fragment) {\n      (<any>route.fragment).next(nextSnapshot.fragment);\n    }\n    if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {\n      (<any>route.params).next(nextSnapshot.params);\n    }\n    if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {\n      (<any>route.url).next(nextSnapshot.url);\n    }\n    if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {\n      (<any>route.data).next(nextSnapshot.data);\n    }\n  } else {\n    route.snapshot = route._futureSnapshot;\n\n    // this is for resolved data\n    (<any>route.data).next(route._futureSnapshot.data);\n  }\n}\n\n\nexport function equalParamsAndUrlSegments(\n    a: ActivatedRouteSnapshot, b: ActivatedRouteSnapshot): boolean {\n  const equalUrlParams = shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);\n  const parentsMismatch = !a.parent !== !b.parent;\n\n  return equalUrlParams && !parentsMismatch &&\n      (!a.parent || equalParamsAndUrlSegments(a.parent, b.parent!));\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {BehaviorSubject} from 'rxjs';\n\nimport {DetachedRouteHandleInternal, RouteReuseStrategy} from './route_reuse_strategy';\nimport {ActivatedRoute, ActivatedRouteSnapshot, RouterState, RouterStateSnapshot} from './router_state';\nimport {TreeNode} from './utils/tree';\n\nexport function createRouterState(\n    routeReuseStrategy: RouteReuseStrategy, curr: RouterStateSnapshot,\n    prevState: RouterState): RouterState {\n  const root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : undefined);\n  return new RouterState(root, curr);\n}\n\nfunction createNode(\n    routeReuseStrategy: RouteReuseStrategy, curr: TreeNode<ActivatedRouteSnapshot>,\n    prevState?: TreeNode<ActivatedRoute>): TreeNode<ActivatedRoute> {\n  // reuse an activated route that is currently displayed on the screen\n  if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {\n    const value = prevState.value;\n    value._futureSnapshot = curr.value;\n    const children = createOrReuseChildren(routeReuseStrategy, curr, prevState);\n    return new TreeNode<ActivatedRoute>(value, children);\n  } else {\n    if (routeReuseStrategy.shouldAttach(curr.value)) {\n      // retrieve an activated route that is used to be displayed, but is not currently displayed\n      const detachedRouteHandle = routeReuseStrategy.retrieve(curr.value);\n      if (detachedRouteHandle !== null) {\n        const tree = (detachedRouteHandle as DetachedRouteHandleInternal).route;\n        tree.value._futureSnapshot = curr.value;\n        tree.children = curr.children.map(c => createNode(routeReuseStrategy, c));\n        return tree;\n      }\n    }\n\n    const value = createActivatedRoute(curr.value);\n    const children = curr.children.map(c => createNode(routeReuseStrategy, c));\n    return new TreeNode<ActivatedRoute>(value, children);\n  }\n}\n\nfunction createOrReuseChildren(\n    routeReuseStrategy: RouteReuseStrategy, curr: TreeNode<ActivatedRouteSnapshot>,\n    prevState: TreeNode<ActivatedRoute>) {\n  return curr.children.map(child => {\n    for (const p of prevState.children) {\n      if (routeReuseStrategy.shouldReuseRoute(child.value, p.value.snapshot)) {\n        return createNode(routeReuseStrategy, child, p);\n      }\n    }\n    return createNode(routeReuseStrategy, child);\n  });\n}\n\nfunction createActivatedRoute(c: ActivatedRouteSnapshot) {\n  return new ActivatedRoute(\n      new BehaviorSubject(c.url), new BehaviorSubject(c.params), new BehaviorSubject(c.queryParams),\n      new BehaviorSubject(c.fragment), new BehaviorSubject(c.data), c.outlet, c.component, c);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NavigationCancellationCode} from './events';\nimport {NavigationBehaviorOptions} from './models';\nimport {isUrlTree, UrlSerializer, UrlTree} from './url_tree';\n\nexport const NAVIGATION_CANCELING_ERROR = 'ngNavigationCancelingError';\n\nexport type NavigationCancelingError =\n    Error&{[NAVIGATION_CANCELING_ERROR]: true, cancellationCode: NavigationCancellationCode};\nexport type RedirectingNavigationCancelingError = NavigationCancelingError&{\n  url: UrlTree;\n  navigationBehaviorOptions?: NavigationBehaviorOptions;\n  cancellationCode: NavigationCancellationCode.Redirect;\n};\n\nexport function redirectingNavigationError(\n    urlSerializer: UrlSerializer, redirect: UrlTree): RedirectingNavigationCancelingError {\n  const {redirectTo, navigationBehaviorOptions} =\n      isUrlTree(redirect) ? {redirectTo: redirect, navigationBehaviorOptions: undefined} : redirect;\n  const error =\n      navigationCancelingError(\n          ngDevMode && `Redirecting to \"${urlSerializer.serialize(redirectTo)}\"`,\n          NavigationCancellationCode.Redirect, redirect) as RedirectingNavigationCancelingError;\n  error.url = redirectTo;\n  error.navigationBehaviorOptions = navigationBehaviorOptions;\n  return error;\n}\n\nexport function navigationCancelingError(\n    message: string|null|false, code: NavigationCancellationCode, redirectUrl?: UrlTree) {\n  const error =\n      new Error('NavigationCancelingError: ' + (message || '')) as NavigationCancelingError;\n  error[NAVIGATION_CANCELING_ERROR] = true;\n  error.cancellationCode = code;\n  if (redirectUrl) {\n    (error as RedirectingNavigationCancelingError).url = redirectUrl;\n  }\n  return error;\n}\n\nexport function isRedirectingNavigationCancelingError(\n    error: unknown|\n    RedirectingNavigationCancelingError): error is RedirectingNavigationCancelingError {\n  return isNavigationCancelingError(error) && isUrlTree((error as any).url);\n}\nexport function isNavigationCancelingError(error: unknown): error is NavigationCancelingError {\n  return error && (error as any)[NAVIGATION_CANCELING_ERROR];\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ComponentFactoryResolver, ComponentRef, EnvironmentInjector} from '@angular/core';\n\nimport {RouterOutletContract} from './directives/router_outlet';\nimport {ActivatedRoute} from './router_state';\n\n\n/**\n * Store contextual information about a `RouterOutlet`\n *\n * @publicApi\n */\nexport class OutletContext {\n  outlet: RouterOutletContract|null = null;\n  route: ActivatedRoute|null = null;\n  /**\n   * @deprecated Passing a resolver to retrieve a component factory is not required and is\n   *     deprecated since v14.\n   */\n  resolver: ComponentFactoryResolver|null = null;\n  injector: EnvironmentInjector|null = null;\n  children = new ChildrenOutletContexts();\n  attachRef: ComponentRef<any>|null = null;\n}\n\n/**\n * Store contextual information about the children (= nested) `RouterOutlet`\n *\n * @publicApi\n */\nexport class ChildrenOutletContexts {\n  // contexts for child outlets, by name.\n  private contexts = new Map<string, OutletContext>();\n\n  /** Called when a `RouterOutlet` directive is instantiated */\n  onChildOutletCreated(childName: string, outlet: RouterOutletContract): void {\n    const context = this.getOrCreateContext(childName);\n    context.outlet = outlet;\n    this.contexts.set(childName, context);\n  }\n\n  /**\n   * Called when a `RouterOutlet` directive is destroyed.\n   * We need to keep the context as the outlet could be destroyed inside a NgIf and might be\n   * re-created later.\n   */\n  onChildOutletDestroyed(childName: string): void {\n    const context = this.getContext(childName);\n    if (context) {\n      context.outlet = null;\n      context.attachRef = null;\n    }\n  }\n\n  /**\n   * Called when the corresponding route is deactivated during navigation.\n   * Because the component get destroyed, all children outlet are destroyed.\n   */\n  onOutletDeactivated(): Map<string, OutletContext> {\n    const contexts = this.contexts;\n    this.contexts = new Map();\n    return contexts;\n  }\n\n  onOutletReAttached(contexts: Map<string, OutletContext>) {\n    this.contexts = contexts;\n  }\n\n  getOrCreateContext(childName: string): OutletContext {\n    let context = this.getContext(childName);\n\n    if (!context) {\n      context = new OutletContext();\n      this.contexts.set(childName, context);\n    }\n\n    return context;\n  }\n\n  getContext(childName: string): OutletContext|null {\n    return this.contexts.get(childName) || null;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Attribute, ChangeDetectorRef, ComponentFactoryResolver, ComponentRef, Directive, EnvironmentInjector, EventEmitter, Injector, OnDestroy, OnInit, Output, ViewContainerRef, ɵRuntimeError as RuntimeError,} from '@angular/core';\n\nimport {RuntimeErrorCode} from '../errors';\nimport {Data} from '../models';\nimport {ChildrenOutletContexts} from '../router_outlet_context';\nimport {ActivatedRoute} from '../router_state';\nimport {PRIMARY_OUTLET} from '../shared';\n\nconst NG_DEV_MODE = typeof ngDevMode === 'undefined' || ngDevMode;\n\n/**\n * An interface that defines the contract for developing a component outlet for the `Router`.\n *\n * An outlet acts as a placeholder that Angular dynamically fills based on the current router state.\n *\n * A router outlet should register itself with the `Router` via\n * `ChildrenOutletContexts#onChildOutletCreated` and unregister with\n * `ChildrenOutletContexts#onChildOutletDestroyed`. When the `Router` identifies a matched `Route`,\n * it looks for a registered outlet in the `ChildrenOutletContexts` and activates it.\n *\n * @see `ChildrenOutletContexts`\n * @publicApi\n */\nexport interface RouterOutletContract {\n  /**\n   * Whether the given outlet is activated.\n   *\n   * An outlet is considered \"activated\" if it has an active component.\n   */\n  isActivated: boolean;\n\n  /** The instance of the activated component or `null` if the outlet is not activated. */\n  component: Object|null;\n\n  /**\n   * The `Data` of the `ActivatedRoute` snapshot.\n   */\n  activatedRouteData: Data;\n\n  /**\n   * The `ActivatedRoute` for the outlet or `null` if the outlet is not activated.\n   */\n  activatedRoute: ActivatedRoute|null;\n\n  /**\n   * Called by the `Router` when the outlet should activate (create a component).\n   */\n  activateWith(activatedRoute: ActivatedRoute, environmentInjector: EnvironmentInjector|null): void;\n  /**\n   * Called by the `Router` when the outlet should activate (create a component).\n   *\n   * @deprecated Passing a resolver to retrieve a component factory is not required and is\n   *     deprecated since v14.\n   */\n  activateWith(activatedRoute: ActivatedRoute, resolver: ComponentFactoryResolver|null): void;\n\n  /**\n   * A request to destroy the currently activated component.\n   *\n   * When a `RouteReuseStrategy` indicates that an `ActivatedRoute` should be removed but stored for\n   * later re-use rather than destroyed, the `Router` will call `detach` instead.\n   */\n  deactivate(): void;\n\n  /**\n   * Called when the `RouteReuseStrategy` instructs to detach the subtree.\n   *\n   * This is similar to `deactivate`, but the activated component should _not_ be destroyed.\n   * Instead, it is returned so that it can be reattached later via the `attach` method.\n   */\n  detach(): ComponentRef<unknown>;\n\n  /**\n   * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree.\n   */\n  attach(ref: ComponentRef<unknown>, activatedRoute: ActivatedRoute): void;\n\n  /**\n   * Emits an activate event when a new component is instantiated\n   **/\n  activateEvents?: EventEmitter<unknown>;\n\n  /**\n   * Emits a deactivate event when a component is destroyed.\n   */\n  deactivateEvents?: EventEmitter<unknown>;\n\n  /**\n   * Emits an attached component instance when the `RouteReuseStrategy` instructs to re-attach a\n   * previously detached subtree.\n   **/\n  attachEvents?: EventEmitter<unknown>;\n\n  /**\n   * Emits a detached component instance when the `RouteReuseStrategy` instructs to detach the\n   * subtree.\n   */\n  detachEvents?: EventEmitter<unknown>;\n}\n\n/**\n * @description\n *\n * Acts as a placeholder that Angular dynamically fills based on the current router state.\n *\n * Each outlet can have a unique name, determined by the optional `name` attribute.\n * The name cannot be set or changed dynamically. If not set, default value is \"primary\".\n *\n * ```\n * <router-outlet></router-outlet>\n * <router-outlet name='left'></router-outlet>\n * <router-outlet name='right'></router-outlet>\n * ```\n *\n * Named outlets can be the targets of secondary routes.\n * The `Route` object for a secondary route has an `outlet` property to identify the target outlet:\n *\n * `{path: <base-path>, component: <component>, outlet: <target_outlet_name>}`\n *\n * Using named outlets and secondary routes, you can target multiple outlets in\n * the same `RouterLink` directive.\n *\n * The router keeps track of separate branches in a navigation tree for each named outlet and\n * generates a representation of that tree in the URL.\n * The URL for a secondary route uses the following syntax to specify both the primary and secondary\n * routes at the same time:\n *\n * `http://base-path/primary-route-path(outlet-name:route-path)`\n *\n * A router outlet emits an activate event when a new component is instantiated,\n * deactivate event when a component is destroyed.\n * An attached event emits when the `RouteReuseStrategy` instructs the outlet to reattach the\n * subtree, and the detached event emits when the `RouteReuseStrategy` instructs the outlet to\n * detach the subtree.\n *\n * ```\n * <router-outlet\n *   (activate)='onActivate($event)'\n *   (deactivate)='onDeactivate($event)'\n *   (attach)='onAttach($event)'\n *   (detach)='onDetach($event)'></router-outlet>\n * ```\n *\n * @see [Routing tutorial](guide/router-tutorial-toh#named-outlets \"Example of a named\n * outlet and secondary route configuration\").\n * @see `RouterLink`\n * @see `Route`\n * @ngModule RouterModule\n *\n * @publicApi\n */\n@Directive({selector: 'router-outlet', exportAs: 'outlet'})\nexport class RouterOutlet implements OnDestroy, OnInit, RouterOutletContract {\n  private activated: ComponentRef<any>|null = null;\n  private _activatedRoute: ActivatedRoute|null = null;\n  private name: string;\n\n  @Output('activate') activateEvents = new EventEmitter<any>();\n  @Output('deactivate') deactivateEvents = new EventEmitter<any>();\n  /**\n   * Emits an attached component instance when the `RouteReuseStrategy` instructs to re-attach a\n   * previously detached subtree.\n   **/\n  @Output('attach') attachEvents = new EventEmitter<unknown>();\n  /**\n   * Emits a detached component instance when the `RouteReuseStrategy` instructs to detach the\n   * subtree.\n   */\n  @Output('detach') detachEvents = new EventEmitter<unknown>();\n\n  constructor(\n      private parentContexts: ChildrenOutletContexts, private location: ViewContainerRef,\n      @Attribute('name') name: string, private changeDetector: ChangeDetectorRef,\n      private environmentInjector: EnvironmentInjector) {\n    this.name = name || PRIMARY_OUTLET;\n    parentContexts.onChildOutletCreated(this.name, this);\n  }\n\n  /** @nodoc */\n  ngOnDestroy(): void {\n    // Ensure that the registered outlet is this one before removing it on the context.\n    if (this.parentContexts.getContext(this.name)?.outlet === this) {\n      this.parentContexts.onChildOutletDestroyed(this.name);\n    }\n  }\n\n  /** @nodoc */\n  ngOnInit(): void {\n    if (!this.activated) {\n      // If the outlet was not instantiated at the time the route got activated we need to populate\n      // the outlet when it is initialized (ie inside a NgIf)\n      const context = this.parentContexts.getContext(this.name);\n      if (context && context.route) {\n        if (context.attachRef) {\n          // `attachRef` is populated when there is an existing component to mount\n          this.attach(context.attachRef, context.route);\n        } else {\n          // otherwise the component defined in the configuration is created\n          this.activateWith(context.route, context.injector);\n        }\n      }\n    }\n  }\n\n  get isActivated(): boolean {\n    return !!this.activated;\n  }\n\n  /**\n   * @returns The currently activated component instance.\n   * @throws An error if the outlet is not activated.\n   */\n  get component(): Object {\n    if (!this.activated)\n      throw new RuntimeError(\n          RuntimeErrorCode.OUTLET_NOT_ACTIVATED, NG_DEV_MODE && 'Outlet is not activated');\n    return this.activated.instance;\n  }\n\n  get activatedRoute(): ActivatedRoute {\n    if (!this.activated)\n      throw new RuntimeError(\n          RuntimeErrorCode.OUTLET_NOT_ACTIVATED, NG_DEV_MODE && 'Outlet is not activated');\n    return this._activatedRoute as ActivatedRoute;\n  }\n\n  get activatedRouteData(): Data {\n    if (this._activatedRoute) {\n      return this._activatedRoute.snapshot.data;\n    }\n    return {};\n  }\n\n  /**\n   * Called when the `RouteReuseStrategy` instructs to detach the subtree\n   */\n  detach(): ComponentRef<any> {\n    if (!this.activated)\n      throw new RuntimeError(\n          RuntimeErrorCode.OUTLET_NOT_ACTIVATED, NG_DEV_MODE && 'Outlet is not activated');\n    this.location.detach();\n    const cmp = this.activated;\n    this.activated = null;\n    this._activatedRoute = null;\n    this.detachEvents.emit(cmp.instance);\n    return cmp;\n  }\n\n  /**\n   * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n   */\n  attach(ref: ComponentRef<any>, activatedRoute: ActivatedRoute) {\n    this.activated = ref;\n    this._activatedRoute = activatedRoute;\n    this.location.insert(ref.hostView);\n    this.attachEvents.emit(ref.instance);\n  }\n\n  deactivate(): void {\n    if (this.activated) {\n      const c = this.component;\n      this.activated.destroy();\n      this.activated = null;\n      this._activatedRoute = null;\n      this.deactivateEvents.emit(c);\n    }\n  }\n\n  activateWith(\n      activatedRoute: ActivatedRoute,\n      resolverOrInjector?: ComponentFactoryResolver|EnvironmentInjector|null) {\n    if (this.isActivated) {\n      throw new RuntimeError(\n          RuntimeErrorCode.OUTLET_ALREADY_ACTIVATED,\n          NG_DEV_MODE && 'Cannot activate an already activated outlet');\n    }\n    this._activatedRoute = activatedRoute;\n    const location = this.location;\n    const snapshot = activatedRoute._futureSnapshot;\n    const component = snapshot.component!;\n    const childContexts = this.parentContexts.getOrCreateContext(this.name).children;\n    const injector = new OutletInjector(activatedRoute, childContexts, location.injector);\n\n    if (resolverOrInjector && isComponentFactoryResolver(resolverOrInjector)) {\n      const factory = resolverOrInjector.resolveComponentFactory(component);\n      this.activated = location.createComponent(factory, location.length, injector);\n    } else {\n      const environmentInjector = resolverOrInjector ?? this.environmentInjector;\n      this.activated = location.createComponent(\n          component, {index: location.length, injector, environmentInjector});\n    }\n    // Calling `markForCheck` to make sure we will run the change detection when the\n    // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.\n    this.changeDetector.markForCheck();\n    this.activateEvents.emit(this.activated.instance);\n  }\n}\n\nclass OutletInjector implements Injector {\n  constructor(\n      private route: ActivatedRoute, private childContexts: ChildrenOutletContexts,\n      private parent: Injector) {}\n\n  get(token: any, notFoundValue?: any): any {\n    if (token === ActivatedRoute) {\n      return this.route;\n    }\n\n    if (token === ChildrenOutletContexts) {\n      return this.childContexts;\n    }\n\n    return this.parent.get(token, notFoundValue);\n  }\n}\n\nfunction isComponentFactoryResolver(item: any): item is ComponentFactoryResolver {\n  return !!item.resolveComponentFactory;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Component} from '@angular/core';\n\n/**\n * This component is used internally within the router to be a placeholder when an empty\n * router-outlet is needed. For example, with a config such as:\n *\n * `{path: 'parent', outlet: 'nav', children: [...]}`\n *\n * In order to render, there needs to be a component on this config, which will default\n * to this `EmptyOutletComponent`.\n */\n@Component({template: `<router-outlet></router-outlet>`})\nexport class ɵEmptyOutletComponent {\n}\n\nexport {ɵEmptyOutletComponent as EmptyOutletComponent};\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {createEnvironmentInjector, EnvironmentInjector, Type, ɵisStandalone as isStandalone, ɵRuntimeError as RuntimeError} from '@angular/core';\n\nimport {EmptyOutletComponent} from '../components/empty_outlet';\nimport {RuntimeErrorCode} from '../errors';\nimport {Route, Routes} from '../models';\nimport {ActivatedRouteSnapshot} from '../router_state';\nimport {PRIMARY_OUTLET} from '../shared';\n\n/**\n * Creates an `EnvironmentInjector` if the `Route` has providers and one does not already exist\n * and returns the injector. Otherwise, if the `Route` does not have `providers`, returns the\n * `currentInjector`.\n *\n * @param route The route that might have providers\n * @param currentInjector The parent injector of the `Route`\n */\nexport function getOrCreateRouteInjectorIfNeeded(\n    route: Route, currentInjector: EnvironmentInjector) {\n  if (route.providers && !route._injector) {\n    route._injector =\n        createEnvironmentInjector(route.providers, currentInjector, `Route: ${route.path}`);\n  }\n  return route._injector ?? currentInjector;\n}\n\nexport function getLoadedRoutes(route: Route): Route[]|undefined {\n  return route._loadedRoutes;\n}\n\nexport function getLoadedInjector(route: Route): EnvironmentInjector|undefined {\n  return route._loadedInjector;\n}\nexport function getLoadedComponent(route: Route): Type<unknown>|undefined {\n  return route._loadedComponent;\n}\n\nexport function getProvidersInjector(route: Route): EnvironmentInjector|undefined {\n  return route._injector;\n}\n\nexport function validateConfig(\n    config: Routes, parentPath: string = '', requireStandaloneComponents = false): void {\n  // forEach doesn't iterate undefined values\n  for (let i = 0; i < config.length; i++) {\n    const route: Route = config[i];\n    const fullPath: string = getFullPath(parentPath, route);\n    validateNode(route, fullPath, requireStandaloneComponents);\n  }\n}\n\nexport function assertStandalone(fullPath: string, component: Type<unknown>|undefined) {\n  if (component && !isStandalone(component)) {\n    throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${fullPath}'. The component must be standalone.`);\n  }\n}\n\nfunction validateNode(route: Route, fullPath: string, requireStandaloneComponents: boolean): void {\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    if (!route) {\n      throw new RuntimeError(RuntimeErrorCode.INVALID_ROUTE_CONFIG, `\n      Invalid configuration of route '${fullPath}': Encountered undefined route.\n      The reason might be an extra comma.\n\n      Example:\n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    `);\n    }\n    if (Array.isArray(route)) {\n      throw new RuntimeError(\n          RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n          `Invalid configuration of route '${fullPath}': Array cannot be specified`);\n    }\n    if (!route.component && !route.loadComponent && !route.children && !route.loadChildren &&\n        (route.outlet && route.outlet !== PRIMARY_OUTLET)) {\n      throw new RuntimeError(\n          RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n          `Invalid configuration of route '${\n              fullPath}': a componentless route without children or loadChildren cannot have a named outlet set`);\n    }\n    if (route.redirectTo && route.children) {\n      throw new RuntimeError(\n          RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n          `Invalid configuration of route '${\n              fullPath}': redirectTo and children cannot be used together`);\n    }\n    if (route.redirectTo && route.loadChildren) {\n      throw new RuntimeError(\n          RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n          `Invalid configuration of route '${\n              fullPath}': redirectTo and loadChildren cannot be used together`);\n    }\n    if (route.children && route.loadChildren) {\n      throw new RuntimeError(\n          RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n          `Invalid configuration of route '${\n              fullPath}': children and loadChildren cannot be used together`);\n    }\n    if (route.redirectTo && (route.component || route.loadComponent)) {\n      throw new RuntimeError(\n          RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n          `Invalid configuration of route '${\n              fullPath}': redirectTo and component/loadComponent cannot be used together`);\n    }\n    if (route.component && route.loadComponent) {\n      throw new RuntimeError(\n          RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n          `Invalid configuration of route '${\n              fullPath}': component and loadComponent cannot be used together`);\n    }\n    if (route.redirectTo && route.canActivate) {\n      throw new RuntimeError(\n          RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n          `Invalid configuration of route '${\n              fullPath}': redirectTo and canActivate cannot be used together. Redirects happen before activation ` +\n              `so canActivate will never be executed.`);\n    }\n    if (route.path && route.matcher) {\n      throw new RuntimeError(\n          RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n          `Invalid configuration of route '${fullPath}': path and matcher cannot be used together`);\n    }\n    if (route.redirectTo === void 0 && !route.component && !route.loadComponent &&\n        !route.children && !route.loadChildren) {\n      throw new RuntimeError(\n          RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n          `Invalid configuration of route '${\n              fullPath}'. One of the following must be provided: component, loadComponent, redirectTo, children or loadChildren`);\n    }\n    if (route.path === void 0 && route.matcher === void 0) {\n      throw new RuntimeError(\n          RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n          `Invalid configuration of route '${\n              fullPath}': routes must have either a path or a matcher specified`);\n    }\n    if (typeof route.path === 'string' && route.path.charAt(0) === '/') {\n      throw new RuntimeError(\n          RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n          `Invalid configuration of route '${fullPath}': path cannot start with a slash`);\n    }\n    if (route.path === '' && route.redirectTo !== void 0 && route.pathMatch === void 0) {\n      const exp =\n          `The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`;\n      throw new RuntimeError(\n          RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n          `Invalid configuration of route '{path: \"${fullPath}\", redirectTo: \"${\n              route.redirectTo}\"}': please provide 'pathMatch'. ${exp}`);\n    }\n    if (requireStandaloneComponents) {\n      assertStandalone(fullPath, route.component);\n    }\n  }\n  if (route.children) {\n    validateConfig(route.children, fullPath, requireStandaloneComponents);\n  }\n}\n\nfunction getFullPath(parentPath: string, currentRoute: Route): string {\n  if (!currentRoute) {\n    return parentPath;\n  }\n  if (!parentPath && !currentRoute.path) {\n    return '';\n  } else if (parentPath && !currentRoute.path) {\n    return `${parentPath}/`;\n  } else if (!parentPath && currentRoute.path) {\n    return currentRoute.path;\n  } else {\n    return `${parentPath}/${currentRoute.path}`;\n  }\n}\n\n/**\n * Makes a copy of the config and adds any default required properties.\n */\nexport function standardizeConfig(r: Route): Route {\n  const children = r.children && r.children.map(standardizeConfig);\n  const c = children ? {...r, children} : {...r};\n  if ((!c.component && !c.loadComponent) && (children || c.loadChildren) &&\n      (c.outlet && c.outlet !== PRIMARY_OUTLET)) {\n    c.component = EmptyOutletComponent;\n  }\n  return c;\n}\n\n/** Returns the `route.outlet` or PRIMARY_OUTLET if none exists. */\nexport function getOutlet(route: Route): string {\n  return route.outlet || PRIMARY_OUTLET;\n}\n\n/**\n * Sorts the `routes` such that the ones with an outlet matching `outletName` come first.\n * The order of the configs is otherwise preserved.\n */\nexport function sortByMatchingOutlets(routes: Routes, outletName: string): Routes {\n  const sortedConfig = routes.filter(r => getOutlet(r) === outletName);\n  sortedConfig.push(...routes.filter(r => getOutlet(r) !== outletName));\n  return sortedConfig;\n}\n\n/**\n * Gets the first injector in the snapshot's parent tree.\n *\n * If the `Route` has a static list of providers, the returned injector will be the one created from\n * those. If it does not exist, the returned injector may come from the parents, which may be from a\n * loaded config or their static providers.\n *\n * Returns `null` if there is neither this nor any parents have a stored injector.\n *\n * Generally used for retrieving the injector to use for getting tokens for guards/resolvers and\n * also used for getting the correct injector to use for creating components.\n */\nexport function getClosestRouteInjector(snapshot: ActivatedRouteSnapshot): EnvironmentInjector|\n    null {\n  if (!snapshot) return null;\n\n  // If the current route has its own injector, which is created from the static providers on the\n  // route itself, we should use that. Otherwise, we start at the parent since we do not want to\n  // include the lazy loaded injector from this route.\n  if (snapshot.routeConfig?._injector) {\n    return snapshot.routeConfig._injector;\n  }\n\n  for (let s = snapshot.parent; s; s = s.parent) {\n    const route = s.routeConfig;\n    // Note that the order here is important. `_loadedInjector` stored on the route with\n    // `loadChildren: () => NgModule` so it applies to child routes with priority. The `_injector`\n    // is created from the static providers on that parent route, so it applies to the children as\n    // well, but only if there is no lazy loaded NgModuleRef injector.\n    if (route?._loadedInjector) return route._loadedInjector;\n    if (route?._injector) return route._injector;\n  }\n\n  return null;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ComponentFactoryResolver, EnvironmentInjector, NgModuleRef} from '@angular/core';\nimport {MonoTypeOperatorFunction} from 'rxjs';\nimport {map} from 'rxjs/operators';\n\nimport {ActivationEnd, ChildActivationEnd, Event} from '../events';\nimport {DetachedRouteHandleInternal, RouteReuseStrategy} from '../route_reuse_strategy';\nimport {NavigationTransition} from '../router';\nimport {ChildrenOutletContexts} from '../router_outlet_context';\nimport {ActivatedRoute, advanceActivatedRoute, RouterState} from '../router_state';\nimport {forEach} from '../utils/collection';\nimport {getClosestRouteInjector} from '../utils/config';\nimport {nodeChildrenAsMap, TreeNode} from '../utils/tree';\n\nexport const activateRoutes =\n    (rootContexts: ChildrenOutletContexts, routeReuseStrategy: RouteReuseStrategy,\n     forwardEvent: (evt: Event) => void): MonoTypeOperatorFunction<NavigationTransition> =>\n        map(t => {\n          new ActivateRoutes(\n              routeReuseStrategy, t.targetRouterState!, t.currentRouterState, forwardEvent)\n              .activate(rootContexts);\n          return t;\n        });\n\nexport class ActivateRoutes {\n  constructor(\n      private routeReuseStrategy: RouteReuseStrategy, private futureState: RouterState,\n      private currState: RouterState, private forwardEvent: (evt: Event) => void) {}\n\n  activate(parentContexts: ChildrenOutletContexts): void {\n    const futureRoot = this.futureState._root;\n    const currRoot = this.currState ? this.currState._root : null;\n\n    this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);\n    advanceActivatedRoute(this.futureState.root);\n    this.activateChildRoutes(futureRoot, currRoot, parentContexts);\n  }\n\n  // De-activate the child route that are not re-used for the future state\n  private deactivateChildRoutes(\n      futureNode: TreeNode<ActivatedRoute>, currNode: TreeNode<ActivatedRoute>|null,\n      contexts: ChildrenOutletContexts): void {\n    const children: {[outletName: string]: TreeNode<ActivatedRoute>} = nodeChildrenAsMap(currNode);\n\n    // Recurse on the routes active in the future state to de-activate deeper children\n    futureNode.children.forEach(futureChild => {\n      const childOutletName = futureChild.value.outlet;\n      this.deactivateRoutes(futureChild, children[childOutletName], contexts);\n      delete children[childOutletName];\n    });\n\n    // De-activate the routes that will not be re-used\n    forEach(children, (v: TreeNode<ActivatedRoute>, childName: string) => {\n      this.deactivateRouteAndItsChildren(v, contexts);\n    });\n  }\n\n  private deactivateRoutes(\n      futureNode: TreeNode<ActivatedRoute>, currNode: TreeNode<ActivatedRoute>,\n      parentContext: ChildrenOutletContexts): void {\n    const future = futureNode.value;\n    const curr = currNode ? currNode.value : null;\n\n    if (future === curr) {\n      // Reusing the node, check to see if the children need to be de-activated\n      if (future.component) {\n        // If we have a normal route, we need to go through an outlet.\n        const context = parentContext.getContext(future.outlet);\n        if (context) {\n          this.deactivateChildRoutes(futureNode, currNode, context.children);\n        }\n      } else {\n        // if we have a componentless route, we recurse but keep the same outlet map.\n        this.deactivateChildRoutes(futureNode, currNode, parentContext);\n      }\n    } else {\n      if (curr) {\n        // Deactivate the current route which will not be re-used\n        this.deactivateRouteAndItsChildren(currNode, parentContext);\n      }\n    }\n  }\n\n  private deactivateRouteAndItsChildren(\n      route: TreeNode<ActivatedRoute>, parentContexts: ChildrenOutletContexts): void {\n    // If there is no component, the Route is never attached to an outlet (because there is no\n    // component to attach).\n    if (route.value.component && this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {\n      this.detachAndStoreRouteSubtree(route, parentContexts);\n    } else {\n      this.deactivateRouteAndOutlet(route, parentContexts);\n    }\n  }\n\n  private detachAndStoreRouteSubtree(\n      route: TreeNode<ActivatedRoute>, parentContexts: ChildrenOutletContexts): void {\n    const context = parentContexts.getContext(route.value.outlet);\n    const contexts = context && route.value.component ? context.children : parentContexts;\n    const children: {[outletName: string]: TreeNode<ActivatedRoute>} = nodeChildrenAsMap(route);\n\n    for (const childOutlet of Object.keys(children)) {\n      this.deactivateRouteAndItsChildren(children[childOutlet], contexts);\n    }\n\n    if (context && context.outlet) {\n      const componentRef = context.outlet.detach();\n      const contexts = context.children.onOutletDeactivated();\n      this.routeReuseStrategy.store(route.value.snapshot, {componentRef, route, contexts});\n    }\n  }\n\n  private deactivateRouteAndOutlet(\n      route: TreeNode<ActivatedRoute>, parentContexts: ChildrenOutletContexts): void {\n    const context = parentContexts.getContext(route.value.outlet);\n    // The context could be `null` if we are on a componentless route but there may still be\n    // children that need deactivating.\n    const contexts = context && route.value.component ? context.children : parentContexts;\n    const children: {[outletName: string]: TreeNode<ActivatedRoute>} = nodeChildrenAsMap(route);\n\n    for (const childOutlet of Object.keys(children)) {\n      this.deactivateRouteAndItsChildren(children[childOutlet], contexts);\n    }\n\n    if (context && context.outlet) {\n      // Destroy the component\n      context.outlet.deactivate();\n      // Destroy the contexts for all the outlets that were in the component\n      context.children.onOutletDeactivated();\n      // Clear the information about the attached component on the context but keep the reference to\n      // the outlet.\n      context.attachRef = null;\n      context.resolver = null;\n      context.route = null;\n    }\n  }\n\n  private activateChildRoutes(\n      futureNode: TreeNode<ActivatedRoute>, currNode: TreeNode<ActivatedRoute>|null,\n      contexts: ChildrenOutletContexts): void {\n    const children: {[outlet: string]: TreeNode<ActivatedRoute>} = nodeChildrenAsMap(currNode);\n    futureNode.children.forEach(c => {\n      this.activateRoutes(c, children[c.value.outlet], contexts);\n      this.forwardEvent(new ActivationEnd(c.value.snapshot));\n    });\n    if (futureNode.children.length) {\n      this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));\n    }\n  }\n\n  private activateRoutes(\n      futureNode: TreeNode<ActivatedRoute>, currNode: TreeNode<ActivatedRoute>,\n      parentContexts: ChildrenOutletContexts): void {\n    const future = futureNode.value;\n    const curr = currNode ? currNode.value : null;\n\n    advanceActivatedRoute(future);\n\n    // reusing the node\n    if (future === curr) {\n      if (future.component) {\n        // If we have a normal route, we need to go through an outlet.\n        const context = parentContexts.getOrCreateContext(future.outlet);\n        this.activateChildRoutes(futureNode, currNode, context.children);\n      } else {\n        // if we have a componentless route, we recurse but keep the same outlet map.\n        this.activateChildRoutes(futureNode, currNode, parentContexts);\n      }\n    } else {\n      if (future.component) {\n        // if we have a normal route, we need to place the component into the outlet and recurse.\n        const context = parentContexts.getOrCreateContext(future.outlet);\n\n        if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {\n          const stored =\n              (<DetachedRouteHandleInternal>this.routeReuseStrategy.retrieve(future.snapshot));\n          this.routeReuseStrategy.store(future.snapshot, null);\n          context.children.onOutletReAttached(stored.contexts);\n          context.attachRef = stored.componentRef;\n          context.route = stored.route.value;\n          if (context.outlet) {\n            // Attach right away when the outlet has already been instantiated\n            // Otherwise attach from `RouterOutlet.ngOnInit` when it is instantiated\n            context.outlet.attach(stored.componentRef, stored.route.value);\n          }\n\n          advanceActivatedRoute(stored.route.value);\n          this.activateChildRoutes(futureNode, null, context.children);\n        } else {\n          const injector = getClosestRouteInjector(future.snapshot);\n          const cmpFactoryResolver = injector?.get(ComponentFactoryResolver) ?? null;\n          context.attachRef = null;\n          context.route = future;\n          context.resolver = cmpFactoryResolver;\n          context.injector = injector;\n          if (context.outlet) {\n            // Activate the outlet when it has already been instantiated\n            // Otherwise it will get activated from its `ngOnInit` when instantiated\n            context.outlet.activateWith(future, context.injector);\n          }\n\n          this.activateChildRoutes(futureNode, null, context.children);\n        }\n      } else {\n        // if we have a componentless route, we recurse but keep the same outlet map.\n        this.activateChildRoutes(futureNode, null, parentContexts);\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '@angular/core';\n\nimport {RunGuardsAndResolvers} from '../models';\nimport {ChildrenOutletContexts, OutletContext} from '../router_outlet_context';\nimport {ActivatedRouteSnapshot, equalParamsAndUrlSegments, RouterStateSnapshot} from '../router_state';\nimport {equalPath} from '../url_tree';\nimport {forEach, shallowEqual} from '../utils/collection';\nimport {getClosestRouteInjector} from '../utils/config';\nimport {nodeChildrenAsMap, TreeNode} from '../utils/tree';\n\nexport class CanActivate {\n  readonly route: ActivatedRouteSnapshot;\n  constructor(public path: ActivatedRouteSnapshot[]) {\n    this.route = this.path[this.path.length - 1];\n  }\n}\n\nexport class CanDeactivate {\n  constructor(public component: Object|null, public route: ActivatedRouteSnapshot) {}\n}\n\nexport declare type Checks = {\n  canDeactivateChecks: CanDeactivate[],\n  canActivateChecks: CanActivate[],\n};\n\nexport function getAllRouteGuards(\n    future: RouterStateSnapshot, curr: RouterStateSnapshot,\n    parentContexts: ChildrenOutletContexts) {\n  const futureRoot = future._root;\n  const currRoot = curr ? curr._root : null;\n\n  return getChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);\n}\n\nexport function getCanActivateChild(p: ActivatedRouteSnapshot):\n    {node: ActivatedRouteSnapshot, guards: any[]}|null {\n  const canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;\n  if (!canActivateChild || canActivateChild.length === 0) return null;\n  return {node: p, guards: canActivateChild};\n}\n\nexport function getToken(\n    token: any, snapshot: ActivatedRouteSnapshot, fallbackInjector: Injector): any {\n  const routeInjector = getClosestRouteInjector(snapshot);\n  const injector = routeInjector ?? fallbackInjector;\n  return injector.get(token);\n}\n\nfunction getChildRouteGuards(\n    futureNode: TreeNode<ActivatedRouteSnapshot>, currNode: TreeNode<ActivatedRouteSnapshot>|null,\n    contexts: ChildrenOutletContexts|null, futurePath: ActivatedRouteSnapshot[], checks: Checks = {\n      canDeactivateChecks: [],\n      canActivateChecks: []\n    }): Checks {\n  const prevChildren = nodeChildrenAsMap(currNode);\n\n  // Process the children of the future route\n  futureNode.children.forEach(c => {\n    getRouteGuards(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]), checks);\n    delete prevChildren[c.value.outlet];\n  });\n\n  // Process any children left from the current route (not active for the future route)\n  forEach(\n      prevChildren,\n      (v: TreeNode<ActivatedRouteSnapshot>, k: string) =>\n          deactivateRouteAndItsChildren(v, contexts!.getContext(k), checks));\n\n  return checks;\n}\n\nfunction getRouteGuards(\n    futureNode: TreeNode<ActivatedRouteSnapshot>, currNode: TreeNode<ActivatedRouteSnapshot>,\n    parentContexts: ChildrenOutletContexts|null, futurePath: ActivatedRouteSnapshot[],\n    checks: Checks = {\n      canDeactivateChecks: [],\n      canActivateChecks: []\n    }): Checks {\n  const future = futureNode.value;\n  const curr = currNode ? currNode.value : null;\n  const context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;\n\n  // reusing the node\n  if (curr && future.routeConfig === curr.routeConfig) {\n    const shouldRun =\n        shouldRunGuardsAndResolvers(curr, future, future.routeConfig!.runGuardsAndResolvers);\n    if (shouldRun) {\n      checks.canActivateChecks.push(new CanActivate(futurePath));\n    } else {\n      // we need to set the data\n      future.data = curr.data;\n      future._resolvedData = curr._resolvedData;\n    }\n\n    // If we have a component, we need to go through an outlet.\n    if (future.component) {\n      getChildRouteGuards(\n          futureNode, currNode, context ? context.children : null, futurePath, checks);\n\n      // if we have a componentless route, we recurse but keep the same outlet map.\n    } else {\n      getChildRouteGuards(futureNode, currNode, parentContexts, futurePath, checks);\n    }\n\n    if (shouldRun && context && context.outlet && context.outlet.isActivated) {\n      checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, curr));\n    }\n  } else {\n    if (curr) {\n      deactivateRouteAndItsChildren(currNode, context, checks);\n    }\n\n    checks.canActivateChecks.push(new CanActivate(futurePath));\n    // If we have a component, we need to go through an outlet.\n    if (future.component) {\n      getChildRouteGuards(futureNode, null, context ? context.children : null, futurePath, checks);\n\n      // if we have a componentless route, we recurse but keep the same outlet map.\n    } else {\n      getChildRouteGuards(futureNode, null, parentContexts, futurePath, checks);\n    }\n  }\n\n  return checks;\n}\n\nfunction shouldRunGuardsAndResolvers(\n    curr: ActivatedRouteSnapshot, future: ActivatedRouteSnapshot,\n    mode: RunGuardsAndResolvers|undefined): boolean {\n  if (typeof mode === 'function') {\n    return mode(curr, future);\n  }\n  switch (mode) {\n    case 'pathParamsChange':\n      return !equalPath(curr.url, future.url);\n\n    case 'pathParamsOrQueryParamsChange':\n      return !equalPath(curr.url, future.url) ||\n          !shallowEqual(curr.queryParams, future.queryParams);\n\n    case 'always':\n      return true;\n\n    case 'paramsOrQueryParamsChange':\n      return !equalParamsAndUrlSegments(curr, future) ||\n          !shallowEqual(curr.queryParams, future.queryParams);\n\n    case 'paramsChange':\n    default:\n      return !equalParamsAndUrlSegments(curr, future);\n  }\n}\n\nfunction deactivateRouteAndItsChildren(\n    route: TreeNode<ActivatedRouteSnapshot>, context: OutletContext|null, checks: Checks): void {\n  const children = nodeChildrenAsMap(route);\n  const r = route.value;\n\n  forEach(children, (node: TreeNode<ActivatedRouteSnapshot>, childName: string) => {\n    if (!r.component) {\n      deactivateRouteAndItsChildren(node, context, checks);\n    } else if (context) {\n      deactivateRouteAndItsChildren(node, context.children.getContext(childName), checks);\n    } else {\n      deactivateRouteAndItsChildren(node, null, checks);\n    }\n  });\n\n  if (!r.component) {\n    checks.canDeactivateChecks.push(new CanDeactivate(null, r));\n  } else if (context && context.outlet && context.outlet.isActivated) {\n    checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));\n  } else {\n    checks.canDeactivateChecks.push(new CanDeactivate(null, r));\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CanActivate, CanActivateChild, CanDeactivate, CanLoad, CanMatch} from '../models';\nimport {NAVIGATION_CANCELING_ERROR, NavigationCancelingError, RedirectingNavigationCancelingError} from '../navigation_canceling_error';\nimport {isUrlTree} from '../url_tree';\n\n/**\n * Simple function check, but generic so type inference will flow. Example:\n *\n * function product(a: number, b: number) {\n *   return a * b;\n * }\n *\n * if (isFunction<product>(fn)) {\n *   return fn(1, 2);\n * } else {\n *   throw \"Must provide the `product` function\";\n * }\n */\nexport function isFunction<T>(v: any): v is T {\n  return typeof v === 'function';\n}\n\nexport function isBoolean(v: any): v is boolean {\n  return typeof v === 'boolean';\n}\n\nexport function isCanLoad(guard: any): guard is CanLoad {\n  return guard && isFunction<CanLoad>(guard.canLoad);\n}\n\nexport function isCanActivate(guard: any): guard is CanActivate {\n  return guard && isFunction<CanActivate>(guard.canActivate);\n}\n\nexport function isCanActivateChild(guard: any): guard is CanActivateChild {\n  return guard && isFunction<CanActivateChild>(guard.canActivateChild);\n}\n\nexport function isCanDeactivate<T>(guard: any): guard is CanDeactivate<T> {\n  return guard && isFunction<CanDeactivate<T>>(guard.canDeactivate);\n}\nexport function isCanMatch(guard: any): guard is CanMatch {\n  return guard && isFunction<CanMatch>(guard.canMatch);\n}\n\nexport function isRedirectingNavigationCancelingError(\n    error: unknown|\n    RedirectingNavigationCancelingError): error is RedirectingNavigationCancelingError {\n  return isNavigationCancelingError(error) && isUrlTree((error as any).url);\n}\n\nexport function isNavigationCancelingError(error: unknown): error is NavigationCancelingError {\n  return error && (error as any)[NAVIGATION_CANCELING_ERROR];\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {combineLatest, Observable, OperatorFunction} from 'rxjs';\nimport {filter, map, scan, startWith, switchMap, take} from 'rxjs/operators';\n\nimport {isUrlTree, UrlTree} from '../url_tree';\n\nconst INITIAL_VALUE = Symbol('INITIAL_VALUE');\ndeclare type INTERIM_VALUES = typeof INITIAL_VALUE | boolean | UrlTree;\n\nexport function prioritizedGuardValue():\n    OperatorFunction<Observable<boolean|UrlTree>[], boolean|UrlTree> {\n  return switchMap(obs => {\n    return combineLatest(obs.map(o => o.pipe(take(1), startWith(INITIAL_VALUE as INTERIM_VALUES))))\n        .pipe(\n            map((results: INTERIM_VALUES[]) => {\n              for (const result of results) {\n                if (result === true) {\n                  // If result is true, check the next one\n                  continue;\n                } else if (result === INITIAL_VALUE) {\n                  // If guard has not finished, we need to stop processing.\n                  return INITIAL_VALUE;\n                } else if (result === false || result instanceof UrlTree) {\n                  // Result finished and was not true. Return the result.\n                  // Note that we only allow false/UrlTree. Other values are considered invalid and\n                  // ignored.\n                  return result;\n                }\n              }\n              // Everything resolved to true. Return true.\n              return true;\n            }),\n            filter((item): item is boolean|UrlTree => item !== INITIAL_VALUE),\n            take(1),\n        );\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {EnvironmentInjector, Injector} from '@angular/core';\nimport {concat, defer, from, MonoTypeOperatorFunction, Observable, of, OperatorFunction, pipe} from 'rxjs';\nimport {concatMap, first, map, mergeMap, tap} from 'rxjs/operators';\n\nimport {ActivationStart, ChildActivationStart, Event} from '../events';\nimport {CanLoad, CanLoadFn, CanMatch, CanMatchFn, Route} from '../models';\nimport {redirectingNavigationError} from '../navigation_canceling_error';\nimport {NavigationTransition} from '../router';\nimport {ActivatedRouteSnapshot, RouterStateSnapshot} from '../router_state';\nimport {isUrlTree, UrlSegment, UrlSerializer, UrlTree} from '../url_tree';\nimport {wrapIntoObservable} from '../utils/collection';\nimport {CanActivate, CanDeactivate, getCanActivateChild, getToken} from '../utils/preactivation';\nimport {isBoolean, isCanActivate, isCanActivateChild, isCanDeactivate, isCanLoad, isCanMatch} from '../utils/type_guards';\n\nimport {prioritizedGuardValue} from './prioritized_guard_value';\n\nexport function checkGuards(moduleInjector: Injector, forwardEvent?: (evt: Event) => void):\n    MonoTypeOperatorFunction<NavigationTransition> {\n  return mergeMap(t => {\n    const {targetSnapshot, currentSnapshot, guards: {canActivateChecks, canDeactivateChecks}} = t;\n    if (canDeactivateChecks.length === 0 && canActivateChecks.length === 0) {\n      return of({...t, guardsResult: true});\n    }\n\n    return runCanDeactivateChecks(\n               canDeactivateChecks, targetSnapshot!, currentSnapshot, moduleInjector)\n        .pipe(\n            mergeMap(canDeactivate => {\n              return canDeactivate && isBoolean(canDeactivate) ?\n                  runCanActivateChecks(\n                      targetSnapshot!, canActivateChecks, moduleInjector, forwardEvent) :\n                  of(canDeactivate);\n            }),\n            map(guardsResult => ({...t, guardsResult})));\n  });\n}\n\nfunction runCanDeactivateChecks(\n    checks: CanDeactivate[], futureRSS: RouterStateSnapshot, currRSS: RouterStateSnapshot,\n    moduleInjector: Injector) {\n  return from(checks).pipe(\n      mergeMap(\n          check =>\n              runCanDeactivate(check.component, check.route, currRSS, futureRSS, moduleInjector)),\n      first(result => {\n        return result !== true;\n      }, true as boolean | UrlTree));\n}\n\nfunction runCanActivateChecks(\n    futureSnapshot: RouterStateSnapshot, checks: CanActivate[], moduleInjector: Injector,\n    forwardEvent?: (evt: Event) => void) {\n  return from(checks).pipe(\n      concatMap((check: CanActivate) => {\n        return concat(\n            fireChildActivationStart(check.route.parent, forwardEvent),\n            fireActivationStart(check.route, forwardEvent),\n            runCanActivateChild(futureSnapshot, check.path, moduleInjector),\n            runCanActivate(futureSnapshot, check.route, moduleInjector));\n      }),\n      first(result => {\n        return result !== true;\n      }, true as boolean | UrlTree));\n}\n\n/**\n * This should fire off `ActivationStart` events for each route being activated at this\n * level.\n * In other words, if you're activating `a` and `b` below, `path` will contain the\n * `ActivatedRouteSnapshot`s for both and we will fire `ActivationStart` for both. Always\n * return\n * `true` so checks continue to run.\n */\nfunction fireActivationStart(\n    snapshot: ActivatedRouteSnapshot|null,\n    forwardEvent?: (evt: Event) => void): Observable<boolean> {\n  if (snapshot !== null && forwardEvent) {\n    forwardEvent(new ActivationStart(snapshot));\n  }\n  return of(true);\n}\n\n/**\n * This should fire off `ChildActivationStart` events for each route being activated at this\n * level.\n * In other words, if you're activating `a` and `b` below, `path` will contain the\n * `ActivatedRouteSnapshot`s for both and we will fire `ChildActivationStart` for both. Always\n * return\n * `true` so checks continue to run.\n */\nfunction fireChildActivationStart(\n    snapshot: ActivatedRouteSnapshot|null,\n    forwardEvent?: (evt: Event) => void): Observable<boolean> {\n  if (snapshot !== null && forwardEvent) {\n    forwardEvent(new ChildActivationStart(snapshot));\n  }\n  return of(true);\n}\n\nfunction runCanActivate(\n    futureRSS: RouterStateSnapshot, futureARS: ActivatedRouteSnapshot,\n    moduleInjector: Injector): Observable<boolean|UrlTree> {\n  const canActivate = futureARS.routeConfig ? futureARS.routeConfig.canActivate : null;\n  if (!canActivate || canActivate.length === 0) return of(true);\n\n  const canActivateObservables = canActivate.map((c: any) => {\n    return defer(() => {\n      const guard = getToken(c, futureARS, moduleInjector);\n      const guardVal = isCanActivate(guard) ? guard.canActivate(futureARS, futureRSS) :\n                                              guard(futureARS, futureRSS);\n      return wrapIntoObservable(guardVal).pipe(first());\n    });\n  });\n  return of(canActivateObservables).pipe(prioritizedGuardValue());\n}\n\nfunction runCanActivateChild(\n    futureRSS: RouterStateSnapshot, path: ActivatedRouteSnapshot[],\n    moduleInjector: Injector): Observable<boolean|UrlTree> {\n  const futureARS = path[path.length - 1];\n\n  const canActivateChildGuards = path.slice(0, path.length - 1)\n                                     .reverse()\n                                     .map(p => getCanActivateChild(p))\n                                     .filter(_ => _ !== null);\n\n  const canActivateChildGuardsMapped = canActivateChildGuards.map((d: any) => {\n    return defer(() => {\n      const guardsMapped = d.guards.map((c: any) => {\n        const guard = getToken(c, d.node, moduleInjector);\n        const guardVal = isCanActivateChild(guard) ? guard.canActivateChild(futureARS, futureRSS) :\n                                                     guard(futureARS, futureRSS);\n        return wrapIntoObservable(guardVal).pipe(first());\n      });\n      return of(guardsMapped).pipe(prioritizedGuardValue());\n    });\n  });\n  return of(canActivateChildGuardsMapped).pipe(prioritizedGuardValue());\n}\n\nfunction runCanDeactivate(\n    component: Object|null, currARS: ActivatedRouteSnapshot, currRSS: RouterStateSnapshot,\n    futureRSS: RouterStateSnapshot, moduleInjector: Injector): Observable<boolean|UrlTree> {\n  const canDeactivate = currARS && currARS.routeConfig ? currARS.routeConfig.canDeactivate : null;\n  if (!canDeactivate || canDeactivate.length === 0) return of(true);\n  const canDeactivateObservables = canDeactivate.map((c: any) => {\n    const guard = getToken(c, currARS, moduleInjector);\n    const guardVal = isCanDeactivate(guard) ?\n        guard.canDeactivate(component!, currARS, currRSS, futureRSS) :\n        guard(component, currARS, currRSS, futureRSS);\n    return wrapIntoObservable(guardVal).pipe(first());\n  });\n  return of(canDeactivateObservables).pipe(prioritizedGuardValue());\n}\n\nexport function runCanLoadGuards(\n    injector: EnvironmentInjector, route: Route, segments: UrlSegment[],\n    urlSerializer: UrlSerializer): Observable<boolean> {\n  const canLoad = route.canLoad;\n  if (canLoad === undefined || canLoad.length === 0) {\n    return of(true);\n  }\n\n  const canLoadObservables = canLoad.map((injectionToken: any) => {\n    const guard = injector.get<CanLoad|CanLoadFn>(injectionToken);\n    const guardVal = isCanLoad(guard) ? guard.canLoad(route, segments) : guard(route, segments);\n    return wrapIntoObservable(guardVal);\n  });\n\n  return of(canLoadObservables)\n      .pipe(\n          prioritizedGuardValue(),\n          redirectIfUrlTree(urlSerializer),\n      );\n}\n\nfunction redirectIfUrlTree(urlSerializer: UrlSerializer):\n    OperatorFunction<UrlTree|boolean, boolean> {\n  return pipe(\n      tap((result: UrlTree|boolean) => {\n        if (!isUrlTree(result)) return;\n\n        throw redirectingNavigationError(urlSerializer, result);\n      }),\n      map(result => result === true),\n  );\n}\n\nexport function runCanMatchGuards(\n    injector: Injector, route: Route, segments: UrlSegment[],\n    urlSerializer: UrlSerializer): Observable<boolean> {\n  const canMatch = route.canMatch;\n  if (!canMatch || canMatch.length === 0) return of(true);\n\n  const canMatchObservables = canMatch.map(injectionToken => {\n    const guard = injector.get<CanMatch|CanMatchFn>(injectionToken);\n    const guardVal = isCanMatch(guard) ? guard.canMatch(route, segments) : guard(route, segments);\n    return wrapIntoObservable(guardVal);\n  });\n\n  return of(canMatchObservables)\n      .pipe(\n          prioritizedGuardValue(),\n          redirectIfUrlTree(urlSerializer),\n      );\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {EnvironmentInjector, Injector} from '@angular/core';\nimport {Observable, of} from 'rxjs';\nimport {map} from 'rxjs/operators';\n\nimport {Route} from '../models';\nimport {runCanMatchGuards} from '../operators/check_guards';\nimport {defaultUrlMatcher, PRIMARY_OUTLET} from '../shared';\nimport {UrlSegment, UrlSegmentGroup, UrlSerializer} from '../url_tree';\n\nimport {forEach} from './collection';\nimport {getOrCreateRouteInjectorIfNeeded, getOutlet} from './config';\n\nexport interface MatchResult {\n  matched: boolean;\n  consumedSegments: UrlSegment[];\n  remainingSegments: UrlSegment[];\n  parameters: {[k: string]: string};\n  positionalParamSegments: {[k: string]: UrlSegment};\n}\n\nconst noMatch: MatchResult = {\n  matched: false,\n  consumedSegments: [],\n  remainingSegments: [],\n  parameters: {},\n  positionalParamSegments: {}\n};\n\nexport function matchWithChecks(\n    segmentGroup: UrlSegmentGroup, route: Route, segments: UrlSegment[],\n    injector: EnvironmentInjector, urlSerializer: UrlSerializer): Observable<MatchResult> {\n  const result = match(segmentGroup, route, segments);\n  if (!result.matched) {\n    return of(result);\n  }\n\n  // Only create the Route's `EnvironmentInjector` if it matches the attempted\n  // navigation\n  injector = getOrCreateRouteInjectorIfNeeded(route, injector);\n  return runCanMatchGuards(injector, route, segments, urlSerializer)\n      .pipe(\n          map((v) => v === true ? result : {...noMatch}),\n      );\n}\n\nexport function match(\n    segmentGroup: UrlSegmentGroup, route: Route, segments: UrlSegment[]): MatchResult {\n  if (route.path === '') {\n    if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {\n      return {...noMatch};\n    }\n\n    return {\n      matched: true,\n      consumedSegments: [],\n      remainingSegments: segments,\n      parameters: {},\n      positionalParamSegments: {}\n    };\n  }\n\n  const matcher = route.matcher || defaultUrlMatcher;\n  const res = matcher(segments, segmentGroup, route);\n  if (!res) return {...noMatch};\n\n  const posParams: {[n: string]: string} = {};\n  forEach(res.posParams!, (v: UrlSegment, k: string) => {\n    posParams[k] = v.path;\n  });\n  const parameters = res.consumed.length > 0 ?\n      {...posParams, ...res.consumed[res.consumed.length - 1].parameters} :\n      posParams;\n\n  return {\n    matched: true,\n    consumedSegments: res.consumed,\n    remainingSegments: segments.slice(res.consumed.length),\n    // TODO(atscott): investigate combining parameters and positionalParamSegments\n    parameters,\n    positionalParamSegments: res.posParams ?? {}\n  };\n}\n\nexport function split(\n    segmentGroup: UrlSegmentGroup, consumedSegments: UrlSegment[], slicedSegments: UrlSegment[],\n    config: Route[], relativeLinkResolution: 'legacy'|'corrected' = 'corrected') {\n  if (slicedSegments.length > 0 &&\n      containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n    const s = new UrlSegmentGroup(\n        consumedSegments,\n        createChildrenForEmptyPaths(\n            segmentGroup, consumedSegments, config,\n            new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n    s._sourceSegment = segmentGroup;\n    s._segmentIndexShift = consumedSegments.length;\n    return {segmentGroup: s, slicedSegments: []};\n  }\n\n  if (slicedSegments.length === 0 &&\n      containsEmptyPathMatches(segmentGroup, slicedSegments, config)) {\n    const s = new UrlSegmentGroup(\n        segmentGroup.segments,\n        addEmptyPathsToChildrenIfNeeded(\n            segmentGroup, consumedSegments, slicedSegments, config, segmentGroup.children,\n            relativeLinkResolution));\n    s._sourceSegment = segmentGroup;\n    s._segmentIndexShift = consumedSegments.length;\n    return {segmentGroup: s, slicedSegments};\n  }\n\n  const s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);\n  s._sourceSegment = segmentGroup;\n  s._segmentIndexShift = consumedSegments.length;\n  return {segmentGroup: s, slicedSegments};\n}\n\nfunction addEmptyPathsToChildrenIfNeeded(\n    segmentGroup: UrlSegmentGroup, consumedSegments: UrlSegment[], slicedSegments: UrlSegment[],\n    routes: Route[], children: {[name: string]: UrlSegmentGroup},\n    relativeLinkResolution: 'legacy'|'corrected'): {[name: string]: UrlSegmentGroup} {\n  const res: {[name: string]: UrlSegmentGroup} = {};\n  for (const r of routes) {\n    if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {\n      const s = new UrlSegmentGroup([], {});\n      s._sourceSegment = segmentGroup;\n      if (relativeLinkResolution === 'legacy') {\n        s._segmentIndexShift = segmentGroup.segments.length;\n        if (typeof ngDevMode === 'undefined' || !!ngDevMode) {\n          s._segmentIndexShiftCorrected = consumedSegments.length;\n        }\n      } else {\n        s._segmentIndexShift = consumedSegments.length;\n      }\n      res[getOutlet(r)] = s;\n    }\n  }\n  return {...children, ...res};\n}\n\nfunction createChildrenForEmptyPaths(\n    segmentGroup: UrlSegmentGroup, consumedSegments: UrlSegment[], routes: Route[],\n    primarySegment: UrlSegmentGroup): {[name: string]: UrlSegmentGroup} {\n  const res: {[name: string]: UrlSegmentGroup} = {};\n  res[PRIMARY_OUTLET] = primarySegment;\n  primarySegment._sourceSegment = segmentGroup;\n  primarySegment._segmentIndexShift = consumedSegments.length;\n\n  for (const r of routes) {\n    if (r.path === '' && getOutlet(r) !== PRIMARY_OUTLET) {\n      const s = new UrlSegmentGroup([], {});\n      s._sourceSegment = segmentGroup;\n      s._segmentIndexShift = consumedSegments.length;\n      res[getOutlet(r)] = s;\n    }\n  }\n  return res;\n}\n\nfunction containsEmptyPathMatchesWithNamedOutlets(\n    segmentGroup: UrlSegmentGroup, slicedSegments: UrlSegment[], routes: Route[]): boolean {\n  return routes.some(\n      r => emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet(r) !== PRIMARY_OUTLET);\n}\n\nfunction containsEmptyPathMatches(\n    segmentGroup: UrlSegmentGroup, slicedSegments: UrlSegment[], routes: Route[]): boolean {\n  return routes.some(r => emptyPathMatch(segmentGroup, slicedSegments, r));\n}\n\nfunction emptyPathMatch(\n    segmentGroup: UrlSegmentGroup, slicedSegments: UrlSegment[], r: Route): boolean {\n  if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full') {\n    return false;\n  }\n\n  return r.path === '';\n}\n\n/**\n * Determines if `route` is a path match for the `rawSegment`, `segments`, and `outlet` without\n * verifying that its children are a full match for the remainder of the `rawSegment` children as\n * well.\n */\nexport function isImmediateMatch(\n    route: Route, rawSegment: UrlSegmentGroup, segments: UrlSegment[], outlet: string): boolean {\n  // We allow matches to empty paths when the outlets differ so we can match a url like `/(b:b)` to\n  // a config like\n  // * `{path: '', children: [{path: 'b', outlet: 'b'}]}`\n  // or even\n  // * `{path: '', outlet: 'a', children: [{path: 'b', outlet: 'b'}]`\n  //\n  // The exception here is when the segment outlet is for the primary outlet. This would\n  // result in a match inside the named outlet because all children there are written as primary\n  // outlets. So we need to prevent child named outlet matches in a url like `/b` in a config like\n  // * `{path: '', outlet: 'x' children: [{path: 'b'}]}`\n  // This should only match if the url is `/(x:b)`.\n  if (getOutlet(route) !== outlet &&\n      (outlet === PRIMARY_OUTLET || !emptyPathMatch(rawSegment, segments, route))) {\n    return false;\n  }\n  if (route.path === '**') {\n    return true;\n  }\n  return match(rawSegment, route, segments).matched;\n}\n\nexport function noLeftoversInUrl(\n    segmentGroup: UrlSegmentGroup, segments: UrlSegment[], outlet: string): boolean {\n  return segments.length === 0 && !segmentGroup.children[outlet];\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {EnvironmentInjector, ɵRuntimeError as RuntimeError} from '@angular/core';\nimport {EmptyError, from, Observable, of, throwError} from 'rxjs';\nimport {catchError, concatMap, first, last, map, mergeMap, scan, switchMap, tap} from 'rxjs/operators';\n\nimport {RuntimeErrorCode} from './errors';\nimport {NavigationCancellationCode} from './events';\nimport {LoadedRouterConfig, Route, Routes} from './models';\nimport {navigationCancelingError} from './navigation_canceling_error';\nimport {runCanLoadGuards} from './operators/check_guards';\nimport {RouterConfigLoader} from './router_config_loader';\nimport {Params, PRIMARY_OUTLET} from './shared';\nimport {createRoot, squashSegmentGroup, UrlSegment, UrlSegmentGroup, UrlSerializer, UrlTree} from './url_tree';\nimport {forEach} from './utils/collection';\nimport {getOrCreateRouteInjectorIfNeeded, getOutlet, sortByMatchingOutlets} from './utils/config';\nimport {isImmediateMatch, match, matchWithChecks, noLeftoversInUrl, split} from './utils/config_matching';\n\nconst NG_DEV_MODE = typeof ngDevMode === 'undefined' || ngDevMode;\n\nclass NoMatch {\n  public segmentGroup: UrlSegmentGroup|null;\n\n  constructor(segmentGroup?: UrlSegmentGroup) {\n    this.segmentGroup = segmentGroup || null;\n  }\n}\n\nclass AbsoluteRedirect {\n  constructor(public urlTree: UrlTree) {}\n}\n\nfunction noMatch(segmentGroup: UrlSegmentGroup): Observable<UrlSegmentGroup> {\n  return throwError(new NoMatch(segmentGroup));\n}\n\nfunction absoluteRedirect(newTree: UrlTree): Observable<any> {\n  return throwError(new AbsoluteRedirect(newTree));\n}\n\nfunction namedOutletsRedirect(redirectTo: string): Observable<any> {\n  return throwError(new RuntimeError(\n      RuntimeErrorCode.NAMED_OUTLET_REDIRECT,\n      NG_DEV_MODE &&\n          `Only absolute redirects can have named outlets. redirectTo: '${redirectTo}'`));\n}\n\nfunction canLoadFails(route: Route): Observable<LoadedRouterConfig> {\n  return throwError(navigationCancelingError(\n      NG_DEV_MODE &&\n          `Cannot load children because the guard of the route \"path: '${\n              route.path}'\" returned false`,\n      NavigationCancellationCode.GuardRejected));\n}\n\n/**\n * Returns the `UrlTree` with the redirection applied.\n *\n * Lazy modules are loaded along the way.\n */\nexport function applyRedirects(\n    injector: EnvironmentInjector, configLoader: RouterConfigLoader, urlSerializer: UrlSerializer,\n    urlTree: UrlTree, config: Routes): Observable<UrlTree> {\n  return new ApplyRedirects(injector, configLoader, urlSerializer, urlTree, config).apply();\n}\n\nclass ApplyRedirects {\n  private allowRedirects: boolean = true;\n\n  constructor(\n      private injector: EnvironmentInjector, private configLoader: RouterConfigLoader,\n      private urlSerializer: UrlSerializer, private urlTree: UrlTree, private config: Routes) {}\n\n  apply(): Observable<UrlTree> {\n    const splitGroup = split(this.urlTree.root, [], [], this.config).segmentGroup;\n    // TODO(atscott): creating a new segment removes the _sourceSegment _segmentIndexShift, which is\n    // only necessary to prevent failures in tests which assert exact object matches. The `split` is\n    // now shared between `applyRedirects` and `recognize` but only the `recognize` step needs these\n    // properties. Before the implementations were merged, the `applyRedirects` would not assign\n    // them. We should be able to remove this logic as a \"breaking change\" but should do some more\n    // investigation into the failures first.\n    const rootSegmentGroup = new UrlSegmentGroup(splitGroup.segments, splitGroup.children);\n\n    const expanded$ =\n        this.expandSegmentGroup(this.injector, this.config, rootSegmentGroup, PRIMARY_OUTLET);\n    const urlTrees$ = expanded$.pipe(map((rootSegmentGroup: UrlSegmentGroup) => {\n      return this.createUrlTree(\n          squashSegmentGroup(rootSegmentGroup), this.urlTree.queryParams, this.urlTree.fragment);\n    }));\n    return urlTrees$.pipe(catchError((e: any) => {\n      if (e instanceof AbsoluteRedirect) {\n        // After an absolute redirect we do not apply any more redirects!\n        // If this implementation changes, update the documentation note in `redirectTo`.\n        this.allowRedirects = false;\n        // we need to run matching, so we can fetch all lazy-loaded modules\n        return this.match(e.urlTree);\n      }\n\n      if (e instanceof NoMatch) {\n        throw this.noMatchError(e);\n      }\n\n      throw e;\n    }));\n  }\n\n  private match(tree: UrlTree): Observable<UrlTree> {\n    const expanded$ =\n        this.expandSegmentGroup(this.injector, this.config, tree.root, PRIMARY_OUTLET);\n    const mapped$ = expanded$.pipe(map((rootSegmentGroup: UrlSegmentGroup) => {\n      return this.createUrlTree(\n          squashSegmentGroup(rootSegmentGroup), tree.queryParams, tree.fragment);\n    }));\n    return mapped$.pipe(catchError((e: any): Observable<UrlTree> => {\n      if (e instanceof NoMatch) {\n        throw this.noMatchError(e);\n      }\n\n      throw e;\n    }));\n  }\n\n  private noMatchError(e: NoMatch): any {\n    return new RuntimeError(\n        RuntimeErrorCode.NO_MATCH,\n        NG_DEV_MODE && `Cannot match any routes. URL Segment: '${e.segmentGroup}'`);\n  }\n\n  private createUrlTree(rootCandidate: UrlSegmentGroup, queryParams: Params, fragment: string|null):\n      UrlTree {\n    const root = createRoot(rootCandidate);\n    return new UrlTree(root, queryParams, fragment);\n  }\n\n  private expandSegmentGroup(\n      injector: EnvironmentInjector, routes: Route[], segmentGroup: UrlSegmentGroup,\n      outlet: string): Observable<UrlSegmentGroup> {\n    if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n      return this.expandChildren(injector, routes, segmentGroup)\n          .pipe(map((children: any) => new UrlSegmentGroup([], children)));\n    }\n\n    return this.expandSegment(injector, segmentGroup, routes, segmentGroup.segments, outlet, true);\n  }\n\n  // Recursively expand segment groups for all the child outlets\n  private expandChildren(\n      injector: EnvironmentInjector, routes: Route[],\n      segmentGroup: UrlSegmentGroup): Observable<{[name: string]: UrlSegmentGroup}> {\n    // Expand outlets one at a time, starting with the primary outlet. We need to do it this way\n    // because an absolute redirect from the primary outlet takes precedence.\n    const childOutlets: string[] = [];\n    for (const child of Object.keys(segmentGroup.children)) {\n      if (child === 'primary') {\n        childOutlets.unshift(child);\n      } else {\n        childOutlets.push(child);\n      }\n    }\n\n    return from(childOutlets)\n        .pipe(\n            concatMap(childOutlet => {\n              const child = segmentGroup.children[childOutlet];\n              // Sort the routes so routes with outlets that match the segment appear\n              // first, followed by routes for other outlets, which might match if they have an\n              // empty path.\n              const sortedRoutes = sortByMatchingOutlets(routes, childOutlet);\n              return this.expandSegmentGroup(injector, sortedRoutes, child, childOutlet)\n                  .pipe(map(s => ({segment: s, outlet: childOutlet})));\n            }),\n            scan(\n                (children, expandedChild) => {\n                  children[expandedChild.outlet] = expandedChild.segment;\n                  return children;\n                },\n                {} as {[outlet: string]: UrlSegmentGroup}),\n            last(),\n        );\n  }\n\n  private expandSegment(\n      injector: EnvironmentInjector, segmentGroup: UrlSegmentGroup, routes: Route[],\n      segments: UrlSegment[], outlet: string,\n      allowRedirects: boolean): Observable<UrlSegmentGroup> {\n    return from(routes).pipe(\n        concatMap(r => {\n          const expanded$ = this.expandSegmentAgainstRoute(\n              injector, segmentGroup, routes, r, segments, outlet, allowRedirects);\n          return expanded$.pipe(catchError((e: any) => {\n            if (e instanceof NoMatch) {\n              return of(null);\n            }\n            throw e;\n          }));\n        }),\n        first((s): s is UrlSegmentGroup => !!s), catchError((e: any, _: any) => {\n          if (e instanceof EmptyError || e.name === 'EmptyError') {\n            if (noLeftoversInUrl(segmentGroup, segments, outlet)) {\n              return of(new UrlSegmentGroup([], {}));\n            }\n            return noMatch(segmentGroup);\n          }\n          throw e;\n        }));\n  }\n\n  private expandSegmentAgainstRoute(\n      injector: EnvironmentInjector, segmentGroup: UrlSegmentGroup, routes: Route[], route: Route,\n      paths: UrlSegment[], outlet: string, allowRedirects: boolean): Observable<UrlSegmentGroup> {\n    if (!isImmediateMatch(route, segmentGroup, paths, outlet)) {\n      return noMatch(segmentGroup);\n    }\n\n    if (route.redirectTo === undefined) {\n      return this.matchSegmentAgainstRoute(injector, segmentGroup, route, paths, outlet);\n    }\n\n    if (allowRedirects && this.allowRedirects) {\n      return this.expandSegmentAgainstRouteUsingRedirect(\n          injector, segmentGroup, routes, route, paths, outlet);\n    }\n\n    return noMatch(segmentGroup);\n  }\n\n  private expandSegmentAgainstRouteUsingRedirect(\n      injector: EnvironmentInjector, segmentGroup: UrlSegmentGroup, routes: Route[], route: Route,\n      segments: UrlSegment[], outlet: string): Observable<UrlSegmentGroup> {\n    if (route.path === '**') {\n      return this.expandWildCardWithParamsAgainstRouteUsingRedirect(\n          injector, routes, route, outlet);\n    }\n\n    return this.expandRegularSegmentAgainstRouteUsingRedirect(\n        injector, segmentGroup, routes, route, segments, outlet);\n  }\n\n  private expandWildCardWithParamsAgainstRouteUsingRedirect(\n      injector: EnvironmentInjector, routes: Route[], route: Route,\n      outlet: string): Observable<UrlSegmentGroup> {\n    const newTree = this.applyRedirectCommands([], route.redirectTo!, {});\n    if (route.redirectTo!.startsWith('/')) {\n      return absoluteRedirect(newTree);\n    }\n\n    return this.lineralizeSegments(route, newTree).pipe(mergeMap((newSegments: UrlSegment[]) => {\n      const group = new UrlSegmentGroup(newSegments, {});\n      return this.expandSegment(injector, group, routes, newSegments, outlet, false);\n    }));\n  }\n\n  private expandRegularSegmentAgainstRouteUsingRedirect(\n      injector: EnvironmentInjector, segmentGroup: UrlSegmentGroup, routes: Route[], route: Route,\n      segments: UrlSegment[], outlet: string): Observable<UrlSegmentGroup> {\n    const {matched, consumedSegments, remainingSegments, positionalParamSegments} =\n        match(segmentGroup, route, segments);\n    if (!matched) return noMatch(segmentGroup);\n\n    const newTree =\n        this.applyRedirectCommands(consumedSegments, route.redirectTo!, positionalParamSegments);\n    if (route.redirectTo!.startsWith('/')) {\n      return absoluteRedirect(newTree);\n    }\n\n    return this.lineralizeSegments(route, newTree).pipe(mergeMap((newSegments: UrlSegment[]) => {\n      return this.expandSegment(\n          injector, segmentGroup, routes, newSegments.concat(remainingSegments), outlet, false);\n    }));\n  }\n\n  private matchSegmentAgainstRoute(\n      injector: EnvironmentInjector, rawSegmentGroup: UrlSegmentGroup, route: Route,\n      segments: UrlSegment[], outlet: string): Observable<UrlSegmentGroup> {\n    if (route.path === '**') {\n      // Only create the Route's `EnvironmentInjector` if it matches the attempted navigation\n      injector = getOrCreateRouteInjectorIfNeeded(route, injector);\n      if (route.loadChildren) {\n        const loaded$ = route._loadedRoutes ?\n            of({routes: route._loadedRoutes, injector: route._loadedInjector}) :\n            this.configLoader.loadChildren(injector, route);\n        return loaded$.pipe(map((cfg: LoadedRouterConfig) => {\n          route._loadedRoutes = cfg.routes;\n          route._loadedInjector = cfg.injector;\n          return new UrlSegmentGroup(segments, {});\n        }));\n      }\n\n      return of(new UrlSegmentGroup(segments, {}));\n    }\n\n    return matchWithChecks(rawSegmentGroup, route, segments, injector, this.urlSerializer)\n        .pipe(\n            switchMap(({matched, consumedSegments, remainingSegments}) => {\n              if (!matched) return noMatch(rawSegmentGroup);\n\n              // If the route has an injector created from providers, we should start using that.\n              injector = route._injector ?? injector;\n              const childConfig$ = this.getChildConfig(injector, route, segments);\n\n              return childConfig$.pipe(mergeMap((routerConfig: LoadedRouterConfig) => {\n                const childInjector = routerConfig.injector ?? injector;\n                const childConfig = routerConfig.routes;\n\n                const {segmentGroup: splitSegmentGroup, slicedSegments} =\n                    split(rawSegmentGroup, consumedSegments, remainingSegments, childConfig);\n                // See comment on the other call to `split` about why this is necessary.\n                const segmentGroup =\n                    new UrlSegmentGroup(splitSegmentGroup.segments, splitSegmentGroup.children);\n\n                if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n                  const expanded$ = this.expandChildren(childInjector, childConfig, segmentGroup);\n                  return expanded$.pipe(\n                      map((children: any) => new UrlSegmentGroup(consumedSegments, children)));\n                }\n\n                if (childConfig.length === 0 && slicedSegments.length === 0) {\n                  return of(new UrlSegmentGroup(consumedSegments, {}));\n                }\n\n                const matchedOnOutlet = getOutlet(route) === outlet;\n                const expanded$ = this.expandSegment(\n                    childInjector, segmentGroup, childConfig, slicedSegments,\n                    matchedOnOutlet ? PRIMARY_OUTLET : outlet, true);\n                return expanded$.pipe(\n                    map((cs: UrlSegmentGroup) => new UrlSegmentGroup(\n                            consumedSegments.concat(cs.segments), cs.children)));\n              }));\n            }),\n        );\n  }\n\n  private getChildConfig(injector: EnvironmentInjector, route: Route, segments: UrlSegment[]):\n      Observable<LoadedRouterConfig> {\n    if (route.children) {\n      // The children belong to the same module\n      return of({routes: route.children, injector});\n    }\n\n    if (route.loadChildren) {\n      // lazy children belong to the loaded module\n      if (route._loadedRoutes !== undefined) {\n        return of({routes: route._loadedRoutes, injector: route._loadedInjector});\n      }\n\n      return runCanLoadGuards(injector, route, segments, this.urlSerializer)\n          .pipe(mergeMap((shouldLoadResult: boolean) => {\n            if (shouldLoadResult) {\n              return this.configLoader.loadChildren(injector, route)\n                  .pipe(tap((cfg: LoadedRouterConfig) => {\n                    route._loadedRoutes = cfg.routes;\n                    route._loadedInjector = cfg.injector;\n                  }));\n            }\n            return canLoadFails(route);\n          }));\n    }\n\n    return of({routes: [], injector});\n  }\n\n  private lineralizeSegments(route: Route, urlTree: UrlTree): Observable<UrlSegment[]> {\n    let res: UrlSegment[] = [];\n    let c = urlTree.root;\n    while (true) {\n      res = res.concat(c.segments);\n      if (c.numberOfChildren === 0) {\n        return of(res);\n      }\n\n      if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {\n        return namedOutletsRedirect(route.redirectTo!);\n      }\n\n      c = c.children[PRIMARY_OUTLET];\n    }\n  }\n\n  private applyRedirectCommands(\n      segments: UrlSegment[], redirectTo: string, posParams: {[k: string]: UrlSegment}): UrlTree {\n    return this.applyRedirectCreateUrlTree(\n        redirectTo, this.urlSerializer.parse(redirectTo), segments, posParams);\n  }\n\n  private applyRedirectCreateUrlTree(\n      redirectTo: string, urlTree: UrlTree, segments: UrlSegment[],\n      posParams: {[k: string]: UrlSegment}): UrlTree {\n    const newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);\n    return new UrlTree(\n        newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams),\n        urlTree.fragment);\n  }\n\n  private createQueryParams(redirectToParams: Params, actualParams: Params): Params {\n    const res: Params = {};\n    forEach(redirectToParams, (v: any, k: string) => {\n      const copySourceValue = typeof v === 'string' && v.startsWith(':');\n      if (copySourceValue) {\n        const sourceName = v.substring(1);\n        res[k] = actualParams[sourceName];\n      } else {\n        res[k] = v;\n      }\n    });\n    return res;\n  }\n\n  private createSegmentGroup(\n      redirectTo: string, group: UrlSegmentGroup, segments: UrlSegment[],\n      posParams: {[k: string]: UrlSegment}): UrlSegmentGroup {\n    const updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);\n\n    let children: {[n: string]: UrlSegmentGroup} = {};\n    forEach(group.children, (child: UrlSegmentGroup, name: string) => {\n      children[name] = this.createSegmentGroup(redirectTo, child, segments, posParams);\n    });\n\n    return new UrlSegmentGroup(updatedSegments, children);\n  }\n\n  private createSegments(\n      redirectTo: string, redirectToSegments: UrlSegment[], actualSegments: UrlSegment[],\n      posParams: {[k: string]: UrlSegment}): UrlSegment[] {\n    return redirectToSegments.map(\n        s => s.path.startsWith(':') ? this.findPosParam(redirectTo, s, posParams) :\n                                      this.findOrReturn(s, actualSegments));\n  }\n\n  private findPosParam(\n      redirectTo: string, redirectToUrlSegment: UrlSegment,\n      posParams: {[k: string]: UrlSegment}): UrlSegment {\n    const pos = posParams[redirectToUrlSegment.path.substring(1)];\n    if (!pos)\n      throw new RuntimeError(\n          RuntimeErrorCode.MISSING_REDIRECT,\n          NG_DEV_MODE &&\n              `Cannot redirect to '${redirectTo}'. Cannot find '${redirectToUrlSegment.path}'.`);\n    return pos;\n  }\n\n  private findOrReturn(redirectToUrlSegment: UrlSegment, actualSegments: UrlSegment[]): UrlSegment {\n    let idx = 0;\n    for (const s of actualSegments) {\n      if (s.path === redirectToUrlSegment.path) {\n        actualSegments.splice(idx);\n        return s;\n      }\n      idx++;\n    }\n    return redirectToUrlSegment;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {EnvironmentInjector} from '@angular/core';\nimport {MonoTypeOperatorFunction} from 'rxjs';\nimport {map, switchMap} from 'rxjs/operators';\n\nimport {applyRedirects as applyRedirectsFn} from '../apply_redirects';\nimport {Routes} from '../models';\nimport {NavigationTransition} from '../router';\nimport {RouterConfigLoader} from '../router_config_loader';\nimport {UrlSerializer} from '../url_tree';\n\nexport function applyRedirects(\n    environmentInjector: EnvironmentInjector, configLoader: RouterConfigLoader,\n    urlSerializer: UrlSerializer, config: Routes): MonoTypeOperatorFunction<NavigationTransition> {\n  return switchMap(\n      t =>\n          applyRedirectsFn(environmentInjector, configLoader, urlSerializer, t.extractedUrl, config)\n              .pipe(map(urlAfterRedirects => ({...t, urlAfterRedirects}))));\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {createEnvironmentInjector, EnvironmentInjector, Type, ɵRuntimeError as RuntimeError} from '@angular/core';\nimport {EmptyError, from, Observable, Observer, of} from 'rxjs';\nimport {catchError, concatMap, defaultIfEmpty, first, last as rxjsLast, map, scan, startWith, switchMap, takeLast, takeWhile} from 'rxjs/operators';\n\nimport {RuntimeErrorCode} from './errors';\nimport {Data, ResolveData, Route, Routes} from './models';\nimport {ActivatedRouteSnapshot, inheritedParamsDataResolve, ParamsInheritanceStrategy, RouterStateSnapshot} from './router_state';\nimport {PRIMARY_OUTLET} from './shared';\nimport {UrlSegment, UrlSegmentGroup, UrlSerializer, UrlTree} from './url_tree';\nimport {last} from './utils/collection';\nimport {getOrCreateRouteInjectorIfNeeded, getOutlet, sortByMatchingOutlets} from './utils/config';\nimport {isImmediateMatch, matchWithChecks, noLeftoversInUrl, split} from './utils/config_matching';\nimport {TreeNode} from './utils/tree';\n\nconst NG_DEV_MODE = typeof ngDevMode === 'undefined' || !!ngDevMode;\n\nclass NoMatch {}\n\nfunction newObservableError(e: unknown): Observable<RouterStateSnapshot> {\n  // TODO(atscott): This pattern is used throughout the router code and can be `throwError` instead.\n  return new Observable<RouterStateSnapshot>((obs: Observer<RouterStateSnapshot>) => obs.error(e));\n}\n\nexport function recognize(\n    injector: EnvironmentInjector, rootComponentType: Type<any>|null, config: Routes,\n    urlTree: UrlTree, url: string, urlSerializer: UrlSerializer,\n    paramsInheritanceStrategy: ParamsInheritanceStrategy = 'emptyOnly',\n    relativeLinkResolution: 'legacy'|'corrected' = 'legacy'): Observable<RouterStateSnapshot> {\n  return new Recognizer(\n             injector, rootComponentType, config, urlTree, url, paramsInheritanceStrategy,\n             relativeLinkResolution, urlSerializer)\n      .recognize()\n      .pipe(switchMap(result => {\n        if (result === null) {\n          return newObservableError(new NoMatch());\n        } else {\n          return of(result);\n        }\n      }));\n}\n\nexport class Recognizer {\n  constructor(\n      private injector: EnvironmentInjector, private rootComponentType: Type<any>|null,\n      private config: Routes, private urlTree: UrlTree, private url: string,\n      private paramsInheritanceStrategy: ParamsInheritanceStrategy,\n      private relativeLinkResolution: 'legacy'|'corrected',\n      private readonly urlSerializer: UrlSerializer) {}\n\n  recognize(): Observable<RouterStateSnapshot|null> {\n    const rootSegmentGroup =\n        split(\n            this.urlTree.root, [], [], this.config.filter(c => c.redirectTo === undefined),\n            this.relativeLinkResolution)\n            .segmentGroup;\n\n    return this.processSegmentGroup(this.injector, this.config, rootSegmentGroup, PRIMARY_OUTLET)\n        .pipe(map(children => {\n          if (children === null) {\n            return null;\n          }\n\n          // Use Object.freeze to prevent readers of the Router state from modifying it outside of a\n          // navigation, resulting in the router being out of sync with the browser.\n          const root = new ActivatedRouteSnapshot(\n              [], Object.freeze({}), Object.freeze({...this.urlTree.queryParams}),\n              this.urlTree.fragment, {}, PRIMARY_OUTLET, this.rootComponentType, null,\n              this.urlTree.root, -1, {});\n\n          const rootNode = new TreeNode<ActivatedRouteSnapshot>(root, children);\n          const routeState = new RouterStateSnapshot(this.url, rootNode);\n          this.inheritParamsAndData(routeState._root);\n          return routeState;\n        }));\n  }\n\n  inheritParamsAndData(routeNode: TreeNode<ActivatedRouteSnapshot>): void {\n    const route = routeNode.value;\n\n    const i = inheritedParamsDataResolve(route, this.paramsInheritanceStrategy);\n    route.params = Object.freeze(i.params);\n    route.data = Object.freeze(i.data);\n\n    routeNode.children.forEach(n => this.inheritParamsAndData(n));\n  }\n\n  processSegmentGroup(\n      injector: EnvironmentInjector, config: Route[], segmentGroup: UrlSegmentGroup,\n      outlet: string): Observable<TreeNode<ActivatedRouteSnapshot>[]|null> {\n    if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n      return this.processChildren(injector, config, segmentGroup);\n    }\n\n    return this.processSegment(injector, config, segmentGroup, segmentGroup.segments, outlet);\n  }\n\n  /**\n   * Matches every child outlet in the `segmentGroup` to a `Route` in the config. Returns `null` if\n   * we cannot find a match for _any_ of the children.\n   *\n   * @param config - The `Routes` to match against\n   * @param segmentGroup - The `UrlSegmentGroup` whose children need to be matched against the\n   *     config.\n   */\n  processChildren(injector: EnvironmentInjector, config: Route[], segmentGroup: UrlSegmentGroup):\n      Observable<TreeNode<ActivatedRouteSnapshot>[]|null> {\n    return from(Object.keys(segmentGroup.children))\n        .pipe(\n            concatMap(childOutlet => {\n              const child = segmentGroup.children[childOutlet];\n              // Sort the config so that routes with outlets that match the one being activated\n              // appear first, followed by routes for other outlets, which might match if they have\n              // an empty path.\n              const sortedConfig = sortByMatchingOutlets(config, childOutlet);\n              return this.processSegmentGroup(injector, sortedConfig, child, childOutlet);\n            }),\n            scan((children, outletChildren) => {\n              if (!children || !outletChildren) return null;\n              children.push(...outletChildren);\n              return children;\n            }),\n            takeWhile(children => children !== null),\n            defaultIfEmpty(null as TreeNode<ActivatedRouteSnapshot>[] | null),\n            rxjsLast(),\n            map(children => {\n              if (children === null) return null;\n              // Because we may have matched two outlets to the same empty path segment, we can have\n              // multiple activated results for the same outlet. We should merge the children of\n              // these results so the final return value is only one `TreeNode` per outlet.\n              const mergedChildren = mergeEmptyPathMatches(children);\n              if (NG_DEV_MODE) {\n                // This should really never happen - we are only taking the first match for each\n                // outlet and merge the empty path matches.\n                checkOutletNameUniqueness(mergedChildren);\n              }\n              sortActivatedRouteSnapshots(mergedChildren);\n              return mergedChildren;\n            }),\n        );\n  }\n\n  processSegment(\n      injector: EnvironmentInjector, routes: Route[], segmentGroup: UrlSegmentGroup,\n      segments: UrlSegment[], outlet: string): Observable<TreeNode<ActivatedRouteSnapshot>[]|null> {\n    return from(routes).pipe(\n        concatMap(r => {\n          return this.processSegmentAgainstRoute(\n              r._injector ?? injector, r, segmentGroup, segments, outlet);\n        }),\n        first((x): x is TreeNode<ActivatedRouteSnapshot>[] => !!x), catchError(e => {\n          if (e instanceof EmptyError) {\n            if (noLeftoversInUrl(segmentGroup, segments, outlet)) {\n              return of([]);\n            }\n            return of(null);\n          }\n          throw e;\n        }));\n  }\n\n  processSegmentAgainstRoute(\n      injector: EnvironmentInjector, route: Route, rawSegment: UrlSegmentGroup,\n      segments: UrlSegment[], outlet: string): Observable<TreeNode<ActivatedRouteSnapshot>[]|null> {\n    if (route.redirectTo || !isImmediateMatch(route, rawSegment, segments, outlet)) return of(null);\n\n    let matchResult: Observable<{\n      snapshot: ActivatedRouteSnapshot,\n      consumedSegments: UrlSegment[],\n      remainingSegments: UrlSegment[],\n    }|null>;\n\n    if (route.path === '**') {\n      const params = segments.length > 0 ? last(segments)!.parameters : {};\n      const pathIndexShift = getPathIndexShift(rawSegment) + segments.length;\n      const snapshot = new ActivatedRouteSnapshot(\n          segments, params, Object.freeze({...this.urlTree.queryParams}), this.urlTree.fragment,\n          getData(route), getOutlet(route), route.component ?? route._loadedComponent ?? null,\n          route, getSourceSegmentGroup(rawSegment), pathIndexShift, getResolve(route),\n          // NG_DEV_MODE is used to prevent the getCorrectedPathIndexShift function from affecting\n          // production bundle size. This value is intended only to surface a warning to users\n          // depending on `relativeLinkResolution: 'legacy'` in dev mode.\n          (NG_DEV_MODE ? getCorrectedPathIndexShift(rawSegment) + segments.length :\n                         pathIndexShift));\n      matchResult = of({\n        snapshot,\n        consumedSegments: [],\n        remainingSegments: [],\n      });\n    } else {\n      matchResult =\n          matchWithChecks(rawSegment, route, segments, injector, this.urlSerializer)\n              .pipe(map(({matched, consumedSegments, remainingSegments, parameters}) => {\n                if (!matched) {\n                  return null;\n                }\n                const pathIndexShift = getPathIndexShift(rawSegment) + consumedSegments.length;\n\n                const snapshot = new ActivatedRouteSnapshot(\n                    consumedSegments, parameters, Object.freeze({...this.urlTree.queryParams}),\n                    this.urlTree.fragment, getData(route), getOutlet(route),\n                    route.component ?? route._loadedComponent ?? null, route,\n                    getSourceSegmentGroup(rawSegment), pathIndexShift, getResolve(route),\n                    (NG_DEV_MODE ?\n                         getCorrectedPathIndexShift(rawSegment) + consumedSegments.length :\n                         pathIndexShift));\n                return {snapshot, consumedSegments, remainingSegments};\n              }));\n    }\n\n    return matchResult.pipe(switchMap((result) => {\n      if (result === null) {\n        return of(null);\n      }\n      const {snapshot, consumedSegments, remainingSegments} = result;\n      // If the route has an injector created from providers, we should start using that.\n      injector = route._injector ?? injector;\n      const childInjector = route._loadedInjector ?? injector;\n      const childConfig: Route[] = getChildConfig(route);\n\n      const {segmentGroup, slicedSegments} = split(\n          rawSegment, consumedSegments, remainingSegments,\n          // Filter out routes with redirectTo because we are trying to create activated route\n          // snapshots and don't handle redirects here. That should have been done in\n          // `applyRedirects`.\n          childConfig.filter(c => c.redirectTo === undefined), this.relativeLinkResolution);\n\n      if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n        return this.processChildren(childInjector, childConfig, segmentGroup).pipe(map(children => {\n          if (children === null) {\n            return null;\n          }\n          return [new TreeNode<ActivatedRouteSnapshot>(snapshot, children)];\n        }));\n      }\n\n      if (childConfig.length === 0 && slicedSegments.length === 0) {\n        return of([new TreeNode<ActivatedRouteSnapshot>(snapshot, [])]);\n      }\n\n      const matchedOnOutlet = getOutlet(route) === outlet;\n      // If we matched a config due to empty path match on a different outlet, we need to\n      // continue passing the current outlet for the segment rather than switch to PRIMARY.\n      // Note that we switch to primary when we have a match because outlet configs look like\n      // this: {path: 'a', outlet: 'a', children: [\n      //  {path: 'b', component: B},\n      //  {path: 'c', component: C},\n      // ]}\n      // Notice that the children of the named outlet are configured with the primary outlet\n      return this\n          .processSegment(\n              childInjector, childConfig, segmentGroup, slicedSegments,\n              matchedOnOutlet ? PRIMARY_OUTLET : outlet)\n          .pipe(map(children => {\n            if (children === null) {\n              return null;\n            }\n            return [new TreeNode<ActivatedRouteSnapshot>(snapshot, children)];\n          }));\n    }));\n  }\n}\n\nfunction sortActivatedRouteSnapshots(nodes: TreeNode<ActivatedRouteSnapshot>[]): void {\n  nodes.sort((a, b) => {\n    if (a.value.outlet === PRIMARY_OUTLET) return -1;\n    if (b.value.outlet === PRIMARY_OUTLET) return 1;\n    return a.value.outlet.localeCompare(b.value.outlet);\n  });\n}\n\nfunction getChildConfig(route: Route): Route[] {\n  if (route.children) {\n    return route.children;\n  }\n\n  if (route.loadChildren) {\n    return route._loadedRoutes!;\n  }\n\n  return [];\n}\n\nfunction hasEmptyPathConfig(node: TreeNode<ActivatedRouteSnapshot>) {\n  const config = node.value.routeConfig;\n  return config && config.path === '' && config.redirectTo === undefined;\n}\n\n/**\n * Finds `TreeNode`s with matching empty path route configs and merges them into `TreeNode` with\n * the children from each duplicate. This is necessary because different outlets can match a\n * single empty path route config and the results need to then be merged.\n */\nfunction mergeEmptyPathMatches(nodes: Array<TreeNode<ActivatedRouteSnapshot>>):\n    Array<TreeNode<ActivatedRouteSnapshot>> {\n  const result: Array<TreeNode<ActivatedRouteSnapshot>> = [];\n  // The set of nodes which contain children that were merged from two duplicate empty path nodes.\n  const mergedNodes: Set<TreeNode<ActivatedRouteSnapshot>> = new Set();\n\n  for (const node of nodes) {\n    if (!hasEmptyPathConfig(node)) {\n      result.push(node);\n      continue;\n    }\n\n    const duplicateEmptyPathNode =\n        result.find(resultNode => node.value.routeConfig === resultNode.value.routeConfig);\n    if (duplicateEmptyPathNode !== undefined) {\n      duplicateEmptyPathNode.children.push(...node.children);\n      mergedNodes.add(duplicateEmptyPathNode);\n    } else {\n      result.push(node);\n    }\n  }\n  // For each node which has children from multiple sources, we need to recompute a new `TreeNode`\n  // by also merging those children. This is necessary when there are multiple empty path configs\n  // in a row. Put another way: whenever we combine children of two nodes, we need to also check\n  // if any of those children can be combined into a single node as well.\n  for (const mergedNode of mergedNodes) {\n    const mergedChildren = mergeEmptyPathMatches(mergedNode.children);\n    result.push(new TreeNode(mergedNode.value, mergedChildren));\n  }\n  return result.filter(n => !mergedNodes.has(n));\n}\n\nfunction checkOutletNameUniqueness(nodes: TreeNode<ActivatedRouteSnapshot>[]): void {\n  const names: {[k: string]: ActivatedRouteSnapshot} = {};\n  nodes.forEach(n => {\n    const routeWithSameOutletName = names[n.value.outlet];\n    if (routeWithSameOutletName) {\n      const p = routeWithSameOutletName.url.map(s => s.toString()).join('/');\n      const c = n.value.url.map(s => s.toString()).join('/');\n      throw new RuntimeError(\n          RuntimeErrorCode.TWO_SEGMENTS_WITH_SAME_OUTLET,\n          NG_DEV_MODE && `Two segments cannot have the same outlet name: '${p}' and '${c}'.`);\n    }\n    names[n.value.outlet] = n.value;\n  });\n}\n\nfunction getSourceSegmentGroup(segmentGroup: UrlSegmentGroup): UrlSegmentGroup {\n  let s = segmentGroup;\n  while (s._sourceSegment) {\n    s = s._sourceSegment;\n  }\n  return s;\n}\n\nfunction getPathIndexShift(segmentGroup: UrlSegmentGroup): number {\n  let s = segmentGroup;\n  let res = s._segmentIndexShift ?? 0;\n  while (s._sourceSegment) {\n    s = s._sourceSegment;\n    res += s._segmentIndexShift ?? 0;\n  }\n  return res - 1;\n}\n\nfunction getCorrectedPathIndexShift(segmentGroup: UrlSegmentGroup): number {\n  let s = segmentGroup;\n  let res = s._segmentIndexShiftCorrected ?? s._segmentIndexShift ?? 0;\n  while (s._sourceSegment) {\n    s = s._sourceSegment;\n    res += s._segmentIndexShiftCorrected ?? s._segmentIndexShift ?? 0;\n  }\n  return res - 1;\n}\n\nfunction getData(route: Route): Data {\n  return route.data || {};\n}\n\nfunction getResolve(route: Route): ResolveData {\n  return route.resolve || {};\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {EnvironmentInjector, Type} from '@angular/core';\nimport {MonoTypeOperatorFunction} from 'rxjs';\nimport {map, mergeMap} from 'rxjs/operators';\n\nimport {Route} from '../models';\nimport {recognize as recognizeFn} from '../recognize';\nimport {NavigationTransition} from '../router';\nimport {UrlSerializer} from '../url_tree';\n\nexport function recognize(\n    injector: EnvironmentInjector, rootComponentType: Type<any>|null, config: Route[],\n    serializer: UrlSerializer, paramsInheritanceStrategy: 'emptyOnly'|'always',\n    relativeLinkResolution: 'legacy'|'corrected'): MonoTypeOperatorFunction<NavigationTransition> {\n  return mergeMap(\n      t => recognizeFn(\n               injector, rootComponentType, config, t.urlAfterRedirects!,\n               serializer.serialize(t.urlAfterRedirects!), serializer, paramsInheritanceStrategy,\n               relativeLinkResolution)\n               .pipe(map(targetSnapshot => ({...t, targetSnapshot}))));\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '@angular/core';\nimport {EMPTY, EmptyError, from, MonoTypeOperatorFunction, Observable, of, throwError} from 'rxjs';\nimport {catchError, concatMap, first, map, mapTo, mergeMap, takeLast, tap} from 'rxjs/operators';\n\nimport {ResolveData, Route} from '../models';\nimport {NavigationTransition} from '../router';\nimport {ActivatedRouteSnapshot, inheritedParamsDataResolve, RouterStateSnapshot} from '../router_state';\nimport {wrapIntoObservable} from '../utils/collection';\nimport {getToken} from '../utils/preactivation';\n\n/**\n * A private symbol used to store the value of `Route.title` inside the `Route.data` if it is a\n * static string or `Route.resolve` if anything else. This allows us to reuse the existing route\n * data/resolvers to support the title feature without new instrumentation in the `Router` pipeline.\n */\nexport const RouteTitle = Symbol('RouteTitle');\n\nexport function resolveData(\n    paramsInheritanceStrategy: 'emptyOnly'|'always',\n    moduleInjector: Injector): MonoTypeOperatorFunction<NavigationTransition> {\n  return mergeMap(t => {\n    const {targetSnapshot, guards: {canActivateChecks}} = t;\n\n    if (!canActivateChecks.length) {\n      return of(t);\n    }\n    let canActivateChecksResolved = 0;\n    return from(canActivateChecks)\n        .pipe(\n            concatMap(\n                check => runResolve(\n                    check.route, targetSnapshot!, paramsInheritanceStrategy, moduleInjector)),\n            tap(() => canActivateChecksResolved++),\n            takeLast(1),\n            mergeMap(_ => canActivateChecksResolved === canActivateChecks.length ? of(t) : EMPTY),\n        );\n  });\n}\n\nfunction runResolve(\n    futureARS: ActivatedRouteSnapshot, futureRSS: RouterStateSnapshot,\n    paramsInheritanceStrategy: 'emptyOnly'|'always', moduleInjector: Injector) {\n  const config = futureARS.routeConfig;\n  const resolve = futureARS._resolve;\n  if (config?.title !== undefined && !hasStaticTitle(config)) {\n    resolve[RouteTitle] = config.title;\n  }\n  return resolveNode(resolve, futureARS, futureRSS, moduleInjector)\n      .pipe(map((resolvedData: any) => {\n        futureARS._resolvedData = resolvedData;\n        futureARS.data = inheritedParamsDataResolve(futureARS, paramsInheritanceStrategy).resolve;\n        if (config && hasStaticTitle(config)) {\n          futureARS.data[RouteTitle] = config.title;\n        }\n        return null;\n      }));\n}\n\nfunction resolveNode(\n    resolve: ResolveData, futureARS: ActivatedRouteSnapshot, futureRSS: RouterStateSnapshot,\n    moduleInjector: Injector): Observable<any> {\n  const keys = getDataKeys(resolve);\n  if (keys.length === 0) {\n    return of({});\n  }\n  const data: {[k: string|symbol]: any} = {};\n  return from(keys).pipe(\n      mergeMap(\n          key => getResolver(resolve[key], futureARS, futureRSS, moduleInjector)\n                     .pipe(first(), tap((value: any) => {\n                             data[key] = value;\n                           }))),\n      takeLast(1),\n      mapTo(data),\n      catchError((e: unknown) => e instanceof EmptyError ? EMPTY : throwError(e)),\n  );\n}\n\nfunction getDataKeys(obj: Object): Array<string|symbol> {\n  return [...Object.keys(obj), ...Object.getOwnPropertySymbols(obj)];\n}\n\nfunction getResolver(\n    injectionToken: any, futureARS: ActivatedRouteSnapshot, futureRSS: RouterStateSnapshot,\n    moduleInjector: Injector): Observable<any> {\n  const resolver = getToken(injectionToken, futureARS, moduleInjector);\n  return resolver.resolve ? wrapIntoObservable(resolver.resolve(futureARS, futureRSS)) :\n                            wrapIntoObservable(resolver(futureARS, futureRSS));\n}\n\nfunction hasStaticTitle(config: Route) {\n  return typeof config.title === 'string' || config.title === null;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {from, MonoTypeOperatorFunction, ObservableInput, of} from 'rxjs';\nimport {map, switchMap} from 'rxjs/operators';\n\n/**\n * Perform a side effect through a switchMap for every emission on the source Observable,\n * but return an Observable that is identical to the source. It's essentially the same as\n * the `tap` operator, but if the side effectful `next` function returns an ObservableInput,\n * it will wait before continuing with the original value.\n */\nexport function switchTap<T>(next: (x: T) => void|ObservableInput<any>):\n    MonoTypeOperatorFunction<T> {\n  return switchMap(v => {\n    const nextResult = next(v);\n    if (nextResult) {\n      return from(nextResult).pipe(map(() => v));\n    }\n    return of(v);\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ComponentRef} from '@angular/core';\n\nimport {OutletContext} from './router_outlet_context';\nimport {ActivatedRoute, ActivatedRouteSnapshot} from './router_state';\nimport {TreeNode} from './utils/tree';\n\n/**\n * @description\n *\n * Represents the detached route tree.\n *\n * This is an opaque value the router will give to a custom route reuse strategy\n * to store and retrieve later on.\n *\n * @publicApi\n */\nexport type DetachedRouteHandle = {};\n\n/** @internal */\nexport type DetachedRouteHandleInternal = {\n  contexts: Map<string, OutletContext>,\n  componentRef: ComponentRef<any>,\n  route: TreeNode<ActivatedRoute>,\n};\n\n/**\n * @description\n *\n * Provides a way to customize when activated routes get reused.\n *\n * @publicApi\n */\nexport abstract class RouteReuseStrategy {\n  /** Determines if this route (and its subtree) should be detached to be reused later */\n  abstract shouldDetach(route: ActivatedRouteSnapshot): boolean;\n\n  /**\n   * Stores the detached route.\n   *\n   * Storing a `null` value should erase the previously stored value.\n   */\n  abstract store(route: ActivatedRouteSnapshot, handle: DetachedRouteHandle|null): void;\n\n  /** Determines if this route (and its subtree) should be reattached */\n  abstract shouldAttach(route: ActivatedRouteSnapshot): boolean;\n\n  /** Retrieves the previously stored route */\n  abstract retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle|null;\n\n  /** Determines if a route should be reused */\n  abstract shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean;\n}\n\n/**\n * @description\n *\n * This base route reuse strategy only reuses routes when the matched router configs are\n * identical. This prevents components from being destroyed and recreated\n * when just the fragment or query parameters change\n * (that is, the existing component is _reused_).\n *\n * This strategy does not store any routes for later reuse.\n *\n * Angular uses this strategy by default.\n *\n *\n * It can be used as a base class for custom route reuse strategies, i.e. you can create your own\n * class that extends the `BaseRouteReuseStrategy` one.\n * @publicApi\n */\nexport abstract class BaseRouteReuseStrategy implements RouteReuseStrategy {\n  /**\n   * Whether the given route should detach for later reuse.\n   * Always returns false for `BaseRouteReuseStrategy`.\n   * */\n  shouldDetach(route: ActivatedRouteSnapshot): boolean {\n    return false;\n  }\n\n  /**\n   * A no-op; the route is never stored since this strategy never detaches routes for later re-use.\n   */\n  store(route: ActivatedRouteSnapshot, detachedTree: DetachedRouteHandle): void {}\n\n  /** Returns `false`, meaning the route (and its subtree) is never reattached */\n  shouldAttach(route: ActivatedRouteSnapshot): boolean {\n    return false;\n  }\n\n  /** Returns `null` because this strategy does not store routes for later re-use. */\n  retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle|null {\n    return null;\n  }\n\n  /**\n   * Determines if a route should be reused.\n   * This strategy returns `true` when the future route config and current route config are\n   * identical.\n   */\n  shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean {\n    return future.routeConfig === curr.routeConfig;\n  }\n}\n\nexport class DefaultRouteReuseStrategy extends BaseRouteReuseStrategy {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Compiler, EnvironmentInjector, Injectable, InjectFlags, InjectionToken, Injector, NgModuleFactory, Type} from '@angular/core';\nimport {ConnectableObservable, from, Observable, of, Subject} from 'rxjs';\nimport {catchError, finalize, map, mergeMap, refCount, tap} from 'rxjs/operators';\n\nimport {LoadChildren, LoadedRouterConfig, Route, Routes} from './models';\nimport {flatten, wrapIntoObservable} from './utils/collection';\nimport {assertStandalone, standardizeConfig, validateConfig} from './utils/config';\n\n\nconst NG_DEV_MODE = typeof ngDevMode === 'undefined' || !!ngDevMode;\n\n/**\n * The [DI token](guide/glossary/#di-token) for a router configuration.\n *\n * `ROUTES` is a low level API for router configuration via dependency injection.\n *\n * We recommend that in almost all cases to use higher level APIs such as `RouterModule.forRoot()`,\n * `RouterModule.forChild()`, `provideRoutes`, or `Router.resetConfig()`.\n *\n * @publicApi\n */\nexport const ROUTES = new InjectionToken<Route[][]>('ROUTES');\n\ntype ComponentLoader = Observable<Type<unknown>>;\n\n@Injectable()\nexport class RouterConfigLoader {\n  private componentLoaders = new WeakMap<Route, ComponentLoader>();\n  private childrenLoaders = new WeakMap<Route, Observable<LoadedRouterConfig>>();\n  onLoadStartListener?: (r: Route) => void;\n  onLoadEndListener?: (r: Route) => void;\n\n  constructor(\n      private injector: Injector,\n      private compiler: Compiler,\n  ) {}\n\n  loadComponent(route: Route): Observable<Type<unknown>> {\n    if (this.componentLoaders.get(route)) {\n      return this.componentLoaders.get(route)!;\n    } else if (route._loadedComponent) {\n      return of(route._loadedComponent);\n    }\n\n    if (this.onLoadStartListener) {\n      this.onLoadStartListener(route);\n    }\n    const loadRunner = wrapIntoObservable(route.loadComponent!())\n                           .pipe(\n                               tap(component => {\n                                 if (this.onLoadEndListener) {\n                                   this.onLoadEndListener(route);\n                                 }\n                                 NG_DEV_MODE && assertStandalone(route.path ?? '', component);\n                                 route._loadedComponent = component;\n                               }),\n                               finalize(() => {\n                                 this.componentLoaders.delete(route);\n                               }),\n                           );\n    // Use custom ConnectableObservable as share in runners pipe increasing the bundle size too much\n    const loader =\n        new ConnectableObservable(loadRunner, () => new Subject<Type<unknown>>()).pipe(refCount());\n    this.componentLoaders.set(route, loader);\n    return loader;\n  }\n\n  loadChildren(parentInjector: Injector, route: Route): Observable<LoadedRouterConfig> {\n    if (this.childrenLoaders.get(route)) {\n      return this.childrenLoaders.get(route)!;\n    } else if (route._loadedRoutes) {\n      return of({routes: route._loadedRoutes, injector: route._loadedInjector});\n    }\n\n    if (this.onLoadStartListener) {\n      this.onLoadStartListener(route);\n    }\n    const moduleFactoryOrRoutes$ = this.loadModuleFactoryOrRoutes(route.loadChildren!);\n    const loadRunner = moduleFactoryOrRoutes$.pipe(\n        map((factoryOrRoutes: NgModuleFactory<any>|Routes) => {\n          if (this.onLoadEndListener) {\n            this.onLoadEndListener(route);\n          }\n          // This injector comes from the `NgModuleRef` when lazy loading an `NgModule`. There is no\n          // injector associated with lazy loading a `Route` array.\n          let injector: EnvironmentInjector|undefined;\n          let rawRoutes: Route[];\n          let requireStandaloneComponents = false;\n          if (Array.isArray(factoryOrRoutes)) {\n            rawRoutes = factoryOrRoutes;\n            requireStandaloneComponents = true;\n          } else {\n            injector = factoryOrRoutes.create(parentInjector).injector;\n            // When loading a module that doesn't provide `RouterModule.forChild()` preloader\n            // will get stuck in an infinite loop. The child module's Injector will look to\n            // its parent `Injector` when it doesn't find any ROUTES so it will return routes\n            // for it's parent module instead.\n            rawRoutes = flatten(injector.get(ROUTES, [], InjectFlags.Self | InjectFlags.Optional));\n          }\n          const routes = rawRoutes.map(standardizeConfig);\n          NG_DEV_MODE && validateConfig(routes, route.path, requireStandaloneComponents);\n          return {routes, injector};\n        }),\n        finalize(() => {\n          this.childrenLoaders.delete(route);\n        }),\n    );\n    // Use custom ConnectableObservable as share in runners pipe increasing the bundle size too much\n    const loader = new ConnectableObservable(loadRunner, () => new Subject<LoadedRouterConfig>())\n                       .pipe(refCount());\n    this.childrenLoaders.set(route, loader);\n    return loader;\n  }\n\n  private loadModuleFactoryOrRoutes(loadChildren: LoadChildren):\n      Observable<NgModuleFactory<any>|Routes> {\n    return wrapIntoObservable(loadChildren()).pipe(mergeMap((t) => {\n      if (t instanceof NgModuleFactory || Array.isArray(t)) {\n        return of(t);\n      } else {\n        return from(this.compiler.compileModuleAsync(t));\n      }\n    }));\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {UrlTree} from './url_tree';\n\n/**\n * @description\n *\n * Provides a way to migrate AngularJS applications to Angular.\n *\n * @publicApi\n */\nexport abstract class UrlHandlingStrategy {\n  /**\n   * Tells the router if this URL should be processed.\n   *\n   * When it returns true, the router will execute the regular navigation.\n   * When it returns false, the router will set the router state to an empty state.\n   * As a result, all the active components will be destroyed.\n   *\n   */\n  abstract shouldProcessUrl(url: UrlTree): boolean;\n\n  /**\n   * Extracts the part of the URL that should be handled by the router.\n   * The rest of the URL will remain untouched.\n   */\n  abstract extract(url: UrlTree): UrlTree;\n\n  /**\n   * Merges the URL fragment with the rest of the URL.\n   */\n  abstract merge(newUrlPart: UrlTree, rawUrl: UrlTree): UrlTree;\n}\n\n/**\n * @publicApi\n */\nexport class DefaultUrlHandlingStrategy implements UrlHandlingStrategy {\n  shouldProcessUrl(url: UrlTree): boolean {\n    return true;\n  }\n  extract(url: UrlTree): UrlTree {\n    return url;\n  }\n  merge(newUrlPart: UrlTree, wholeUrl: UrlTree): UrlTree {\n    return newUrlPart;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Location} from '@angular/common';\nimport {Compiler, Injectable, Injector, NgModuleRef, NgZone, Type, ɵConsole as Console, ɵRuntimeError as RuntimeError} from '@angular/core';\nimport {BehaviorSubject, combineLatest, EMPTY, Observable, of, Subject, SubscriptionLike} from 'rxjs';\nimport {catchError, defaultIfEmpty, filter, finalize, map, switchMap, take, tap} from 'rxjs/operators';\n\nimport {createRouterState} from './create_router_state';\nimport {createUrlTree} from './create_url_tree';\nimport {RuntimeErrorCode} from './errors';\nimport {Event, GuardsCheckEnd, GuardsCheckStart, NavigationCancel, NavigationCancellationCode, NavigationEnd, NavigationError, NavigationStart, NavigationTrigger, ResolveEnd, ResolveStart, RouteConfigLoadEnd, RouteConfigLoadStart, RoutesRecognized} from './events';\nimport {NavigationBehaviorOptions, QueryParamsHandling, Route, Routes} from './models';\nimport {isNavigationCancelingError, isRedirectingNavigationCancelingError, redirectingNavigationError} from './navigation_canceling_error';\nimport {activateRoutes} from './operators/activate_routes';\nimport {applyRedirects} from './operators/apply_redirects';\nimport {checkGuards} from './operators/check_guards';\nimport {recognize} from './operators/recognize';\nimport {resolveData} from './operators/resolve_data';\nimport {switchTap} from './operators/switch_tap';\nimport {TitleStrategy} from './page_title_strategy';\nimport {DefaultRouteReuseStrategy, RouteReuseStrategy} from './route_reuse_strategy';\nimport {RouterConfigLoader} from './router_config_loader';\nimport {ChildrenOutletContexts} from './router_outlet_context';\nimport {ActivatedRoute, ActivatedRouteSnapshot, createEmptyState, RouterState, RouterStateSnapshot} from './router_state';\nimport {Params} from './shared';\nimport {DefaultUrlHandlingStrategy, UrlHandlingStrategy} from './url_handling_strategy';\nimport {containsTree, createEmptyUrlTree, IsActiveMatchOptions, isUrlTree, UrlSerializer, UrlTree} from './url_tree';\nimport {standardizeConfig, validateConfig} from './utils/config';\nimport {Checks, getAllRouteGuards} from './utils/preactivation';\n\n\nconst NG_DEV_MODE = typeof ngDevMode === 'undefined' || !!ngDevMode;\n\n/**\n * @description\n *\n * Options that modify the `Router` URL.\n * Supply an object containing any of these properties to a `Router` navigation function to\n * control how the target URL should be constructed.\n *\n * @see [Router.navigate() method](api/router/Router#navigate)\n * @see [Router.createUrlTree() method](api/router/Router#createurltree)\n * @see [Routing and Navigation guide](guide/router)\n *\n * @publicApi\n */\nexport interface UrlCreationOptions {\n  /**\n   * Specifies a root URI to use for relative navigation.\n   *\n   * For example, consider the following route configuration where the parent route\n   * has two children.\n   *\n   * ```\n   * [{\n   *   path: 'parent',\n   *   component: ParentComponent,\n   *   children: [{\n   *     path: 'list',\n   *     component: ListComponent\n   *   },{\n   *     path: 'child',\n   *     component: ChildComponent\n   *   }]\n   * }]\n   * ```\n   *\n   * The following `go()` function navigates to the `list` route by\n   * interpreting the destination URI as relative to the activated `child`  route\n   *\n   * ```\n   *  @Component({...})\n   *  class ChildComponent {\n   *    constructor(private router: Router, private route: ActivatedRoute) {}\n   *\n   *    go() {\n   *      this.router.navigate(['../list'], { relativeTo: this.route });\n   *    }\n   *  }\n   * ```\n   *\n   * A value of `null` or `undefined` indicates that the navigation commands should be applied\n   * relative to the root.\n   */\n  relativeTo?: ActivatedRoute|null;\n\n  /**\n   * Sets query parameters to the URL.\n   *\n   * ```\n   * // Navigate to /results?page=1\n   * this.router.navigate(['/results'], { queryParams: { page: 1 } });\n   * ```\n   */\n  queryParams?: Params|null;\n\n  /**\n   * Sets the hash fragment for the URL.\n   *\n   * ```\n   * // Navigate to /results#top\n   * this.router.navigate(['/results'], { fragment: 'top' });\n   * ```\n   */\n  fragment?: string;\n\n  /**\n   * How to handle query parameters in the router link for the next navigation.\n   * One of:\n   * * `preserve` : Preserve current parameters.\n   * * `merge` : Merge new with current parameters.\n   *\n   * The \"preserve\" option discards any new query params:\n   * ```\n   * // from /view1?page=1 to/view2?page=1\n   * this.router.navigate(['/view2'], { queryParams: { page: 2 },  queryParamsHandling: \"preserve\"\n   * });\n   * ```\n   * The \"merge\" option appends new query params to the params from the current URL:\n   * ```\n   * // from /view1?page=1 to/view2?page=1&otherKey=2\n   * this.router.navigate(['/view2'], { queryParams: { otherKey: 2 },  queryParamsHandling: \"merge\"\n   * });\n   * ```\n   * In case of a key collision between current parameters and those in the `queryParams` object,\n   * the new value is used.\n   *\n   */\n  queryParamsHandling?: QueryParamsHandling|null;\n\n  /**\n   * When true, preserves the URL fragment for the next navigation\n   *\n   * ```\n   * // Preserve fragment from /results#top to /view#top\n   * this.router.navigate(['/view'], { preserveFragment: true });\n   * ```\n   */\n  preserveFragment?: boolean;\n}\n\n/**\n * @description\n *\n * Options that modify the `Router` navigation strategy.\n * Supply an object containing any of these properties to a `Router` navigation function to\n * control how the target URL should be constructed or interpreted.\n *\n * @see [Router.navigate() method](api/router/Router#navigate)\n * @see [Router.navigateByUrl() method](api/router/Router#navigatebyurl)\n * @see [Router.createUrlTree() method](api/router/Router#createurltree)\n * @see [Routing and Navigation guide](guide/router)\n * @see UrlCreationOptions\n * @see NavigationBehaviorOptions\n *\n * @publicApi\n */\nexport interface NavigationExtras extends UrlCreationOptions, NavigationBehaviorOptions {}\n\n/**\n * Error handler that is invoked when a navigation error occurs.\n *\n * If the handler returns a value, the navigation Promise is resolved with this value.\n * If the handler throws an exception, the navigation Promise is rejected with\n * the exception.\n *\n * @publicApi\n */\nexport type ErrorHandler = (error: any) => any;\n\nfunction defaultErrorHandler(error: any): any {\n  throw error;\n}\n\nfunction defaultMalformedUriErrorHandler(\n    error: URIError, urlSerializer: UrlSerializer, url: string): UrlTree {\n  return urlSerializer.parse('/');\n}\n\nexport type RestoredState = {\n  [k: string]: any,\n  // TODO(#27607): Remove `navigationId` and `ɵrouterPageId` and move to `ng` or `ɵ` namespace.\n  navigationId: number,\n  // The `ɵ` prefix is there to reduce the chance of colliding with any existing user properties on\n  // the history state.\n  ɵrouterPageId?: number,\n};\n\n/**\n * Information about a navigation operation.\n * Retrieve the most recent navigation object with the\n * [Router.getCurrentNavigation() method](api/router/Router#getcurrentnavigation) .\n *\n * * *id* : The unique identifier of the current navigation.\n * * *initialUrl* : The target URL passed into the `Router#navigateByUrl()` call before navigation.\n * This is the value before the router has parsed or applied redirects to it.\n * * *extractedUrl* : The initial target URL after being parsed with `UrlSerializer.extract()`.\n * * *finalUrl* : The extracted URL after redirects have been applied.\n * This URL may not be available immediately, therefore this property can be `undefined`.\n * It is guaranteed to be set after the `RoutesRecognized` event fires.\n * * *trigger* : Identifies how this navigation was triggered.\n * -- 'imperative'--Triggered by `router.navigateByUrl` or `router.navigate`.\n * -- 'popstate'--Triggered by a popstate event.\n * -- 'hashchange'--Triggered by a hashchange event.\n * * *extras* : A `NavigationExtras` options object that controlled the strategy used for this\n * navigation.\n * * *previousNavigation* : The previously successful `Navigation` object. Only one previous\n * navigation is available, therefore this previous `Navigation` object has a `null` value for its\n * own `previousNavigation`.\n *\n * @publicApi\n */\nexport interface Navigation {\n  /**\n   * The unique identifier of the current navigation.\n   */\n  id: number;\n  /**\n   * The target URL passed into the `Router#navigateByUrl()` call before navigation. This is\n   * the value before the router has parsed or applied redirects to it.\n   */\n  initialUrl: UrlTree;\n  /**\n   * The initial target URL after being parsed with `UrlSerializer.extract()`.\n   */\n  extractedUrl: UrlTree;\n  /**\n   * The extracted URL after redirects have been applied.\n   * This URL may not be available immediately, therefore this property can be `undefined`.\n   * It is guaranteed to be set after the `RoutesRecognized` event fires.\n   */\n  finalUrl?: UrlTree;\n  /**\n   * Identifies how this navigation was triggered.\n   *\n   * * 'imperative'--Triggered by `router.navigateByUrl` or `router.navigate`.\n   * * 'popstate'--Triggered by a popstate event.\n   * * 'hashchange'--Triggered by a hashchange event.\n   */\n  trigger: 'imperative'|'popstate'|'hashchange';\n  /**\n   * Options that controlled the strategy used for this navigation.\n   * See `NavigationExtras`.\n   */\n  extras: NavigationExtras;\n  /**\n   * The previously successful `Navigation` object. Only one previous navigation\n   * is available, therefore this previous `Navigation` object has a `null` value\n   * for its own `previousNavigation`.\n   */\n  previousNavigation: Navigation|null;\n}\n\nexport interface NavigationTransition {\n  id: number;\n  targetPageId: number;\n  currentUrlTree: UrlTree;\n  currentRawUrl: UrlTree;\n  extractedUrl: UrlTree;\n  urlAfterRedirects?: UrlTree;\n  rawUrl: UrlTree;\n  extras: NavigationExtras;\n  resolve: any;\n  reject: any;\n  promise: Promise<boolean>;\n  source: NavigationTrigger;\n  restoredState: RestoredState|null;\n  currentSnapshot: RouterStateSnapshot;\n  targetSnapshot: RouterStateSnapshot|null;\n  currentRouterState: RouterState;\n  targetRouterState: RouterState|null;\n  guards: Checks;\n  guardsResult: boolean|UrlTree|null;\n}\n\n/**\n * The equivalent `IsActiveMatchOptions` options for `Router.isActive` is called with `true`\n * (exact = true).\n */\nexport const exactMatchOptions: IsActiveMatchOptions = {\n  paths: 'exact',\n  fragment: 'ignored',\n  matrixParams: 'ignored',\n  queryParams: 'exact'\n};\n\n/**\n * The equivalent `IsActiveMatchOptions` options for `Router.isActive` is called with `false`\n * (exact = false).\n */\nexport const subsetMatchOptions: IsActiveMatchOptions = {\n  paths: 'subset',\n  fragment: 'ignored',\n  matrixParams: 'ignored',\n  queryParams: 'subset'\n};\n\n/**\n * @description\n *\n * A service that provides navigation among views and URL manipulation capabilities.\n *\n * @see `Route`.\n * @see [Routing and Navigation Guide](guide/router).\n *\n * @ngModule RouterModule\n *\n * @publicApi\n */\n@Injectable()\nexport class Router {\n  /**\n   * Represents the activated `UrlTree` that the `Router` is configured to handle (through\n   * `UrlHandlingStrategy`). That is, after we find the route config tree that we're going to\n   * activate, run guards, and are just about to activate the route, we set the currentUrlTree.\n   *\n   * This should match the `browserUrlTree` when a navigation succeeds. If the\n   * `UrlHandlingStrategy.shouldProcessUrl` is `false`, only the `browserUrlTree` is updated.\n   */\n  private currentUrlTree: UrlTree;\n  /**\n   * Meant to represent the entire browser url after a successful navigation. In the life of a\n   * navigation transition:\n   * 1. The rawUrl represents the full URL that's being navigated to\n   * 2. We apply redirects, which might only apply to _part_ of the URL (due to\n   * `UrlHandlingStrategy`).\n   * 3. Right before activation (because we assume activation will succeed), we update the\n   * rawUrlTree to be a combination of the urlAfterRedirects (again, this might only apply to part\n   * of the initial url) and the rawUrl of the transition (which was the original navigation url in\n   * its full form).\n   */\n  private rawUrlTree: UrlTree;\n  /**\n   * Meant to represent the part of the browser url that the `Router` is set up to handle (via the\n   * `UrlHandlingStrategy`). This value is updated immediately after the browser url is updated (or\n   * the browser url update is skipped via `skipLocationChange`). With that, note that\n   * `browserUrlTree` _may not_ reflect the actual browser URL for two reasons:\n   *\n   * 1. `UrlHandlingStrategy` only handles part of the URL\n   * 2. `skipLocationChange` does not update the browser url.\n   *\n   * So to reiterate, `browserUrlTree` only represents the Router's internal understanding of the\n   * current route, either before guards with `urlUpdateStrategy === 'eager'` or right before\n   * activation with `'deferred'`.\n   *\n   * This should match the `currentUrlTree` when the navigation succeeds.\n   */\n  private browserUrlTree: UrlTree;\n  private readonly transitions: BehaviorSubject<NavigationTransition>;\n  private navigations: Observable<NavigationTransition>;\n  private lastSuccessfulNavigation: Navigation|null = null;\n  private currentNavigation: Navigation|null = null;\n  private disposed = false;\n\n  private locationSubscription?: SubscriptionLike;\n  private navigationId: number = 0;\n\n  /**\n   * The id of the currently active page in the router.\n   * Updated to the transition's target id on a successful navigation.\n   *\n   * This is used to track what page the router last activated. When an attempted navigation fails,\n   * the router can then use this to compute how to restore the state back to the previously active\n   * page.\n   */\n  private currentPageId: number = 0;\n  /**\n   * The ɵrouterPageId of whatever page is currently active in the browser history. This is\n   * important for computing the target page id for new navigations because we need to ensure each\n   * page id in the browser history is 1 more than the previous entry.\n   */\n  private get browserPageId(): number|undefined {\n    return (this.location.getState() as RestoredState | null)?.ɵrouterPageId;\n  }\n  private configLoader: RouterConfigLoader;\n  private ngModule: NgModuleRef<any>;\n  private console: Console;\n  private isNgZoneEnabled: boolean = false;\n\n  /**\n   * An event stream for routing events in this NgModule.\n   */\n  public readonly events: Observable<Event> = new Subject<Event>();\n  /**\n   * The current state of routing in this NgModule.\n   */\n  public readonly routerState: RouterState;\n\n  /**\n   * A handler for navigation errors in this NgModule.\n   */\n  errorHandler: ErrorHandler = defaultErrorHandler;\n\n  /**\n   * A handler for errors thrown by `Router.parseUrl(url)`\n   * when `url` contains an invalid character.\n   * The most common case is a `%` sign\n   * that's not encoded and is not part of a percent encoded sequence.\n   */\n  malformedUriErrorHandler:\n      (error: URIError, urlSerializer: UrlSerializer,\n       url: string) => UrlTree = defaultMalformedUriErrorHandler;\n\n  /**\n   * True if at least one navigation event has occurred,\n   * false otherwise.\n   */\n  navigated: boolean = false;\n  private lastSuccessfulId: number = -1;\n\n  /**\n   * Hook that enables you to pause navigation after the preactivation phase.\n   * Used by `RouterModule`.\n   *\n   * @internal\n   */\n  afterPreactivation: () => Observable<void> = () => of(void 0);\n\n  /**\n   * A strategy for extracting and merging URLs.\n   * Used for AngularJS to Angular migrations.\n   */\n  urlHandlingStrategy: UrlHandlingStrategy = new DefaultUrlHandlingStrategy();\n\n  /**\n   * A strategy for re-using routes.\n   */\n  routeReuseStrategy: RouteReuseStrategy = new DefaultRouteReuseStrategy();\n\n  /**\n   * A strategy for setting the title based on the `routerState`.\n   */\n  titleStrategy?: TitleStrategy;\n\n  /**\n   * How to handle a navigation request to the current URL. One of:\n   *\n   * - `'ignore'` :  The router ignores the request.\n   * - `'reload'` : The router reloads the URL. Use to implement a \"refresh\" feature.\n   *\n   * Note that this only configures whether the Route reprocesses the URL and triggers related\n   * action and events like redirects, guards, and resolvers. By default, the router re-uses a\n   * component instance when it re-navigates to the same component type without visiting a different\n   * component first. This behavior is configured by the `RouteReuseStrategy`. In order to reload\n   * routed components on same url navigation, you need to set `onSameUrlNavigation` to `'reload'`\n   * _and_ provide a `RouteReuseStrategy` which returns `false` for `shouldReuseRoute`.\n   */\n  onSameUrlNavigation: 'reload'|'ignore' = 'ignore';\n\n  /**\n   * How to merge parameters, data, resolved data, and title from parent to child\n   * routes. One of:\n   *\n   * - `'emptyOnly'` : Inherit parent parameters, data, and resolved data\n   * for path-less or component-less routes.\n   * - `'always'` : Inherit parent parameters, data, and resolved data\n   * for all child routes.\n   */\n  paramsInheritanceStrategy: 'emptyOnly'|'always' = 'emptyOnly';\n\n  /**\n   * Determines when the router updates the browser URL.\n   * By default (`\"deferred\"`), updates the browser URL after navigation has finished.\n   * Set to `'eager'` to update the browser URL at the beginning of navigation.\n   * You can choose to update early so that, if navigation fails,\n   * you can show an error message with the URL that failed.\n   */\n  urlUpdateStrategy: 'deferred'|'eager' = 'deferred';\n\n  /**\n   * Enables a bug fix that corrects relative link resolution in components with empty paths.\n   * @see `RouterModule`\n   *\n   * @deprecated\n   */\n  relativeLinkResolution: 'legacy'|'corrected' = 'corrected';\n\n  /**\n   * Configures how the Router attempts to restore state when a navigation is cancelled.\n   *\n   * 'replace' - Always uses `location.replaceState` to set the browser state to the state of the\n   * router before the navigation started. This means that if the URL of the browser is updated\n   * _before_ the navigation is canceled, the Router will simply replace the item in history rather\n   * than trying to restore to the previous location in the session history. This happens most\n   * frequently with `urlUpdateStrategy: 'eager'` and navigations with the browser back/forward\n   * buttons.\n   *\n   * 'computed' - Will attempt to return to the same index in the session history that corresponds\n   * to the Angular route when the navigation gets cancelled. For example, if the browser back\n   * button is clicked and the navigation is cancelled, the Router will trigger a forward navigation\n   * and vice versa.\n   *\n   * Note: the 'computed' option is incompatible with any `UrlHandlingStrategy` which only\n   * handles a portion of the URL because the history restoration navigates to the previous place in\n   * the browser history rather than simply resetting a portion of the URL.\n   *\n   * The default value is `replace`.\n   *\n   */\n  canceledNavigationResolution: 'replace'|'computed' = 'replace';\n\n  /**\n   * Creates the router service.\n   */\n  // TODO: vsavkin make internal after the final is out.\n  constructor(\n      private rootComponentType: Type<any>|null, private urlSerializer: UrlSerializer,\n      private rootContexts: ChildrenOutletContexts, private location: Location, injector: Injector,\n      compiler: Compiler, public config: Routes) {\n    const onLoadStart = (r: Route) => this.triggerEvent(new RouteConfigLoadStart(r));\n    const onLoadEnd = (r: Route) => this.triggerEvent(new RouteC