}\n\n  private _commentStart(input: string): number|null {\n    let outerQuote: number|null = null;\n    for (let i = 0; i < input.length - 1; i++) {\n      const char = input.charCodeAt(i);\n      const nextChar = input.charCodeAt(i + 1);\n\n      if (char === chars.$SLASH && nextChar == chars.$SLASH && outerQuote == null) return i;\n\n      if (outerQuote === char) {\n        outerQuote = null;\n      } else if (outerQuote == null && chars.isQuote(char)) {\n        outerQuote = char;\n      }\n    }\n    return null;\n  }\n\n  private _checkNoInterpolation(input: string, location: string, {start, end}: InterpolationConfig):\n      void {\n    let startIndex = -1;\n    let endIndex = -1;\n\n    for (const charIndex of this._forEachUnquotedChar(input, 0)) {\n      if (startIndex === -1) {\n        if (input.startsWith(start)) {\n          startIndex = charIndex;\n        }\n      } else {\n        endIndex = this._getInterpolationEndIndex(input, end, charIndex);\n        if (endIndex > -1) {\n          break;\n        }\n      }\n    }\n\n    if (startIndex > -1 && endIndex > -1) {\n      this._reportError(\n          `Got interpolation (${start}${end}) where expression was expected`, input,\n          `at column ${startIndex} in`, location);\n    }\n  }\n\n  /**\n   * Finds the index of the end of an interpolation expression\n   * while ignoring comments and quoted content.\n   */\n  private _getInterpolationEndIndex(input: string, expressionEnd: string, start: number): number {\n    for (const charIndex of this._forEachUnquotedChar(input, start)) {\n      if (input.startsWith(expressionEnd, charIndex)) {\n        return charIndex;\n      }\n\n      // Nothing else in the expression matters after we've\n      // hit a comment so look directly for the end token.\n      if (input.startsWith('//', charIndex)) {\n        return input.indexOf(expressionEnd, charIndex);\n      }\n    }\n\n    return -1;\n  }\n\n