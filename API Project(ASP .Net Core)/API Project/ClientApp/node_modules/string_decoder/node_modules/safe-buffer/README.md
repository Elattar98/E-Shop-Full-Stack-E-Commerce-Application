oryProvider|StaticClassProvider;\n\n/**\n * The logic visits an `InjectorType`, an `InjectorTypeWithProviders`, or a standalone\n * `ComponentType`, and all of its transitive providers and collects providers.\n *\n * If an `InjectorTypeWithProviders` that declares providers besides the type is specified,\n * the function will return \"true\" to indicate that the providers of the type definition need\n * to be processed. This allows us to process providers of injector types after all imports of\n * an injector definition are processed. (following View Engine semantics: see FW-1349)\n */\nexport function walkProviderTree(\n    container: Type<unknown>|InjectorTypeWithProviders<unknown>, providersOut: SingleProvider[],\n    parents: Type<unknown>[],\n    dedup: Set<Type<unknown>>): container is InjectorTypeWithProviders<unknown> {\n  container = resolveForwardRef(container);\n  if (!container) return false;\n\n  // The actual type which had the definition. Usually `container`, but may be an unwrapped type\n  // from `InjectorTypeWithProviders`.\n  let defType: Type<unknown>|null = null;\n\n  let injDef = getInjectorDef(container);\n  const cmpDef = !injDef && getComponentDef(container);\n  if (!injDef && !cmpDef) {\n    // `container` is not an injector type or a component type. It might be:\n    //  * An `InjectorTypeWithProviders` that wraps an injector type.\n    //  * A standalone directive or pipe that got pulled in from a standalone component's\n    //    dependencies.\n    // Try to unwrap it as an `InjectorTypeWithProviders` first.\n    const ngModule: Type<unknown>|undefined =\n        (container as InjectorTypeWithProviders<any>).ngModule as Type<unknown>| undefined;\n    injDef = getInjectorDef(ngModule);\n    if (injDef) {\n      defType = ngModule!;\n    } else {\n      // Not a component or injector type, so ignore it.\n      return false;\n    }\n  } else if (cmpDef && !cmpDef.standalone) {\n    return false;\n  } else {\n    defType = container as Type<unknown>;\n  }\n\n  // Check for circular dependencies.\n  if (ngDevMode && parents.indexOf(defType) !== -1) {\n    const defName = stringify(defType);\n    const path = parents.map(stringify);\n    throwCyclicDependencyError(defName, path);\n  }\n\n  // Check for multiple imports of the same module\n  const isDuplicate = dedup.has(defType);\n\n  if (cmpDef) {\n    if (isDuplicate) {\n      // This component definition has already been processed.\n      return false;\n    }\n    dedup.add(defType);\n\n    if (cmpDef.dependencies) {\n      const deps =\n          typeof cmpDef.dependencies === 'function' ? cmpDef.dependencies() : cmpDef.dependencies;\n      for (const dep of deps) {\n        walkProviderTree(dep, providersOut, parents, dedup);\n      }\n    }\n  } else if (injDef) {\n    // First, include providers from any imports.\n    if (injDef.imports != null && !isDuplicate) {\n      // Before processing defType's imports, add it to the set of parents. This way, if it ends\n      // up deeply importing itself, this can be detected.\n      ngDevMode && parents.push(defType);\n      // Add it to the set of dedups. This way we can detect multiple imports of the same module\n      dedup.add(defType);\n\n      let importTypesWithProviders: (InjectorTypeWithProviders<any>[])|undefined;\n      try {\n        deepForEach(injDef.imports, imported => {\n          if (walkProviderTree(imported, providersOut, parents, dedup)) {\n            importTypesWithProviders ||= [];\n            // If the processed import is an injector type with providers, we store it in the\n            // list of import types with providers, so that we can process those afterwards.\n            importTypesWithProviders.push(imported);\n          }\n        });\n      } finally {\n        // Remove it from the parents set when finished.\n        ngDevMode && parents.pop();\n      }\n\n      // Imports which are declared with providers (TypeWithProviders) need to be processed\n      // after all imported modules are processed. This is similar to how View Engine\n      // processes/merges module imports in the metadata resolver. See: FW-1349.\n      if (importTypesWithProviders !== undefined) {\n        processInjectorTypesWithProviders(importTypesWithProviders, providersOut);\n      }\n    }\n\n    if (!isDuplicate) {\n      // Track the InjectorType and add a provider for it.\n      // It's important that this is done after the def's imports.\n      const factory = getFactoryDef(defType) || (() => new defType!());\n\n      // Append extra providers to make more info available for consumers (to retrieve an injector\n      // type), as well as internally (to calculate an injection scope correctly and eagerly\n      // instantiate a `defType` when an injector is created).\n      providersOut.push(\n          // Provider to create `defType` using its factory.\n          {provide: defType, useFactory: factory, deps: EMPTY_ARRAY},\n\n          // Make this `defType` available to an internal logic that calculates injector scope.\n          {provide: INJECTOR_DEF_TYPES, useValue: defType, multi: true},\n\n          // Provider to eagerly instantiate `defType` via `ENVIRONMENT_INITIALIZER`.\n          {provide: ENVIRONMENT_INITIALIZER, useValue: () => inject(defType!), multi: true}  //\n      );\n    }\n\n    // Next, include providers listed on the definition itself.\n    const defProviders = injDef.providers;\n    if (defProviders != null && !isDuplicate) {\n      const injectorType = container as InjectorType<any>;\n      deepForEach(defProviders, provider => {\n        ngDevMode && validateProvider(provider, defProviders as SingleProvider[], injectorType);\n        providersOut.push(provider);\n      });\n    }\n  } else {\n    // Should not happen, but just in case.\n    return false;\n  }\n\n  return (\n      defType !== container &&\n      (container as InjectorTypeWithProviders<any>).providers !== undefined);\n}\n\nfunction validateProvider(\n    provider: SingleProvider, providers: SingleProvider[], containerType: Type<unknown>): void {\n  if (isTypeProvider(provider) || isValueProvider(provider) || isFactoryProvider(provider) ||\n      isExistingProvider(provider)) {\n    return;\n  }\n\n  // Here we expect the provider to be a `useClass` provider (by elimination).\n  const classRef = resolveForwardRef(\n      provider && ((provider as StaticClassProvider | ClassProvider).useClass || provider.provide));\n  if (!classRef) {\n    throwInvalidProviderError(containerType, providers, provider);\n  }\n}\n\nexport const USE_VALUE =\n    getClosureSafeProperty<ValueProvider>({provide: String, useValue: getClosureSafeProperty});\n\nexport function isValueProvider(value: SingleProvider): value is ValueProvider {\n  return value !== null && typeof value == 'object' && USE_VALUE in value;\n}\n\nexport function isExistingProvider(value: SingleProvider): value is ExistingProvider {\n  return !!(value && (value as ExistingProvider).useExisting);\n}\n\nexport function isFactoryProvider(value: SingleProvider): value is FactoryProvider {\n  return !!(value && (value as FactoryProvider).useFactory);\n}\n\nexport function isTypeProvider(value: SingleProvider): value is TypeProvider {\n  return typeof value === 'function';\n}\n\nexport function isClassProvider(value: SingleProvider): value is ClassProvider {\n  return !!(value as StaticClassProvider | ClassProvider).useClass;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from './injection_token';\n\n\nexport type InjectorScope = 'root'|'platform'|'environment';\n\n/**\n * An internal token whose presence in an injector indicates that the injector should treat itself\n * as a root scoped injector when processing requests for unknown tokens which may indicate\n * they are provided in the root scope.\n */\nexport const INJECTOR_SCOPE = new InjectionToken<InjectorScope|null>('Set Injector scope.');\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport '../util/ng_dev_mode';\n\nimport {RuntimeError, RuntimeErrorCode} from '../errors';\nimport {OnDestroy} from '../interface/lifecycle_hooks';\nimport {Type} from '../interface/type';\nimport {getComponentDef} from '../render3/definition';\nimport {FactoryFn, getFactoryDef} from '../render3/definition_factory';\nimport {throwCyclicDependencyError, throwInvalidProviderError, throwMixedMultiProviderError} from '../render3/errors_di';\nimport {newArray} from '../util/array_utils';\nimport {EMPTY_ARRAY} from '../util/empty';\nimport {stringify} from '../util/stringify';\n\nimport {resolveForwardRef} from './forward_ref';\nimport {ENVIRONMENT_INITIALIZER} from './initializer_token';\nimport {setInjectImplementation} from './inject_switch';\nimport {InjectionToken} from './injection_token';\nimport {Injector} from './injector';\nimport {catchInjectorError, injectArgs, NG_TEMP_TOKEN_PATH, setCurrentInjector, THROW_IF_NOT_FOUND, ɵɵinject} from './injector_compatibility';\nimport {INJECTOR} from './injector_token';\nimport {getInheritedInjectableDef, getInjectableDef, InjectorType, ɵɵInjectableDeclaration} from './interface/defs';\nimport {InjectFlags} from './interface/injector';\nimport {ClassProvider, ConstructorProvider, ImportedNgModuleProviders, Provider, StaticClassProvider} from './interface/provider';\nimport {INJECTOR_DEF_TYPES} from './internal_tokens';\nimport {NullInjector} from './null_injector';\nimport {importProvidersFrom, isExistingProvider, isFactoryProvider, isTypeProvider, isValueProvider, SingleProvider} from './provider_collection';\nimport {ProviderToken} from './provider_token';\nimport {INJECTOR_SCOPE, InjectorScope} from './scope';\n\n/**\n * Marker which indicates that a value has not yet been created from the factory function.\n */\nconst NOT_YET = {};\n\n/**\n * Marker which indicates that the factory function for a token is in the process of being called.\n *\n * If the injector is asked to inject a token with its value set to CIRCULAR, that indicates\n * injection of a dependency has recursively attempted to inject the original token, and there is\n * a circular dependency among the providers.\n */\nconst CIRCULAR = {};\n\n/**\n * A lazily initialized NullInjector.\n */\nlet NULL_INJECTOR: Injector|undefined = undefined;\n\nexport function getNullInjector(): Injector {\n  if (NULL_INJECTOR === undefined) {\n    NULL_INJECTOR = new NullInjector();\n  }\n  return NULL_INJECTOR;\n}\n\n/**\n * An entry in the injector which tracks information about the given token, including a possible\n * current value.\n */\ninterface Record<T> {\n  factory: (() => T)|undefined;\n  value: T|{};\n  multi: any[]|undefined;\n}\n\n/**\n * An `Injector` that's part of the environment injector hierarchy, which exists outside of the\n * component tree.\n *\n * @developerPreview\n */\nexport abstract class EnvironmentInjector implements Injector {\n  /**\n   * Retrieves an instance from the injector based on the provided token.\n   * @returns The instance from the injector if defined, otherwise the `notFoundValue`.\n   * @throws When the `notFoundValue` is `undefined` or `Injector.THROW_IF_NOT_FOUND`.\n   */\n  abstract get<T>(token: ProviderToken<T>, notFoundValue?: T, flags?: InjectFlags): T;\n  /**\n   * @deprecated from v4.0.0 use ProviderToken<T>\n   * @suppress {duplicate}\n   */\n  abstract get(token: any, notFoundValue?: any): any;\n\n  /**\n   * Runs the given function in the context of this `EnvironmentInjector`.\n   *\n   * Within the function's stack frame, `inject` can be used to inject dependencies from this\n   * injector. Note that `inject` is only usable synchronously, and cannot be used in any\n   * asynchronous callbacks or after any `await` points.\n   *\n   * @param fn the closure to be run in the context of this injector\n   * @returns the return value of the function, if any\n   */\n  abstract runInContext<ReturnT>(fn: () => ReturnT): ReturnT;\n\n  abstract destroy(): void;\n\n  /**\n   * @internal\n   */\n  abstract onDestroy(callback: () => void): void;\n}\n\nexport class R3Injector extends EnvironmentInjector {\n  /**\n   * Map of tokens to records which contain the instances of those tokens.\n   * - `null` value implies that we don't have the record. Used by tree-shakable injectors\n   * to prevent further searches.\n   */\n  private records = new Map<ProviderToken<any>, Record<any>|null>();\n\n  /**\n   * Set of values instantiated by this injector which contain `ngOnDestroy` lifecycle hooks.\n   */\n  private _ngOnDestroyHooks = new Set<OnDestroy>();\n\n  private _onDestroyHooks: Array<() => void> = [];\n\n  /**\n   * Flag indicating that this injector was previously destroyed.\n   */\n  get destroyed(): boolean {\n    return this._destroyed;\n  }\n  private _destroyed = false;\n\n  private injectorDefTypes: Set<Type<unknown>>;\n\n  constructor(\n      providers: Array<Provider|ImportedNgModuleProviders>, readonly parent: Injector,\n      readonly source: string|null, readonly scopes: Set<InjectorScope>) {\n    super();\n    // Start off by creating Records for every provider.\n    forEachSingleProvider(providers, provider => this.processProvider(provider));\n\n    // Make sure the INJECTOR token provides this injector.\n    this.records.set(INJECTOR, makeRecord(undefined, this));\n\n    // And `EnvironmentInjector` if the current injector is supposed to be env-scoped.\n    if (scopes.has('environment')) {\n      this.records.set(EnvironmentInjector, makeRecord(undefined, this));\n    }\n\n    // Detect whether this injector has the APP_ROOT_SCOPE token and thus should provide\n    // any injectable scoped to APP_ROOT_SCOPE.\n    const record = this.records.get(INJECTOR_SCOPE) as Record<InjectorScope|null>;\n    if (record != null && typeof record.value === 'string') {\n      this.scopes.add(record.value as InjectorScope);\n    }\n\n    this.injectorDefTypes =\n        new Set(this.get(INJECTOR_DEF_TYPES.multi, EMPTY_ARRAY, InjectFlags.Self));\n  }\n\n  /**\n   * Destroy the injector and release references to every instance or provider associated with it.\n   *\n   * Also calls the `OnDestroy` lifecycle hooks of every instance that was created for which a\n   * hook was found.\n   */\n  override destroy(): void {\n    this.assertNotDestroyed();\n\n    // Set destroyed = true first, in case lifecycle hooks re-enter destroy().\n    this._destroyed = true;\n    try {\n      // Call all the lifecycle hooks.\n      for (const service of this._ngOnDestroyHooks) {\n        service.ngOnDestroy();\n      }\n      for (const hook of this._onDestroyHooks) {\n        hook();\n      }\n    } finally {\n      // Release all references.\n      this.records.clear();\n      this._ngOnDestroyHooks.clear();\n      this.injectorDefTypes.clear();\n      this._onDestroyHooks.length = 0;\n    }\n  }\n\n  override onDestroy(callback: () => void): void {\n    this._onDestroyHooks.push(callback);\n  }\n\n  override runInContext<ReturnT>(fn: () => ReturnT): ReturnT {\n    this.assertNotDestroyed();\n\n    const previousInjector = setCurrentInjector(this);\n    const previousInjectImplementation = setInjectImplementation(undefined);\n    try {\n      return fn();\n    } finally {\n      setCurrentInjector(previousInjector);\n      setInjectImplementation(previousInjectImplementation);\n    }\n  }\n\n  override get<T>(\n      token: ProviderToken<T>, notFoundValue: any = THROW_IF_NOT_FOUND,\n      flags = InjectFlags.Default): T {\n    this.assertNotDestroyed();\n    // Set the injection context.\n    const previousInjector = setCurrentInjector(this);\n    const previousInjectImplementation = setInjectImplementation(undefined);\n    try {\n      // Check for the SkipSelf flag.\n      if (!(flags & InjectFlags.SkipSelf)) {\n        // SkipSelf isn't set, check if the record belongs to this injector.\n        let record: Record<T>|undefined|null = this.records.get(token);\n        if (record === undefined) {\n          // No record, but maybe the token is scoped to this injector. Look for an injectable\n          // def with a scope matching this injector.\n          const def = couldBeInjectableType(token) && getInjectableDef(token);\n          if (def && this.injectableDefInScope(def)) {\n            // Found an injectable def and it's scoped to this injector. Pretend as if it was here\n            // all along.\n            record = makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET);\n          } else {\n            record = null;\n          }\n          this.records.set(token, record);\n        }\n        // If a record was found, get the instance for it and return it.\n        if (record != null /* NOT null || undefined */) {\n          return this.hydrate(token, record);\n        }\n      }\n\n      // Select the next injector based on the Self flag - if self is set, the next injector is\n      // the NullInjector, otherwise it's the parent.\n      const nextInjector = !(flags & InjectFlags.Self) ? this.parent : getNullInjector();\n      // Set the notFoundValue based on the Optional flag - if optional is set and notFoundValue\n      // is undefined, the value is null, otherwise it's the notFoundValue.\n      notFoundValue = (flags & InjectFlags.Optional) && notFoundValue === THROW_IF_NOT_FOUND ?\n          null :\n          notFoundValue;\n      return nextInjector.get(token, notFoundValue);\n    } catch (e: any) {\n      if (e.name === 'NullInjectorError') {\n        const path: any[] = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];\n        path.unshift(stringify(token));\n        if (previousInjector) {\n          // We still have a parent injector, keep throwing\n          throw e;\n        } else {\n          // Format & throw the final error message when we don't have any previous injector\n          return catchInjectorError(e, token, 'R3InjectorError', this.source);\n        }\n      } else {\n        throw e;\n      }\n    } finally {\n      // Lastly, restore the previous injection context.\n      setInjectImplementation(previousInjectImplementation);\n      setCurrentInjector(previousInjector);\n    }\n  }\n\n  /** @internal */\n  resolveInjectorInitializers() {\n    const previousInjector = setCurrentInjector(this);\n    const previousInjectImplementation = setInjectImplementation(undefined);\n    try {\n      const initializers = this.get(ENVIRONMENT_INITIALIZER.multi, EMPTY_ARRAY, InjectFlags.Self);\n      if (ngDevMode && !Array.isArray(initializers)) {\n        throw new RuntimeError(\n            RuntimeErrorCode.INVALID_MULTI_PROVIDER,\n            'Unexpected type of the `ENVIRONMENT_INITIALIZER` token value ' +\n                `(expected an array, but got ${typeof initializers}). ` +\n                'Please check that the `ENVIRONMENT_INITIALIZER` token is configured as a ' +\n                '`multi: true` provider.');\n      }\n      for (const initializer of initializers) {\n        initializer();\n      }\n    } finally {\n      setCurrentInjector(previousInjector);\n      setInjectImplementation(previousInjectImplementation);\n    }\n  }\n\n  override toString() {\n    const tokens: string[] = [];\n    const records = this.records;\n    for (const token of records.keys()