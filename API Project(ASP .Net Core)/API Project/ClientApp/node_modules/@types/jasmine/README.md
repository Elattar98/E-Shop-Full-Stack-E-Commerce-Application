xportPath,
    exportName,
    importBindingsReferences,
    importPaths
  } = metadata;
  const dependenciesRefs = {};
  dependencies.forEach((name, id) => {
    dependenciesRefs[id.name] = typeof getDependency === "function" && getDependency(name) || id;
  });
  const toRename = {};
  const bindings = new Set(localBindings || []);
  localBindingNames.forEach(name => {
    let newName = name;

    while (bindings.has(newName)) newName = "_" + newName;

    if (newName !== name) toRename[name] = newName;
  });

  if (id.type === "Identifier" && exportName !== id.name) {
    toRename[exportName] = id.name;
  }

  const {
    path
  } = file;
  const exp = path.get(exportPath);
  const imps = importPaths.map(p => path.get(p));
  const impsBindingRefs = importBindingsReferences.map(p => path.get(p));
  const decl = exp.get("declaration");

  if (id.type === "Identifier") {
    exp.replaceWith(decl);
  } else if (id.type === "MemberExpression") {
    exportBindingAssignments.forEach(assignPath => {
      const assign = path.get(assignPath);
      assign.replaceWith(assignmentExpression("=", id, assign.node));
    });
    exp.replaceWith(decl);
    path.pushContainer("body", expressionStatement(assignmentExpression("=", id, identifier(exportName))));
  } else {
    throw new Error("Unexpected helper format.");
  }

  Object.keys(toRename).forEach(name => {
    path.scope