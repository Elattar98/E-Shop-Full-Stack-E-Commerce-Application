nChangedAfterItHasBeenCheckedError:\n * - property name (for property bindings or interpolations)\n * - old and new values, enriched using information from metadata\n *\n * More information on the metadata storage format can be found in `storePropertyBindingMetadata`\n * function description.\n */\nexport function getExpressionChangedErrorDetails(\n    lView: LView, bindingIndex: number, oldValue: any,\n    newValue: any): {propName?: string, oldValue: any, newValue: any} {\n  const tData = lView[TVIEW].data;\n  const metadata = tData[bindingIndex];\n\n  if (typeof metadata === 'string') {\n    // metadata for property interpolation\n    if (metadata.indexOf(INTERPOLATION_DELIMITER) > -1) {\n      return constructDetailsForInterpolation(\n          lView, bindingIndex, bindingIndex, metadata, newValue);\n    }\n    // metadata for property binding\n    return {propName: metadata, oldValue, newValue};\n  }\n\n  // metadata is not available for this expression, check if this expression is a part of the\n  // property interpolation by going from the current binding index left and look for a string that\n  // contains INTERPOLATION_DELIMITER, the layout in tView.data for this case will look like this:\n  // [..., 'id�Prefix � and � suffix', null, null, null, ...]\n  if (metadata === null) {\n    let idx = bindingIndex - 1;\n    while (typeof tData[idx] !== 'string' && tData[idx + 1] === null) {\n      idx--;\n    }\n    const meta = tData[idx];\n    if (typeof meta === 'string') {\n      const matches = meta.match(new RegExp(INTERPOLATION_DELIMITER, 'g'));\n      // first interpolation delimiter separates property name from interpolation parts (in case of\n      // property interpolations), so we subtract one from total number of found delimiters\n      if (matches && (matches.length - 1) > bindingIndex - idx) {\n        return constructDetailsForInterpolation(lView, idx, bindingIndex, meta, newValue);\n      }\n    }\n  }\n  return {propName: undefined, oldValue, newValue};\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ViewEncapsulation} from '../metadata/view';\n\n\n/**\n * Used by `RendererFactory2` to associate custom rendering data and styles\n * with a rendering implementation.\n *  @publicApi\n */\nexport interface RendererType2 {\n  /**\n   * A unique identifying string for the new renderer, used when creating\n   * unique styles for encapsulation.\n   */\n  id: string;\n  /**\n   * The view encapsulation type, which determines how styles are applied to\n   * DOM elements. One of\n   * - `Emulated` (default): Emulate native scoping of styles.\n   * - `Native`: Use the native encapsulation mechanism of the renderer.\n   * - `ShadowDom`: Use modern [Shadow\n   * DOM](https://w3c.github.io/webcomponents/spec/shadow/) and\n   * create a ShadowRoot for component's host element.\n   * - `None`: Do not provide any template or style encapsulation.\n   */\n  encapsulation: ViewEncapsulation;\n  /**\n   * Defines CSS styles to be stored on a renderer instance.\n   */\n  styles: (string|any[])[];\n  /**\n   * Defines arbitrary developer-defined data to be stored on a renderer instance.\n   * This is useful for renderers that delegate to other renderers.\n   */\n  data: {[kind: string]: any};\n}\n\n\n/**\n * Flags for renderer-specific style modifiers.\n * @publicApi\n */\nexport enum RendererStyleFlags2 {\n  // TODO(misko): This needs to be refactored into a separate file so that it can be imported from\n  // `node_manipulation.ts` Currently doing the import cause resolution order to change and fails\n  // the tests. The work around is to have hard coded value in `node_manipulation.ts` for now.\n  /**\n   * Marks a style as important.\n   */\n  Important = 1 << 0,\n  /**\n   * Marks a style as using dash case naming (this-is-dash-case).\n   */\n  DashCase = 1 << 1\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @fileoverview\n *\n * This file provides mechanism by which code relevant to the `TIcuContainerNode` is only loaded if\n * ICU is present in the template.\n */\n\nimport {TIcuContainerNode} from '../interfaces/node';\nimport {RNode} from '../interfaces/renderer_dom';\nimport {LView} from '../interfaces/view';\n\n\nlet _icuContainerIterate: (tIcuContainerNode: TIcuContainerNode, lView: LView) =>\n    (() => RNode | null);\n\n/**\n * Iterator which provides ability to visit all of the `TIcuContainerNode` root `RNode`s.\n */\nexport function icuContainerIterate(tIcuContainerNode: TIcuContainerNode, lView: LView): () =>\n    RNode | null {\n  return _icuContainerIterate(tIcuContainerNode, lView);\n}\n\n/**\n * Ensures that `IcuContainerVisitor`'s implementation is present.\n *\n * This function is invoked when i18n instruction comes across an ICU. The purpose is to allow the\n * bundler to tree shake ICU logic and only load it if ICU instruction is executed.\n */\nexport function ensureIcuContainerVisitorLoaded(\n    loader: () => ((tIcuContainerNode: TIcuContainerNode, lView: LView) => (() => RNode | null))) {\n  if (_icuContainerIterate === undefined) {\n    // Do not inline this function. We want to keep `ensureIcuContainerVisitorLoaded` light, so it\n    // can be inlined into call-site.\n    _icuContainerIterate = loader();\n  }\n}\n","\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n/**\n * Expresses a single CSS Selector.\n *\n * Beginning of array\n * - First index: element name\n * - Subsequent odd indices: attr keys\n * - Subsequent even indices: attr values\n *\n * After SelectorFlags.CLASS flag\n * - Class name values\n *\n * SelectorFlags.NOT flag\n * - Changes the mode to NOT\n * - Can be combined with other flags to set the element / attr / class mode\n *\n * e.g. SelectorFlags.NOT | SelectorFlags.ELEMENT\n *\n * Example:\n * Original: `div.foo.bar[attr1=val1][attr2]`\n * Parsed: ['div', 'attr1', 'val1', 'attr2', '', SelectorFlags.CLASS, 'foo', 'bar']\n *\n * Original: 'div[attr1]:not(.foo[attr2])\n * Parsed: [\n *  'div', 'attr1', '',\n *  SelectorFlags.NOT | SelectorFlags.ATTRIBUTE 'attr2', '', SelectorFlags.CLASS, 'foo'\n * ]\n *\n * See more examples in node_selector_matcher_spec.ts\n */\nexport type CssSelector = (string|SelectorFlags)[];\n\n/**\n * A list of CssSelectors.\n *\n * A directive or component can have multiple selectors. This type is used for\n * directive defs so any of the selectors in the list will match that directive.\n *\n * Original: 'form, [ngForm]'\n * Parsed: [['form'], ['', 'ngForm', '']]\n */\nexport type CssSelectorList = CssSelector[];\n\n/**\n * List of slots for a projection. A slot can be either based on a parsed CSS selector\n * which will be used to determine nodes which are projected into that slot.\n *\n * When set to \"*\", the slot is reserved and can be used for multi-slot projection\n * using {@link ViewContainerRef#createComponent}. The last slot that specifies the\n * wildcard selector will retrieve all projectable nodes which do not match any selector.\n */\nexport type ProjectionSlots = (CssSelectorList|'*')[];\n\n/** Flags used to build up CssSelectors */\nexport const enum SelectorFlags {\n  /** Indicates this is the beginning of a new negative selector */\n  NOT = 0b0001,\n\n  /** Mode for matching attributes */\n  ATTRIBUTE = 0b0010,\n\n  /** Mode for matching tag names */\n  ELEMENT = 0b0100,\n\n  /** Mode for matching class names */\n  CLASS = 0b1000,\n}\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {RendererStyleFlags2, RendererType2} from '../../render/api_flags';\nimport {TrustedHTML, TrustedScript, TrustedScriptURL} from '../../util/security/trusted_type_defs';\n\nimport {RComment, RElement, RNode, RText} from './renderer_dom';\n\n/**\n * The goal here is to make sure that the browser DOM API is the Renderer.\n * We do this by defining a subset of DOM API to be the renderer and then\n * use that at runtime for rendering.\n *\n * At runtime we can then use the DOM api directly, in server or web-worker\n * it will be easy to implement such API.\n */\n\nexport type GlobalTargetName = 'document'|'window'|'body';\n\nexport type GlobalTargetResolver = (element: any) => EventTarget;\n\n/**\n * Procedural style of API needed to create elements and text nodes.\n *\n * In non-native browser environments (e.g. platforms such as web-workers), this is the\n * facade that enables element manipulation. In practice, this is implemented by `Renderer2`.\n */\nexport interface Renderer {\n  destroy(): void;\n  createComment(value: string): RComment;\n  createElement(name: string, namespace?: string|null): RElement;\n  createText(value: string): RText;\n  /**\n   * This property is allowed to be null / undefined,\n   * in which case the view engine won't call it.\n   * This is used as a performance optimization for production mode.\n   */\n  destroyNode?: ((node: RNode) => void)|null;\n  appendChild(parent: RElement, newChild: RNode): void;\n  insertBefore(parent: RNode, newChild: RNode, refChild: RNode|null, isMove?: boolean): void;\n  removeChild(parent: RElement, oldChild: RNode, isHostElement?: boolean): void;\n  selectRootElement(selectorOrNode: string|any, preserveContent?: boolean): RElement;\n\n  parentNode(node: RNode): RElement|null;\n  nextSibling(node: RNode): RNode|null;\n\n  setAttribute(\n      el: RElement, name: string, value: string|TrustedHTML|TrustedScript|TrustedScriptURL,\n      namespace?: string|null): void;\n  removeAttribute(el: RElement, name: string, namespace?: string|null): void;\n  addClass(el: RElement, name: string): void;\n  removeClass(el: RElement, name: string): void;\n  setStyle(el: RElement, style: string, value: any, flags?: RendererStyleFlags2): void;\n  removeStyle(el: RElement, style: string, flags?: RendererStyleFlags2): void;\n  setProperty(el: RElement, name: string, value: any): void;\n  setValue(node: RText|RComment, value: string): void;\n\n  // TODO(misko): Deprecate in favor of addEventListener/removeEventListener\n  listen(\n      target: GlobalTargetName|RNode, eventName: string,\n      callback: (event: any) => boolean | void): () => void;\n}\n\nexport interface RendererFactory {\n  createRenderer(hostElement: RElement|null, rendererType: RendererType2|null): Renderer;\n  begin?(): void;\n  end?(): void;\n}\n\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDefined} from '../../util/assert';\nimport {assertLView} from '../assert';\nimport {readPatchedLView} from '../context_discovery';\nimport {LContainer} from '../interfaces/container';\nimport {isLContainer, isLView} from '../interfaces/type_checks';\nimport {CHILD_HEAD, CONTEXT, FLAGS, LView, LViewFlags, NEXT, PARENT, RootContext} from '../interfaces/view';\n\n\n/**\n * Gets the parent LView of the passed LView, if the PARENT is an LContainer, will get the parent of\n * that LContainer, which is an LView\n * @param lView the lView whose parent to get\n */\nexport function getLViewParent(lView: LView): LView|null {\n  ngDevMode && assertLView(lView);\n  const parent = lView[PARENT];\n  return isLContainer(parent) ? parent[PARENT]! : parent;\n}\n\n/**\n * Retrieve the root view from any component or `LView` by walking the parent `LView` until\n * reaching the root `LView`.\n *\n * @param componentOrLView any component or `LView`\n */\nexport function getRootView<T>(componentOrLView: LView|{}): LView<T> {\n  ngDevMode && assertDefined(componentOrLView, 'component');\n  let lView = isLView(componentOrLView) ? componentOrLView : readPatchedLView(componentOrLView)!;\n  while (lView && !(lView[FLAGS] & LViewFlags.IsRoot)) {\n    lView = getLViewParent(lView)!;\n  }\n  ngDevMode && assertLView(lView);\n  return lView as LView<T>;\n}\n\n/**\n * Returns the `RootContext` instance that is associated with\n * the application where the target is situated. It does this by walking the parent views until it\n * gets to the root view, then getting the context off of that.\n *\n * @param viewOrComponent the `LView` or component to get the root context for.\n */\nexport function getRootContext<T>(viewOrComponent: LView<T>|{}): RootContext {\n  const rootView = getRootView(viewOrComponent);\n  ngDevMode &&\n      assertDefined(rootView[CONTEXT], 'RootView has no context. Perhaps it is disconnected?');\n  return rootView[CONTEXT] as RootContext;\n}\n\n\n/**\n * Gets the first `LContainer` in the LView or `null` if none exists.\n */\nexport function getFirstLContainer(lView: LView): LContainer|null {\n  return getNearestLContainer(lView[CHILD_HEAD]);\n}\n\n/**\n * Gets the next `LContainer` that is a sibling of the given container.\n */\nexport function getNextLContainer(container: LContainer): LContainer|null {\n  return getNearestLContainer(container[NEXT]);\n}\n\nfunction getNearestLContainer(viewOrContainer: LContainer|LView|null) {\n  while (viewOrContainer !== null && !isLContainer(viewOrContainer)) {\n    viewOrContainer = viewOrContainer[NEXT];\n  }\n  return viewOrContainer as LContainer | null;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ViewEncapsulation} from '../metadata/view';\nimport {RendererStyleFlags2} from '../render/api_flags';\nimport {addToArray, removeFromArray} from '../util/array_utils';\nimport {assertDefined, assertEqual, assertFunction, assertString} from '../util/assert';\nimport {escapeCommentText} from '../util/dom';\n\nimport {assertLContainer, assertLView, assertParentView, assertProjectionSlots, assertTNodeForLView} from './assert';\nimport {attachPatchData} from './context_discovery';\nimport {icuContainerIterate} from './i18n/i18n_tree_shaking';\nimport {CONTAINER_HEADER_OFFSET, HAS_TRANSPLANTED_VIEWS, LContainer, MOVED_VIEWS, NATIVE, unusedValueExportToPlacateAjd as unused1} from './interfaces/container';\nimport {ComponentDef} from './interfaces/definition';\nimport {NodeInjectorFactory} from './interfaces/injector';\nimport {unregisterLView} from './interfaces/lview_tracking';\nimport {TElementNode, TIcuContainerNode, TNode, TNodeFlags, TNodeType, TProjectionNode, unusedValueExportToPlacateAjd as unused2} from './interfaces/node';\nimport {unusedValueExportToPlacateAjd as unused3} from './interfaces/projection';\nimport {Renderer, unusedValueExportToPlacateAjd as unused4} from './interfaces/renderer';\nimport {RComment, RElement, RNode, RTemplate, RText} from './interfaces/renderer_dom';\nimport {isLContainer, isLView} from './interfaces/type_checks';\nimport {CHILD_HEAD, CLEANUP, DECLARATION_COMPONENT_VIEW, DECLARATION_LCONTAINER, DestroyHookData, FLAGS, HookData, HookFn, HOST, LView, LViewFlags, NEXT, PARENT, QUERIES, RENDERER, T_HOST, TVIEW, TView, TViewType, unusedValueExportToPlacateAjd as unused5} from './interfaces/view';\nimport {assertTNodeType} from './node_assert';\nimport {profiler, ProfilerEvent} from './profiler';\nimport {getLViewParent} from './util/view_traversal_utils';\nimport {getNativeByTNode, unwrapRNode, updateTransplantedViewCount} from './util/view_utils';\n\n\n\nconst unusedValueToPlacateAjd = unused1 + unused2 + unused3 + unused4 + unused5;\n\nconst enum WalkTNodeTreeAction {\n  /** node create in the native environment. Run on initial creation. */\n  Create = 0,\n\n  /**\n   * node insert in the native environment.\n   * Run when existing node has been detached and needs to be re-attached.\n   */\n  Insert = 1,\n\n  /** node detach from the native environment */\n  Detach = 2,\n\n  /** node destruction using the renderer's API */\n  Destroy = 3,\n}\n\n\n\n/**\n * NOTE: for performance reasons, the possible actions are inlined within the function instead of\n * being passed as an argument.\n */\nfunction applyToElementOrContainer(\n    action: WalkTNodeTreeAction, renderer: Renderer, parent: RElement|null,\n    lNodeToHandle: RNode|LContainer|LView, beforeNode?: RNode|null) {\n  // If this slot was allocated for a text node dynamically created by i18n, the text node itself\n  // won't be created until i18nApply() in the update block, so this node should be skipped.\n  // For more info, see \"ICU expressions should work inside an ngTemplateOutlet inside an ngFor\"\n  // in `i18n_spec.ts`.\n  if (lNodeToHandle != null) {\n    let lContainer: LContainer|undefined;\n    let isComponent = false;\n    // We are expecting an RNode, but in the case of a component or LContainer the `RNode` is\n    // wrapped in an array which needs to be unwrapped. We need to know if it is a component and if\n    // it has LContainer so that we can process all of those cases appropriately.\n    if (isLContainer(lNodeToHandle)) {\n      lContainer = lNodeToHandle;\n    } else if (isLView(lNodeToHandle)) {\n      isComponent = true;\n      ngDevMode && assertDefined(lNodeToHandle[HOST], 'HOST must be defined for a component LView');\n      lNodeToHandle = lNodeToHandle[HOST]!;\n    }\n    const rNode: RNode = unwrapRNode(lNodeToHandle);\n\n    if (action === WalkTNodeTreeAction.Create && parent !== null) {\n      if (beforeNode == null) {\n        nativeAppendChild(renderer, parent, rNode);\n      } else {\n        nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);\n      }\n    } else if (action === WalkTNodeTreeAction.Insert && parent !== null) {\n      nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);\n    } else if (action === WalkTNodeTreeAction.Detach) {\n      nativeRemoveNode(renderer, rNode, isComponent);\n    } else if (action === WalkTNodeTreeAction.Destroy) {\n      ngDevMode && ngDevMode.rendererDestroyNode++;\n      renderer.destroyNode!(rNode);\n    }\n    if (lContainer != null) {\n      applyContainer(renderer, action, lContainer, parent, beforeNode);\n    }\n  }\n}\n\nexport function createTextNode(renderer: Renderer, value: string): RText {\n  ngDevMode && ngDevMode.rendererCreateTextNode++;\n  ngDevMode && ngDevMode.rendererSetText++;\n  return renderer.createText(value);\n}\n\nexport function updateTextNode(renderer: Renderer, rNode: RText, value: string): void {\n  ngDevMode && ngDevMode.rendererSetText++;\n  renderer.setValue(rNode, value);\n}\n\nexport function createCommentNode(renderer: Renderer, value: string): RComment {\n  ngDevMode && ngDevMode.rendererCreateComment++;\n  return renderer.createComment(escapeCommentText(value));\n}\n\n/**\n * Creates a native element from a tag name, using a renderer.\n * @param renderer A renderer to use\n * @param name the tag name\n * @param namespace Optional namespace for element.\n * @returns the element created\n */\nexport function createElementNode(\n    renderer: Renderer, name: string, namespace: string|null): RElement {\n  ngDevMode && ngDevMode.rendererCreateElement++;\n  return renderer.createElement(name, namespace);\n}\n\n\n/**\n * Removes all DOM elements associated with a view.\n *\n * Because some root nodes of the view may be containers, we sometimes need\n * to propagate deeply into the nested containers to remove all elements in the\n * views beneath it.\n *\n * @param tView The `TView' of the `LView` from which elements should be added or removed\n * @param lView The view from which elements should be added or removed\n */\nexport function removeViewFromContainer(tView: TView, lView: LView): void {\n  const renderer = lView[RENDERER];\n  applyView(tView, lView, renderer, WalkTNodeTreeAction.Detach, null, null);\n  lView[HOST] = null;\n  lView[T_HOST] = null;\n}\n\n/**\n * Adds all DOM elements associated with a view.\n *\n * Because some root nodes of the view may be containers, we sometimes need\n * to propagate deeply into the nested containers to add all elements in the\n * views beneath it.\n *\n * @param tView The `TView' of the `LView` from which elements should be added or removed\n * @param parentTNode The `TNode` where the `LView` should be attached to.\n * @param renderer Current renderer to use for DOM manipulations.\n * @param lView The view from which elements should be added or removed\n * @param parentNativeNode The parent `RElement` where it should be inserted into.\n * @param beforeNode The node before which elements should be added, if insert mode\n */\nexport function addViewToContainer(\n    tView: TView, parentTNode: TNode, renderer: Renderer, lView: LView, parentNativeNode: RElement,\n    beforeNode: RNode|null): void {\n  lView[HOST] = parentNativeNode;\n  lView[T_HOST] = parentTNode;\n  applyView(tView, lView, renderer, WalkTNodeTreeAction.Insert, parentNativeNode, beforeNode);\n}\n\n\n/**\n * Detach a `LView` from the DOM by detaching its nodes.\n *\n * @param tView The `TView' of the `LView` to be detached\n * @param lView the `LView` to be detached.\n */\nexport function renderDetachView(tView: TView, lView: LView) {\n  applyView(tView, lView, lView[RENDERER], WalkTNodeTreeAction.Detach, null, null);\n}\n\n/**\n * Traverses down and up the tree of views and containers to remove listeners and\n * call onDestroy callbacks.\n *\n * Notes:\n *  - Because it's used for onDestroy calls, it needs to be bottom-up.\n *  - Must process containers instead of their views to avoid splicing\n *  when views are destroyed and re-added.\n *  - Using a while loop because it's faster than recursion\n *  - Destroy only called on movement to sibling or movement to parent (laterally or up)\n *\n *  @param rootView The view to destroy\n */\nexport function destroyViewTree(rootView: LView): void {\n  // If the view has no children, we can clean it up and return early.\n  let lViewOrLContainer = rootView[CHILD_HEAD];\n  if (!lViewOrLContainer) {\n    return cleanUpView(rootView[TVIEW], rootView);\n  }\n\n  while (lViewOrLContainer) {\n    let next: LView|LContainer|null = null;\n\n    if (isLView(lViewOrLContainer)) {\n      // If LView, traverse down to child.\n      next = lViewOrLContainer[CHILD_HEAD];\n    } else {\n      ngDevMode && assertLContainer(lViewOrLContainer);\n      // If container, traverse down to its first LView.\n      const firstView: LView|undefined = lViewOrLContainer[CONTAINER_HEADER_OFFSET];\n      if (firstView) next = firstView;\n    }\n\n    if (!next) {\n      // Only clean up view when moving to the side or up, as destroy hooks\n      // should be called in order from the bottom up.\n      while (lViewOrLContainer && !lViewOrLContainer![NEXT] && lViewOrLContainer !== rootView) {\n        if (isLView(lViewOrLContainer)) {\n          cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);\n        }\n        lViewOrLContainer = lViewOrLContainer[PARENT];\n      }\n      if (lViewOrLContainer === null) lViewOrLContainer = rootView;\n      if (isLView(lViewOrLContainer)) {\n        cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);\n      }\n      next = lViewOrLContainer && lViewOrLContainer![NEXT];\n    }\n    lViewOrLContainer = next;\n  }\n}\n\n/**\n * Inserts a view into a container.\n *\n * This adds the view to the container's array of active views in the correct\n * position. It also adds the view's elements to the DOM if the container isn't a\n * root node of another view (in that case, the view's elements will be added when\n * the container's parent view is added later).\n *\n * @param tView The `TView' of the `LView` to insert\n * @param lView The view to insert\n * @param lContainer The container into which the view should be inserted\n * @param index Which index in the container to insert the child view into\n */\nexport function insertView(tView: TView, lView: LView, lContainer: LContainer, index: number) {\n  ngDevMode && assertLView(lView);\n  ngDevMode && assertLContainer(lContainer);\n  const indexInContainer = CONTAINER_HEADER_OFFSET + index;\n  const containerLength = lContainer.length;\n\n  if (index > 0) {\n    // This is a new view, we need to add it to the children.\n    lContainer[indexInContainer - 1][NEXT] = lView;\n  }\n  if (index < containerLength - CONTAINER_HEADER_OFFSET) {\n    lView[NEXT] = lContainer[indexInContainer];\n    addToArray(lContainer, CONTAINER_HEADER_OFFSET + index, lView);\n  } else {\n    lContainer.push(lView);\n    lView[NEXT] = null;\n  }\n\n  lView[PARENT] = lContainer;\n\n  // track views where declaration and insertion points are different\n  const declarationLContainer = lView[DECLARATION_LCONTAINER];\n  if (declarationLContainer !== null && lContainer !== declarationLContainer) {\n    trackMovedView(declarationLContainer, lView);\n  }\n\n  // notify query that a new view has been added\n  const lQueries = lView[QUERIES];\n  if (lQueries !== null) {\n    lQueries.insertView(tView);\n  }\n\n  // Sets the attached flag\n  lView[FLAGS] |= LViewFlags.Attached;\n}\n\n/**\n * Track views created from the declaration container (TemplateRef) and inserted into a\n * different LContainer.\n */\nfunction trackMovedView(declarationContainer: LContainer, lView: LView) {\n  ngDevMode && assertDefined(lView, 'LView required');\n  ngDevMode && assertLContainer(declarationContainer);\n  const movedViews = declarationContainer[MOVED_VIEWS];\n  const insertedLContainer = lView[PARENT] as LContainer;\n  ngDevMode && assertLContainer(insertedLContainer);\n  const insertedComponentLView = insertedLContainer[PARENT]![DECLARATION_COMPONENT_VIEW];\n  ngDevMode && assertDefined(insertedComponentLView, 'Missing insertedComponentLView');\n  const declaredComponentLView = lView[DECLARATION_COMPONENT_VIEW];\n  ngDevMode && assertDefined(declaredComponentLView, 'Missing declaredComponentLView');\n  if (declaredComponentLView !== insertedComponentLView) {\n    // At this point the declaration-component is not same as insertion-component; this means that\n    // this is a transplanted view. Mark the declared lView as having transplanted views so that\n    // those views can participate in CD.\n    declarationContainer[HAS_TRANSPLANTED_VIEWS] = true;\n  }\n  if (movedViews === null) {\n    declarationContainer[MOVED_VIEWS] = [lView];\n  } else {\n    movedViews.push(lView);\n  }\n}\n\nfunction detachMovedView(declarationContainer: LContainer, lView: LView) {\n  ngDevMode && assertLContainer(declarationContainer);\n  ngDevMode &&\n      assertDefined(\n          declarationContainer[MOVED_VIEWS],\n          'A projected view should belong to a non-empty projected views collection');\n  const movedViews = declarationContainer[MOVED_VIEWS]!;\n  const declarationViewIndex = movedViews.indexOf(lView);\n  const insertionLContainer = lView[PARENT] as LContainer;\n  ngDevMode && assertLContainer(insertionLContainer);\n\n  // If the view was marked for refresh but then detached before it was checked (where the flag\n  // would be cleared and the counter decremented), we need to decrement the view counter here\n  // instead.\n  if (lView[FLAGS] & LViewFlags.RefreshTransplantedView) {\n    lView[FLAGS] &= ~LViewFlags.RefreshTransplantedView;\n    updateTransplantedViewCount(insertionLContainer, -1);\n  }\n\n  movedViews.splice(declarationViewIndex, 1);\n}\n\n/**\n * Detaches a view from a container.\n *\n * This method removes the view from the container's array of active views. It also\n * removes the view's elements from the DOM.\n *\n * @param lContainer The container from which to detach a view\n * @param removeIndex The index of the view to detach\n * @returns Detached LView instance.\n */\nexport function detachView(lContainer: LContainer, removeIndex: number): LView|undefined {\n  if (lContainer.length <= CONTAINER_HEADER_OFFSET) return;\n\n  const indexInContainer = CONTAINER_HEADER_OFFSET + removeIndex;\n  const viewToDetach = lContainer[indexInContainer];\n\n  if (viewToDetach) {\n    const declarationLContainer = viewToDetach[DECLARATION_LCONTAINER];\n    if (declarationLContainer !== null && declarationLContainer !== lContainer) {\n      detachMovedView(declarationLContainer, viewToDetach);\n    }\n\n\n    if (removeIndex > 0) {\n      lContainer[indexInContainer - 1][NEXT] = viewToDetach[NEXT] as LView;\n    }\n    const removedLView = removeFromArray(lContainer, CONTAINER_HEADER_OFFSET + removeIndex);\n    removeViewFromContainer(viewToDetach[TVIEW], viewToDetach);\n\n    // notify query that a view has been removed\n    const lQueries = removedLView[QUERIES];\n    if (lQueries !== null) {\n      lQueries.detachView(removedLView[TVIEW]);\n    }\n\n    viewToDetach[PARENT] = null;\n    viewToDetach[NEXT] = null;\n    // Unsets the attached flag\n    viewToDetach[FLAGS] &= ~LViewFlags.Attached;\n  }\n  return viewToDetach;\n}\n\n/**\n * A standalone function which destroys an LView,\n * conducting clean up (e.g. removing listeners, calling onDestroys).\n *\n * @param tView The `TView' of the `LView` to be destroyed\n * @param lView The view to be destroyed.\n */\nexport function destroyLView(tView: TView, lView: LView) {\n  if (!(lView[FLAGS] & LViewFlags.Destroyed)) {\n    const renderer = lView[RENDERER];\n    if (renderer.destroyNode) {\n      applyView(tView, lView, renderer, WalkTNodeTreeAction.Destroy, null, null);\n    }\n\n    destroyViewTree(lView);\n  }\n}\n\n/**\n * Calls onDestroys hooks for all directives and pipes in a given view and then removes all\n * listeners. Listeners are removed as the last step so events delivered in the onDestroys hooks\n * can be propagated to @Output listeners.\n *\n * @param tView `TView` for the `LView` to clean up.\n * @param lView The LView to clean up\n */\nfunction cleanUpView(tView: TView, lView: LView): void {\n  if (!(lView[FLAGS] & LViewFlags.Destroyed)) {\n    // Usually the Attached flag is removed when the view is detached from its parent, however\n    // if it's a root view, the flag won't be unset hence why we're also removing on destroy.\n    lView[FLAGS] &= ~LViewFlags.Attached;\n\n    // Mark the LView as destroyed *before* executing the onDestroy hooks. An onDestroy hook\n    // runs arbitrary user code, which could include its own `viewRef.destroy()` (or similar). If\n    // We don't flag the view as destroyed before the hooks, this could lead to an infinite loop.\n    // This also aligns with the ViewEngine behavior. It also means that the onDestroy hook is\n    // really more of an \"afterDestroy\" hook if you think about it.\n    lView[FLAGS] |= LViewFlags.Destroyed;\n\n    executeOnDestroys(tView, lView);\n    processCleanups(tView, lView);\n    // For component views only, the local renderer is destroyed at clean up time.\n    if (lView[TVIEW].type === TViewType.Component) {\n      ngDevMode && ngDevMode.rendererDestroy++;\n      lView[RENDERER].destroy();\n    }\n\n    const declarationContainer = lView[DECLARATION_LCONTAINER];\n    // we are dealing with an embedded view that is still inserted into a container\n    if (declarationContainer !== null && isLContainer(lView[PARENT])) {\n      // and this is a projected view\n      if (declarationContainer !== lView[PARENT]) {\n        detachMovedView(declarationContainer, lView);\n      }\n\n      // For embedded views still attached to a container: remove query result from this view.\n      const lQueries = lView[QUERIES];\n      if (lQueries !== null) {\n        lQueries.detachView(tView);\n      }\n    }\n\n    // Unregister the view once everything else has been cleaned up.\n    unregisterLView(lView);\n  }\n}\n\n/** Removes listeners and unsubscribes from output subscriptions */\nfunction processCleanups(tView: TView, lView: LView): void {\n  const tCleanup = tView.cleanup;\n  const lCleanup = lView[CLEANUP]!;\n  // `LCleanup` contains both share information with `TCleanup` as well as instance specific\n  // information appended at the end. We need to know where the end of the `TCleanup` information\n  // is, and we track this with `lastLCleanupIndex`.\n  let lastLCleanupIndex = -1;\n  if (tCleanup !== null) {\n    for (let i = 0; i < tCleanup.length - 1; i += 2) {\n      if (typeof tCleanup[i] === 'string') {\n        // This is a native DOM listener\n        const idxOrTargetGetter = tCleanup[i + 1];\n        const target = typeof idxOrTargetGetter === 'function' ?\n            idxOrTargetGetter(lView) :\n            unwrapRNode(lView[idxOrTargetGetter]);\n        const listener = lCleanup[lastLCleanupIndex = tCleanup[i + 2]];\n        const useCaptureOrSubIdx = tCleanup[i + 3];\n        if (typeof useCaptureOrSubIdx === 'boolean') {\n          // native DOM listener registered with Renderer3\n          target.removeEventListener(tCleanup[i], listener, useCaptureOrSubIdx);\n        } else {\n          if (useCaptureOrSubIdx >= 0) {\n            // unregister\n            lCleanup[lastLCleanupIndex = useCaptureOrSubIdx]();\n          } else {\n            // Subscription\n            lCleanup[lastLCleanupIndex = -useCaptureOrSubIdx].unsubscribe();\n          }\n        }\n        i += 2;\n      } else {\n        // This is a cleanup function that is grouped with the index of its context\n        const context = lCleanup[lastLCleanupIndex = tCleanup[i + 1]];\n        tCleanup[i].call(context);\n      }\n    }\n  }\n  if (lCleanup !== null) {\n    for (let i = lastLCleanupIndex + 1; i < lCleanup.length; i++) {\n      const instanceCleanupFn = lCleanup[i];\n      ngDevMode && assertFunction(instanceCleanupFn, 'Expecting instance cleanup function.');\n      instanceCleanupFn();\n    }\n    lView[CLEANUP] = null;\n  }\n}\n\n/** Calls onDestroy hooks for this view */\nfunction executeOnDestroys(tView: TView, lView: LView): void {\n  let destroyHooks: DestroyHookData|null;\n\n  if (tView != null && (destroyHooks = tView.destroyHooks) != null) {\n    for (let i = 0; i < destroyHooks.length; i += 2) {\n      const context = lView[destroyHooks[i] as number];\n\n      // Only call the destroy hook if the context has been requested.\n      if (!(context instanceof NodeInjectorFactory)) {\n        const toCall = destroyHooks[i + 1] as HookFn | HookData;\n\n        if (Array.isArray(toCall)) {\n          for (let j = 0; j < toCall.length; j += 2) {\n            const callContext = context[toCall[j] as number];\n            const hook = toCall[j + 1] as HookFn;\n            profiler(ProfilerEvent.LifecycleHookStart, callContext, hook);\n            try {\n              hook.call(callContext);\n            } finally {\n              profiler(ProfilerEvent.LifecycleHookEnd, callContext, hook);\n            }\n          }\n        } else {\n          profiler(ProfilerEvent.LifecycleHookStart, context, toCall);\n          try {\n            toCall.call(context);\n          } finally {\n            profiler(ProfilerEvent.LifecycleHookEnd, context, toCall);\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Returns a native element if a node can be inserted into the given parent.\n *\n * There are two reasons why we may not be able to insert a element immediately.\n * - Projection: When creating a child content element of a component, we have to skip the\n *   insertion because the content of a component will be projected.\n *   `<component><content>delayed due to projection</content></component>`\n * - Parent container is disconnected: This can happen when we are inserting a view into\n *   parent container, which itself is disconnected. For example the parent container is part\n *   of a View which has not be inserted or is made for projection but has not been inserted\n *   into destination.\n *\n * @param tView: Current `TView`.\n * @param tNode: `TNode` for which we wish to retrieve render parent.\n * @param lView: Current `LView`.\n */\nexport function getParentRElement(tView: TView, tNode: TNode, lView: LView): RElement|null {\n  return getClosestRElement(tView, tNode.parent, lView);\n}\n\n/**\n * Get closest `RElement` or `null` if it can't be found.\n *\n * If `TNode` is `TNodeType.Element` => return `RElement` at `LView[tNode.index]` location.\n * If `TNode` is `TNodeType.ElementContainer|IcuContain` => return the parent (recursively).\n * If `TNode` is `null` then return host `RElement`:\n *   - return `null` if projection\n *   - return `null` if parent container is disconnected (we have no parent.)\n *\n * @param tView: Current `TView`.\n * @param tNode: `TNode` for which we wish to retrieve `RElement` (or `null` if host element is\n *     needed).\n * @param lView: Current `LView`.\n * @returns `null` if the `RElement` can't be determined at this time (no parent / projection)\n */\nexport function getClosestRElement(tView: TView, tNode: TNode|null, lView: LView): RElement|null {\n  let parentTNode: TNode|null = tNode;\n  // Skip over element and ICU containers as those are represented by a comment node and\n  // can't be used as a render parent.\n  while (parentTNode !== null &&\n         (parentTNode.type & (TNodeType.ElementContainer | TNodeType.Icu))) {\n    tNode = parentTNode;\n    parentTNode = tNode.parent;\n  }\n\n  // If the parent tNode is null, then we are inserting across views: either into an embedded view\n  // or a component view.\n  if (parentTNode === null) {\n    // We are inserting a root element of the component view into the component host element and\n    // it should always be eager.\n    return lView[HOST];\n  } else {\n    ngDevMode && assertTNodeType(parentTNode, TNodeType.AnyRNode | TNodeType.Container);\n    if (parentTNode.flags & TNodeFlags.isComponentHost) {\n      ngDevMode && assertTNodeForLView(parentTNode, lView);\n      const encapsulation =\n          (tView.data[parentTNode.directiveStart] as ComponentDef<unknown>).encapsulation;\n      // We've got a parent which is an element in the current view. We just need to verify if the\n      // parent element is not a component. Component's content nodes are not inserted immediately\n      // because they will be projected, and so doing insert at this point would be wasteful.\n      // Since the projection would then move it to its final destination. Note that we can't\n      // make this assumption when using the Shadow DOM, because the native projection placeholders\n      // (<content> or <slot>) have to be in place as elements are being inserted.\n      if (encapsulation === ViewEncapsulation.None ||\n          encapsulation === ViewEncapsulation.Emulated) {\n        return null;\n      }\n    }\n\n    return getNativeByTNode(parentTNode, lView) as RElement;\n  }\n}\n\n/**\n * Inserts a native node before another native node for a given parent.\n * This is a utility function that can be used when native nodes were determined.\n */\nexport function nativeInsertBefore(\n    renderer: Renderer, parent: RElement, child: RNode, beforeNode: RNode|null,\n    isMove: boolean): void {\n  ngDevMode && ngDevMode.rendererInsertBefore++;\n  renderer.insertBefore(parent, child, beforeNode, isMove);\n}\n\nfunction nativeAppendChild(renderer: Renderer, parent: RElement, child: RNode): void {\n  ngDevMode && ngDevMode.rendererAppendChild++;\n  ngDevMode && assertDefined(parent, 'parent node must be defined');\n  renderer.appendChild(parent, child);\n}\n\nfunction nativeAppendOrInsertBefore(\n    renderer: Renderer, parent: RElement, child: RNode, beforeNode: RNode|null, isMove: boolean) {\n  if (beforeNode !== null) {\n    nativeInsertBefore(renderer, parent, child, beforeNode, isMove);\n  } else {\n    nativeAppendChild(renderer, parent, child);\n  }\n}\n\n/** Removes a node from the DOM given its native parent. */\nfunction nativeRemoveChild(\n    renderer: Renderer, parent: RElement, child: RNode, isHostElement?: boolean): void {\n  renderer.removeChild(parent, child, isHostElement);\n}\n\n/** Checks if an element is a `<template>` node. */\nfunction isTemplateNode(node: RElement): node is RTemplate {\n  return node.tagName === 'TEMPLATE' && (node as RTemplate).content !== undefined;\n}\n\n/**\n * Returns a native parent of a given native node.\n */\nexport function nativeParentNode(renderer: Renderer, node: RNode): RElement|null {\n  return renderer.parentNode(node);\n}\n\n/**\n * Returns a native sibling of a given native node.\n */\nexport function nativeNextSibling(renderer: Renderer, node: RNode): RNode|null {\n  return renderer.nextSibling(node);\n}\n\n/**\n * Find a node in front of which `currentTNode` should be inserted.\n *\n * This method determines the `RNode` in front of which we should insert the `currentRNode`. This\n * takes `TNode.insertBeforeIndex` into account if i18n code has been invoked.\n *\n * @param parentTNode parent `TNode`\n * @param currentTNode current `TNode` (The node which we would like to insert into the DOM)\n * @param lView current `LView`\n */\nfunction getInsertInFrontOfRNode(parentTNode: TNode, currentTNode: TNode, lView: LView): RNode|\n    null {\n  return _getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView);\n}\n\n\n/**\n * Find a node in front of which `currentTNode` should be inserted. (Does not take i18n into\n * account)\n *\n * This method determines the `RNode` in front of which we should insert the `currentRNode`. This\n * does not take `TNode.insertBeforeIndex` into account.\n *\n * @param parentTNode parent `TNode`\n * @param currentTNode current `TNode` (The node which we would like to insert into the DOM)\n * @param lView current `LView`\n */\nexport function getInsertInFrontOfRNodeWithNoI18n(\n    parentTNode: TNode, currentTNode: TNode, lView: LView): RNode|null {\n  if (parentTNode.type & (TNodeType.ElementContainer | TNodeType.Icu)) {\n    return getNativeByTNode(parentTNode, lView);\n  }\n  return null;\n}\n\n/**\n * Tree shakable boundary for `getInsertInFrontOfRNodeWithI18n` function.\n *\n * This function will only be set if i18n code runs.\n */\nlet _getInsertInFrontOfRNodeWithI18n: (parentTNode: TNode, currentTNode: TNode, lView: LView) =>\n    RNode | null = getInsertInFrontOfRNodeWithNoI18n;\n\n/**\n * Tree shakable boundary for `processI18nInsertBefore` function.\n *\n * This function will only be set if i18n code runs.\n */\nlet _processI18nInsertBefore: (\n    renderer: Renderer, childTNode: TNode, lView: LView, childRNode: RNode|RNode[],\n    parentRElement: RElement|null) => void;\n\nexport function setI18nHandling(\n    getInsertInFrontOfRNodeWithI18n: (parentTNode: TNode, currentTNode: TNode, lView: LView) =>\n        RNode | null,\n    processI18nInsertBefore: (\n        renderer: Renderer, childTNode: TNode, lView: LView, childRNode: RNode|RNode[],\n        parentRElement: RElement|null) => void) {\n  _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithI18n;\n  _processI18nInsertBefore = processI18nInsertBefore;\n}\n\n/**\n * Appends the `child` native node (or a collection of nodes) to the `parent`.\n *\n * @param tView The `TView' to be appended\n * @param lView The current LView\n * @param childRNode The native child (or children) that should be appended\n * @param childTNode The TNode of the child element\n */\nexport function appendChild(\n    tView: TView, lView: LView, childRNode: RNode|RNode[], childTNode: TNode): void {\n  const parentRNode = getParentRElement(tView, childTNode, lView);\n  const renderer = lView[RENDERER];\n  const parentTNode: TNode = childTNode.parent || lView[T_HOST]!;\n  const anchorNode = getInsertInFrontOfRNode(parentTNode, childTNode, lView);\n  if (parentRNode != null) {\n    if (Array.isArray(childRNode)) {\n      for (let i = 0; i < childRNode.length; i++) {\n        nativeAppendOrInsertBefore(renderer, parentRNode, childRNode[i], anchorNode, false);\n      }\n    } else {\n      nativeAppendOrInsertBefore(renderer, parentRNode, childRNode, anchorNode, false);\n    }\n  }\n\n  _processI18nInsertBefore !== undefined &&\n      _processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRNode);\n}\n\n/**\n * Returns the first native node for a given LView, starting from the provided TNode.\n *\n * Native nodes are returned in the order in which those appear in the native tree (DOM).\n */\nfunction getFirstNativeNode(lView: LView, tNode: TNode|null): RNode|null {\n  if (tNode !== null) {\n    ngDevMode &&\n        assertTNodeType(\n            tNode,\n            TNodeType.AnyRNode | TNodeType.AnyContainer | TNodeType.Icu | TNodeType.Projection);\n\n    const tNodeType = tNode.type;\n    if (tNodeType & TNodeType.AnyRNode) {\n      return getNativeByTNode(tNode, lView);\n    } else if (tNodeType & TNodeType.Container) {\n      return getBeforeNodeForView(-1, lView[tNode.index]);\n    } else if (tNodeType & TNodeType.ElementContainer) {\n      const elIcuContainerChild = tNode.child;\n      if (elIcuContainerChild !== null) {\n        return getFirstNativeNode(lView, elIcuContainerChild);\n      } else {\n        const rNodeOrLContainer = lView[tNode.index];\n        if (isLContainer(rNodeOrLContainer)) {\n          return getBeforeNodeForView(-1, rNodeOrLContainer);\n        } else {\n          return unwrapRNode(rNodeOrLContainer);\n        }\n      }\n    } else if (tNodeType & TNodeType.Icu) {\n      let nextRNode = icuContainerIterate(tNode as TIcuContainerNode, lView);\n      let rNode: RNode|null = nextRNode();\n      // If the ICU container has no nodes, than we use the ICU anchor as the node.\n      return rNode || unwrapRNode(lView[tNode.index]);\n    } else {\n      const projectionNodes = getProjectionNodes(lView, tNode);\n      if (projectionNodes !== null) {\n        if (Array.isArray(projectionNodes)) {\n          return projectionNodes[0];\n        }\n        const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);\n        ngDevMode && assertParentView(parentView);\n        return getFirstNativeNode(parentView!, projectionNodes);\n      } else {\n        return getFirstNativeNode(lView, tNode.next);\n      }\n    }\n  }\n\n  return null;\n}\n\nexport function getProjectionNodes(lView: LView, tNode: TNode|null): TNode|RNode[]|null {\n  if (tNode !== null) {\n    const componentView = lView[DECLARATION_COMPONENT_VIEW];\n    const componentHost = componentView[T_HOST] as TElementNode;\n    const slotIdx = tNode.projection as number;\n    ngDevMode && assertProjectionSlots(lView);\n    return componentHost.projection![slotIdx];\n  }\n  return null;\n}\n\nexport function getBeforeNodeForView(viewIndexInContainer: number, lContainer: LContainer): RNode|\n    null {\n  const nextViewIndex = CONTAINER_HEADER_OFFSET + viewIndexInContainer + 1;\n  if (nextViewIndex < lContainer.length) {\n    const lView = lContainer[nextViewIndex] as LView;\n    const firstTNodeOfView = lView[TVIEW].firstChild;\n    if (firstTNodeOfView !== null) {\n      return getFirstNativeNode(lView, firstTNodeOfView);\n    }\n  }\n\n  return lContainer[NATIVE];\n}\n\n/**\n * Removes a native node itself using a given renderer. To remove the node we are looking up its\n * parent from the native tree as not all platforms / browsers support the equivalent of\n * node.remove().\n *\n * @param renderer A renderer to be used\n * @param rNode The native node that should be removed\n * @param isHostElement A flag indicating if a node to be removed is a host of a component.\n */\nexport function nativeRemoveNode(renderer: Renderer, rNode: RNode, isHostElement?: boolean): void {\n  ngDevMode && ngDevMode.rendererRemoveNode++;\n  const nativeParent = nativeParentNode(renderer, rNode);\n  if (nativeParent) {\n    nativeRemoveChild(renderer, nativeParent, rNode, isHostElement);\n  }\n}\n\n\n/**\n * Performs the operation of `action` on the node. Typically this involves inserting or removing\n * nodes on the LView or projection boundary.\n */\nfunction applyNodes(\n    renderer: Renderer, action: WalkTNodeTreeAction, tNode: TNode|null, lView: LView,\n    parentRElement: RElement|null, beforeNode: RNode|null, isProjection: boolean) {\n  while (tNode != null) {\n    ngDevMode && assertTNodeForLView(tNode, lView);\n    ngDevMode &&\n        assertTNodeType(\n            tNode,\n            TNodeType.AnyRNode | TNodeType.AnyContainer | TNodeType.Projection | TNodeType.Icu);\n    const rawSlotValue = lView[tNode.index];\n    const tNodeType = tNode.type;\n    if (isProjection) {\n      if (action === WalkTNodeTreeAction.Create) {\n        rawSlotValue && attachPatchData(unwrapRNode(rawSlotValue), lView);\n        tNode.flags |= TNodeFlags.isProjected;\n      }\n    }\n    if ((tNode.flags & TNodeFlags.isDetached) !== TNodeFlags.isDetached) {\n      if (tNodeType & TNodeType.ElementContainer) {\n        applyNodes(renderer, action, tNode.child, lView, parentRElement, beforeNode, false);\n        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);\n      } else if (tNodeType & TNodeType.Icu) {\n        const nextRNode = icuContainerIterate(tNode as TIcuContainerNode, lView);\n        let rNode: RNode|null;\n        while (rNode = nextRNode()) {\n          applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);\n        }\n        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);\n      } else if (tNodeType & TNodeType.Projection) {\n        applyProjectionRecursive(\n            renderer, action, lView, tNode as TProjectionNode, parentRElement, beforeNode);\n      } else {\n        ngDevMode && assertTNodeType(tNode, TNodeType.AnyRNode | TNodeType.Container);\n        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);\n      }\n    }\n    tNode = isProjection ? tNode.projectionNext : tNode.next;\n  }\n}\n\n\n/**\n * `applyView` performs operation on the view as specified in `action` (insert, detach, destroy)\n *\n * Inserting a view without projection or containers at top level is simple. Just iterate over the\n * root nodes of the View, and for each node perform the `action`.\n *\n * Things get more complicated with containers and projections. That is because coming across:\n * - Container: implies that we have to insert/remove/destroy the views of that container as well\n *              which in turn can have their own Containers at the View roots.\n * - Projection: implies that we have to insert/remove/destroy the nodes of the projection. The\n *               complication is that the nodes we are projecting can themselves have Containers\n *               or other Projections.\n *\n * As you can see this is a very recursive problem. Yes recursion is not most efficient but the\n * code is complicated enough that trying to implemented with recursion becomes unmaintainable.\n *\n * @param tView The `TView' which needs to be inserted, detached, destroyed\n * @param lView The LView which needs to be inserted, detached, destroyed.\n * @param renderer Renderer to use\n * @param action action to perform (insert, detach, destroy)\n * @param parentRElement parent DOM element for insertion (Removal does not need it).\n * @param beforeNode Before which node the insertions should happen.\n */\nfunction applyView(\n    tView: TView, lView: LView, renderer: Renderer, action: WalkTNodeTreeAction.Destroy,\n    parentRElement: null, beforeNode: null): void;\nfunction applyView(\n    tView: TView, lView: LView, renderer: Renderer, action: WalkTNodeTreeAction,\n    parentRElement: RElement|null, beforeNode: RNode|null): void;\nfunction applyView(\n    tView: TView, lView: LView, renderer: Renderer, action: WalkTNodeTreeAction,\n    parentRElement: RElement|null, beforeNode: RNode|null): void {\n  applyNodes(renderer, action, tView.firstChild, lView, parentRElement, beforeNode, false);\n}\n\n/**\n * `applyProjection` performs operation on the projection.\n *\n * Inserting a projection requires us to locate the projected nodes from the parent component. The\n * complication is that those nodes themselves could be re-projected from their parent component.\n *\n * @param tView The `TView` of `LView` which needs to be inserted, detached, destroyed\n * @param lView The `LView` which needs to be inserted, detached, destroyed.\n * @param tProjectionNode node to project\n */\nexport function applyProjection(tView: TView, lView: LView, tProjectionNode: TProjectionNode) {\n  const renderer = lView[RENDERER];\n  const parentRNode = getParentRElement(tView, tProjectionNode, lView);\n  const parentTNode = tProjectionNode.parent || lView[T_HOST]!;\n  let beforeNode = getInsertInFrontOfRNode(parentTNode, tProjectionNode, lView);\n  applyProjectionRecursive(\n      renderer, WalkTNodeTreeAction.Create, lView, tProjectionNode, parentRNode, beforeNode);\n}\n\n/**\n * `applyProjectionRecursive` performs operation on the projection specified by `action` (insert,\n * detach, destroy)\n *\n * Inserting a projection requires us to locate the projected nodes from the parent component. The\n * complication is that those nodes themselves could be re-projected from their parent component.\n *\n * @param renderer Render to use\n * @param action action to perform (insert, detach, destroy)\n * @param lView The LView which needs to be inserted, detached, destroyed.\n * @param tProjectionNode node to project\n * @param parentRElement parent DOM element for insertion/removal.\n * @param beforeNode Before which node the insertions should happen.\n */\nfunction applyProjectionRecursive(\n    renderer: Renderer, action: WalkTNodeTreeAction, lView: LView, tProjectionNode: TProjectionNode,\n    parentRElement: RElement|null, beforeNode: RNode|null) {\n  const componentLView = lView[DECLARATION_COMPONENT_VIEW];\n  const componentNode = componentLView[T_HOST] as TElementNode;\n  ngDevMode &&\n      assertEqual(typeof tProjectionNode.projection, 'number', 'expecting projection index');\n  const nodeToProjectOrRNodes = componentNode.projection![tProjectionNode.projection]!;\n  if (Array.isArray(nodeToProjectOrRNodes)) {\n    // This should not exist, it is a bit of a hack. When we bootstrap a top level node and we\n    // need to support passing projectable nodes, so we cheat and put them in the TNode\n    // of the Host TView. (Yes we put instance info at the T Level). We can get away with it\n    // because we know that that TView is not shared and therefore it will not be a problem.\n    // This should be refactored and cleaned up.\n    for (let i = 0; i < nodeToProjectOrRNodes.length; i++) {\n      const rNode = nodeToProjectOrRNodes[i];\n      applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);\n    }\n  } else {\n    let nodeToProject: TNode|null = nodeToProjectOrRNodes;\n    const projectedComponentLView = componentLView[PARENT] as LView;\n    applyNodes(\n        renderer, action, nodeToProject, projectedComponentLView, parentRElement, beforeNode, true);\n  }\n}\n\n\n/**\n * `applyContainer` performs an operation on the container and its views as specified by\n * `action` (insert, detach, destroy)\n *\n * Inserting a Container is complicated by the fact that the container may have Views which\n * themselves have containers or projections.\n *\n * @param renderer Renderer to use\n * @param action action to perform (insert, detach, destroy)\n * @param lContainer The LContainer which needs to be inserted, detached, destroyed.\n * @param parentRElement parent DOM element for insertion/removal.\n * @param beforeNode Before which node the insertions should happen.\n */\nfunction applyContainer(\n    renderer: Renderer, action: WalkTNodeTreeAction, lContainer: LContainer,\n    parentRElement: RElement|null, beforeNode: RNode|null|undefined) {\n  ngDevMode && assertLContainer(lContainer);\n  const anchor = lContainer[NATIVE];  // LContainer has its own before node.\n  const native = unwrapRNode(lContainer);\n  // An LContainer can be created dynamically on any node by injecting ViewContainerRef.\n  // Asking for a ViewContainerRef on an element will result in a creation of a separate anchor\n  // node (comment in the DOM) that will be different from the LContainer's host node. In this\n  // particular case we need to execute action on 2 nodes:\n  // - container's host node (this is done in the executeActionOnElementOrContainer)\n  // - container's host node (this is done here)\n  if (anchor !== native) {\n    // This is very strange to me (Misko). I would expect that the native is same as anchor. I\n    // don't see a reason why they should be different, but they are.\n    //\n    // If they are we need to process the second anchor as well.\n    applyToElementOrContainer(action, renderer, parentRElement, anchor, beforeNode);\n  }\n  for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n    const lView = lContainer[i] as LView;\n    applyView(lView[TVIEW], lView, renderer, action, parentRElement, anchor);\n  }\n}\n\n/**\n * Writes class/style to element.\n *\n * @param renderer Renderer to use.\n * @param isClassBased `true` if it should be written to `class` (`false` to write to `style`)\n * @param rNode The Node to write to.\n * @param prop Property to write to. This would be the class/style name.\n * @param value Value to write. If `null`/`undefined`/`false` this is considered a remove (set/add\n *        otherwise).\n */\nexport function applyStyling(\n    renderer: Renderer, isClassBased: boolean, rNode: RElement, prop: string, value: any) {\n  if (isClassBased) {\n    // We actually want JS true/false here because any truthy value should add the class\n    if (!value) {\n      ngDevMode && ngDevMode.rendererRemoveClass++;\n      renderer.removeClass(rNode, prop);\n    } else {\n      ngDevMode && ngDevMode.rendererAddClass++;\n      renderer.addClass(rNode, prop);\n    }\n  } else {\n    let flags = prop.indexOf('-') === -1 ? undefined : RendererStyleFlags2.DashCase as number;\n    if (value == null /** || value === undefined */) {\n      ngDevMode && ngDevMode.rendererRemoveStyle++;\n      renderer.removeStyle(rNode, prop, flags);\n    } else {\n      // A value is important if it ends with `!important`. The style\n      // parser strips any semicolons at the end of the value.\n      const isImportant = typeof value === 'string' ? value.endsWith('!important') : false;\n\n      if (isImportant) {\n        // !important has to be stripped from the value for it to be valid.\n        value = value.slice(0, -10);\n        flags! |= RendererStyleFlags2.Important;\n      }\n\n      ngDevMode && ngDevMode.rendererSetStyle++;\n      renderer.setStyle(rNode, prop, value, flags);\n    }\n  }\n}\n\n\n/**\n * Write `cssText` to `RElement`.\n *\n * This function does direct write without any reconciliation. Used for writing initial values, so\n * that static styling values do not pull in the style parser.\n *\n * @param renderer Renderer to use\n * @param element The element which needs to be updated.\n * @param newValue The new class list to write.\n */\nexport function writeDirectStyle(renderer: Renderer, element: RElement, newValue: string) {\n  ngDevMode && assertString(newValue, '\\'newValue\\' should be a string');\n  renderer.setAttribute(element, 'style', newValue);\n  ngDevMode && ngDevMode.rendererSetStyle++;\n}\n\n/**\n * Write `className` to `RElement`.\n *\n * This function does direct write without any reconciliation. Used for writing initial values, so\n * that static styling values do not pull in the style parser.\n *\n * @param renderer Renderer to use\n * @param element The element which needs to be updated.\n * @param newValue The new class list to write.\n */\nexport function writeDirectClass(renderer: Renderer, element: RElement, newValue: string) {\n  ngDevMode && assertString(newValue, '\\'newValue\\' should be a string');\n  if (newValue === '') {\n    // There are tests in `google3` which expect `element.getAttribute('class')` to be `null`.\n    renderer.removeAttribute(element, 'class');\n  } else {\n    renderer.setAttribute(element, 'class', newValue);\n  }\n  ngDevMode && ngDevMode.rendererSetClassName++;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertNotEqual} from '../../util/assert';\nimport {CharCode} from '../../util/char_code';\n\n\n/**\n * Returns an index of `classToSearch` in `className` taking token boundaries into account.\n *\n * `classIndexOf('AB A', 'A', 0)` will be 3 (not 0 since `AB!==A`)\n *\n * @param className A string containing classes (whitespace separated)\n * @param classToSearch A class name to locate\n * @param startingIndex Starting location of search\n * @returns an index of the located class (or -1 if not found)\n */\nexport function classIndexOf(\n    className: string, classToSearch: string, startingIndex: number): number {\n  ngDevMode && assertNotEqual(classToSearch, '', 'can not look for \"\" string.');\n  let end = className.length;\n  while (true) {\n    const foundIndex = className.indexOf(classToSearch, startingIndex);\n    if (foundIndex === -1) return foundIndex;\n    if (foundIndex === 0 || className.charCodeAt(foundIndex - 1) <= CharCode.SPACE) {\n      // Ensure that it has leading whitespace\n      const length = classToSearch.length;\n      if (foundIndex + length === end ||\n          className.charCodeAt(foundIndex + length) <= CharCode.SPACE) {\n        // Ensure that it has trailing whitespace\n        return foundIndex;\n      }\n    }\n    // False positive, keep searching from where we left off.\n    startingIndex = foundIndex + 1;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport '../util/ng_dev_mode';\n\nimport {assertDefined, assertEqual, assertNotEqual} from '../util/assert';\n\nimport {AttributeMarker, TAttributes, TNode, TNodeType, unusedValueExportToPlacateAjd as unused1} from './interfaces/node';\nimport {CssSelector, CssSelectorList, SelectorFlags, unusedValueExportToPlacateAjd as unused2} from './interfaces/projection';\nimport {classIndexOf} from './styling/class_differ';\nimport {isNameOnlyAttributeMarker} from './util/attrs_utils';\n\nconst unusedValueToPlacateAjd = unused1 + unused2;\n\nconst NG_TEMPLATE_SELECTOR = 'ng-template';\n\n/**\n * Search the `TAttributes` to see if it contains `cssClassToMatch` (case insensitive)\n *\n * @param attrs `TAttributes` to search through.\n * @param cssClassToMatch class to match (lowercase)\n * @param isProjectionMode Whether or not class matching should look into the attribute `class` in\n *    addition to the `AttributeMarker.Classes`.\n */\nfunction isCssClassMatching(\n    attrs: TAttributes, cssClassToMatch: string, isProjectionMode: boolean): boolean {\n  // TODO(misko): The fact that this function needs to know about `isProjectionMode` seems suspect.\n  // It is strange to me that sometimes the class information comes in form of `class` attribute\n  // and sometimes in form of `AttributeMarker.Classes`. Some investigation is needed to determine\n  // if that is the right behavior.\n  ngDevMode &&\n      assertEqual(\n          cssClassToMatch, cssClassToMatch.toLowerCase(), 'Class name expected to be lowercase.');\n  let i = 0;\n  while (i < attrs.length) {\n    let item = attrs[i++];\n    if (isProjectionMode && item === 'class') {\n      item = attrs[i] as string;\n      if (classIndexOf(item.toLowerCase(), cssClassToMatch, 0) !== -1) {\n        return true;\n      }\n    } else if (item === AttributeMarker.Classes) {\n      // We found the classes section. Start searching for the class.\n      while (i < attrs.length && typeof (item = attrs[i++]) == 'string') {\n        // while we have strings\n        if (item.toLowerCase() === cssClassToMatch) return true;\n      }\n      return false;\n    }\n  }\n  return false;\n}\n\n/**\n * Checks whether the `tNode` represents an inline template (e.g. `*ngFor`).\n *\n * @param tNode current TNode\n */\nexport function isInlineTemplate(tNode: TNode): boolean {\n  return tNode.type === TNodeType.Container && tNode.value !== NG_TEMPLATE_SELECTOR;\n}\n\n/**\n * Function that checks whether a given tNode matches tag-based selector and has a valid type.\n *\n * Matching can be performed in 2 modes: projection mode (when we project nodes) and regular\n * directive matching mode:\n * - in the \"directive matching\" mode we do _not_ take TContainer's tagName into account if it is\n * different from NG_TEMPLATE_SELECTOR (value different from NG_TEMPLATE_SELECTOR indicates that a\n * tag name was extracted from * syntax so we would match the same directive twice);\n * - in the \"projection\" mode, we use a tag name potentially extracted from the * syntax processing\n * (applicable to TNodeType.Container only).\n */\nfunction hasTagAndTypeMatch(\n    tNode: TNode, currentSelector: string, isProjectionMode: boolean): boolean {\n  const tagNameToCompare =\n      tNode.type === TNodeType.Container && !isProjectionMode ? NG_TEMPLATE_SELECTOR : tNode.value;\n  return currentSelector === tagNameToCompare;\n}\n\n/**\n * A utility function to match an Ivy node static data against a simple CSS selector\n *\n * @param node static data of the node to match\n * @param selector The selector to try matching against the node.\n * @param isProjectionMode if `true` we are matching for content projection, otherwise we are doing\n * directive matching.\n * @returns true if node matches the selector.\n */\nexport function isNodeMatchingSelector(\n    tNode: TNode, selector: CssSelector, isProjectionMode: boolean): boolean {\n  ngDevMode && assertDefined(selector[0], 'Selector should have a tag name');\n  let mode: SelectorFlags = SelectorFlags.ELEMENT;\n  const nodeAttrs = tNode.attrs || [];\n\n  // Find the index of first attribute that has no value, only a name.\n  const nameOnlyMarkerIdx = getNameOnlyMarkerIndex(nodeAttrs);\n\n  // When processing \":not\" selectors, we skip to the next \":not\" if the\n  // current one doesn't match\n  let skipToNextSelector = false;\n\n  for (let i = 0; i < selector.length; i++) {\n    const current = selector[i];\n    if (typeof current === 'number') {\n      // If we finish processing a :not selector and it hasn't failed, return false\n      if (!skipToNextSelector && !isPositive(mode) && !isPositive(current)) {\n        return false;\n      }\n      // If we are skipping to the next :not() and this mode flag is positive,\n      // it's a part of the current :not() selector, and we should keep skipping\n      if (skipToNextSelector && isPositive(current)) continue;\n      skipToNextSelector = false;\n      mode = (current as number) | (mode & SelectorFlags.NOT);\n      continue;\n    }\n\n    if (skipToNextSelector) continue;\n\n    if (mode & SelectorFlags.ELEMENT) {\n      mode = SelectorFlags.ATTRIBUTE | mode & SelectorFlags.NOT;\n      if (current !== '' && !hasTagAndTypeMatch(tNode, current, isProjectionMode) ||\n          current === '' && selector.length === 1) {\n        if (isPositive(mode)) return false;\n        skipToNextSelector = true;\n      }\n    } else {\n      const selectorAttrValue = mode & SelectorFlags.CLASS ? current : selector[++i];\n\n      // special case for matching against classes when a tNode has been instantiated with\n      // class and style values as separate attribute values (e.g. ['title', CLASS, 'foo'])\n      if ((mode & SelectorFlags.CLASS) && tNode.attrs !== null) {\n        if (!isCssClassMatching(tNode.attrs, selectorAttrValue as string, isProjectionMode)) {\n          if (isPositive(mode)) return false;\n          skipToNextSelector = true;\n        }\n        continue;\n      }\n\n      const attrName = (mode & SelectorFlags.CLASS) ? 'class' : current;\n      const attrIndexInNode =\n          findAttrIndexInNode(attrName, nodeAttrs, isInlineTemplate(tNode), isProjectionMode);\n\n      if (attrIndexInNode === -1) {\n        if (isPositive(mode)) return false;\n        skipToNextSelector = true;\n        continue;\n      }\n\n      if (selectorAttrValue !== '') {\n        let nodeAttrValue: string;\n        if (attrIndexInNode > nameOnlyMarkerIdx) {\n          nodeAttrValue = '';\n        } else {\n          ngDevMode &&\n              assertNotEqual(\n                  nodeAttrs[attrIndexInNode], AttributeMarker.NamespaceURI,\n                  'We do not match directives on namespaced attributes');\n          // we lowercase the attribute value to be able to match\n          // selectors without case-sensitivity\n          // (selectors are already in lowercase when generated)\n          nodeAttrValue = (nodeAttrs[attrIndexInNode + 1] as string).toLowerCase();\n        }\n\n        const compareAgainstClassName = mode & SelectorFlags.CLASS ? nodeAttrValue : null;\n        if (compareAgainstClassName &&\n                classIndexOf(compareAgainstClassName, selectorAttrValue as string, 0) !== -1 ||\n            mode & SelectorFlags.ATTRIBUTE && selectorAttrValue !== nodeAttrValue) {\n          if (isPositive(mode)) return false;\n          skipToNextSelector = true;\n        }\n      }\n    }\n  }\n\n  return isPositive(mode) || skipToNextSelector;\n}\n\nfunction isPositive(mode: SelectorFlags): boolean {\n  return (mode & SelectorFlags.NOT) === 0;\n}\n\n/**\n * Examines the attribute's definition array for a node to find the index of the\n * attribute that matches the given `name`.\n *\n * NOTE: This will not match namespaced attributes.\n *\n * Attribute matching depends upon `isInlineTemplate` and `isProjectionMode`.\n * The following table summarizes which types of attributes we attempt to match:\n *\n * ===========================================================================================================\n * Modes                   | Normal Attributes | Bindings Attributes | Template Attributes | I18n\n * Attributes\n * ===========================================================================================================\n * Inline + Projection     | YES               | YES                 | NO                  | YES\n * -----------------------------------------------------------------------------------------------------------\n * Inline + Directive      | NO                | NO                  | YES                 | NO\n * -----------------------------------------------------------------------------------------------------------\n * Non-inline + Projection | YES               | YES                 | NO                  | YES\n * -----------------------------------------------------------------------------------------------------------\n * Non-inline + Directive  | YES               | YES                 | NO                  | YES\n * ===========================================================================================================\n *\n * @param name the name of the attribute to find\n * @param attrs the attribute array to examine\n * @param isInlineTemplate true if the node being matched is an inline template (e.g. `*ngFor`)\n * rather than a manually expanded template node (e.g `<ng-template>`).\n * @param isProjectionMode true if we are matching against content projection otherwise we are\n * matching against directives.\n */\nfunction findAttrIndexInNode(\n    name: string, attrs: TAttributes|null, isInlineTemplate: boolean,\n    isProjectionMode: boolean): number {\n  if (attrs === null) return -1;\n\n  let i = 0;\n\n  if (isProjectionMode || !isInlineTemplate) {\n    let bindingsMode = false;\n    while (i < attrs.length) {\n      const maybeAttrName = attrs[i];\n      if (maybeAttrName === name) {\n        return i;\n      } else if (\n          maybeAttrName === AttributeMarker.Bindings || maybeAttrName === AttributeMarker.I18n) {\n        bindingsMode = true;\n      } else if (\n          maybeAttrName === AttributeMarker.Classes || maybeAttrName === AttributeMarker.Styles) {\n        let value = attrs[++i];\n        // We should skip classes here because we have a separate mechanism for\n        // matching classes in projection mode.\n        while (typeof value === 'string') {\n          value = attrs[++i];\n        }\n        continue;\n      } else if (maybeAttrName === AttributeMarker.Template) {\n        // We do not care about Template attributes in this scenario.\n        break;\n      } else if (maybeAttrName === AttributeMarker.NamespaceURI) {\n        // Skip the whole namespaced attribute and value. This is by design.\n        i += 4;\n        continue;\n      }\n      // In binding mode there are only names, rather than name-value pairs.\n      i += bindingsMode ? 1 : 2;\n    }\n    // We did not match the attribute\n    return -1;\n  } else {\n    return matchTemplateAttribute(attrs, name);\n  }\n}\n\nexport function isNodeMatchingSelectorList(\n    tNode: TNode, selector: CssSelectorList, isProjectionMode: boolean = false): boolean {\n  for (let i = 0; i < selector.length; i++) {\n    if (isNodeMatchingSelector(tNode, selector[i], isProjectionMode)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function getProjectAsAttrValue(tNode: TNode): CssSelector|null {\n  const nodeAttrs = tNode.attrs;\n  if (nodeAttrs != null) {\n    const ngProjectAsAttrIdx = nodeAttrs.indexOf(AttributeMarker.ProjectAs);\n    // only check for ngProjectAs in attribute names, don't accidentally match attribute's value\n    // (attribute names are stored at even indexes)\n    if ((ngProjectAsAttrIdx & 1) === 0) {\n      return nodeAttrs[ngProjectAsAttrIdx + 1] as CssSelector;\n    }\n  }\n  return null;\n}\n\nfunction getNameOnlyMarkerIndex(nodeAttrs: TAttributes) {\n  for (let i = 0; i < nodeAttrs.length; i++) {\n    const nodeAttr = nodeAttrs[i];\n    if (isNameOnlyAttributeMarker(nodeAttr)) {\n      return i;\n    }\n  }\n  return nodeAttrs.length;\n}\n\nfunction matchTemplateAttribute(attrs: TAttributes, name: string): number {\n  let i = attrs.indexOf(AttributeMarker.Template);\n  if (i > -1) {\n    i++;\n    while (i < attrs.length) {\n      const attr = attrs[i];\n      // Return in case we checked all template attrs and are switching to the next section in the\n      // attrs array (that starts with a number that represents an attribute marker).\n      if (typeof attr === 'number') return -1;\n      if (attr === name) return i;\n      i++;\n    }\n  }\n  return -1;\n}\n\n/**\n * Checks whether a selector is inside a CssSelectorList\n * @param selector Selector to be checked.\n * @param list List in which to look for the selector.\n */\nexport function isSelectorInSelectorList(selector: CssSelector, list: CssSelectorList): boolean {\n  selectorListLoop: for (let i = 0; i < list.length; i++) {\n    const currentSelectorInList = list[i];\n    if (selector.length !== currentSelectorInList.length) {\n      continue;\n    }\n    for (let j = 0; j < selector.length; j++) {\n      if (selector[j] !== currentSelectorInList[j]) {\n        continue selectorListLoop;\n      }\n    }\n    return true;\n  }\n  return false;\n}\n\nfunction maybeWrapInNotSelector(isNegativeMode: boolean, chunk: string): string {\n  return isNegativeMode ? ':not(' + chunk.trim() + ')' : chunk;\n}\n\nfunction stringifyCSSSelector(selector: CssSelector): string {\n  let result = selector[0] as string;\n  let i = 1;\n  let mode = SelectorFlags.ATTRIBUTE;\n  let currentChunk = '';\n  let isNegativeMode = false;\n  while (i < selector.length) {\n    let valueOrMarker = selector[i];\n    if (typeof valueOrMarker === 'string') {\n      if (mode & SelectorFlags.ATTRIBUTE) {\n        const attrValue = selector[++i] as string;\n        currentChunk +=\n            '[' + valueOrMarker + (attrValue.length > 0 ? '=\"' + attrValue + '\"' : '') + ']';\n      } else if (mode & SelectorFlags.CLASS) {\n        currentChunk += '.' + valueOrMarker;\n      } else if (mode & SelectorFlags.ELEMENT) {\n        currentChunk += ' ' + valueOrMarker;\n      }\n    } else {\n      //\n      // Append current chunk to the final result in case we come across SelectorFlag, which\n      // indicates that the previous section of a selector is over. We need to accumulate content\n      // between flags to make sure we wrap the chunk later in :not() selector if needed, e.g.\n      // ```\n      //  ['', Flags.CLASS, '.classA', Flags.CLASS | Flags.NOT, '.classB', '.classC']\n      // ```\n      // should be transformed to `.classA :not(.classB .classC)`.\n      //\n      // Note: for negative selector part, we accumulate content between flags until we find the\n      // next negative flag. This is needed to support a case where `:not()` rule contains more than\n      // one chunk, e.g. the following selector:\n      // ```\n      //  ['', Flags.ELEMENT | Flags.NOT, 'p', Flags.CLASS, 'foo', Flags.CLASS | Flags.NOT, 'bar']\n      // ```\n      // should be stringified to `:not(p.foo) :not(.bar)`\n      //\n      if (currentChunk !== '' && !isPositive(valueOrMarker)) {\n        result += maybeWrapInNotSelector(isNegativeMode, currentChunk);\n        currentChunk = '';\n      }\n      mode = valueOrMarker;\n      // According to CssSelector spec, once we come across `SelectorFlags.NOT` flag, the negative\n      // mode is maintained for remaining chunks of a selector.\n      isNegativeMode = isNegativeMode || !isPositive(mode);\n    }\n    i++;\n  }\n  if (currentChunk !== '') {\n    result += maybeWrapInNotSelector(isNegativeMode, currentChunk);\n  }\n  return result;\n}\n\n/**\n * Generates string representation of CSS selector in parsed form.\n *\n * ComponentDef and DirectiveDef are generated with the selector in parsed form to avoid doing\n * additional parsing at runtime (for example, for directive matching). However in some cases (for\n * example, while bootstrapping a component), a string version of the selector is required to query\n * for the host element on the page. This function takes the parsed form of a selector and returns\n * its string representation.\n *\n * @param selectorList selector in parsed form\n * @returns string representation of a given selector\n */\nexport function stringifyCSSSelectorList(selectorList: CssSelectorList): string {\n  return selectorList.map(stringifyCSSSelector).join(',');\n}\n\n/**\n * Extracts attributes and classes information from a given CSS selector.\n *\n * This function is used while creating a component dynamically. In this case, the host element\n * (that is created dynamically) should contain attributes and classes specified in component's CSS\n * selector.\n *\n * @param selector CSS selector in parsed form (in a form of array)\n * @returns object with `attrs` and `classes` fields that contain extracted information\n */\nexport function extractAttrsAndClassesFromSelector(selector: CssSelector):\n    {attrs: string[], classes: string[]} {\n  const attrs: string[] = [];\n  const classes: string[] = [];\n  let i = 1;\n  let mode = SelectorFlags.ATTRIBUTE;\n  while (i < selector.length) {\n    let valueOrMarker = selector[i];\n    if (typeof valueOrMarker === 'string') {\n      if (mode === SelectorFlags.ATTRIBUTE) {\n        if (valueOrMarker !== '') {\n          attrs.push(valueOrMarker, selector[++i] as string);\n        }\n      } else if (mode === SelectorFlags.CLASS) {\n        classes.push(valueOrMarker);\n      }\n    } else {\n      // According to CssSelector spec, once we come across `SelectorFlags.NOT` flag, the negative\n      // mode is maintained for remaining chunks of a selector. Since attributes and classes are\n      // extracted only for \"positive\" part of the selector, we can stop here.\n      if (!isPositive(mode)) break;\n      mode = valueOrMarker;\n    }\n    i++;\n  }\n  return {attrs, classes};\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport interface NO_CHANGE {\n  // This is a brand that ensures that this type can never match anything else\n  __brand__: 'NO_CHANGE';\n}\n\n/** A special value which designates that a value has not changed. */\nexport const NO_CHANGE: NO_CHANGE =\n    (typeof ngDevMode === 'undefined' || ngDevMode) ? {__brand__: 'NO_CHANGE'} : ({} as NO_CHANGE);\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {assertGreaterThan} from '../../util/assert';\nimport {assertIndexInDeclRange} from '../assert';\nimport {executeCheckHooks, executeInitAndCheckHooks} from '../hooks';\nimport {FLAGS, InitPhaseState, LView, LViewFlags, TView} from '../interfaces/view';\nimport {getLView, getSelectedIndex, getTView, isInCheckNoChangesMode, setSelectedIndex} from '../state';\n\n\n/**\n * Advances to an element for later binding instructions.\n *\n * Used in conjunction with instructions like {@link property} to act on elements with specified\n * indices, for example those created with {@link element} or {@link elementStart}.\n *\n * ```ts\n * (rf: RenderFlags, ctx: any) => {\n *   if (rf & 1) {\n *     text(0, 'Hello');\n *     text(1, 'Goodbye')\n *     element(2, 'div');\n *   }\n *   if (rf & 2) {\n *     advance(2); // Advance twice to the <div>.\n *     property('title', 'test');\n *   }\n *  }\n * ```\n * @param delta Number of elements to advance forwards by.\n *\n * @codeGenApi\n */\nexport function ɵɵadvance(delta: number): void {\n  ngDevMode && assertGreaterThan(delta, 0, 'Can only advance forward');\n  selectIndexInternal(\n      getTView(), getLView(), getSelectedIndex() + delta, !!ngDevMode && isInCheckNoChangesMode());\n}\n\nexport function selectIndexInternal(\n    tView: TView, lView: LView, index: number, checkNoChangesMode: boolean) {\n  ngDevMode && assertIndexInDeclRange(lView, index);\n\n  // Flush the initial hooks for elements in the view that have been added up to this point.\n  // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n  if (!checkNoChangesMode) {\n    const hooksInitPhaseCompleted =\n        (lView[FLAGS] & LViewFlags.InitPhaseStateMask) === InitPhaseState.InitPhaseCompleted;\n    if (hooksInitPhaseCompleted) {\n      const preOrderCheckHooks = tView.preOrderCheckHooks;\n      if (preOrderCheckHooks !== null) {\n        executeCheckHooks(lView, preOrderCheckHooks, index);\n      }\n    } else {\n      const preOrderHooks = tView.preOrderHooks;\n      if (preOrderHooks !== null) {\n        executeInitAndCheckHooks(lView, preOrderHooks, InitPhaseState.OnInitHooksToBeRun, index);\n      }\n    }\n  }\n\n  // We must set the selected index *after* running the hooks, because hooks may have side-effects\n  // that cause other template functions to run, thus updating the selected index, which is global\n  // state. If we run `setSelectedIndex` *before* we run the hooks, in some cases the selected index\n  // will be altered by the time we leave the `ɵɵadvance` instruction.\n  setSelectedIndex(index);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {resolveForwardRef} from '../forward_ref';\nimport {ɵɵinject, ɵɵinvalidFactoryDep} from '../injector_compatibility';\nimport {ɵɵdefineInjectable, ɵɵdefineInjector} from '../interface/defs';\n\n/**\n * A mapping of the @angular/core API surface used in generated expressions to the actual symbols.\n *\n * This should be kept up to date with the public exports of @angular/core.\n */\nexport const angularCoreDiEnv: {[name: string]: Function} = {\n  'ɵɵdefineInjectable': ɵɵdefineInjectable,\n  'ɵɵdefineInjector': ɵɵdefineInjector,\n  'ɵɵinject': ɵɵinject,\n  'ɵɵinvalidFactoryDep': ɵɵinvalidFactoryDep,\n  'resolveForwardRef': resolveForwardRef,\n};\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getCompilerFacade, JitCompilerUsage, R3InjectableMetadataFacade} from '../../compiler/compiler_facade';\nimport {Type} from '../../interface/type';\nimport {NG_FACTORY_DEF} from '../../render3/fields';\nimport {getClosureSafeProperty} from '../../util/property';\nimport {resolveForwardRef} from '../forward_ref';\nimport {Injectable} from '../injectable';\nimport {NG_PROV_DEF} from '../interface/defs';\nimport {ClassSansProvider, ExistingSansProvider, FactorySansProvider, ValueProvider, ValueSansProvider} from '../interface/provider';\n\nimport {angularCoreDiEnv} from './environment';\nimport {convertDependencies, reflectDependencies} from './util';\n\n\n\n/**\n * Compile an Angular injectable according to its `Injectable` metadata, and patch the resulting\n * injectable def (`ɵprov`) onto the injectable type.\n */\nexport function compileInjectable(type: Type<any>, meta?: Injectable): void {\n  let ngInjectableDef: any = null;\n  let ngFactoryDef: any = null;\n\n  // if NG_PROV_DEF is already defined on this class then don't overwrite it\n  if (!type.hasOwnProperty(NG_PROV_DEF)) {\n    Object.defineProperty(type, NG_PROV_DEF, {\n      get: () => {\n        if (ngInjectableDef === null) {\n          const compiler =\n              getCompilerFacade({usage: JitCompilerUsage.Decorator, kind: 'injectable', type});\n          ngInjectableDef = compiler.compileInjectable(\n              angularCoreDiEnv, `ng:///${type.name}/ɵprov.js`, getInjectableMetadata(type, meta));\n        }\n        return ngInjectableDef;\n      },\n    });\n  }\n\n  // if NG_FACTORY_DEF is already defined on this class then don't overwrite it\n  if (!type.hasOwnProperty(NG_FACTORY_DEF)) {\n    Object.defineProperty(type, NG_FACTORY_DEF, {\n      get: () => {\n        if (ngFactoryDef === null) {\n          const compiler =\n              getCompilerFacade({usage: JitCompilerUsage.Decorator, kind: 'injectable', type});\n          ngFactoryDef = compiler.compileFactory(angularCoreDiEnv, `ng:///${type.name}/ɵfac.js`, {\n            name: type.name,\n            type,\n            typeArgumentCount: 0,  // In JIT mode types are not available nor used.\n            deps: reflectDependencies(type),\n            target: compiler.FactoryTarget.Injectable\n          });\n        }\n        return ngFactoryDef;\n      },\n      // Leave this configurable so that the factories from directives or pipes can take precedence.\n      configurable: true\n    });\n  }\n}\n\ntype UseClassProvider = Injectable&ClassSansProvider&{deps?: any[]};\n\nconst USE_VALUE =\n    getClosureSafeProperty<ValueProvider>({provide: String, useValue: getClosureSafeProperty});\n\nfunction isUseClassProvider(meta: Injectable): meta is UseClassProvider {\n  return (meta as UseClassProvider).useClass !== undefined;\n}\n\nfunction isUseValueProvider(meta: Injectable): meta is Injectable&ValueSansProvider {\n  return USE_VALUE in meta;\n}\n\nfunction isUseFactoryProvider(meta: Injectable): meta is Injectable&FactorySansProvider {\n  return (meta as FactorySansProvider).useFactory !== undefined;\n}\n\nfunction isUseExistingProvider(meta: Injectable): meta is Injectable&ExistingSansProvider {\n  return (meta as ExistingSansProvider).useExisting !== undefined;\n}\n\nfunction getInjectableMetadata(type: Type<any>, srcMeta?: Injectable): R3InjectableMetadataFacade {\n  // Allow the compilation of a class with a `@Injectable()` decorator without parameters\n  const meta: Injectable = srcMeta || {providedIn: null};\n  const compilerMeta: R3InjectableMetadataFacade = {\n    name: type.name,\n    type: type,\n    typeArgumentCount: 0,\n    providedIn: meta.providedIn,\n  };\n  if ((isUseClassProvider(meta) || isUseFactoryProvider(meta)) && meta.deps !== undefined) {\n    compilerMeta.deps = convertDependencies(meta.deps);\n  }\n  // Check to see if the user explicitly provided a `useXxxx` property.\n  if (isUseClassProvider(meta)) {\n    compilerMeta.useClass = meta.useClass;\n  } else if (isUseValueProvider(meta)) {\n    compilerMeta.useValue = meta.useValue;\n  } else if (isUseFactoryProvider(meta)) {\n    compilerMeta.useFactory = meta.useFactory;\n  } else if (isUseExistingProvider(meta)) {\n    compilerMeta.useExisting = meta.useExisting;\n  }\n  return compilerMeta;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../interface/type';\nimport {makeDecorator, TypeDecorator} from '../util/decorators';\n\nimport {ClassSansProvider, ConstructorSansProvider, ExistingSansProvider, FactorySansProvider, StaticClassSansProvider, ValueSansProvider} from './interface/provider';\nimport {compileInjectable} from './jit/injectable';\n\nexport {compileInjectable};\n\n/**\n * Injectable providers used in `@Injectable` decorator.\n *\n * @publicApi\n */\nexport type InjectableProvider = ValueSansProvider|ExistingSansProvider|StaticClassSansProvider|\n    ConstructorSansProvider|FactorySansProvider|ClassSansProvider;\n\n/**\n * Type of the Injectable decorator / constructor function.\n *\n * @publicApi\n */\nexport interface InjectableDecorator {\n  /**\n   * Decorator that marks a class as available to be\n   * provided and injected as a dependency.\n   *\n   * @see [Introduction to Services and DI](guide/architecture-services)\n   * @see [Dependency Injection Guide](guide/dependency-injection)\n   *\n   * @usageNotes\n   *\n   * Marking a class with `@Injectable` ensures that the compiler\n   * will generate the necessary metadata to create the class's\n   * dependencies when the class is injected.\n   *\n   * The following example shows how a service class is properly\n   *  marked so that a supporting service can be injected upon creation.\n   *\n   * <code-example path=\"core/di/ts/metadata_spec.ts\" region=\"Injectable\"></code-example>\n   *\n   */\n  (): TypeDecorator;\n  (options?: {providedIn: Type<any>|'root'|'platform'|'any'|null}&\n   InjectableProvider): TypeDecorator;\n  new(): Injectable;\n  new(options?: {providedIn: Type<any>|'root'|'platform'|'any'|null}&\n      InjectableProvider): Injectable;\n}\n\n/**\n * Type of the Injectable metadata.\n *\n * @publicApi\n */\nexport interface Injectable {\n  /**\n   * Determines which injectors will provide the injectable.\n   *\n   * - `Type<any>` - associates the injectable with an `@NgModule` or other `InjectorType`,\n   * - 'null' : Equivalent to `undefined`. The injectable is not provided in any scope automatically\n   * and must be added to a `providers` array of an [@NgModule](api/core/NgModule#providers),\n   * [@Component](api/core/Directive#providers) or [@Directive](api/core/Directive#providers).\n   *\n   * The following options specify that this injectable should be provided in one of the following\n   * injectors:\n   * - 'root' : The application-level injector in most apps.\n   * - 'platform' : A special singleton platform injector shared by all\n   * applications on the page.\n   * - 'any' : Provides a unique instance in each lazy loaded module while all eagerly loaded\n   * modules share one instance.\n   *\n   */\n  providedIn?: Type<any>|'root'|'platform'|'any'|null;\n}\n\n/**\n * Injectable decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Injectable: InjectableDecorator = makeDecorator(\n    'Injectable', undefined, undefined, undefined,\n    (type: Type<any>, meta: Injectable) => compileInjectable(type as any, meta));\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {flatten} from '../util/array_utils';\nimport {EMPTY_ARRAY} from '../util/empty';\nimport {stringify} from '../util/stringify';\n\nimport {Injector} from './injector';\nimport {StaticProvider} from './interface/provider';\nimport {importProvidersFrom} from './provider_collection';\nimport {getNullInjector, R3Injector} from './r3_injector';\nimport {InjectorScope} from './scope';\n\n/**\n * Create a new `Injector` which is configured using a `defType` of `InjectorType<any>`s.\n *\n * @publicApi\n */\nexport function createInjector(\n    defType: /* InjectorType<any> */ any, parent: Injector|null = null,\n    additionalProviders: StaticProvider[]|null = null, name?: string): Injector {\n  const injector =\n      createInjectorWithoutInjectorInstances(defType, parent, additionalProviders, name);\n  injector.resolveInjectorInitializers();\n  return injector;\n}\n\n/**\n * Creates a new injector without eagerly resolving its injector types. Can be used in places\n * where resolving the injector types immediately can lead to an infinite loop. The injector types\n * should be resolved at a later point by calling `_resolveInjectorDefTypes`.\n */\nexport function createInjectorWithoutInjectorInstances(\n    defType: /* InjectorType<any> */ any, parent: Injector|null = null,\n    additionalProviders: StaticProvider[]|null = null, name?: string,\n    scopes = new Set<InjectorScope>()): R3Injector {\n  const providers = [\n    additionalProviders || EMPTY_ARRAY,\n    importProvidersFrom(defType),\n  ];\n  name = name || (typeof defType === 'object' ? undefined : stringify(defType));\n\n  return new R3Injector(providers, parent || getNullInjector(), name || null, scopes);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {createInjector} from './create_injector';\nimport {THROW_IF_NOT_FOUND, ɵɵinject} from './injector_compatibility';\nimport {InjectorMarkers} from './injector_marker';\nimport {INJECTOR} from './injector_token';\nimport {ɵɵdefineInjectable} from './interface/defs';\nimport {InjectFlags} from './interface/injector';\nimport {StaticProvider} from './interface/provider';\nimport {NullInjector} from './null_injector';\nimport {ProviderToken} from './provider_token';\n\n/**\n * Concrete injectors implement this interface. Injectors are configured\n * with [providers](guide/glossary#provider) that associate\n * dependencies of various types with [injection tokens](guide/glossary#di-token).\n *\n * @see [\"DI Providers\"](guide/dependency-injection-providers).\n * @see `StaticProvider`\n *\n * @usageNotes\n *\n *  The following example creates a service injector instance.\n *\n * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}\n *\n * ### Usage example\n *\n * {@example core/di/ts/injector_spec.ts region='Injector'}\n *\n * `Injector` returns itself when given `Injector` as a token:\n *\n * {@example core/di/ts/injector_spec.ts region='injectInjector'}\n *\n * @publicApi\n */\nexport abstract class Injector {\n  static THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;\n  static NULL: Injector = (/* @__PURE__ */ new NullInjector());\n\n  /**\n   * Retrieves an instance from the injector based on the provided token.\n   * @returns The instance from the injector if defined, otherwise the `notFoundValue`.\n   * @throws When the `notFoundValue` is `undefined` or `Injector.THROW_IF_NOT_FOUND`.\n   */\n  abstract get<T>(token: ProviderToken<T>, notFoundValue?: T, flags?: InjectFlags): T;\n  /**\n   * @deprecated from v4.0.0 use ProviderToken<T>\n   * @suppress {duplicate}\n   */\n  abstract get(token: any, notFoundValue?: any): any;\n\n  /**\n   * @deprecated from v5 use the new signature Injector.create(options)\n   */\n  static create(providers: StaticProvider[], parent?: Injector): Injector;\n\n  /**\n   * Creates a new injector instance that provides one or more dependencies,\n   * according to a given type or types of `StaticProvider`.\n   *\n   * @param options An object with the following properties:\n   * * `providers`: An array of providers of the [StaticProvider type](api/core/StaticProvider).\n   * * `parent`: (optional) A parent injector.\n   * * `name`: (optional) A developer-defined identifying name for the new injector.\n   *\n   * @returns The new injector instance.\n   *\n   */\n  static create(options: {providers: StaticProvider[], parent?: Injector, name?: string}): Injector;\n\n\n  static create(\n      options: StaticProvider[]|{providers: StaticProvider[], parent?: Injector, name?: string},\n      parent?: Injector): Injector {\n    if (Array.isArray(options)) {\n      return createInjector({name: ''}, parent, options, '');\n    } else {\n      const name = options.name ?? '';\n      return createInjector({name}, options.parent, options.providers, name);\n    }\n  }\n\n  /** @nocollapse */\n  static ɵprov = /** @pureOrBreakMyCode */ ɵɵdefineInjectable({\n    token: Injector,\n    providedIn: 'any',\n    factory: () => ɵɵinject(INJECTOR),\n  });\n\n  /**\n   * @internal\n   * @nocollapse\n   */\n  static __NG_ELEMENT_ID__ = InjectorMarkers.Injector;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../interface/type';\nimport {ERROR_ORIGINAL_ERROR, wrappedError} from '../util/errors';\nimport {stringify} from '../util/stringify';\n\nimport {ReflectiveInjector} from './reflective_injector';\nimport {ReflectiveKey} from './reflective_key';\n\nfunction findFirstClosedCycle(keys: any[]): any[] {\n  const res: any[] = [];\n  for (let i = 0; i < keys.length; ++i) {\n    if (res.indexOf(keys[i]) > -1) {\n      res.push(keys[i]);\n      return res;\n    }\n    res.push(keys[i]);\n  }\n  return res;\n}\n\nfunction constructResolvingPath(keys: any[]): string {\n  if (keys.length > 1) {\n    const reversed = findFirstClosedCycle(keys.slice().reverse());\n    const tokenStrs = reversed.map(k => stringify(k.token));\n    return ' (' + tokenStrs.join(' -> ') + ')';\n  }\n\n  return '';\n}\n\nexport interface InjectionError extends Error {\n  keys: ReflectiveKey[];\n  injectors: ReflectiveInjector[];\n  constructResolvingMessage: (keys: ReflectiveKey[]) => string;\n  addKey(injector: ReflectiveInjector, key: ReflectiveKey): void;\n}\n\nfunction injectionError(\n    injector: ReflectiveInjector, key: ReflectiveKey,\n    constructResolvingMessage: (keys: ReflectiveKey[]) => string,\n    originalError?: Error): InjectionError {\n  const keys = [key];\n  const errMsg = constructResolvingMessage(keys);\n  const error =\n      (originalError ? wrappedError(errMsg, originalError) : Error(errMsg)) as InjectionError;\n  error.addKey = addKey;\n  error.keys = keys;\n  error.injectors = [injector];\n  error.constructResolvingMessage = constructResolvingMessage;\n  (error as any)[ERROR_ORIGINAL_ERROR] = originalError;\n  return error;\n}\n\nfunction addKey(this: InjectionError, injector: ReflectiveInjector, key: ReflectiveKey): void {\n  this.injectors.push(injector);\n  this.keys.push(key);\n  // Note: This updated message won't be reflected in the `.stack` property\n  this.message = this.constructResolvingMessage(this.keys);\n}\n\n/**\n * Thrown when trying to retrieve a dependency by key from {@link Injector}, but the\n * {@link Injector} does not have a {@link Provider} for the given key.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * class A {\n *   constructor(b:B) {}\n * }\n *\n * expect(() => Injector.resolveAndCreate([A])).toThrowError();\n * ```\n */\nexport function noProviderError(injector: ReflectiveInjector, key: ReflectiveKey): InjectionError {\n  return injectionError(injector, key, function(keys: ReflectiveKey[]) {\n    const first = stringify(keys[0].token);\n    return `No provider for ${first}!${constructResolvingPath(keys)}`;\n  });\n}\n\n/**\n * Thrown when dependencies form a cycle.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * var injector = Injector.resolveAndCreate([\n *   {provide: \"one\", useFactory: (two) => \"two\", deps: [[new Inject(\"two\")]]},\n *   {provide: \"two\", useFactory: (one) => \"one\", deps: [[new Inject(\"one\")]]}\n * ]);\n *\n * expect(() => injector.get(\"one\")).toThrowError();\n * ```\n *\n * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.\n */\nexport function cyclicDependencyError(\n    injector: ReflectiveInjector, key: ReflectiveKey): InjectionError {\n  return injectionError(injector, key, function(keys: ReflectiveKey[]) {\n    return `Cannot instantiate cyclic dependency!${constructResolvingPath(keys)}`;\n  });\n}\n\n/**\n * Thrown when a constructing type returns with an Error.\n *\n * The `InstantiationError` class contains the original error plus the dependency graph which caused\n * this object to be instantiated.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * class A {\n *   constructor() {\n *     throw new Error('message');\n *   }\n * }\n *\n * var injector = Injector.resolveAndCreate([A]);\n\n * try {\n *   injector.get(A);\n * } catch (e) {\n *   expect(e instanceof InstantiationError).toBe(true);\n *   expect(e.originalException.message).toEqual(\"message\");\n *   expect(e.originalStack).toBeDefined();\n * }\n * ```\n */\nexport function instantiationError(\n    injector: ReflectiveInjector, originalException: any, originalStack: any,\n    key: ReflectiveKey): InjectionError {\n  return injectionError(injector, key, function(keys: ReflectiveKey[]) {\n    const first = stringify(keys[0].token);\n    return `${originalException.message}: Error during instantiation of ${first}!${\n        constructResolvingPath(keys)}.`;\n  }, originalException);\n}\n\n/**\n * Thrown when an object other then {@link Provider} (or `Type`) is passed to {@link Injector}\n * creation.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * expect(() => Injector.resolveAndCreate([\"not a type\"])).toThrowError();\n * ```\n */\nexport function invalidProviderError(provider: any) {\n  return Error(\n      `Invalid provider - only instances of Provider and Type are allowed, got: ${provider}`);\n}\n\n/**\n * Thrown when the class has no annotation information.\n *\n * Lack of annotation information prevents the {@link Injector} from determining which dependencies\n * need to be injected into the constructor.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * class A {\n *   constructor(b) {}\n * }\n *\n * expect(() => Injector.resolveAndCreate([A])).toThrowError();\n * ```\n *\n * This error is also thrown when the class not marked with {@link Injectable} has parameter types.\n *\n * ```typescript\n * class B {}\n *\n * class A {\n *   constructor(b:B) {} // no information about the parameter types of A is available at runtime.\n * }\n *\n * expect(() => Injector.resolveAndCreate([A,B])).toThrowError();\n * ```\n *\n */\nexport function noAnnotationError(typeOrFunc: Type<any>|Function, params: any[][]): Error {\n  const signature: string[] = [];\n  for (let i = 0, ii = params.length; i < ii; i++) {\n    const parameter = params[i];\n    if (!parameter || parameter.length == 0) {\n      signature.push('?');\n    } else {\n      signature.push(parameter.map(stringify).join(' '));\n    }\n  }\n  return Error(\n      'Cannot resolve all parameters for \\'' + stringify(typeOrFunc) + '\\'(' +\n      signature.join(', ') + '). ' +\n      'Make sure that all the parameters are decorated with Inject or have valid type annotations and that \\'' +\n      stringify(typeOrFunc) + '\\' is decorated with Injectable.');\n}\n\n/**\n * Thrown when getting an object by index.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * class A {}\n *\n * var injector = Injector.resolveAndCreate([A]);\n *\n * expect(() => injector.getAt(100)).toThrowError();\n * ```\n *\n */\nexport function outOfBoundsError(index: number) {\n  return Error(`Index ${index} is out-of-bounds.`);\n}\n\n// TODO: add a working example after alpha38 is released\n/**\n * Thrown when a multi provider and a regular provider are bound to the same token.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * expect(() => Injector.resolveAndCreate([\n *   { provide: \"Strings\", useValue: \"string1\", multi: true},\n *   { provide: \"Strings\", useValue: \"string2\", multi: false}\n * ])).toThrowError();\n * ```\n */\nexport function mixingMultiProvidersWithRegularProvidersError(\n    provider1: any, provider2: any): Error {\n  return Error(`Cannot mix multi providers and regular providers, got: ${provider1} ${provider2}`);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {RuntimeError, RuntimeErrorCode} from '../errors';\nimport {stringify} from '../util/stringify';\n\nimport {resolveForwardRef} from './forward_ref';\n\n\n/**\n * A unique object used for retrieving items from the {@link ReflectiveInjector}.\n *\n * Keys have:\n * - a system-wide unique `id`.\n * - a `token`.\n *\n * `Key` is used internally by {@link ReflectiveInjector} because its system-wide unique `id` allows\n * the\n * injector to store created objects in a more efficient way.\n *\n * `Key` should not be created directly. {@link ReflectiveInjector} creates keys automatically when\n * resolving\n * providers.\n *\n * @deprecated No replacement\n * @publicApi\n */\nexport class ReflectiveKey {\n  public readonly displayName: string;\n  /**\n   * Private\n   */\n  constructor(public token: Object, public id: number) {\n    if (!token) {\n      throw new RuntimeError(\n          RuntimeErrorCode.MISSING_INJECTION_TOKEN, ngDevMode && 'Token must be defined!');\n    }\n    this.displayName = stringify(this.token);\n  }\n\n  /**\n   * Retrieves a `Key` for a token.\n   */\n  static get(token: Object): ReflectiveKey {\n    return _globalKeyRegistry.get(resolveForwardRef(token));\n  }\n\n  /**\n   * @returns the number of keys registered in the system.\n   */\n  static get numberOfKeys(): number {\n    return _globalKeyRegistry.numberOfKeys;\n  }\n}\n\nexport class KeyRegistry {\n  private _allKeys = new Map<Object, ReflectiveKey>();\n\n  get(token: Object): ReflectiveKey {\n    if (token instanceof ReflectiveKey) return token;\n\n    if (this._allKeys.has(token)) {\n      return this._allKeys.get(token)!;\n    }\n\n    const newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);\n    this._allKeys.set(token, newKey);\n    return newKey;\n  }\n\n  get numberOfKeys(): number {\n    return this._allKeys.size;\n  }\n}\n\nconst _globalKeyRegistry = new KeyRegistry();\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../interface/type';\n\nimport {resolveForwardRef} from './forward_ref';\nimport {InjectionToken} from './injection_token';\nimport {ClassProvider, ExistingProvider, FactoryProvider, Provider, TypeProvider, ValueProvider} from './interface/provider';\nimport {getReflect} from './jit/util';\nimport {Inject, Optional, Self, SkipSelf} from './metadata';\nimport {invalidProviderError, mixingMultiProvidersWithRegularProvidersError, noAnnotationError} from './reflective_errors';\nimport {ReflectiveKey} from './reflective_key';\n\n\ninterface NormalizedProvider extends TypeProvider, ValueProvider, ClassProvider, ExistingProvider,\n                                     FactoryProvider {}\n\n/**\n * `Dependency` is used by the framework to extend DI.\n * This is internal to Angular and should not be used directly.\n */\nexport class ReflectiveDependency {\n  constructor(\n      public key: ReflectiveKey, public optional: boolean, public visibility: Self|SkipSelf|null) {}\n\n  static fromKey(key: ReflectiveKey): ReflectiveDependency {\n    return new ReflectiveDependency(key, false, null);\n  }\n}\n\nconst _EMPTY_LIST: any[] = [];\n\n/**\n * An internal resolved representation of a `Provider` used by the `Injector`.\n *\n * @usageNotes\n * This is usually created automatically by `Injector.resolveAndCreate`.\n *\n * It can be created manually, as follows:\n *\n * ### Example\n *\n * ```typescript\n * var resolvedProviders = Injector.resolve([{ provide: 'message', useValue: 'Hello' }]);\n * var injector = Injector.fromResolvedProviders(resolvedProviders);\n *\n * expect(injector.get('message')).toEqual('Hello');\n * ```\n *\n * @publicApi\n */\nexport interface ResolvedReflectiveProvider {\n  /**\n   * A key, usually a `Type<any>`.\n   */\n  key: ReflectiveKey;\n\n  /**\n   * Factory function which can return an instance of an object represented by a key.\n   */\n  resolvedFactories: ResolvedReflectiveFactory[];\n\n  /**\n   * Indicates if the provider is a multi-provider or a regular provider.\n   */\n  multiProvider: boolean;\n}\n\nexport class ResolvedReflectiveProvider_ implements ResolvedReflectiveProvider {\n  readonly resolvedFactory: ResolvedReflectiveFactory;\n\n  constructor(\n      public key: ReflectiveKey, public resolvedFactories: ResolvedReflectiveFactory[],\n      public multiProvider: boolean) {\n    this.resolvedFactory = this.resolvedFactories[0];\n  }\n}\n\n/**\n * An internal resolved representation of a factory function created by resolving `Provider`.\n * @publicApi\n */\nexport class ResolvedReflectiveFactory {\n  constructor(\n      /**\n       * Factory function which can return an instance of an object represented by a key.\n       */\n      public factory: Function,\n\n      /**\n       * Arguments (dependencies) to the `factory` function.\n       */\n      public dependencies: ReflectiveDependency[]) {}\n}\n\n\n/**\n * Resolve a single provider.\n */\nfunction resolveReflectiveFactory(provider: NormalizedProvider): ResolvedReflectiveFactory {\n  let factoryFn: Function;\n  let resolvedDeps: ReflectiveDependency[];\n  if (provider.useClass) {\n    const useClass = resolveForwardRef(provider.useClass);\n    factoryFn = getReflect().factory(useClass);\n    resolvedDeps = _dependenciesFor(useClass);\n  } else if (provider.useExisting) {\n    factoryFn = (aliasInstance: any) => aliasInstance;\n    resolvedDeps = [ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting))];\n  } else if (provider.useFactory) {\n    factoryFn = provider.useFactory;\n    resolvedDeps = constructDependencies(provider.useFactory, provider.deps);\n  } else {\n    factoryFn = () => provider.useValue;\n    resolvedDeps = _EMPTY_LIST;\n  }\n  return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);\n}\n\n/**\n * Converts the `Provider` into `ResolvedProvider`.\n *\n * `Injector` internally only uses `ResolvedProvider`, `Provider` contains convenience provider\n * syntax.\n */\nfunction resolveReflectiveProvider(provider: NormalizedProvider): ResolvedReflectiveProvider {\n  return new ResolvedReflectiveProvider_(\n      ReflectiveKey.get(provider.provide), [resolveReflectiveFactory(provider)],\n      provider.multi || false);\n}\n\n/**\n * Resolve a list of Providers.\n */\nexport function resolveReflectiveProviders(providers: Provider[]): ResolvedReflectiveProvider[] {\n  const normalized = _normalizeProviders(providers, []);\n  const resolved = normalized.map(resolveReflectiveProvider);\n  const resolvedProviderMap = mergeResolvedReflectiveProviders(resolved, new Map());\n  return Array.from(resolvedProviderMap.values());\n}\n\n/**\n * Merges a list of ResolvedProviders into a list where each key is contained exactly once and\n * multi providers have been merged.\n */\nexport function mergeResolvedReflectiveProviders(\n    providers: ResolvedReflectiveProvider[],\n    normalizedProvidersMap: Map<number, ResolvedReflectiveProvider>):\n    Map<number, ResolvedReflectiveProvider> {\n  for (let i = 0; i < providers.length; i++) {\n    const provider = providers[i];\n    const existing = normalizedProvidersMap.get(provider.key.id);\n    if (existing) {\n      if (provider.multiProvider !== existing.multiProvider) {\n        throw mixingMultiProvidersWithRegularProvidersError(existing, provider);\n      }\n      if (provider.multiProvider) {\n        for (let j = 0; j < provider.resolvedFactories.length; j++) {\n          existing.resolvedFactories.push(provider.resolvedFactories[j]);\n        }\n      } else {\n        normalizedProvidersMap.set(provider.key.id, provider);\n      }\n    } else {\n      let resolvedProvider: ResolvedReflectiveProvider;\n      if (provider.multiProvider) {\n        resolvedProvider = new ResolvedReflectiveProvider_(\n            provider.key, provider.resolvedFactories.slice(), provider.multiProvider);\n      } else {\n        resolvedProvider = provider;\n      }\n      normalizedProvidersMap.set(provider.key.id, resolvedProvider);\n    }\n  }\n  return normalizedProvidersMap;\n}\n\nfunction _normalizeProviders(\n    providers: Provider[], res: NormalizedProvider[]): NormalizedProvider[] {\n  providers.forEach(b => {\n    if (b instanceof Type) {\n      res.push({provide: b, useClass: b} as NormalizedProvider);\n\n    } else if (b && typeof b == 'object' && (b as any).provide !== undefined) {\n      res.push(b as NormalizedProvider);\n\n    } else if (Array.isArray(b)) {\n      _normalizeProviders(b, res);\n\n    } else {\n      throw invalidProviderError(b);\n    }\n  });\n\n  return res;\n}\n\nexport function constructDependencies(\n    typeOrFunc: any, dependencies?: any[]): ReflectiveDependency[] {\n  if (!dependencies) {\n    return _dependenciesFor(typeOrFunc);\n  } else {\n    const params: any[][] = dependencies.map(t => [t]);\n    return dependencies.map(t => _extractToken(typeOrFunc, t, params));\n  }\n}\n\nfunction _dependenciesFor(typeOrFunc: any): ReflectiveDependency[] {\n  const params = getReflect().parameters(typeOrFunc);\n\n  if (!params) return [];\n  if (params.some(p => p == null)) {\n    throw noAnnotationError(typeOrFunc, params);\n  }\n  return params.map(p => _extractToken(typeOrFunc, p, params));\n}\n\nfunction _extractToken(\n    typeOrFunc: any, metadata: any[]|any, params: any[][]): ReflectiveDependency {\n  let token: any = null;\n  let optional = false;\n\n  if (!Array.isArray(metadata)) {\n    if (metadata instanceof Inject) {\n      return _createDependency(metadata.token, optional, null);\n    } else {\n      return _createDependency(metadata, optional, null);\n    }\n  }\n\n  let visibility: Self|SkipSelf|null = null;\n\n  for (let i = 0; i < metadata.length; ++i) {\n    const paramMetadata = metadata[i];\n\n    if (paramMetadata instanceof Type) {\n      token = paramMetadata;\n\n    } else if (paramMetadata instanceof Inject) {\n      token = paramMetadata.token;\n\n    } else if (paramMetadata instanceof Optional) {\n      optional = true;\n\n    } else if (paramMetadata instanceof Self || paramMetadata instanceof SkipSelf) {\n      visibility = paramMetadata;\n    } else if (paramMetadata instanceof InjectionToken) {\n      token = paramMetadata;\n    }\n  }\n\n  token = resolveForwardRef(token);\n\n  if (token != null) {\n    return _createDependency(token, optional, visibility);\n  } else {\n    throw noAnnotationError(typeOrFunc, params);\n  }\n}\n\nfunction _createDependency(\n    token: any, optional: boolean, visibility: Self|SkipSelf|null): ReflectiveDependency {\n  return new ReflectiveDependency(ReflectiveKey.get(token), optional, visibility);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from './injector';\nimport {THROW_IF_NOT_FOUND} from './injector_compatibility';\nimport {Provider} from './interface/provider';\nimport {Self, SkipSelf} from './metadata';\nimport {cyclicDependencyError, instantiationError, noProviderError, outOfBoundsError} from './reflective_errors';\nimport {ReflectiveKey} from './reflective_key';\nimport {ReflectiveDependency, ResolvedReflectiveFactory, ResolvedReflectiveProvider, resolveReflectiveProviders} from './reflective_provider';\n\n\n// Threshold for the dynamic version\nconst UNDEFINED = {};\n\n/**\n * A ReflectiveDependency injection container used for instantiating objects and resolving\n * dependencies.\n *\n * An `Injector` is a replacement for a `new` operator, which can automatically resolve the\n * constructor dependencies.\n *\n * In typical use, application code asks for the dependencies in the constructor and they are\n * resolved by the `Injector`.\n *\n * @usageNotes\n * ### Example\n *\n * The following example creates an `Injector` configured to create `Engine` and `Car`.\n *\n * ```typescript\n * @Injectable()\n * class Engine {\n * }\n *\n * @Injectable()\n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n *\n * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\n * var car = injector.get(Car);\n * expect(car instanceof Car).toBe(true);\n * expect(car.engine instanceof Engine).toBe(true);\n * ```\n *\n * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`\n * resolve all of the object's dependencies automatically.\n *\n * TODO: delete in v14.\n *\n * @deprecated from v5 - slow and brings in a lot of code, Use `Injector.create` instead.\n * @publicApi\n */\nexport abstract class ReflectiveInjector implements Injector {\n  /**\n   * Turns an array of provider definitions into an array of resolved providers.\n   *\n   * A resolution is a process of flattening multiple nested arrays and converting individual\n   * providers into an array of `ResolvedReflectiveProvider`s.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Injectable()\n   * class Engine {\n   * }\n   *\n   * @Injectable()\n   * class Car {\n   *   constructor(public engine:Engine) {}\n   * }\n   *\n   * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);\n   *\n   * expect(providers.length).toEqual(2);\n   *\n   * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);\n   * expect(providers[0].key.displayName).toBe(\"Car\");\n   * expect(providers[0].dependencies.length).toEqual(1);\n   * expect(providers[0].factory).toBeDefined();\n   *\n   * expect(providers[1].key.displayName).toBe(\"Engine\");\n   * });\n   * ```\n   *\n   */\n  static resolve(providers: Provider[]): ResolvedReflectiveProvider[] {\n    return resolveReflectiveProviders(providers);\n  }\n\n  /**\n   * Resolves an array of providers and creates an injector from those providers.\n   *\n   * The passed-in providers can be an array of `Type`, `Provider`,\n   * or a recursive array of more providers.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Injectable()\n   * class Engine {\n   * }\n   *\n   * @Injectable()\n   * class Car {\n   *   constructor(public engine:Engine) {}\n   * }\n   *\n   * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\n   * expect(injector.get(Car) instanceof Car).toBe(true);\n   * ```\n   */\n  static resolveAndCreate(providers: Provider[], parent?: Injector): ReflectiveInjector {\n    const ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);\n    return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);\n  }\n\n  /**\n   * Creates an injector from previously resolved providers.\n   *\n   * This API is the recommended way to construct injectors in performance-sensitive parts.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Injectable()\n   * class Engine {\n   * }\n   *\n   * @Injectable()\n   * class Car {\n   *   constructor(public engine:Engine) {}\n   * }\n   *\n   * var providers = ReflectiveInjector.resolve([Car, Engine]);\n   * var injector = ReflectiveInjector.fromResolvedProviders(providers);\n   * expect(injector.get(Car) instanceof Car).toBe(true);\n   * ```\n   */\n  static fromResolvedProviders(providers: ResolvedReflectiveProvider[], parent?: Injector):\n      ReflectiveInjector {\n    return new ReflectiveInjector_(providers, parent);\n  }\n\n\n  /**\n   * Parent of this injector.\n   *\n   * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n   * -->\n   */\n  abstract get parent(): Injector|null;\n\n  /**\n   * Resolves an array of providers and creates a child injector from those providers.\n   *\n   * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n   * -->\n   *\n   * The passed-in providers can be an array of `Type`, `Provider`,\n   * or a recursive array of more providers.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * class ParentProvider {}\n   * class ChildProvider {}\n   *\n   * var parent = ReflectiveInjector.resolveAndCreate([ParentProvider]);\n   * var child = parent.resolveAndCreateChild([ChildProvider]);\n   *\n   * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);\n   * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);\n   * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));\n   * ```\n   */\n  abstract resolveAndCreateChild(providers: Provider[]): ReflectiveInjector;\n\n  /**\n   * Creates a child injector from previously resolved providers.\n   *\n   * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n   * -->\n   *\n   * This API is the recommended way to construct injectors in performance-sensitive parts.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * class ParentProvider {}\n   * class ChildProvider {}\n   *\n   * var parentProviders = ReflectiveInjector.resolve([ParentProvider]);\n   * var childProviders = ReflectiveInjector.resolve([ChildProvider]);\n   *\n   * var parent = ReflectiveInjector.fromResolvedProviders(parentProviders);\n   * var child = parent.createChildFromResolved(childProviders);\n   *\n   * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);\n   * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);\n   * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));\n   * ```\n   */\n  abstract createChildFromResolved(providers: ResolvedReflectiveProvider[]): ReflectiveInjector;\n\n  /**\n   * Resolves a provider and instantiates an object in the context of the injector.\n   *\n   * The created object does not get cached by the injector.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Injectable()\n   * class Engine {\n   * }\n   *\n   * @Injectable()\n   * class Car {\n   *   constructor(public engine:Engine) {}\n   * }\n   *\n   * var injector = ReflectiveInjector.resolveAndCreate([Engine]);\n   *\n   * var car = injector.resolveAndInstantiate(Car);\n   * expect(car.engine).toBe(injector.get(Engine));\n   * expect(car).not.toBe(injector.resolveAndInstantiate(Car));\n   * ```\n   */\n  abstract resolveAndInstantiate(provider: Provider): any;\n\n  /**\n   * Instantiates an object using a resolved provider in the context of the injector.\n   *\n   * The created object does not get cached by the injector.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Injectable()\n   * class Engine {\n   * }\n   *\n   * @Injectable()\n   * class Car {\n   *   constructor(public engine:Engine) {}\n   * }\n   *\n   * var injector = ReflectiveInjector.resolveAndCreate([Engine]);\n   * var carProvider = ReflectiveInjector.resolve([Car])[0];\n   * var car = injector.instantiateResolved(carProvider);\n   * expect(car.engine).toBe(injector.get(Engine));\n   * expect(car).not.toBe(injector.instantiateResolved(carProvider));\n   * ```\n   */\n  abstract instantiateResolved(provider: ResolvedReflectiveProvider): any;\n\n  abstract get(token: any, notFoundValue?: any): any;\n}\n\nexport class ReflectiveInjector_ implements ReflectiveInjector {\n  private static INJECTOR_KEY = (/* @__PURE__ */ ReflectiveKey.get(Injector));\n  /** @internal */\n  _constructionCounter: number = 0;\n  /** @internal */\n  public _providers: ResolvedReflectiveProvider[];\n  public readonly parent: Injector|null;\n\n  keyIds: number[];\n  objs: any[];\n  /**\n   * Private\n   */\n  constructor(_providers: ResolvedReflectiveProvider[], _parent?: Injector) {\n    this._providers = _providers;\n    this.parent = _parent || null;\n\n    const len = _providers.length;\n\n    this.keyIds = [];\n    this.objs = [];\n\n    for (let i = 0; i < len; i++) {\n      this.keyIds[i] = _providers[i].key.id;\n      this.objs[i] = UNDEFINED;\n    }\n  }\n\n  get(token: any, notFoundValue: any = THROW_IF_NOT_FOUND): any {\n    return this._getByKey(ReflectiveKey.get(token), null, notFoundValue);\n  }\n\n  resolveAndCreateChild(providers: Provider[]): ReflectiveInjector {\n    const ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);\n    return this.createChildFromResolved(ResolvedReflectiveProviders);\n  }\n\n  createChildFromResolved(providers: ResolvedReflectiveProvider[]): ReflectiveInjector {\n    const inj = new ReflectiveInjector_(providers);\n    (inj as {parent: Injector | null}).parent = this;\n    return inj;\n  }\n\n  resolveAndInstantiate(provider: Provider): any {\n    return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);\n  }\n\n  instantiateResolved(provider: ResolvedReflectiveProvider): any {\n    return this._instantiateProvider(provider);\n  }\n\n  getProviderAtIndex(index: number): ResolvedReflectiveProvider {\n    if (index < 0 || index >= this._providers.length) {\n      throw outOfBoundsError(index);\n    }\n    return this._providers[index];\n  }\n\n  /** @internal */\n  _new(provider: ResolvedReflectiveProvider): any {\n    if (this._constructionCounter++ > this._getMaxNumberOfObjects()) {\n      throw cyclicDependencyError(this, provider.key);\n    }\n    return this._instantiateProvider(provider);\n  }\n\n  private _getMaxNumberOfObjects(): number {\n    return this.objs.length;\n  }\n\n  private _instantiateProvider(provider: ResolvedReflectiveProvider): any {\n    if (provider.multiProvider) {\n      const res = [];\n      for (let i = 0; i < provider.resolvedFactories.length; ++i) {\n        res[i] = this._instantiate(provider, provider.resolvedFactories[i]);\n      }\n      return res;\n    } else {\n      return this._instantiate(provider, provider.resolvedFactories[0]);\n    }\n  }\n\n  private _instantiate(\n      provider: ResolvedReflectiveProvider,\n      ResolvedReflectiveFactory: ResolvedReflectiveFactory): any {\n    const factory = ResolvedReflectiveFactory.factory;\n\n    let deps: any[];\n    try {\n      deps =\n          ResolvedReflectiveFactory.dependencies.map(dep => this._getByReflectiveDependency(dep));\n    } catch (e: any) {\n      if (e.addKey) {\n        e.addKey(this, provider.key);\n      }\n      throw e;\n    }\n\n    let obj: any;\n    try {\n      obj = factory(...deps);\n    } catch (e) {\n      throw instantiationError(this, e, (e as Error).stack, provider.key);\n    }\n\n    return obj;\n  }\n\n  private _getByReflectiveDependency(dep: ReflectiveDependency): any {\n    return this._getByKey(dep.key, dep.visibility, dep.optional ? null : THROW_IF_NOT_FOUND);\n  }\n\n  private _getByKey(key: ReflectiveKey, visibility: Self|SkipSelf|null, notFoundValue: any): any {\n    if (key === ReflectiveInjector_.INJECTOR_KEY) {\n      return this;\n    }\n\n    if (visibility instanceof Self) {\n      return this._getByKeySelf(key, notFoundValue);\n\n    } else {\n      return this._getByKeyDefault(key, notFoundValue, visibility);\n    }\n  }\n\n  private _getObjByKeyId(keyId: number): any {\n    for (let i = 0; i < this.keyIds.length; i++) {\n      if (this.keyIds[i] === keyId) {\n        if (this.objs[i] === UNDEFINED) {\n          this.objs[i] = this._new(this._providers[i]);\n        }\n\n        return this.objs[i];\n      }\n    }\n\n    return UNDEFINED;\n  }\n\n  /** @internal */\n  _throwOrNull(key: ReflectiveKey, notFoundValue: any): any {\n    if (notFoundValue !== THROW_IF_NOT_FOUND) {\n      return notFoundValue;\n    } else {\n      throw noProviderError(this, key);\n    }\n  }\n\n  /** @internal */\n  _getByKeySelf(key: ReflectiveKey, notFoundValue: any): any {\n    const obj = this._getObjByKeyId(key.id);\n    return (obj !== UNDEFINED) ? obj : this._throwOrNull(key, notFoundValue);\n  }\n\n  /** @internal */\n  _getByKeyDefault(key: ReflectiveKey, notFoundValue: any, visibility: Self|SkipSelf|null): any {\n    let inj: Injector|null;\n\n    if (visibility instanceof SkipSelf) {\n      inj = this.parent;\n    } else {\n      inj = this;\n    }\n\n    while (inj instanceof ReflectiveInjector_) {\n      const inj_ = <ReflectiveInjector_>inj;\n      const obj = inj_._getObjByKeyId(key.id);\n      if (obj !== UNDEFINED) return obj;\n      inj = inj_.parent;\n    }\n    if (inj !== null) {\n      return inj.get(key.token, notFoundValue);\n    } else {\n      return this._throwOrNull(key, notFoundValue);\n    }\n  }\n\n  get displayName(): string {\n    const providers =\n        _mapProviders(this, (b: ResolvedReflectiveProvider) => ' \"' + b.key.displayName + '\" ')\n            .join(', ');\n    return `ReflectiveInjector(providers: [${providers}])`;\n  }\n\n  toString(): string {\n    return this.displayName;\n  }\n}\n\nfunction _mapProviders(injector: ReflectiveInjector_, fn: Function): any[] {\n  const res: any[] = [];\n  for (let i = 0; i < injector._providers.length; ++i) {\n    res[i] = fn(injector.getProviderAtIndex(i));\n  }\n  return res;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @module\n * @description\n * The `di` module provides dependency injection container services.\n */\n\nexport * from './metadata';\nexport {InjectFlags} from './interface/injector';\nexport {ɵɵdefineInjectable, defineInjectable, ɵɵdefineInjector, InjectableType, InjectorType} from './interface/defs';\nexport {forwardRef, resolveForwardRef, ForwardRefFn} from './forward_ref';\nexport {Injectable, InjectableDecorator, InjectableProvider} from './injectable';\nexport {Injector} from './injector';\nexport {EnvironmentInjector} from './r3_injector';\nexport {importProvidersFrom, ImportProvidersSource} from './provider_collection';\nexport {ENVIRONMENT_INITIALIZER} from './initializer_token';\nexport {ProviderToken} from './provider_token';\nexport {ɵɵinject, inject, InjectOptions, ɵɵinvalidFactoryDep} from './injector_compatibility';\nexport {INJECTOR} from './injector_token';\nexport {ReflectiveInjector} from './reflective_injector';\nexport {ClassProvider, ModuleWithProviders, ClassSansProvider, ImportedNgModuleProviders, ConstructorProvider, ConstructorSansProvider, ExistingProvider, ExistingSansProvider, FactoryProvider, FactorySansProvider, Provider, StaticClassProvider, StaticClassSansProvider, StaticProvider, TypeProvider, ValueProvider, ValueSansProvider} from './interface/provider';\nexport {ResolvedReflectiveFactory, ResolvedReflectiveProvider} from './reflective_provider';\nexport {ReflectiveKey} from './reflective_key';\nexport {InjectionToken} from './injection_token';\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * This file should not be necessary because node resolution should just default to `./di/index`!\n *\n * However it does not seem to work and it breaks:\n *  - //packages/animations/browser/test:test_web_chromium-local\n *  - //packages/compiler-cli/test:extract_i18n\n *  - //packages/compiler-cli/test:ngc\n *  - //packages/compiler-cli/test:perform_watch\n *  - //packages/compiler-cli/test/diagnostics:check_types\n *  - //packages/compiler-cli/test/transformers:test\n *  - //packages/compiler/test:test\n *  - //tools/public_api_guard:core_api\n *\n * Remove this file once the above is solved or wait until `ngc` is deleted and then it should be\n * safe to delete this file.\n */\n\nexport * from './di/index';\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {InjectFlags, resolveForwardRef} from '../../di';\nimport {assertInjectImplementationNotEqual} from '../../di/inject_switch';\nimport {ɵɵinject} from '../../di/injector_compatibility';\nimport {ProviderToken} from '../../di/provider_token';\nimport {getOrCreateInjectable} from '../di';\nimport {TDirectiveHostNode} from '../interfaces/node';\nimport {getCurrentTNode, getLView} from '../state';\n\n/**\n * Returns the value associated to the given token from the injectors.\n *\n * `directiveInject` is intended to be used for directive, component and pipe factories.\n *  All other injection use `inject` which does not walk the node injector tree.\n *\n * Usage example (in factory function):\n *\n * ```ts\n * class SomeDirective {\n *   constructor(directive: DirectiveA) {}\n *\n *   static ɵdir = ɵɵdefineDirective({\n *     type: SomeDirective,\n *     factory: () => new SomeDirective(ɵɵdirectiveInject(DirectiveA))\n *   });\n * }\n * ```\n * @param token the type or token to inject\n * @param flags Injection flags\n * @returns the value from the injector or `null` when not found\n *\n * @codeGenApi\n */\nexport function ɵɵdirectiveInject<T>(token: ProviderToken<T>): T;\nexport function ɵɵdirectiveInject<T>(token: ProviderToken<T>, flags: InjectFlags): T;\nexport function ɵɵdirectiveInject<T>(token: ProviderToken<T>, flags = InjectFlags.Default): T|null {\n  const lView = getLView();\n  // Fall back to inject() if view hasn't been created. This situation can happen in tests\n  // if inject utilities are used before bootstrapping.\n  if (lView === null) {\n    // Verify that we will not get into infinite loop.\n    ngDevMode && assertInjectImplementationNotEqual(ɵɵdirectiveInject);\n    return ɵɵinject(token, flags);\n  }\n  const tNode = getCurrentTNode();\n  return getOrCreateInjectable<T>(\n      tNode as TDirectiveHostNode, lView, resolveForwardRef(token), flags);\n}\n\n/**\n * Throws an error indicating that a factory function could not be generated by the compiler for a\n * particular class.\n *\n * This instruction allows the actual error message to be optimized away when ngDevMode is turned\n * off, saving bytes of generated code while still providing a good experience in dev mode.\n *\n * The name of the class is not mentioned here, but will be in the generated factory function name\n * and thus in the stack trace.\n *\n * @codeGenApi\n */\nexport function ɵɵinvalidFactory(): never {\n  const msg =\n      ngDevMode ? `This constructor was not compatible with Dependency Injection.` : 'invalid';\n  throw new Error(msg);\n}\n","\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport './ng_dev_mode';\nimport {newTrustedFunctionForDev} from './security/trusted_types';\n\n/**\n * THIS FILE CONTAINS CODE WHICH SHOULD BE TREE SHAKEN AND NEVER CALLED FROM PRODUCTION CODE!!!\n */\n\n\n/**\n * Creates an `Array` construction with a given name. This is useful when\n * looking for memory consumption to see what time of array it is.\n *\n *\n * @param name Name to give to the constructor\n * @returns A subclass of `Array` if possible. This can only be done in\n *          environments which support `class` construct.\n */\nexport function createNamedArrayType(name: string): typeof Array {\n  // This should never be called in prod mode, so let's verify that is the case.\n  if (ngDevMode) {\n    try {\n      // If this function were compromised the following could lead to arbitrary\n      // script execution. We bless it with Trusted Types anyway since this\n      // function is stripped out of production binaries.\n      return (newTrustedFunctionForDev('Array', `return class ${name} extends Array{}`))(Array);\n    } catch (e) {\n      // If it does not work just give up and fall back to regular Array.\n      return Array;\n    }\n  } else {\n    throw new Error(\n        'Looks like we are in \\'prod mode\\', but we are creating a named Array type, which is wrong! Check your code');\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {KeyValueArray} from '../../util/array_utils';\nimport {assertNumber, assertNumberInRange} from '../../util/assert';\n\n/**\n * Value stored in the `TData` which is needed to re-concatenate the styling.\n *\n * See: `TStylingKeyPrimitive` and `TStylingStatic`\n */\nexport type TStylingKey = TStylingKeyPrimitive|TStylingStatic;\n\n\n/**\n * The primitive portion (`TStylingStatic` removed) of the value stored in the `TData` which is\n * needed to re-concatenate the styling.\n *\n * - `string`: Stores the property name. Used with `ɵɵstyleProp`/`ɵɵclassProp` instruction.\n * - `null`: Represents map, so there is no name. Used with `ɵɵstyleMap`/`ɵɵclassMap`.\n * - `false`: Represents an ignore case. This happens when `ɵɵstyleProp`/`ɵɵclassProp` instruction\n *   is combined with directive which shadows its input `@Input('class')`. That way the binding\n *   should not participate in the styling resolution.\n */\nexport type TStylingKeyPrimitive = string|null|false;\n\n/**\n * Store the static values for the styling binding.\n *\n * The `TStylingStatic` is just `KeyValueArray` where key `\"\"` (stored at location 0) contains the\n * `TStylingKey` (stored at location 1). In other words this wraps the `TStylingKey` such that the\n * `\"\"` contains the wrapped value.\n *\n * When instructions are resolving styling they may need to look forward or backwards in the linked\n * list to resolve the value. For this reason we have to make sure that he linked list also contains\n * the static values. However the list only has space for one item per styling instruction. For this\n * reason we store the static values here as part of the `TStylingKey`. This means that the\n * resolution function when looking for a value needs to first look at the binding value, and than\n * at `TStylingKey` (if it exists).\n *\n * Imagine we have:\n *\n * ```\n * <div class=\"TEMPLATE\" my-dir>\n *\n * @Directive({\n *   host: {\n *     class: 'DIR',\n *     '[class.dynamic]': 'exp' // ɵɵclassProp('dynamic', ctx.exp);\n *   }\n * })\n * ```\n *\n * In the above case the linked list will contain one item:\n *\n * ```\n *   // assume binding location: 10 for `ɵɵclassProp('dynamic', ctx.exp);`\n *   tData[10] = <TStylingStatic>[\n *     '': 'dynamic', // This is the wrapped value of `TStylingKey`\n *     'DIR': true,   // This is the default static value of directive binding.\n *   ];\n *   tData[10 + 1] = 0; // We don't have prev/next.\n *\n *   lView[10] = undefined;     // assume `ctx.exp` is `undefined`\n *   lView[10 + 1] = undefined; // Just normalized `lView[10]`\n * ```\n *\n * So when the function is resolving styling value, it first needs to look into the linked list\n * (there is none) and than into the static `TStylingStatic` too see if there is a default value for\n * `dynamic` (there is not). Therefore it is safe to remove it.\n *\n * If setting `true` case:\n * ```\n *   lView[10] = true;     // assume `ctx.exp` is `true`\n *   lView[10 + 1] = true; // Just normalized `lView[10]`\n * ```\n * So when the function is resolving styling value, it first needs to look into the linked list\n * (there is none) and than into `TNode.residualClass` (TNode.residualStyle) which contains\n * ```\n *   tNode.residualClass = [\n *     'TEMPLATE': true,\n *   ];\n * ```\n *\n * This means that it is safe to add class.\n */\nexport interface TStylingStatic extends KeyValueArray<any> {}\n\n/**\n * This is a branded number which contains previous and next index.\n *\n * When we come across styling instructions we need to store the `TStylingKey` in the correct\n * order so that we can re-concatenate the styling value in the desired priority.\n *\n * The insertion can happen either at the:\n * - end of template as in the case of coming across additional styling instruction in the template\n * - in front of the template in the case of coming across additional instruction in the\n *   `hostBindings`.\n *\n * We use `TStylingRange` to store the previous and next index into the `TData` where the template\n * bindings can be found.\n *\n * - bit 0 is used to mark that the previous index has a duplicate for current value.\n * - bit 1 is used to mark that the next index has a duplicate for the current value.\n * - bits 2-16 are used to encode the next/tail of the template.\n * - bits 17-32 are used to encode the previous/head of template.\n *\n * NODE: *duplicate* false implies that it is statically known that this binding will not collide\n * with other bindings and therefore there is no need to check other bindings. For example the\n * bindings in `<div [style.color]=\"exp\" [style.width]=\"exp\">` will never collide and will have\n * their bits set accordingly. Previous duplicate means that we may need to check previous if the\n * current binding is `null`. Next duplicate means that we may need to check next bindings if the\n * current binding is not `null`.\n *\n * NOTE: `0` has special significance and represents `null` as in no additional pointer.\n */\nexport interface TStylingRange {\n  __brand__: 'TStylingRange';\n}\n\n/**\n * Shift and masks constants for encoding two numbers into and duplicate info into a single number.\n */\nexport const enum StylingRange {\n  /// Number of bits to shift for the previous pointer\n  PREV_SHIFT = 17,\n  /// Previous pointer mask.\n  PREV_MASK = 0xFFFE0000,\n\n  /// Number of bits to shift for the next pointer\n  NEXT_SHIFT = 2,\n  /// Next pointer mask.\n  NEXT_MASK = 0x001FFFC,\n\n  // Mask to remove negative bit. (interpret number as positive)\n  UNSIGNED_MASK = 0x7FFF,\n\n  /**\n   * This bit is set if the previous bindings contains a binding which could possibly cause a\n   * duplicate. For example: `<div [style]=\"map\" [style.width]=\"width\">`, the `width` binding will\n   * have previous duplicate set. The implication is that if `width` binding becomes `null`, it is\n   * necessary to defer the value to `map.width`. (Because `width` overwrites `map.width`.)\n   */\n  PREV_DUPLICATE = 0x02,\n\n  /**\n   * This bit is set to if the next binding contains a binding which could possibly cause a\n   * duplicate. For example: `<div [style]=\"map\" [style.width]=\"width\">`, the `map` binding will\n   * have next duplicate set. The implication is that if `map.width` binding becomes not `null`, it\n   * is necessary to defer the value to `width`. (Because `width` overwrites `map.width`.)\n   */\n  NEXT_DUPLICATE = 0x01,\n}\n\n\nexport function toTStylingRange(prev: number, next: number): TStylingRange {\n  ngDevMode && assertNumberInRange(prev, 0, StylingRange.UNSIGNED_MASK);\n  ngDevMode && assertNumberInRange(next, 0, StylingRange.UNSIGNED_MASK);\n  return (prev << StylingRange.PREV_SHIFT | next << StylingRange.NEXT_SHIFT) as any;\n}\n\nexport function getTStylingRangePrev(tStylingRange: TStylingRange): number {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  return ((tStylingRange as any as number) >> StylingRange.PREV_SHIFT) & StylingRange.UNSIGNED_MASK;\n}\n\nexport function getTStylingRangePrevDuplicate(tStylingRange: TStylingRange): boolean {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  return ((tStylingRange as any as number) & StylingRange.PREV_DUPLICATE) ==\n      StylingRange.PREV_DUPLICATE;\n}\n\nexport function setTStylingRangePrev(\n    tStylingRange: TStylingRange, previous: number): TStylingRange {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  ngDevMode && assertNumberInRange(previous, 0, StylingRange.UNSIGNED_MASK);\n  return (((tStylingRange as any as number) & ~StylingRange.PREV_MASK) |\n          (previous << StylingRange.PREV_SHIFT)) as any;\n}\n\nexport function setTStylingRangePrevDuplicate(tStylingRange: TStylingRange): TStylingRange {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  return ((tStylingRange as any as number) | StylingRange.PREV_DUPLICATE) as any;\n}\n\nexport function getTStylingRangeNext(tStylingRange: TStylingRange): number {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  return ((tStylingRange as any as number) & StylingRange.NEXT_MASK) >> StylingRange.NEXT_SHIFT;\n}\n\nexport function setTStylingRangeNext(tStylingRange: TStylingRange, next: number): TStylingRange {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  ngDevMode && assertNumberInRange(next, 0, StylingRange.UNSIGNED_MASK);\n  return (((tStylingRange as any as number) & ~StylingRange.NEXT_MASK) |  //\n          next << StylingRange.NEXT_SHIFT) as any;\n}\n\nexport function getTStylingRangeNextDuplicate(tStylingRange: TStylingRange): boolean {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  return ((tStylingRange as any as number) & StylingRange.NEXT_DUPLICATE) ===\n      StylingRange.NEXT_DUPLICATE;\n}\n\nexport function setTStylingRangeNextDuplicate(tStylingRange: TStylingRange): TStylingRange {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  return ((tStylingRange as any as number) | StylingRange.NEXT_DUPLICATE) as any;\n}\n\nexport function getTStylingRangeTail(tStylingRange: TStylingRange): number {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  const next = getTStylingRangeNext(tStylingRange);\n  return next === 0 ? getTStylingRangePrev(tStylingRange) : next;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Patch a `debug` property on top of the existing object.\n *\n * NOTE: always call this method with `ngDevMode && attachDebugObject(...)`\n *\n * @param obj Object to patch\n * @param debug Value to patch\n */\nexport function attachDebugObject(obj: any, debug: any): void {\n  if (ngDevMode) {\n    Object.defineProperty(obj, 'debug', {value: debug, enumerable: false});\n  } else {\n    throw new Error(\n        'This method should be guarded with `ngDevMode` so that it can be tree shaken in production!');\n  }\n}\n\n/**\n * Patch a `debug` property getter on top of the existing object.\n *\n * NOTE: always call this method with `ngDevMode && attachDebugObject(...)`\n *\n * @param obj Object to patch\n * @param debugGetter Getter returning a value to patch\n */\nexport function attachDebugGetter<T>(obj: T, debugGetter: (this: T) => any): void {\n  if (ngDevMode) {\n    Object.defineProperty(obj, 'debug', {get: debugGetter, enumerable: false});\n  } else {\n    throw new Error(\n        'This method should be guarded with `ngDevMode` so that it can be tree shaken in production!');\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '../../di/injector';\nimport {Type} from '../../interface/type';\nimport {SchemaMetadata} from '../../metadata/schema';\nimport {Sanitizer} from '../../sanitization/sanitizer';\nimport {KeyValueArray} from '../../util/array_utils';\nimport {assertDefined} from '../../util/assert';\nimport {createNamedArrayType} from '../../util/named_array_type';\nimport {assertNodeInjector} from '../assert';\nimport {getInjectorIndex, getParentInjectorLocation} from '../di';\nimport {CONTAINER_HEADER_OFFSET, HAS_TRANSPLANTED_VIEWS, LContainer, MOVED_VIEWS, NATIVE} from '../interfaces/container';\nimport {ComponentTemplate, DirectiveDef, DirectiveDefList, PipeDefList, ViewQueriesFunction} from '../interfaces/definition';\nimport {NO_PARENT_INJECTOR, NodeInjectorOffset} from '../interfaces/injector';\nimport {AttributeMarker, InsertBeforeIndex, PropertyAliases, TConstants, TContainerNode, TElementNode, TNode as ITNode, TNodeFlags, TNodeProviderIndexes, TNodeType, toTNodeTypeAsString} from '../interfaces/node';\nimport {SelectorFlags} from '../interfaces/projection';\nimport {LQueries, TQueries} from '../interfaces/query';\nimport {Renderer, RendererFactory} from '../interfaces/renderer';\nimport {RComment, RElement, RNode} from '../interfaces/renderer_dom';\nimport {getTStylingRangeNext, getTStylingRangeNextDuplicate, getTStylingRangePrev, getTStylingRangePrevDuplicate, TStylingKey, TStylingRange} from '../interfaces/styling';\nimport {CHILD_HEAD, CHILD_TAIL, CLEANUP, CONTEXT, DebugNode, DECLARATION_VIEW, DestroyHookData, FLAGS, HEADER_OFFSET, HookData, HOST, HostBindingOpCodes, ID, INJECTOR, LContainerDebug as ILContainerDebug, LView, LViewDebug as ILViewDebug, LViewDebugRange, LViewDebugRangeContent, LViewFlags, NEXT, NodeInjectorDebug, PARENT, QUERIES, RENDERER, RENDERER_FACTORY, SANITIZER, T_HOST, TData, TView as ITView, TVIEW, TView, TViewType, TViewTypeAsString} from '../interfaces/view';\nimport {attachDebugObject} from '../util/debug_utils';\nimport {getParentInjectorIndex, getParentInjectorView} from '../util/injector_utils';\nimport {unwrapRNode} from '../util/view_utils';\n\n/*\n * This file contains conditionally attached classes which provide human readable (debug) level\n * information for `LView`, `LContainer` and other internal data structures. These data structures\n * are stored internally as array which makes it very difficult during debugging to reason about the\n * current state of the system.\n *\n * Patching the array with extra property does change the array's hidden class' but it does not\n * change the cost of access, therefore this patching should not have significant if any impact in\n * `ngDevMode` mode. (see: https://jsperf.com/array-vs-monkey-patch-array)\n *\n * So instead of seeing:\n * ```\n * Array(30) [Object, 659, null, …]\n * ```\n *\n * You get to see:\n * ```\n * LViewDebug {\n *   views: [...],\n *   flags: {attached: true, ...}\n *   nodes: [\n *     {html: '<div id=\"123\">', ..., nodes: [\n *       {html: '<span>', ..., nodes: null}\n *     ]}\n *   ]\n * }\n * ```\n */\n\nlet LVIEW_COMPONENT_CACHE: Map<string|null, Array<any>>|undefined;\nlet LVIEW_EMBEDDED_CACHE: Map<string|null, Array<any>>|undefined;\nlet LVIEW_ROOT: Array<any>|undefined;\nlet LVIEW_COMPONENT: Array<any>|undefined;\nlet LVIEW_EMBEDDED: Array<any>|undefined;\n\ninterface TViewDebug extends ITView {\n  type: TViewType;\n}\n\n/**\n * This function clones a blueprint and creates LView.\n *\n * Simple slice will keep the same type, and we need it to be LView\n */\nexport function cloneToLViewFromTViewBlueprint<T>(tView: TView): LView<T> {\n  const debugTView = tView as TViewDebug;\n  const lView = getLViewToClone(debugTView.type, tView.template && tView.template.name);\n  return lView.concat(tView.blueprint) as any;\n}\n\nclass LRootView extends Array {}\nclass LComponentView extends Array {}\nclass LEmbeddedView extends Array {}\n\nfunction getLViewToClone(type: TViewType, name: string|null): Array<any> {\n  switch (type) {\n    case TViewType.Root:\n      if (LVIEW_ROOT === undefined) LVIEW_ROOT = new LRootView();\n      return LVIEW_ROOT;\n    case TViewType.Component:\n      if (!ngDevMode || !ngDevMode.namedConstructors) {\n        if (LVIEW_COMPONENT === undefined) LVIEW_COMPONENT = new LComponentView();\n        return LVIEW_COMPONENT;\n      }\n      if (LVIEW_COMPONENT_CACHE === undefined) LVIEW_COMPONENT_CACHE = new Map();\n      let componentArray = LVIEW_COMPONENT_CACHE.get(name);\n      if (componentArray === undefined) {\n        componentArray = new (createNamedArrayType('LComponentView' + nameSuffix(name)))();\n        LVIEW_COMPONENT_CACHE.set(name, componentArray);\n      }\n      return componentArray;\n    case TViewType.Embedded:\n      if (!ngDevMode || !ngDevMode.namedConstructors) {\n        if (LVIEW_EMBEDDED === undefined) LVIEW_EMBEDDED = new LEmbeddedView();\n        return LVIEW_EMBEDDED;\n      }\n      if (LVIEW_EMBEDDED_CACHE === undefined) LVIEW_EMBEDDED_CACHE = new Map();\n      let embeddedArray = LVIEW_EMBEDDED_CACHE.get(name);\n      if (embeddedArray === undefined) {\n        embeddedArray = new (createNamedArrayType('LEmbeddedView' + nameSuffix(name)))();\n        LVIEW_EMBEDDED_CACHE.set(name, embeddedArray);\n      }\n      return embeddedArray;\n  }\n}\n\nfunction nameSuffix(text: string|null|undefined): string {\n  if (text == null) return '';\n  const index = text.lastIndexOf('_Template');\n  return '_' + (index === -1 ? text : text.slice(0, index));\n}\n\n/**\n * This class is a debug version of Object literal so that we can have constructor name show up\n * in\n * debug tools in ngDevMode.\n */\nexport const TViewConstructor = class TView implements ITView {\n  constructor(\n      public type: TViewType,\n      public blueprint: LView,\n      public template: ComponentTemplate<{}>|null,\n      public queries: TQueries|null,\n      public viewQuery: ViewQueriesFunction<{}>|null,\n      public declTNode: ITNode|null,\n      public data: TData,\n      public bindingStartIndex: number,\n      public expandoStartIndex: number,\n      public hostBindingOpCodes: HostBindingOpCodes|null,\n      public firstCreatePass: boolean,\n      public firstUpdatePass: boolean,\n      public staticViewQueries: boolean,\n      public staticContentQueries: boolean,\n      public preOrderHooks: HookData|null,\n      public preOrderCheckHooks: HookData|null,\n      public contentHooks: HookData|null,\n      public contentCheckHooks: HookData|null,\n      public viewHooks: HookData|null,\n      public viewCheckHooks: HookData|null,\n      public destroyHooks: DestroyHookData|null,\n      public cleanup: any[]|null,\n      public contentQueries: number[]|null,\n      public components: number[]|null,\n      public directiveRegistry: DirectiveDefList|null,\n      public pipeRegistry: PipeDefList|null,\n      public firstChild: ITNode|null,\n      public schemas: SchemaMetadata[]|null,\n      public consts: TConstants|null,\n      public incompleteFirstPass: boolean,\n      public _decls: number,\n      public _vars: number,\n\n  ) {}\n\n  get template_(): string {\n    const buf: string[] = [];\n    processTNodeChildren(this.firstChild, buf);\n    return buf.join('');\n  }\n\n  get type_(): string {\n    return TViewTypeAsString[this.type] || `TViewType.?${this.type}?`;\n  }\n};\n\nclass TNode implements ITNode {\n  constructor(\n      public tView_: TView,                                                          //\n      public type: TNodeType,                                                        //\n      public index: number,                                                          //\n      public insertBeforeIndex: InsertBeforeIndex,                                   //\n      public injectorIndex: number,                                                  //\n      public directiveStart: number,                                                 //\n      public directiveEnd: number,                                                   //\n      public directiveStylingLast: number,                                           //\n      public propertyBindings: number[]|null,                                        //\n      public flags: TNodeFlags,                                                      //\n      public providerIndexes: TNodeProviderIndexes,                                  //\n      public value: string|null,                                                     //\n      public attrs: (string|AttributeMarker|(string|SelectorFlags)[])[]|null,        //\n      public mergedAttrs: (string|AttributeMarker|(string|SelectorFlags)[])[]|null,  //\n      public localNames: (string|number)[]|null,                                     //\n      public initialInputs: (string[]|null)[]|null|undefined,                        //\n      public inputs: PropertyAliases|null,                                           //\n      public outputs: PropertyAliases|null,                                          //\n      public tViews: ITView|ITView[]|null,                                           //\n      public next: ITNode|null,                                                      //\n      public projectionNext: ITNode|null,                                            //\n      public child: ITNode|null,                                                     //\n      public parent: TElementNode|TContainerNode|null,                               //\n      public projection: number|(ITNode|RNode[])[]|null,                             //\n      public styles: string|null,                                                    //\n      public stylesWithoutHost: string|null,                                         //\n      public residualStyles: KeyValueArray<any>|undefined|null,                      //\n      public classes: string|null,                                                   //\n      public classesWithoutHost: string|null,                                        //\n      public residualClasses: KeyValueArray<any>|undefined|null,                     //\n      public classBindings: TStylingRange,                                           //\n      public styleBindings: TStylingRange,                                           //\n  ) {}\n\n  /**\n   * Return a human debug version of the set of `NodeInjector`s which will be consulted when\n   * resolving tokens from this `TNode`.\n   *\n   * When debugging applications, it is often difficult to determine which `NodeInjector`s will be\n   * consulted. This method shows a list of `DebugNode`s representing the `TNode`s which will be\n   * consulted in order when resolving a token starting at this `TNode`.\n   *\n   * The original data is stored in `LView` and `TView` with a lot of offset indexes, and so it is\n   * difficult to reason about.\n   *\n   * @param lView The `LView` instance for this `TNode`.\n   */\n  debugNodeInjectorPath(lView: LView): DebugNode[] {\n    const path: DebugNode[] = [];\n    let injectorIndex = getInjectorIndex(this, lView);\n    if (injectorIndex === -1) {\n      // Looks like the current `TNode` does not have `NodeInjector` associated with it => look for\n      // parent NodeInjector.\n      const parentLocation = getParentInjectorLocation(this, lView);\n      if (parentLocation !== NO_PARENT_INJECTOR) {\n        // We found a parent, so start searching from the parent location.\n        injectorIndex = getParentInjectorIndex(parentLocation);\n        lView = getParentInjectorView(parentLocation, lView);\n      } else {\n        // No parents have been found, so there are no `NodeInjector`s to consult.\n      }\n    }\n    while (injectorIndex !== -1) {\n      ngDevMode && assertNodeInjector(lView, injectorIndex);\n      const tNode = lView[TVIEW].data[injectorIndex + NodeInjectorOffset.TNODE] as TNode;\n      path.push(buildDebugNode(tNode, lView));\n      const parentLocation = lView[injectorIndex + NodeInjectorOffset.PARENT];\n      if (parentLocation === NO_PARENT_INJECTOR) {\n        injectorIndex = -1;\n      } else {\n        injectorIndex = getParentInjectorIndex(parentLocation);\n        lView = getParentInjectorView(parentLocation, lView);\n      }\n    }\n    return path;\n  }\n\n  get type_(): string {\n    return toTNodeTypeAsString(this.type) || `TNodeType.?${this.type}?`;\n  }\n\n  get flags_(): string {\n    const flags: string[] = [];\n    if (this.flags & TNodeFlags.hasClassInput) flags.push('TNodeFlags.hasClassInput');\n    if (this.flags & TNodeFlags.hasContentQuery) flags.push('TNodeFlags.hasContentQuery');\n    if (this.flags & TNodeFlags.hasStyleInput) flags.push('TNodeFlags.hasStyleInput');\n    if (this.flags & TNodeFlags.hasHostBindings) flags.push('TNodeFlags.hasHostBindings');\n    if (this.flags & TNodeFlags.isComponentHost) flags.push('TNodeFlags.isComponentHost');\n    if (this.flags & TNodeFlags.isDirectiveHost) flags.push('TNodeFlags.isDirectiveHost');\n    if (this.flags & TNodeFlags.isDetached) flags.push('TNodeFlags.isDetached');\n    if (this.flags & TNodeFlags.isProjected) flags.push('TNodeFlags.isProjected');\n    return flags.join('|');\n  }\n\n  get template_(): string {\n    if (this.type & TNodeType.Text) return this.value!;\n    const buf: string[] = [];\n    const tagName = typeof this.value === 'string' && this.value || this.type_;\n    buf.push('<', tagName);\n    if (this.flags) {\n      buf.push(' ', this.flags_);\n    }\n    if (this.attrs) {\n      for (let i = 0; i < this.attrs.length;) {\n        const attrName = this.attrs[i++];\n        if (typeof attrName == 'number') {\n          break;\n        }\n        const attrValue = this.attrs[i++];\n        buf.push(' ', attrName as string, '=\"', attrValue as string, '\"');\n      }\n    }\n    buf.push('>');\n    processTNodeChildren(this.child, buf);\n    buf.push('</', tagName, '>');\n    return buf.join('');\n  }\n\n  get styleBindings_(): DebugStyleBindings {\n    return toDebugStyleBinding(this, false);\n  }\n  get classBindings_(): DebugStyleBindings {\n    return toDebugStyleBinding(this, true);\n  }\n\n  get providerIndexStart_(): number {\n    return this.providerIndexes & TNodeProviderIndexes.ProvidersStartIndexMask;\n  }\n  get providerIndexEnd_(): number {\n    return this.providerIndexStart_ +\n        (this.providerIndexes >>> TNodeProviderIndexes.CptViewProvidersCountShift);\n  }\n}\nexport const TNodeDebug = TNode;\nexport type TNodeDebug = TNode;\n\nexport interface DebugStyleBindings extends\n    Array<KeyValueArray<any>|DebugStyleBinding|string|null> {}\nexport interface DebugStyleBinding {\n  key: TStylingKey;\n  index: number;\n  isTemplate: boolean;\n  prevDuplicate: boolean;\n  nextDuplicate: boolean;\n  prevIndex: number;\n  nextIndex: number;\n}\n\nfunction toDebugStyleBinding(tNode: TNode, isClassBased: boolean): DebugStyleBindings {\n  const tData = tNode.tView_.data;\n  const bindings: DebugStyleBindings = [] as any;\n  const range = isClassBased ? tNode.classBindings : tNode.styleBindings;\n  const prev = getTStylingRangePrev(range);\n  const next = getTStylingRangeNext(range);\n  let isTemplate = next !== 0;\n  let cursor = isTemplate ? next : prev;\n  while (cursor !== 0) {\n    const itemKey = tData[cursor] as TStylingKey;\n    const itemRange = tData[cursor + 1] as TStylingRange;\n    bindings.unshift({\n      key: itemKey,\n      index: cursor,\n      isTemplate: isTemplate,\n      prevDuplicate: getTStylingRangePrevDuplicate(itemRange),\n      nextDuplicate: getTStylingRangeNextDuplicate(itemRange),\n      nextIndex: getTStylingRangeNext(itemRange),\n      prevIndex: getTStylingRangePrev(itemRange),\n    });\n    if (cursor === prev) isTemplate = false;\n    cursor = getTStylingRangePrev(itemRange);\n  }\n  bindings.push((isClassBased ? tNode.residualClasses : tNode.residualStyles) || null);\n  return bindings;\n}\n\nfunction processTNodeChildren(tNode: ITNode|null, buf: string[]) {\n  while (tNode) {\n    buf.push((tNode as any as {template_: string}).template_);\n    tNode = tNode.next;\n  }\n}\n\nclass TViewData extends Array {}\nlet TVIEWDATA_EMPTY: unknown[];  // can't initialize here or it will not be tree shaken, because\n                                 // `LView` constructor could have side-effects.\n/**\n * This function clones a blueprint and creates TData.\n *\n * Simple slice will keep the same type, and we need it to be TData\n */\nexport function cloneToTViewData(list: any[]): TData {\n  if (TVIEWDATA_EMPTY === undefined) TVIEWDATA_EMPTY = new TViewData();\n  return TVIEWDATA_EMPTY.concat(list) as any;\n}\n\nexport class LViewBlueprint extends Array {}\nexport class MatchesArray extends Array {}\nexport class TViewComponents extends Array {}\nexport class TNodeLocalNames extends Array {}\nexport class TNodeInitialInputs extends Array {}\nexport class LCleanup extends Array {}\nexport class TCleanup extends Array {}\n\nexport function attachLViewDebug(lView: LView) {\n  attachDebugObject(lView, new LViewDebug(lView));\n}\n\nexport function attachLContainerDebug(lContainer: LContainer) {\n  attachDebugObject(lContainer, new LContainerDebug(lContainer));\n}\n\nexport function toDebug<T>(obj: LView<T>): ILViewDebug<T>;\nexport function toDebug<T>(obj: LView<T>|null): ILViewDebug<T>|null;\nexport function toDebug<T>(obj: LView<T>|LContainer|null): ILViewDebug<T>|ILContainerDebug|null;\nexport function toDebug(obj: any): any {\n  if (obj) {\n    const debug = (obj as any).debug;\n    assertDefined(debug, 'Object does not have a debug representation.');\n    return debug;\n  } else {\n    return obj;\n  }\n}\n\n/**\n * Use this method to unwrap a native element in `LView` and convert it into HTML for easier\n * reading.\n *\n * @param value possibly wrapped native DOM node.\n * @param includeChildren If `true` then the serialized HTML form will include child elements\n * (same\n * as `outerHTML`). If `false` then the serialized HTML form will only contain the element\n * itself\n * (will not serialize child elements).\n */\nfunction toHtml(value: any, includeChildren: boolean = false): string|null {\n  const node: Node|null = unwrapRNode(value) as any;\n  if (node) {\n    switch (node.nodeType) {\n      case Node.TEXT_NODE:\n        return node.textContent;\n      case Node.COMMENT_NODE:\n        return `<!--${(node as Comment).textContent}-->`;\n      case Node.ELEMENT_NODE:\n        const outerHTML = (node as Element).outerHTML;\n        if (includeChildren) {\n          return outerHTML;\n        } else {\n          const innerHTML = '>' + (node as Element).innerHTML + '<';\n          return (outerHTML.split(innerHTML)[0]) + '>';\n        }\n    }\n  }\n  return null;\n}\n\nexport class LViewDebug<T = unknown> implements ILViewDebug<T> {\n  constructor(private readonly _raw_lView: LView<T>) {}\n\n  /**\n   * Flags associated with the `LView` unpacked into a more readable state.\n   */\n  get flags() {\n    const flags = this._raw_lView[FLAGS];\n    return {\n      __raw__flags__: flags,\n      initPhaseState: flags & LViewFlags.InitPhaseStateMask,\n      creationMode: !!(flags & LViewFlags.CreationMode),\n      firstViewPass: !!(flags & LViewFlags.FirstLViewPass),\n      checkAlways: !!(flags & LViewFlags.CheckAlways),\n      dirty: !!(flags & LViewFlags.Dirty),\n      attached: !!(flags & LViewFlags.Attached),\n      destroyed: !!(flags & LViewFlags.Destroyed),\n      isRoot: !!(flags & LViewFlags.IsRoot),\n      indexWithinInitPhase: flags >> LViewFlags.IndexWithinInitPhaseShift,\n    };\n  }\n  get parent(): ILViewDebug<T>|ILContainerDebug|null {\n    return toDebug<T>(this._raw_lView[PARENT] as LView<T>| LContainer | null);\n  }\n  get hostHTML(): string|null {\n    return toHtml(this._raw_lView[HOST], true);\n  }\n  get html(): string {\n    return (this.nodes || []).map(mapToHTML).join('');\n  }\n  get context(): T {\n    return this._raw_lView[CONTEXT];\n  }\n  /**\n   * The tree of nodes associated with the current `LView`. The nodes have been normalized into\n   * a tree structure with relevant details pulled out for readability.\n   */\n  get nodes(): DebugNode[] {\n    const lView = this._raw_lView;\n    const tNode = lView[TVIEW].firstChild;\n    return toDebugNodes(tNode, lView);\n  }\n  get template(): string {\n    return (this.tView as any as {template_: string}).template_;\n  }\n  get tView(): ITView {\n    return this._raw_lView[TVIEW];\n  }\n  get cleanup(): any[]|null {\n    return this._raw_lView[CLEANUP];\n  }\n  get injector(): Injector|null {\n    return this._raw_lView[INJECTOR];\n  }\n  get rendererFactory(): RendererFactory {\n    return this._raw_lView[RENDERER_FACTORY];\n  }\n  get renderer(): Renderer {\n    return this._raw_lView[RENDERER];\n  }\n  get sanitizer(): Sanitizer|null {\n    return this._raw_lView[SANITIZER];\n  }\n  get childHead(): ILViewDebug|ILContainerDebug|null {\n    return toDebug(this._raw_lView[CHILD_HEAD]);\n  }\n  get next(): ILViewDebug<T>|ILContainerDebug|null {\n    return toDebug<T>(this._raw_lView[NEXT] as LView<T>| LContainer | null);\n  }\n  get childTail(): ILViewDebug|ILContainerDebug|null {\n    return toDebug(this._raw_lView[CHILD_TAIL]);\n  }\n  get declarationView(): ILViewDebug|null {\n    return toDebug(this._raw_lView[DECLARATION_VIEW]);\n  }\n  get queries(): LQueries|null {\n    return this._raw_lView[QUERIES];\n  }\n  get tHost(): ITNode|null {\n    return this._raw_lView[T_HOST];\n  }\n  get id(): number {\n    return this._raw_lView[ID];\n  }\n\n  get decls(): LViewDebugRange {\n    return toLViewRange(this.tView, this._raw_lView, HEADER_OFFSET, this.tView.bindingStartIndex);\n  }\n\n  get vars(): LViewDebugRange {\n    return toLViewRange(\n        this.tView, this._raw_lView, this.tView.bindingStartIndex, this.tView.expandoStartIndex);\n  }\n\n  get expando(): LViewDebugRange {\n    return toLViewRange(\n        this.tView, this._raw_lView, this.tView.expandoStartIndex, this._raw_lView.length);\n  }\n\n  /**\n   * Normalized view of child views (and containers) attached at this location.\n   */\n  get childViews(): Array<ILViewDebug<T>|ILContainerDebug> {\n    const childViews: Array<ILViewDebug<T>|ILContainerDebug> = [];\n    let child = this.childHead;\n    while (child) {\n      childViews.push(child as ILViewDebug<T>| ILContainerDebug);\n      child = child.next;\n    }\n    return childViews;\n  }\n}\n\nfunction mapToHTML(node: DebugNode): string {\n  if (node.type === 'ElementContainer') {\n    return (node.children || []).map(mapToHTML).join('');\n  } else if (node.type === 'IcuContainer') {\n    throw new Error('Not implemented');\n  } else {\n    return toHtml(node.native, true) || '';\n  }\n}\n\nfunction toLViewRange(tView: TView, lView: LView, start: number, end: number): LViewDebugRange {\n  let content: LViewDebugRangeContent[] = [];\n  for (let index = start; index < end; index++) {\n    content.push({index: index, t: tView.data[index], l: lView[index]});\n  }\n  return {start: start, end: end, length: end - start, content: content};\n}\n\n/**\n * Turns a flat list of nodes into a tree by walking the associated `TNode` tree.\n *\n * @param tNode\n * @param lView\n */\nexport function toDebugNodes(tNode: ITNode|null, lView: LView): DebugNode[] {\n  if (tNode) {\n    const debugNodes: DebugNode[] = [];\n    let tNodeCursor: ITNode|null = tNode;\n    while (tNodeCursor) {\n      debugNodes.push(buildDebugNode(tNodeCursor, lView));\n      tNodeCursor = tNodeCursor.next;\n    }\n    return debugNodes;\n  } else {\n    return [];\n  }\n}\n\nexport function buildDebugNode(tNode: ITNode, lView: LView): DebugNode {\n  const rawValue = lView[tNode.index];\n  const native = unwrapRNode(rawValue);\n  const factories: Type<any>[] = [];\n  const instances: any[] = [];\n  const tView = lView[TVIEW];\n  for (let i = tNode.directiveStart; i < tNode.directiveEnd; i++) {\n    const def = tView.data[i] as DirectiveDef<any>;\n    factories.push(def.type);\n    instances.push(lView[i]);\n  }\n  return {\n    html: toHtml(native),\n    type: toTNodeTypeAsString(tNode.type),\n    tNode,\n    native: native as any,\n    children: toDebugNodes(tNode.child, lView),\n    factories,\n    instances,\n    injector: buildNodeInjectorDebug(tNode, tView, lView),\n    get injectorResolutionPath() {\n      return (tNode as TNode).debugNodeInjectorPath(lView);\n    },\n  };\n}\n\nfunction buildNodeInjectorDebug(tNode: ITNode, tView: ITView, lView: LView): NodeInjectorDebug {\n  const viewProviders: Type<any>[] = [];\n  for (let i = (tNode as TNode).providerIndexStart_; i < (tNode as TNode).providerIndexEnd_; i++) {\n    viewProviders.push(tView.data[i] as Type<any>);\n  }\n  const providers: Type<any>[] = [];\n  for (let i = (tNode as TNode).providerIndexEnd_; i < (tNode as TNode).directiveEnd; i++) {\n    providers.push(tView.data[i] as Type<any>);\n  }\n  const nodeInjectorDebug = {\n    bloom: toBloom(lView, tNode.injectorIndex),\n    cumulativeBloom: toBloom(tView.data, tNode.injectorIndex),\n    providers,\n    viewProviders,\n    parentInjectorIndex: lView[(tNode as TNode).providerIndexStart_ - 1],\n  };\n  return nodeInjectorDebug;\n}\n\n/**\n * Convert a number at `idx` location in `array` into binary representation.\n *\n * @param array\n * @param idx\n */\nfunction binary(array: any[], idx: number): string {\n  const value = array[idx];\n  // If not a number we print 8 `?` to retain alignment but let user know that it was called on\n  // wrong type.\n  if (typeof value !== 'number') return '????????';\n  // We prefix 0s so that we have constant length number\n  const text = '00000000' + value.toString(2);\n  return text.substring(text.length - 8);\n}\n\n/**\n * Convert a bloom filter at location `idx` in `array` into binary representation.\n *\n * @param array\n * @param idx\n */\nfunction toBloom(array: any[], idx: number): string {\n  if (idx < 0) {\n    return 'NO_NODE_INJECTOR';\n  }\n  return `${binary(array, idx + 7)}_${binary(array, idx + 6)}_${binary(array, idx + 5)}_${\n      binary(array, idx + 4)}_${binary(array, idx + 3)}_${binary(array, idx + 2)}_${\n      binary(array, idx + 1)}_${binary(array, idx + 0)}`;\n}\n\nexport class LContainerDebug implements ILContainerDebug {\n  constructor(private readonly _raw_lContainer: LContainer) {}\n\n  get hasTransplantedViews(): boolean {\n    return this._raw_lContainer[HAS_TRANSPLANTED_VIEWS];\n  }\n  get views(): ILViewDebug[] {\n    return this._raw_lContainer.slice(CONTAINER_HEADER_OFFSET)\n        .map(toDebug as (l: LView) => ILViewDebug);\n  }\n  get parent(): ILViewDebug|null {\n    return toDebug(this._raw_lContainer[PARENT]);\n  }\n  get movedViews(): LView[]|null {\n    return this._raw_lContainer[MOVED_VIEWS];\n  }\n  get host(): RElement|RComment|LView {\n    return this._raw_lContainer[HOST];\n  }\n  get native(): RComment {\n    return this._raw_lContainer[NATIVE];\n  }\n  get next() {\n    return toDebug(this._raw_lContainer[NEXT]);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '../../di/injector';\nimport {ErrorHandler} from '../../error_handler';\nimport {RuntimeError, RuntimeErrorCode} from '../../errors';\nimport {DoCheck, OnChanges, OnInit} from '../../interface/lifecycle_hooks';\nimport {SchemaMetadata} from '../../metadata/schema';\nimport {ViewEncapsulation} from '../../metadata/view';\nimport {validateAgainstEventAttributes, validateAgainstEventProperties} from '../../sanitization/sanitization';\nimport {Sanitizer} from '../../sanitization/sanitizer';\nimport {assertDefined, assertEqual, assertGreaterThanOrEqual, assertIndexInRange, assertNotEqual, assertNotSame, assertSame, assertString} from '../../util/assert';\nimport {escapeCommentText} from '../../util/dom';\nimport {normalizeDebugBindingName, normalizeDebugBindingValue} from '../../util/ng_reflect';\nimport {stringify} from '../../util/stringify';\nimport {assertFirstCreatePass, assertFirstUpdatePass, assertLContainer, assertLView, assertTNodeForLView, assertTNodeForTView} from '../assert';\nimport {attachPatchData, readPatchedLView} from '../context_discovery';\nimport {getFactoryDef} from '../definition_factory';\nimport {diPublicInInjector, getNodeInjectable, getOrCreateNodeInjectorForNode} from '../di';\nimport {throwMultipleComponentError} from '../errors';\nimport {executeCheckHooks, executeInitAndCheckHooks, incrementInitPhaseFlags} from '../hooks';\nimport {CONTAINER_HEADER_OFFSET, HAS_TRANSPLANTED_VIEWS, LContainer, MOVED_VIEWS} from '../interfaces/container';\nimport {ComponentDef, ComponentTemplate, DirectiveDef, DirectiveDefListOrFactory, HostBindingsFunction, PipeDefListOrFactory, RenderFlags, ViewQueriesFunction} from '../interfaces/definition';\nimport {NodeInjectorFactory} from '../interfaces/injector';\nimport {getUniqueLViewId} from '../interfaces/lview_tracking';\nimport {AttributeMarker, InitialInputData, InitialInputs, LocalRefExtractor, PropertyAliases, PropertyAliasValue, TAttributes, TConstantsOrFactory, TContainerNode, TDirectiveHostNode, TElementContainerNode, TElementNode, TIcuContainerNode, TNode, TNodeFlags, TNodeType, TProjectionNode} from '../interfaces/node';\nimport {Renderer, RendererFactory} from '../interfaces/renderer';\nimport {RComment, RElement, RNode, RText} from '../interfaces/renderer_dom';\nimport {SanitizerFn} from '../interfaces/sanitization';\nimport {isComponentDef, isComponentHost, isContentQueryHost, isRootView} from '../interfaces/type_checks';\nimport {CHILD_HEAD, CHILD_TAIL, CLEANUP, CONTEXT, DECLARATION_COMPONENT_VIEW, DECLARATION_VIEW, EMBEDDED_VIEW_INJECTOR, FLAGS, HEADER_OFFSET, HOST, HostBindingOpCodes, ID, InitPhaseState, INJECTOR, LView, LViewFlags, NEXT, PARENT, RENDERER, RENDERER_FACTORY, RootContext, RootContextFlags, SANITIZER, T_HOST, TData, TRANSPLANTED_VIEWS_TO_REFRESH, TVIEW, TView, TViewType} from '../interfaces/view';\nimport {assertPureTNodeType, assertTNodeType} from '../node_assert';\nimport {updateTextNode} from '../node_manipulation';\nimport {isInlineTemplate, isNodeMatchingSelectorList} from '../node_selector_matcher';\nimport {profiler, ProfilerEvent} from '../profiler';\nimport {enterView, getBindingsEnabled, getCurrentDirectiveIndex, getCurrentParentTNode, getCurrentTNode, getCurrentTNodePlaceholderOk, getSelectedIndex, isCurrentTNodeParent, isInCheckNoChangesMode, isInI18nBlock, leaveView, setBindingIndex, setBindingRootForHostBindings, setCurrentDirectiveIndex, setCurrentQueryIndex, setCurrentTNode, setIsInCheckNoChangesMode, setSelectedIndex} from '../state';\nimport {NO_CHANGE} from '../tokens';\nimport {mergeHostAttrs} from '../util/attrs_utils';\nimport {INTERPOLATION_DELIMITER} from '../util/misc_utils';\nimport {renderStringify, stringifyForError} from '../util/stringify_utils';\nimport {getFirstLContainer, getLViewParent, getNextLContainer} from '../util/view_traversal_utils';\nimport {getComponentLViewByIndex, getNativeByIndex, getNativeByTNode, isCreationMode, resetPreOrderHookFlags, unwrapLView, updateTransplantedViewCount, viewAttachedToChangeDetector} from '../util/view_utils';\n\nimport {selectIndexInternal} from './advance';\nimport {ɵɵdirectiveInject} from './di';\nimport {handleUnknownPropertyError, isPropertyValid, matchingSchemas} from './element_validation';\nimport {attachLContainerDebug, attachLViewDebug, cloneToLViewFromTViewBlueprint, cloneToTViewData, LCleanup, LViewBlueprint, MatchesArray, TCleanup, TNodeDebug, TNodeInitialInputs, TNodeLocalNames, TViewComponents, TViewConstructor} from './lview_debug';\n\n/**\n * A permanent marker promise which signifies that the current CD tree is\n * clean.\n */\nconst _CLEAN_PROMISE = (() => Promise.resolve(null))();\n\n/**\n * Invoke `HostBindingsFunction`s for view.\n *\n * This methods executes `TView.hostBindingOpCodes`. It is used to execute the\n * `HostBindingsFunction`s associated with the current `LView`.\n *\n * @param tView Current `TView`.\n * @param lView Current `LView`.\n */\nexport function processHostBindingOpCodes(tView: TView, lView: LView): void {\n  const hostBindingOpCodes = tView.hostBindingOpCodes;\n  if (hostBindingOpCodes === null) return;\n  try {\n    for (let i = 0; i < hostBindingOpCodes.length; i++) {\n      const opCode = hostBindingOpCodes[i] as number;\n      if (opCode < 0) {\n        // Negative numbers are element indexes.\n        setSelectedIndex(~opCode);\n      } else {\n        // Positive numbers are NumberTuple which store bindingRootIndex and directiveIndex.\n        const directiveIdx = opCode;\n        const bindingRootIndx = hostBindingOpCodes[++i] as number;\n        const hostBindingFn = hostBindingOpCodes[++i] as HostBindingsFunction<any>;\n        setBindingRootForHostBindings(bindingRootIndx, directiveIdx);\n        const context = lView[directiveIdx];\n        hostBindingFn(RenderFlags.Update, context);\n      }\n    }\n  } finally {\n    setSelectedIndex(-1);\n  }\n}\n\n\n/** Refreshes all content queries declared by directives in a given view */\nfunction refreshContentQueries(tView: TView, lView: LView): void {\n  const contentQueries = tView.contentQueries;\n  if (contentQueries !== null) {\n    for (let i = 0; i < contentQueries.length; i += 2) {\n      const queryStartIdx = contentQueries[i];\n      const directiveDefIdx = contentQueries[i + 1];\n      if (directiveDefIdx !== -1) {\n        const directiveDef = tView.data[directiveDefIdx] as DirectiveDef<any>;\n        ngDevMode && assertDefined(directiveDef, 'DirectiveDef not found.');\n        ngDevMode &&\n            assertDefined(directiveDef.contentQueries, 'contentQueries function should be defined');\n        setCurrentQueryIndex(queryStartIdx);\n        directiveDef.contentQueries!(RenderFlags.Update, lView[directiveDefIdx], directiveDefIdx);\n      }\n    }\n  }\n}\n\n/** Refreshes child components in the current view (update mode). */\nfunction refreshChildComponents(hostLView: LView, components: number[]): void {\n  for (let i = 0; i < components.length; i++) {\n    refreshComponent(hostLView, components[i]);\n  }\n}\n\n/** Renders child components in the current view (creation mode). */\nfunction renderChildComponents(hostLView: LView, components: number[]): void {\n  for (let i = 0; i < components.length; i++) {\n    renderComponent(hostLView, components[i]);\n  }\n}\n\nexport function createLView<T>(\n    parentLView: LView|null, tView: TView, context: T|null, flags: LViewFlags, host: RElement|null,\n    tHostNode: TNode|null, rendererFactory: RendererFactory|null, renderer: Renderer|null,\n    sanitizer: Sanitizer|null, injector: Injector|null,\n    embeddedViewInjector: Injector|null): LView {\n  const lView =\n      ngDevMode ? cloneToLViewFromTViewBlueprint(tView) : tView.blueprint.slice() as LView;\n  lView[HOST] = host;\n  lView[FLAGS] = flags | LViewFlags.CreationMode | LViewFlags.Attached | LViewFlags.FirstLViewPass;\n  if (embeddedViewInjector !== null ||\n      (parentLView && (parentLView[FLAGS] & LViewFlags.HasEmbeddedViewInjector))) {\n    lView[FLAGS] |= LViewFlags.HasEmbeddedViewInjector;\n  }\n  resetPreOrderHookFlags(lView);\n  ngDevMode && tView.declTNode && parentLView && assertTNodeForLView(tView.declTNode, parentLView);\n  lView[PARENT] = lView[DECLARATION_VIEW] = parentLView;\n  lView[CONTEXT] = context;\n  lView[RENDERER_FACTORY] = (rendererFactory || parentLView && parentLView[RENDERER_FACTORY])!;\n  ngDevMode && assertDefined(lView[RENDERER_FACTORY], 'RendererFactory is required');\n  lView[RENDERER] = (renderer || parentLView && parentLView[RENDERER])!;\n  ngDevMode && assertDefined(lView[RENDERER], 'Renderer is required');\n  lView[SANITIZER] = sanitizer || parentLView && parentLView[SANITIZER] || null!;\n  lView[INJECTOR as any] = injector || parentLView && parentLView[INJECTOR] || null;\n  lView[T_HOST] = tHostNode;\n  lView[ID] = getUniqueLViewId();\n  lView[EMBEDDED_VIEW_INJECTOR as any] = embeddedViewInjector;\n  ngDevMode &&\n      assertEqual(\n          tView.type == TViewType.Embedded ? parentLView !== null : true, true,\n          'Embedded views must have parentLView');\n  lView[DECLARATION_COMPONENT_VIEW] =\n      tView.type == TViewType.Embedded ? parentLView![DECLARATION_COMPONENT_VIEW] : lView;\n  ngDevMode && attachLViewDebug(lView);\n  return lView;\n}\n\n/**\n * Create and stores the TNode, and hooks it up to the tree.\n *\n * @param tView The current `TView`.\n * @param index The index at which the TNode should be saved (null if view, since they are not\n * saved).\n * @param type The type of TNode to create\n * @param native The native element for this node, if applicable\n * @param name The tag name of the associated native element, if applicable\n * @param attrs Any attrs for the native element, if applicable\n */\nexport function getOrCreateTNode(\n    tView: TView, index: number, type: TNodeType.Element|TNodeType.Text, name: string|null,\n    attrs: TAttributes|null): TElementNode;\nexport function getOrCreateTNode(\n    tView: TView, index: number, type: TNodeType.Container, name: string|null,\n    attrs: TAttributes|null): TContainerNode;\nexport function getOrCreateTNode(\n    tView: TView, index: number, type: TNodeType.Projection, name: null,\n    attrs: TAttributes|null): TProjectionNode;\nexport function getOrCreateTNode(\n    tView: TView, index: number, type: TNodeType.ElementContainer, name: string|null,\n    attrs: TAttributes|null): TElementContainerNode;\nexport function getOrCreateTNode(\n    tView: TView, index: number, type: TNodeType.Icu, name: null,\n    attrs: TAttributes|null): TElementContainerNode;\nexport function getOrCreateTNode(\n    tView: TView, index: number, type: TNodeType, name: string|null, attrs: TAttributes|null):\n    TElementNode&TContainerNode&TElementContainerNode&TProjectionNode&TIcuContainerNode {\n  ngDevMode && index !== 0 &&  // 0 are bogus nodes and they are OK. See `createContainerRef` in\n                               // `view_engine_compatibility` for additional context.\n      assertGreaterThanOrEqual(index, HEADER_OFFSET, 'TNodes can\\'t be in the LView header.');\n  // Keep this function short, so that the VM will inline it.\n  ngDevMode && assertPureTNodeType(type);\n  let tNode = tView.data[index] as TNode;\n  if (tNode === null) {\n    tNode = createTNodeAtIndex(tView, index, type, name, attrs);\n    if (isInI18nBlock()) {\n      // If we are in i18n block then all elements should be pre declared through `Placeholder`\n      // See `TNodeType.Placeholder` and `LFrame.inI18n` for more context.\n      // If the `TNode` was not pre-declared than it means it was not mentioned which means it was\n      // removed, so we mark it as detached.\n      tNode.flags |= TNodeFlags.isDetached;\n    }\n  } else if (tNode.type & TNodeType.Placeholder) {\n    tNode.type = type;\n    tNode.value = name;\n    tNode.attrs = attrs;\n    const parent = getCurrentParentTNode();\n    tNode.injectorIndex = parent === null ? -1 : parent.injectorIndex;\n    ngDevMode && assertTNodeForTView(tNode, tView);\n    ngDevMode && assertEqual(index, tNode.index, 'Expecting same index');\n  }\n  setCurrentTNode(tNode, true);\n  return tNode as TElementNode & TContainerNode & TElementContainerNode & TProjectionNode &\n      TIcuContainerNode;\n}\n\nexport function createTNodeAtIndex(\n    tView: TView, index: number, type: TNodeType, name: string|null, attrs: TAttributes|null) {\n  const currentTNode = getCurrentTNodePlaceholderOk();\n  const isParent = isCurrentTNodeParent();\n  const parent = isParent ? currentTNode : currentTNode && currentTNode.parent;\n  // Parents cannot cross component boundaries because components will be used in multiple places.\n  const tNode = tView.data[index] =\n      createTNode(tView, parent as TElementNode | TContainerNode, type, index, name, attrs);\n  // Assign a pointer to the first child node of a given view. The first node is not always the one\n  // at index 0, in case of i18n, index 0 can be the instruction `i18nStart` and the first node has\n  // the index 1 or more, so we can't just check node index.\n  if (tView.firstChild === null) {\n    tView.firstChild = tNode;\n  }\n  if (currentTNode !== null) {\n    if (isParent) {\n      // FIXME(misko): This logic looks unnecessarily complicated. Could we simplify?\n      if (currentTNode.child == null && tNode.parent !== null) {\n        // We are in the same view, which means we are adding content node to the parent view.\n        currentTNode.child = tNode;\n      }\n    } else {\n      if (currentTNode.next === null) {\n        // In the case of i18n the `currentTNode` may already be linked, in which case we don't want\n        // to break the links which i18n created.\n        currentTNode.next = tNode;\n      }\n    }\n  }\n  return tNode;\n}\n\n/**\n * When elements are created dynamically after a view blueprint is created (e.g. through\n * i18nApply()), we need to adjust the blueprint for future\n * template passes.\n *\n * @param tView `TView` associated with `LView`\n * @param lView The `LView` containing the blueprint to adjust\n * @param numSlotsToAlloc The number of slots to alloc in the LView, should be >0\n * @param initialValue Initial value to store in blueprint\n */\nexport function allocExpando(\n    tView: TView, lView: LView, numSlotsToAlloc: number, initialValue: any): number {\n  if (numSlotsToAlloc === 0) return -1;\n  if (ngDevMode) {\n    assertFirstCreatePass(tView);\n    assertSame(tView, lView[TVIEW], '`LView` must be associated with `TView`!');\n    assertEqual(tView.data.length, lView.length, 'Expecting LView to be same size as TView');\n    assertEqual(\n        tView.data.length, tView.blueprint.length, 'Expecting Blueprint to be same size as TView');\n    assertFirstUpdatePass(tView);\n  }\n  const allocIdx = lView.length;\n  for (let i = 0; i < numSlotsToAlloc; i++) {\n    lView.push(initialValue);\n    tView.blueprint.push(initialValue);\n    tView.data.push(null);\n  }\n  return allocIdx;\n}\n\n\n//////////////////////////\n//// Render\n//////////////////////////\n\n/**\n * Processes a view in the creation mode. This includes a number of steps in a specific order:\n * - creating view query functions (if any);\n * - executing a template function in the creation mode;\n * - updating static queries (if any);\n * - creating child components defined in a given view.\n */\nexport function renderView<T>(tView: TView, lView: LView<T>, context: T): void {\n  ngDevMode && assertEqual(isCreationMode(lView), true, 'Should be run in creation mode');\n  enterView(lView);\n  try {\n    const viewQuery = tView.viewQuery;\n    if (viewQuery !== null) {\n      executeViewQueryFn<T>(RenderFlags.Create, viewQuery, context);\n    }\n\n    // Execute a template associated with this view, if it exists. A template function might not be\n    // defined for the root component views.\n    const templateFn = tView.template;\n    if (templateFn !== null) {\n      executeTemplate<T>(tView, lView, templateFn, RenderFlags.Create, context);\n    }\n\n    // This needs to be set before children are processed to support recursive components.\n    // This must be set to false immediately after the first creation run because in an\n    // ngFor loop, all the views will be created together before update mode runs and turns\n    // off firstCreatePass. If we don't set it here, instances will perform directive\n    // matching, etc again and again.\n    if (tView.firstCreatePass) {\n      tView.firstCreatePass = false;\n    }\n\n    // We resolve content queries specifically marked as `static` in creation mode. Dynamic\n    // content queries are resolved during change detection (i.e. update mode), after embedded\n    // views are refreshed (see block above).\n    if (tView.staticContentQueries) {\n      refreshContentQueries(tView, lView);\n    }\n\n    // We must materialize query results before child components are processed\n    // in case a child component has projected a container. The LContainer needs\n    // to exist so the embedded views are properly attached by the container.\n    if (tView.staticViewQueries) {\n      executeViewQueryFn<T>(RenderFlags.Update, tView.viewQuery!, context);\n    }\n\n    // Render child component views.\n    const components = tView.components;\n    if (components !== null) {\n      renderChildComponents(lView, components);\n    }\n\n  } catch (error) {\n    // If we didn't manage to get past the first template pass due to\n    // an error, mark the view as corrupted so we can try to recover.\n    if (tView.firstCreatePass) {\n      tView.incompleteFirstPass = true;\n      tView.firstCreatePass = false;\n    }\n\n    throw error;\n  } finally {\n    lView[FLAGS] &= ~LViewFlags.CreationMode;\n    leaveView();\n  }\n}\n\n/**\n * Processes a view in update mode. This includes a number of steps in a specific order:\n * - executing a template function in update mode;\n * - executing hooks;\n * - refreshing queries;\n * - setting host bindings;\n * - refreshing child (embedded and component) views.\n */\nexport function refreshView<T>(\n    tView: TView, lView: LView, templateFn: ComponentTemplate<{}>|null, context: T) {\n  ngDevMode && assertEqual(isCreationMode(lView), false, 'Should be run in update mode');\n  const flags = lView[FLAGS];\n  if ((flags & LViewFlags.Destroyed) === LViewFlags.Destroyed) return;\n  enterView(lView);\n  // Check no changes mode is a dev only mode used to verify that bindings have not changed\n  // since they were assigned. We do not want to execute lifecycle hooks in that mode.\n  const isInCheckNoChangesPass = ngDevMode && isInCheckNoChangesMode();\n  try {\n    resetPreOrderHookFlags(lView);\n\n    setBindingIndex(tView.bindingStartIndex);\n    if (templateFn !== null) {\n      executeTemplate(tView, lView, templateFn, RenderFlags.Update, context);\n    }\n\n    const hooksInitPhaseCompleted =\n        (flags & LViewFlags.InitPhaseStateMask) === InitPhaseState.InitPhaseCompleted;\n\n    // execute pre-order hooks (OnInit, OnChanges, DoCheck)\n    // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n    if (!isInCheckNoChangesPass) {\n      if (hooksInitPhaseCompleted) {\n        const preOrderCheckHooks = tView.preOrderCheckHooks;\n        if (preOrderCheckHooks !== null) {\n          executeCheckHooks(lView, preOrderCheckHooks, null);\n        }\n      } else {\n        const preOrderHooks = tView.preOrderHooks;\n        if (preOrderHooks !== null) {\n          executeInitAndCheckHooks(lView, preOrderHooks, InitPhaseState.OnInitHooksToBeRun, null);\n        }\n        incrementInitPhaseFlags(lView, InitPhaseState.OnInitHooksToBeRun);\n      }\n    }\n\n    // First mark transplanted views that are declared in this lView as needing a refresh at their\n    // insertion points. This is needed to avoid the situation where the template is defined in this\n    // `LView` but its declaration appears after the insertion component.\n    markTransplantedViewsForRefresh(lView);\n    refreshEmbeddedViews(lView);\n\n    // Content query results must be refreshed before content hooks are called.\n    if (tView.contentQueries !== null) {\n      refreshContentQueries(tView, lView);\n    }\n\n    // execute content hooks (AfterContentInit, AfterContentChecked)\n    // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n    if (!isInCheckNoChangesPass) {\n      if (hooksInitPhaseCompleted) {\n        const contentCheckHooks = tView.contentCheckHooks;\n        if (contentCheckHooks !== null) {\n          executeCheckHooks(lView, contentCheckHooks);\n        }\n      } else {\n        const contentHooks = tView.contentHooks;\n        if (contentHooks !== null) {\n          executeInitAndCheckHooks(\n              lView, contentHooks, InitPhaseState.AfterContentInitHooksToBeRun);\n        }\n        incrementInitPhaseFlags(lView, InitPhaseState.AfterContentInitHooksToBeRun);\n      }\n    }\n\n    processHostBindingOpCodes(tView, lView);\n\n    // Refresh child component views.\n    const components = tView.components;\n    if (components !== null) {\n      refreshChildComponents(lView, components);\n    }\n\n    // View queries must execute after refreshing child components because a template in this view\n    // could be inserted in a child component. If the view query executes before child component\n    // refresh, the template might not yet be inserted.\n    const viewQuery = tView.viewQuery;\n    if (viewQuery !== null) {\n      executeViewQueryFn<T>(RenderFlags.Update, viewQuery, context);\n    }\n\n    // execute view hooks (AfterViewInit, AfterViewChecked)\n    // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n    if (!isInCheckNoChangesPass) {\n      if (hooksInitPhaseCompleted) {\n        const viewCheckHooks = tView.viewCheckHooks;\n        if (viewCheckHooks !== null) {\n          executeCheckHooks(lView, viewCheckHooks);\n        }\n      } else {\n        const viewHooks = tView.viewHooks;\n        if (viewHooks !== null) {\n          executeInitAndCheckHooks(lView, viewHooks, InitPhaseState.AfterViewInitHooksToBeRun);\n        }\n        incrementInitPhaseFlags(lView, InitPhaseState.AfterViewInitHooksToBeRun);\n      }\n    }\n    if (tView.firstUpdatePass === true) {\n      // We need to make sure that we only flip the flag on successful `refreshView` only\n      // Don't do this in `finally` block.\n      // If we did this in `finally` block then an exception could block the execution of styling\n      // instructions which in turn would be unable to insert themselves into the styling linked\n      // list. The result of this would be that if the exception would not be throw on subsequent CD\n      // the styling would be unable to process it data and reflect to the DOM.\n      tView.firstUpdatePass = false;\n    }\n\n    // Do not reset the dirty state when running in check no changes mode. We don't want components\n    // to behave differently depending on whether check no changes is enabled or not. For example:\n    // Marking an OnPush component as dirty from within the `ngAfterViewInit` hook in order to\n    // refresh a `NgClass` binding should work. If we would reset the dirty state in the check\n    // no changes cycle, the component would be not be dirty for the next update pass. This would\n    // be different in production mode where the component dirty state is not reset.\n    if (!isInCheckNoChangesPass) {\n      lView[FLAGS] &= ~(LViewFlags.Dirty | LViewFlags.FirstLViewPass);\n    }\n    if (lView[FLAGS] & LViewFlags.RefreshTransplantedView) {\n      lView[FLAGS] &= ~LViewFlags.RefreshTransplantedView;\n      updateTransplantedViewCount(lView[PARENT] as LContainer, -1);\n    }\n  } finally {\n    leaveView();\n  }\n}\n\nexport function renderComponentOrTemplate<T>(\n    tView: TView, lView: LView, templateFn: ComponentTemplate<{}>|null, context: T) {\n  const rendererFactory = lView[RENDERER_FACTORY];\n\n  // Check no changes mode is a dev only mode used to verify that bindings have not changed\n  // since they were assigned. We do not want to invoke renderer factory functions in that mode\n  // to avoid any possible side-effects.\n  const checkNoChangesMode = !!ngDevMode && isInCheckNoChangesMode();\n  const creationModeIsActive = isCreationMode(lView);\n  try {\n    if (!checkNoChangesMode && !creationModeIsActive && rendererFactory.begin) {\n      rendererFactory.begin();\n    }\n    if (creationModeIsActive) {\n      renderView(tView, lView, context);\n    }\n    refreshView(tView, lView, templateFn, context);\n  } finally {\n    if (!checkNoChangesMode && !creationModeIsActive && rendererFactory.end) {\n      rendererFactory.end();\n    }\n  }\n}\n\nfunction executeTemplate<T>(\n    tView: TView, lView: LView<T>, templateFn: ComponentTemplate<T>, rf: RenderFlags, context: T) {\n  const prevSelectedIndex = getSelectedIndex();\n  const isUpdatePhase = rf & RenderFlags.Update;\n  try {\n    setSelectedIndex(-1);\n    if (isUpdatePhase && lView.length > HEADER_OFFSET) {\n      // When we're updating, inherently select 0 so we don't\n      // have to generate that instruction for most update blocks.\n      selectIndexInternal(tView, lView, HEADER_OFFSET, !!ngDevMode && isInCheckNoChangesMode());\n    }\n\n    const preHookType =\n        isUpdatePhase ? ProfilerEvent.TemplateUpdateStart : ProfilerEvent.TemplateCreateStart;\n    profiler(preHookType, context as unknown as {});\n    templateFn(rf, context);\n  } finally {\n    setSelectedIndex(prevSelectedIndex);\n\n    const postHookType =\n        isUpdatePhase ? ProfilerEvent.TemplateUpdateEnd : ProfilerEvent.TemplateCreateEnd;\n    profiler(postHookType, context as unknown as {});\n  }\n}\n\n//////////////////////////\n//// Element\n//////////////////////////\n\nexport function executeContentQueries(tView: TView, tNode: TNode, lView: LView) {\n  if (isContentQueryHost(tNode)) {\n    const start = tNode.directiveStart;\n    const end = tNode.directiveEnd;\n    for (let directiveIndex = start; directiveIndex < end; directiveIndex++) {\n      const def = tView.data[directiveIndex] as DirectiveDef<any>;\n      if (def.contentQueries) {\n        def.contentQueries(RenderFlags.Create, lView[directiveIndex], directiveIndex);\n      }\n    }\n  }\n}\n\n\n/**\n * Creates directive instances.\n */\nexport function createDirectivesInstances(tView: TView, lView: LView, tNode: TDirectiveHostNode) {\n  if (!getBindingsEnabled()) return;\n  instantiateAllDirectives(tView, lView, tNode, getNativeByTNode(tNode, lView));\n  if ((tNode.flags & TNodeFlags.hasHostBindings) === TNodeFlags.hasHostBindings) {\n    invokeDirectivesHostBindings(tView, lView, tNode);\n  }\n}\n\n/**\n * Takes a list of local names and indices and pushes the resolved local variable values\n * to LView in the same order as they are loaded in the template with load().\n */\nexport function saveResolvedLocalsInData(\n    viewData: LView, tNode: TDirectiveHostNode,\n    localRefExtractor: LocalRefExtractor = getNativeByTNode): void {\n  const localNames = tNode.localNames;\n  if (localNames !== null) {\n    let localIndex = tNode.index + 1;\n    for (let i = 0; i < localNames.length; i += 2) {\n      const index = localNames[i + 1] as number;\n      const value = index === -1 ?\n          localRefExtractor(\n              tNode as TElementNode | TContainerNode | TElementContainerNode, viewData) :\n          viewData[index];\n      viewData[localIndex++] = value;\n    }\n  }\n}\n\n/**\n * Gets TView from a template function or creates a new TView\n * if it doesn't already exist.\n *\n * @param def ComponentDef\n * @returns TView\n */\nexport function getOrCreateTComponentView(def: ComponentDef<any>): TView {\n  const tView = def.tView;\n\n  // Create a TView if there isn't one, or recreate it if the first create pass didn't\n  // complete successfully since we can't know for sure whether it's in a usable shape.\n  if (tView === null || tView.incompleteFirstPass) {\n    // Declaration node here is null since this function is called when we dynamically create a\n    // component and hence there is no declaration.\n    const declTNode = null;\n    return def.tView = createTView(\n               TViewType.Component, declTNode, def.template, def.decls, def.vars, def.directiveDefs,\n               def.pipeDefs, def.viewQuery, def.schemas, def.consts);\n  }\n\n  return tView;\n}\n\n\n/**\n * Creates a TView instance\n *\n * @param type Type of `TView`.\n * @param declTNode Declaration location of this `TView`.\n * @param templateFn Template function\n * @param decls The number of nodes, local refs, and pipes in this template\n * @param directives Registry of directives for this view\n * @param pipes Registry of pipes for this view\n * @param viewQuery View queries for this view\n * @param schemas Schemas for this view\n * @param consts Constants for this view\n */\nexport function createTView(\n    type: TViewType, declTNode: TNode|null, templateFn: ComponentTemplate<any>|null, decls: number,\n    vars: number, directives: DirectiveDefListOrFactory|null, pipes: PipeDefListOrFactory|null,\n    viewQuery: ViewQueriesFunction<any>|null, schemas: SchemaMetadata[]|null,\n    constsOrFactory: TConstantsOrFactory|null): TView {\n  ngDevMode && ngDevMode.tView++;\n  const bindingStartIndex = HEADER_OFFSET + decls;\n  // This length does not yet contain host bindings from child directives because at this point,\n  // we don't know which directives are active on this template. As soon as a directive is matched\n  // that has a host binding, we will update the blueprint with that def's hostVars count.\n  const initialViewLength = bindingStartIndex + vars;\n  const blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);\n  const consts = typeof constsOrFactory === 'function' ? constsOrFactory() : constsOrFactory;\n  const tView = blueprint[TVIEW as any] = ngDevMode ?\n      new TViewConstructor(\n          type,        // type: TViewType,\n          blueprint,   // blueprint: LView,\n          templateFn,  // template: ComponentTemplate<{}>|null,\n          null,        // queries: TQueries|null\n          viewQuery,   // viewQuery: ViewQueriesFunction<{}>|null,\n          declTNode,   // declTNode: TNode|null,\n          cloneToTViewData(blueprint).fill(null, bindingStartIndex),  // data: TData,\n          bindingStartIndex,                                          // bindingStartIndex: number,\n          initialViewLength,                                          // expandoStartIndex: number,\n          null,                               // hostBindingOpCodes: HostBindingOpCodes,\n          true,                               // firstCreatePass: boolean,\n          true,                               // firstUpdatePass: boolean,\n          false,                              // staticViewQueries: boolean,\n          false,                              // staticContentQueries: boolean,\n          null,                               // preOrderHooks: HookData|null,\n          null,                               // preOrderCheckHooks: HookData|null,\n          null,                               // contentHooks: HookData|null,\n          null,                               // contentCheckHooks: HookData|null,\n          null,                               // viewHooks: HookData|null,\n          null,                               // viewCheckHooks: HookData|null,\n          null,                               // destroyHooks: DestroyHookData|null,\n          null,                               // cleanup: any[]|null,\n          null,                               // contentQueries: number[]|null,\n          null,                               // components: number[]|null,\n          typeof directives === 'function' ?  //\n              directives() :                  //\n              directives,                     // directiveRegistry: DirectiveDefList|null,\n          typeof pipes === 'function' ? pipes() : pipes,  // pipeRegistry: PipeDefList|null,\n          null,                                           // firstChild: TNode|null,\n          schemas,                                        // schemas: SchemaMetadata[]|null,\n          consts,                                         // consts: TConstants|null\n          false,                                          // incompleteFirstPass: boolean\n          decls,                                          // ngDevMode only: decls\n          vars,                                           // ngDevMode only: vars\n          ) :\n      {\n        type: type,\n        blueprint: blueprint,\n        template: templateFn,\n        queries: null,\n        viewQuery: viewQuery,\n        declTNode: declTNode,\n        data: blueprint.slice().fill(null, bindingStartIndex),\n        bindingStartIndex: bindingStartIndex,\n        expandoStartIndex: initialViewLength,\n        hostBindingOpCodes: null,\n        firstCreatePass: true,\n        firstUpdatePass: true,\n        staticViewQueries: false,\n        staticContentQueries: false,\n        preOrderHooks: null,\n        preOrderCheckHooks: null,\n        contentHooks: null,\n        contentCheckHooks: null,\n        viewHooks: null,\n        viewCheckHooks: null,\n        destroyHooks: null,\n        cleanup: null,\n        contentQueries: null,\n        components: null,\n        directiveRegistry: typeof directives === 'function' ? directives() : directives,\n        pipeRegistry: typeof pipes === 'function' ? pipes() : pipes,\n        firstChild: null,\n        schemas: schemas,\n        consts: consts,\n        incompleteFirstPass: false\n      };\n  if (ngDevMode) {\n    // For performance reasons it is important that the tView retains the same shape during runtime.\n    // (To make sure that all of the code is monomorphic.) For this reason we seal the object to\n    // prevent class transitions.\n    Object.seal(tView);\n  }\n  return tView;\n}\n\nfunction createViewBlueprint(bindingStartIndex: number, initialViewLength: number): LView {\n  const blueprint = ngDevMode ? new LViewBlueprint() : [];\n\n  for (let i = 0; i < initialViewLength; i++) {\n    blueprint.push(i < bindingStartIndex ? null : NO_CHANGE);\n  }\n\n  return blueprint as LView;\n}\n\nfunction createError(text: string, token: any) {\n  return new Error(`Renderer: ${text} [${stringifyForError(token)}]`);\n}\n\n/**\n * Locates the host native element, used for bootstrapping existing nodes into rendering pipeline.\n *\n * @param rendererFactory Factory function to create renderer instance.\n * @param elementOrSelector Render element or CSS selector to locate the element.\n * @param encapsulation View Encapsulation defined for component that requests host element.\n */\nexport function locateHostElement(\n    renderer: Renderer, elementOrSelector: RElement|string,\n    encapsulation: ViewEncapsulation): RElement {\n  // When using native Shadow DOM, do not clear host element to allow native slot projection\n  const preserveContent = encapsulation === ViewEncapsulation.ShadowDom;\n  return renderer.selectRootElement(elementOrSelector, preserveContent);\n}\n\n/**\n * Saves context for this cleanup function in LView.cleanupInstances.\n *\n * On the first template pass, saves in TView:\n * - Cleanup function\n * - Index of context we just saved in LView.cleanupInstances\n *\n * This function can also be used to store instance specific cleanup fns. In that case the `context`\n * is `null` and the function is store in `LView` (rather than it `TView`).\n */\nexport function storeCleanupWithContext(\n    tView: TView, lView: LView, context: any, cleanupFn: Function): void {\n  const lCleanup = getOrCreateLViewCleanup(lView);\n  if (context === null) {\n    // If context is null that this is instance specific callback. These callbacks can only be\n    // inserted after template shared instances. For this reason in ngDevMode we freeze the TView.\n    if (ngDevMode) {\n      Object.freeze(getOrCreateTViewCleanup(tView));\n    }\n    lCleanup.push(cleanupFn);\n  } else {\n    lCleanup.push(context);\n\n    if (tView.firstCreatePass) {\n      getOrCreateTViewCleanup(tView).push(cleanupFn, lCleanup.length - 1);\n    }\n  }\n}\n\n/**\n * Constructs a TNode object from the arguments.\n *\n * @param tView `TView` to which this `TNode` belongs (used only in `ngDevMode`)\n * @param tParent Parent `TNode`\n * @param type The type of the node\n * @param index The index of the TNode in TView.data, adjusted for HEADER_OFFSET\n * @param tagName The tag name of the node\n * @param attrs The attributes defined on this node\n * @param tViews Any TViews attached to this node\n * @returns the TNode object\n */\nexport function createTNode(\n    tView: TView, tParent: TElementNode|TContainerNode|null, type: TNodeType.Container,\n    index: number, tagName: string|null, attrs: TAttributes|null): TContainerNode;\nexport function createTNode(\n    tView: TView, tParent: TElementNode|TContainerNode|null, type: TNodeType.Element|TNodeType.Text,\n    index: number, tagName: string|null, attrs: TAttributes|null): TElementNode;\nexport function createTNode(\n    tView: TView, tParent: TElementNode|TContainerNode|null, type: TNodeType.ElementContainer,\n    index: number, tagName: string|null, attrs: TAttributes|null): TElementContainerNode;\nexport function createTNode(\n    tView: TView, tParent: TElementNode|TContainerNode|null, type: TNodeType.Icu, index: number,\n    tagName: string|null, attrs: TAttributes|null): TIcuContainerNode;\nexport function createTNode(\n    tView: TView, tParent: TElementNode|TContainerNode|null, type: TNodeType.Projection,\n    index: number, tagName: string|null, attrs: TAttributes|null): TProjectionNode;\nexport function createTNode(\n    tView: TView, tParent: TElementNode|TContainerNode|null, type: TNodeType, index: number,\n    tagName: string|null, attrs: TAttributes|null): TNode;\nexport function createTNode(\n    tView: TView, tParent: TElementNode|TContainerNode|null, type: TNodeType, index: number,\n    value: string|null, attrs: TAttributes|null): TNode {\n  ngDevMode && index !== 0 &&  // 0 are bogus nodes and they are OK. See `createContainerRef` in\n                               // `view_engine_compatibility` for additional context.\n      assertGreaterThanOrEqual(index, HEADER_OFFSET, 'TNodes can\\'t be in the LView header.');\n  ngDevMode && assertNotSame(attrs, undefined, '\\'undefined\\' is not valid value for \\'attrs\\'');\n  ngDevMode && ngDevMode.tNode++;\n  ngDevMode && tParent && assertTNodeForTView(tParent, tView);\n  let injectorIndex = tParent ? tParent.injectorIndex : -1;\n  const tNode = ngDevMode ?\n      new TNodeDebug(\n          tView,          // tView_: TView\n          type,           // type: TNodeType\n          index,          // index: number\n          null,           // insertBeforeIndex: null|-1|number|number[]\n          injectorIndex,  // injectorIndex: number\n          -1,             // directiveStart: number\n          -1,             // directiveEnd: number\n          -1,             // directiveStylingLast: number\n          null,           // propertyBindings: number[]|null\n          0,              // flags: TNodeFlags\n          0,              // providerIndexes: TNodeProviderIndexes\n          value,          // value: string|null\n          attrs,          // attrs: (string|AttributeMarker|(string|SelectorFlags)[])[]|null\n          null,           // mergedAttrs\n          null,           // localNames: (string|number)[]|null\n          undefined,      // initialInputs: (string[]|null)[]|null|undefined\n          null,           // inputs: PropertyAliases|null\n          null,           // outputs: PropertyAliases|null\n          null,           // tViews: ITView|ITView[]|null\n          null,           // next: ITNode|null\n          null,           // projectionNext: ITNode|null\n          null,           // child: ITNode|null\n          tParent,        // parent: TElementNode|TContainerNode|null\n          null,           // projection: number|(ITNode|RNode[])[]|null\n          null,           // styles: string|null\n          null,           // stylesWithoutHost: string|null\n          undefined,      // residualStyles: string|null\n          null,           // classes: string|null\n          null,           // classesWithoutHost: string|null\n          undefined,      // residualClasses: string|null\n          0 as any,       // classBindings: TStylingRange;\n          0 as any,       // styleBindings: TStylingRange;\n          ) :\n      {\n        type,\n        index,\n        insertBeforeIndex: null,\n        injectorIndex,\n        directiveStart: -1,\n        directiveEnd: -1,\n        directiveStylingLast: -1,\n        propertyBindings: null,\n        flags: 0,\n        providerIndexes: 0,\n        value: value,\n        attrs: attrs,\n        mergedAttrs: null,\n        localNames: null,\n        initialInputs: undefined,\n        inputs: null,\n        outputs: null,\n        tViews: null,\n        next: null,\n        projectionNext: null,\n        child: null,\n        parent: tParent,\n        projection: null,\n        styles: null,\n        stylesWithoutHost: null,\n        residualStyles: undefined,\n        classes: null,\n        classesWithoutHost: null,\n        residualClasses: undefined,\n        classBindings: 0 as any,\n        styleBindings: 0 as any,\n      };\n  if (ngDevMode) {\n    // For performance reasons it is important that the tNode retains the same shape during runtime.\n    // (To make sure that all of the code is monomorphic.) For this reason we seal the object to\n    // prevent class transitions.\n    Object.seal(tNode);\n  }\n  return tNode;\n}\n\n\nfunction generatePropertyAliases(\n    inputAliasMap: {[publicName: string]: string}, directiveDefIdx: number,\n    propStore: PropertyAliases|null): PropertyAliases|null {\n  for (let publicName in inputAliasMap) {\n    if (inputAliasMap.hasOwnProperty(publicName)) {\n      propStore = propStore === null ? {} : propStore;\n      const internalName = inputAliasMap[publicName];\n\n      if (propStore.hasOwnProperty(publicName)) {\n        propStore[publicName].push(directiveDefIdx, internalName);\n      } else {\n        (propStore[publicName] = [directiveDefIdx, internalName]);\n      }\n    }\n  }\n  return propStore;\n}\n\n/**\n * Initializes data structures required to work with directive inputs and outputs.\n * Initialization is done for all directives matched on a given TNode.\n */\nexport function initializeInputAndOutputAliases(tView: TView, tNode: TNode): void {\n  ngDevMode && assertFirstCreatePass(tView);\n\n  const start = tNode.directiveStart;\n  const end = tNode.directiveEnd;\n  const tViewData = tView.data;\n\n  const tNodeAttrs = tNode.attrs;\n  const inputsFromAttrs: InitialInputData = ngDevMode ? new TNodeInitialInputs() : [];\n  let inputsStore: PropertyAliases|null = null;\n  let outputsStore: PropertyAliases|null = null;\n  for (let i = start; i < end; i++) {\n    const directiveDef = tViewData[i] as DirectiveDef<any>;\n    const directiveInputs = directiveDef.inputs;\n    // Do not use unbound attributes as inputs to structural directives, since structural\n    // directive inputs can only be set using microsyntax (e.g. `<div *dir=\"exp\">`).\n    // TODO(FW-1930): microsyntax expressions may also contain unbound/static attributes, which\n    // should be set for inline templates.\n    const initialInputs = (tNodeAttrs !== null && !isInlineTemplate(tNode)) ?\n        generateInitialInputs(directiveInputs, tNodeAttrs) :\n        null;\n    inputsFromAttrs.push(initialInputs);\n    inputsStore = generatePropertyAliases(directiveInputs, i, inputsStore);\n    outputsStore = generatePropertyAliases(directiveDef.outputs, i, outputsStore);\n  }\n\n  if (inputsStore !== null) {\n    if (inputsStore.hasOwnProperty('class')) {\n      tNode.flags |= TNodeFlags.hasClassInput;\n    }\n    if (inputsStore.hasOwnProperty('style')) {\n      tNode.flags |= TNodeFlags.hasStyleInput;\n    }\n  }\n\n  tNode.initialInputs = inputsFromAttrs;\n  tNode.inputs = inputsStore;\n  tNode.outputs = outputsStore;\n}\n\n/**\n * Mapping between attributes names that don't correspond to their element property names.\n *\n * Performance note: this function is written as a series of if checks (instead of, say, a property\n * object lookup) for performance reasons - the series of `if` checks seems to be the fastest way of\n * mapping property names. Do NOT change without benchmarking.\n *\n * Note: this mapping has to be kept in sync with the equally named mapping in the template\n * type-checking machinery of ngtsc.\n */\nfunction mapPropName(name: string): string {\n  if (name === 'class') return 'className';\n  if (name === 'for') return 'htmlFor';\n  if (name === 'formaction') return 'formAction';\n  if (name === 'innerHtml') return 'innerHTML';\n  if (name === 'readonly') return 'readOnly';\n  if (name === 'tabindex') return 'tabIndex';\n  return name;\n}\n\nexport function elementPropertyInternal<T>(\n    tView: TView, tNode: TNode, lView: LView, propName: string, value: T, renderer: Renderer,\n    sanitizer: SanitizerFn|null|undefined, nativeOnly: boolean): void {\n  ngDevMode && assertNotSame(value, NO_CHANGE as any, 'Incoming value should never be NO_CHANGE.');\n  const element = getNativeByTNode(tNode, lView) as RElement | RComment;\n  let inputData = tNode.inputs;\n  let dataValue: PropertyAliasValue|undefined;\n  if (!nativeOnly && inputData != null && (dataValue = inputData[propName])) {\n    setInputsForProperty(tView, lView, dataValue, propName, value);\n    if (isComponentHost(tNode)) markDirtyIfOnPush(lView, tNode.index);\n    if (ngDevMode) {\n      setNgReflectProperties(lView, element, tNode.type, dataValue, value);\n    }\n  } else if (tNode.type & TNodeType.AnyRNode) {\n    propName = mapPropName(propName);\n\n    if (ngDevMode) {\n      validateAgainstEventProperties(propName);\n      if (!isPropertyValid(element, propName, tNode.value, tView.schemas)) {\n        handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);\n      }\n      ngDevMode.rendererSetProperty++;\n    }\n\n    // It is assumed that the sanitizer is only added when the compiler determines that the\n    // property is risky, so sanitization can be done without further checks.\n    value = sanitizer != null ? (sanitizer(value, tNode.value || '', propName) as any) : value;\n    renderer.setProperty(element as RElement, propName, value);\n  } else if (tNode.type & TNodeType.AnyContainer) {\n    // If the node is a container and the property didn't\n    // match any of the inputs or schemas we should throw.\n    if (ngDevMode && !matchingSchemas(tView.schemas, tNode.value)) {\n      handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);\n    }\n  }\n}\n\n/** If node is an OnPush component, marks its LView dirty. */\nexport function markDirtyIfOnPush(lView: LView, viewIndex: number): void {\n  ngDevMode && assertLView(lView);\n  const childComponentLView = getComponentLViewByIndex(viewIndex, lView);\n  if (!(childComponentLView[FLAGS] & LViewFlags.CheckAlways)) {\n    childComponentLView[FLAGS] |= LViewFlags.Dirty;\n  }\n}\n\nfunction setNgReflectProperty(\n    lView: LView, element: RElement|RComment, type: TNodeType, attrName: string, value: any) {\n  const renderer = lView[RENDERER];\n  attrName = normalizeDebugBindingName(attrName);\n  const debugValue = normalizeDebugBindingValue(value);\n  if (type & TNodeType.AnyRNode) {\n    if (value == null) {\n      renderer.removeAttribute((element as RElement), attrName);\n    } else {\n      renderer.setAttribute((element as RElement), attrName, debugValue);\n    }\n  } else {\n    const textContent =\n        escapeCommentText(`bindings=${JSON.stringify({[attrName]: debugValue}, null, 2)}`);\n    renderer.setValue((element as RComment), textContent);\n  }\n}\n\nexport function setNgReflectProperties(\n    lView: LView, element: RElement|RComment, type: TNodeType, dataValue: PropertyAliasValue,\n    value: any) {\n  if (type & (TNodeType.AnyRNode | TNodeType.Container)) {\n    /**\n     * dataValue is an array containing runtime input or output names for the directives:\n     * i+0: directive instance index\n     * i+1: privateName\n     *\n     * e.g. [0, 'change', 'change-minified']\n     * we want to set the reflected property with the privateName: dataValue[i+1]\n     */\n    for (let i = 0; i < dataValue.length; i += 2) {\n      setNgReflectProperty(lView, element, type, dataValue[i + 1] as string, value);\n    }\n  }\n}\n\n/**\n * Instantiate a root component.\n */\nexport function instantiateRootComponent<T>(tView: TView, lView: LView, def: ComponentDef<T>): T {\n  const rootTNode = getCurrentTNode()!;\n  if (tView.firstCreatePass) {\n    if (def.providersResolver) def.providersResolver(def);\n    const directiveIndex = allocExpando(tView, lView, 1, null);\n    ngDevMode &&\n        assertEqual(\n            directiveIndex, rootTNode.directiveStart,\n            'Because this is a root component the allocated expando should match the TNode component.');\n    configureViewWithDirective(tView, rootTNode, lView, directiveIndex, def);\n    initializeInputAndOutputAliases(tView, rootTNode);\n  }\n  const directive =\n      getNodeInjectable(lView, tView, rootTNode.directiveStart, rootTNode as TElementNode);\n  attachPatchData(directive, lView);\n  const native = getNativeByTNode(rootTNode, lView);\n  if (native) {\n    attachPatchData(native, lView);\n  }\n  return directive;\n}\n\n/**\n * Resolve the matched directives on a node.\n */\nexport function resolveDirectives(\n    tView: TView, lView: LView, tNode: TElementNode|TContainerNode|TElementContainerNode,\n    localRefs: string[]|null): boolean {\n  // Please make sure to have explicit type for `exportsMap`. Inferred type triggers bug in\n  // tsickle.\n  ngDevMode && assertFirstCreatePass(tView);\n\n  let hasDirectives = false;\n  if (getBindingsEnabled()) {\n    const directiveDefs: DirectiveDef<any>[]|null = findDirectiveDefMatches(tView, lView, tNode);\n    const exportsMap: ({[key: string]: number}|null) = localRefs === null ? null : {'': -1};\n\n    if (directiveDefs !== null) {\n      hasDirectives = true;\n      initTNodeFlags(tNode, tView.data.length, directiveDefs.length);\n      // When the same token is provided by several directives on the same node, some rules apply in\n      // the viewEngine:\n      // - viewProviders have priority over providers\n      // - the last directive in NgModule.declarations has priority over the previous one\n      // So to match these rules, the order in which providers are added in the arrays is very\n      // important.\n      for (let i = 0; i < directiveDefs.length; i++) {\n        const def = directiveDefs[i];\n        if (def.providersResolver) def.providersResolver(def);\n      }\n      let preOrderHooksFound = false;\n      let preOrderCheckHooksFound = false;\n      let directiveIdx = allocExpando(tView, lView, directiveDefs.length, null);\n      ngDevMode &&\n          assertSame(\n              directiveIdx, tNode.directiveStart,\n              'TNode.directiveStart should point to just allocated space');\n\n      for (let i = 0; i < directiveDefs.length; i++) {\n        const def = directiveDefs[i];\n        // Merge the attrs in the order of matches. This assumes that the first directive is the\n        // component itself, so that the component has the least priority.\n        tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, def.hostAttrs);\n\n        configureViewWithDirective(tView, tNode, lView, directiveIdx, def);\n        saveNameToExportMap(directiveIdx, def, exportsMap);\n\n        if (def.contentQueries !== null) tNode.flags |= TNodeFlags.hasContentQuery;\n        if (def.hostBindings !== null || def.hostAttrs !== null || def.hostVars !== 0)\n          tNode.flags |= TNodeFlags.hasHostBindings;\n\n        const lifeCycleHooks: OnChanges&OnInit&DoCheck = def.type.prototype;\n        // Only push a node index into the preOrderHooks array if this is the first\n        // pre-order hook found on this node.\n        if (!preOrderHooksFound &&\n            (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngOnInit || lifeCycleHooks.ngDoCheck)) {\n          // We will push the actual hook function into this array later during dir instantiation.\n          // We cannot do it now because we must ensure hooks are registered in the same\n          // order that directives are created (i.e. injection order).\n          (tView.preOrderHooks || (tView.preOrderHooks = [])).push(tNode.index);\n          preOrderHooksFound = true;\n        }\n\n        if (!preOrderCheckHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngDoCheck)) {\n          (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(tNode.index);\n          preOrderCheckHooksFound = true;\n        }\n\n        directiveIdx++;\n      }\n\n      initializeInputAndOutputAliases(tView, tNode);\n    }\n    if (exportsMap) cacheMatchingLocalNames(tNode, localRefs, exportsMap);\n  }\n  // Merge the template attrs last so that they have the highest priority.\n  tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);\n  return hasDirectives;\n}\n\n/**\n * Add `hostBindings` to the `TView.hostBindingOpCodes`.\n *\n * @param tView `TView` to which the `hostBindings` should be added.\n * @param tNode `TNode` the element which contains the directive\n * @param lView `LView` current `LView`\n * @param directiveIdx Directive index in view.\n * @param directiveVarsIdx Where will the directive's vars be stored\n * @param def `ComponentDef`/`DirectiveDef`, which contains the `hostVars`/`hostBindings` to add.\n */\nexport function registerHostBindingOpCodes(\n    tView: TView, tNode: TNode, lView: LView, directiveIdx: number, directiveVarsIdx: number,\n    def: ComponentDef<any>|DirectiveDef<any>): void {\n  ngDevMode && assertFirstCreatePass(tView);\n\n  const hostBindings = def.hostBindings;\n  if (hostBindings) {\n    let hostBindingOpCodes = tView.hostBindingOpCodes;\n    if (hostBindingOpCodes === null) {\n      hostBindingOpCodes = tView.hostBindingOpCodes = [] as any as HostBindingOpCodes;\n    }\n    const elementIndx = ~tNode.index;\n    if (lastSelectedElementIdx(hostBindingOpCodes) != elementIndx) {\n      // Conditionally add select element so that we are more efficient in execution.\n      // NOTE: this is strictly not necessary and it trades code size for runtime perf.\n      // (We could just always add it.)\n      hostBindingOpCodes.push(elementIndx);\n    }\n    hostBindingOpCodes.push(directiveIdx, directiveVarsIdx, hostBindings);\n  }\n}\n\n/**\n * Returns the last selected element index in the `HostBindingOpCodes`\n *\n * For perf reasons we don't need to update the selected element index in `HostBindingOpCodes` only\n * if it changes. This method returns the last index (or '0' if not found.)\n *\n * Selected element index are only the ones which are negative.\n */\nfunction lastSelectedElementIdx(hostBindingOpCodes: HostBindingOpCodes): number {\n  let i = hostBindingOpCodes.length;\n  while (i > 0) {\n    const value = hostBindingOpCodes[--i];\n    if (typeof value === 'number' && value < 0) {\n      return value;\n    }\n  }\n  return 0;\n}\n\n\n/**\n * Instantiate all the directives that were previously resolved on the current node.\n */\nfunction instantiateAllDirectives(\n    tView: TView, lView: LView, tNode: TDirectiveHostNode, native: RNode) {\n  const start = tNode.directiveStart;\n  const end = tNode.directiveEnd;\n  if (!tView.firstCreatePass) {\n    getOrCreateNodeInjectorForNode(tNode, lView);\n  }\n\n  attachPatchData(native, lView);\n\n  const initialInputs = tNode.initialInputs;\n  for (let i = start; i < end; i++) {\n    const def = tView.data[i] as DirectiveDef<any>;\n    const isComponent = isComponentDef(def);\n\n    if (isComponent) {\n      ngDevMode && assertTNodeType(tNode, TNodeType.AnyRNode);\n      addComponentLogic(lView, tNode as TElementNode, def as ComponentDef<any>);\n    }\n\n    const directive = getNodeInjectable(lView, tView, i, tNode);\n    attachPatchData(directive, lView);\n\n    if (initialInputs !== null) {\n      setInputsFromAttrs(lView, i - start, directive, def, tNode, initialInputs!);\n    }\n\n    if (isComponent) {\n      const componentView = getComponentLViewByIndex(tNode.index, lView);\n      componentView[CONTEXT] = directive;\n    }\n  }\n}\n\nfunction invokeDirectivesHostBindings(tView: TView, lView: LView, tNode: TNode) {\n  const start = tNode.directiveStart;\n  const end = tNode.directiveEnd;\n  const elementIndex = tNode.index;\n  const currentDirectiveIndex = getCurrentDirectiveIndex();\n  try {\n    setSelectedIndex(elementIndex);\n    for (let dirIndex = start; dirIndex < end; dirIndex++) {\n      const def = tView.data[dirIndex] as DirectiveDef<unknown>;\n      const directive = lView[dirIndex];\n      setCurrentDirectiveIndex(dirIndex);\n      if (def.hostBindings !== null || def.hostVars !== 0 || def.hostAttrs !== null) {\n        invokeHostBindingsInCreationMode(def, directive);\n      }\n    }\n  } finally {\n    setSelectedIndex(-1);\n    setCurrentDirectiveIndex(currentDirectiveIndex);\n  }\n}\n\n/**\n * Invoke the host bindings in creation mode.\n *\n * @param def `DirectiveDef` which may contain the `hostBindings` function.\n * @param directive Instance of directive.\n */\nexport function invokeHostBindingsInCreationMode(def: DirectiveDef<any>, directive: any) {\n  if (def.hostBindings !== null) {\n    def.hostBindings!(RenderFlags.Create, directive);\n  }\n}\n\n/**\n * Matches the current node against all available selectors.\n * If a component is matched (at most one), it is returned in first position in the array.\n */\nfunction findDirectiveDefMatches(\n    tView: TView, viewData: LView,\n    tNode: TElementNode|TContainerNode|TElementContainerNode): DirectiveDef<any>[]|null {\n  ngDevMode && assertFirstCreatePass(tView);\n  ngDevMode && assertTNodeType(tNode, TNodeType.AnyRNode | TNodeType.AnyContainer);\n\n  const registry = tView.directiveRegistry;\n  let matches: any[]|null = null;\n  if (registry) {\n    for (let i = 0; i < registry.length; i++) {\n      const def = registry[i] as ComponentDef<any>| DirectiveDef<any>;\n      if (isNodeMatchingSelectorList(tNode, def.selectors!, /* isProjectionMode */ false)) {\n        matches || (matches = ngDevMode ? new MatchesArray() : []);\n        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, viewData), tView, def.type);\n\n        if (isComponentDef(def)) {\n          if (ngDevMode) {\n            assertTNodeType(\n                tNode, TNodeType.Element,\n                `\"${tNode.value}\" tags cannot be used as component hosts. ` +\n                    `Please use a different tag to activate the ${stringify(def.type)} component.`);\n\n            if (tNode.flags & TNodeFlags.isComponentHost) {\n              // If another component has been matched previously, it's the first element in the\n              // `matches` array, see how we store components/directives in `matches` below.\n              throwMultipleComponentError(tNode, matches[0].type, def.type);\n            }\n          }\n          markAsComponentHost(tView, tNode);\n          // The component is always stored first with directives after.\n          matches.unshift(def);\n        } else {\n          matches.push(def);\n        }\n      }\n    }\n  }\n  return matches;\n}\n\n/**\n * Marks a given TNode as a component's host. This consists of:\n * - setting appropriate TNode flags;\n * - storing index of component's host element so it will be queued for view refresh during CD.\n */\nexport function markAsComponentHost(tView: TView, hostTNode: TNode): void {\n  ngDevMode && assertFirstCreatePass(tView);\n  hostTNode.flags |= TNodeFlags.isComponentHost;\n  (tView.components || (tView.components = ngDevMode ? new TViewComponents() : []))\n      .push(hostTNode.index);\n}\n\n\n/** Caches local names and their matching directive indices for query and template lookups. */\nfunction cacheMatchingLocalNames(\n    tNode: TNode, localRefs: string[]|null, exportsMap: {[key: string]: number}): void {\n  if (localRefs) {\n    const localNames: (string|number)[] = tNode.localNames = ngDevMode ? new TNodeLocalNames() : [];\n\n    // Local names must be stored in tNode in the same order that localRefs are defined\n    // in the template to ensure the data is loaded in the same slots as their refs\n    // in the template (for template queries).\n    for (let i = 0; i < localRefs.length; i += 2) {\n      const index = exportsMap[localRefs[i + 1]];\n      if (index == null)\n        throw new RuntimeError(\n            RuntimeErrorCode.EXPORT_NOT_FOUND,\n            ngDevMode && `Export of name '${localRefs[i + 1]}' not found!`);\n      localNames.push(localRefs[i], index);\n    }\n  }\n}\n\n/**\n * Builds up an export map as directives are created, so local refs can be quickly mapped\n * to their directive instances.\n */\nfunction saveNameToExportMap(\n    directiveIdx: number, def: DirectiveDef<any>|ComponentDef<any>,\n    exportsMap: {[key: string]: number}|null) {\n  if (exportsMap) {\n    if (def.exportAs) {\n      for (let i = 0; i < def.exportAs.length; i++) {\n        exportsMap[def.exportAs[i]] = directiveIdx;\n      }\n    }\n    if (isComponentDef(def)) exportsMap[''] = directiveIdx;\n  }\n}\n\n/**\n * Initializes the flags on the current node, setting all indices to the initial index,\n * the directive count to 0, and adding the isComponent flag.\n * @param index the initial index\n */\nexport function initTNodeFlags(tNode: TNode, index: number, numberOfDirectives: number) {\n  ngDevMode &&\n      assertNotEqual(\n          numberOfDirectives, tNode.directiveEnd - tNode.directiveStart,\n          'Reached the max number of directives');\n  tNode.flags |= TNodeFlags.isDirectiveHost;\n  // When the first directive is created on a node, save the index\n  tNode.directiveStart = index;\n  tNode.directiveEnd = index + numberOfDirectives;\n  tNode.providerIndexes = index;\n}\n\n/**\n * Setup directive for instantiation.\n *\n * We need to create a `NodeInjectorFactory` which is then inserted in both the `Blueprint` as well\n * as `LView`. `TView` gets the `DirectiveDef`.\n *\n * @param tView `TView`\n * @param tNode `TNode`\n * @param lView `LView`\n * @param directiveIndex Index where the directive will be stored in the Expando.\n * @param def `DirectiveDef`\n */\nfunction configureViewWithDirective<T>(\n    tView: TView, tNode: TNode, lView: LView, directiveIndex: number, def: DirectiveDef<T>): void {\n  ngDevMode &&\n      assertGreaterThanOrEqual(directiveIndex, HEADER_OFFSET, 'Must be in Expando section');\n  tView.data[directiveIndex] = def;\n  const directiveFactory =\n      def.factory || ((def as {factory: Function}).factory = getFactoryDef(def.type, true));\n  // Even though `directiveFactory` will already be using `ɵɵdirectiveInject` in its generated code,\n  // we also want to support `inject()` directly from the directive constructor context so we set\n  // `ɵɵdirectiveInject` as the inject implementation here too.\n  const nodeInjectorFactory =\n      new NodeInjectorFactory(directiveFactory, isComponentDef(def), ɵɵdirectiveInject);\n  tView.blueprint[directiveIndex] = nodeInjectorFactory;\n  lView[directiveIndex] = nodeInjectorFactory;\n\n  registerHostBindingOpCodes(\n      tView, tNode, lView, directiveIndex, allocExpando(tView, lView, def.hostVars, NO_CHANGE),\n      def);\n}\n\nfunction addComponentLogic<T>(lView: LView, hostTNode: TElementNode, def: ComponentDef<T>): void {\n  const native = getNativeByTNode(hostTNode, lView) as RElement;\n  const tView = getOrCreateTComponentView(def);\n\n  // Only component views should be added to the view tree directly. Embedded views are\n  // accessed through their containers because they may be removed / re-added later.\n  const rendererFactory = lView[RENDERER_FACTORY];\n  const componentView = addToViewTree(\n      lView,\n      createLView(\n          lView, tView, null, def.onPush ? LViewFlags.Dirty : LViewFlags.CheckAlways, native,\n          hostTNode as TElementNode, rendererFactory, rendererFactory.createRenderer(native, def),\n          null, null, null));\n\n  // Component view will always be created before any injected LContainers,\n  // so this is a regular element, wrap it with the component view\n  lView[hostTNode.index] = componentView;\n}\n\nexport function elementAttributeInternal(\n    tNode: TNode, lView: LView, name: string, value: any, sanitizer: SanitizerFn|null|undefined,\n    namespace: string|null|undefined) {\n  if (ngDevMode) {\n    assertNotSame(value, NO_CHANGE as any, 'Incoming value should never be NO_CHANGE.');\n    validateAgainstEventAttributes(name);\n    assertTNodeType(\n        tNode, TNodeType.Element,\n        `Attempted to set attribute \\`${name}\\` on a container node. ` +\n            `Host bindings are not valid on ng-container or ng-template.`);\n  }\n  const element = getNativeByTNode(tNode, lView) as RElement;\n  setElementAttribute(lView[RENDERER], element, namespace, tNode.value, name, value, sanitizer);\n}\n\nexport function setElementAttribute(\n    renderer: Renderer, element: RElement, namespace: string|null|undefined, tagName: string|null,\n    name: string, value: any, sanitizer: SanitizerFn|null|undefined) {\n  if (value == null) {\n    ngDevMode && ngDevMode.rendererRemoveAttribute++;\n    renderer.removeAttribute(element, name, namespace);\n  } else {\n    ngDevMode && ngDevMode.rendererSetAttribute++;\n    const strValue =\n        sanitizer == null ? renderStringify(value) : sanitizer(value, tagName || '', name);\n\n\n    renderer.setAttribute(element, name, strValue as string, namespace);\n  }\n}\n\n/**\n * Sets initial input properties on directive instances from attribute data\n *\n * @param lView Current LView that is being processed.\n * @param directiveIndex Index of the directive in directives array\n * @param instance Instance of the directive on which to set the initial inputs\n * @param def The directive def that contains the list of inputs\n * @param tNode The static data for this node\n */\nfunction setInputsFromAttrs<T>(\n    lView: LView, directiveIndex: number, instance: T, def: DirectiveDef<T>, tNode: TNode,\n    initialInputData: InitialInputData): void {\n  const initialInputs: InitialInputs|null = initialInputData![directiveIndex];\n  if (initialInputs !== null) {\n    const setInput = def.setInput;\n    for (let i = 0; i < initialInputs.length;) {\n      const publicName = initialInputs[i++];\n      const privateName = initialInputs[i++];\n      const value = initialInputs[i++];\n      if (setInput !== null) {\n        def.setInput!(instance, value, publicName, privateName);\n      } else {\n        (instance as any)[privateName] = value;\n      }\n      if (ngDevMode) {\n        const nativeElement = getNativeByTNode(tNode, lView) as RElement;\n        setNgReflectProperty(lView, nativeElement, tNode.type, privateName, value);\n      }\n    }\n  }\n}\n\n/**\n * Generates initialInputData for a node and stores it in the template's static storage\n * so subsequent template invocations don't have to recalculate it.\n *\n * initialInputData is an array containing values that need to be set as input properties\n * for directives on this node, but only once on creation. We need this array to support\n * the case where you set an @Input property of a directive using attribute-like syntax.\n * e.g. if you have a `name` @Input, you can set it once like this:\n *\n * <my-component name=\"Bess\"></my-component>\n *\n * @param inputs The list of inputs from the directive def\n * @param attrs The static attrs on this node\n */\nfunction generateInitialInputs(inputs: {[key: string]: string}, attrs: TAttributes): InitialInputs|\n    null {\n  let inputsToStore: InitialInputs|null = null;\n  let i = 0;\n  while (i < attrs.length) {\n    const attrName = attrs[i];\n    if (attrName === AttributeMarker.NamespaceURI) {\n      // We do not allow inputs on namespaced attributes.\n      i += 4;\n      continue;\n    } else if (attrName === AttributeMarker.ProjectAs) {\n      // Skip over the `ngProjectAs` value.\n      i += 2;\n      continue;\n    }\n\n    // If we hit any other attribute markers, we're done anyway. None of those are valid inputs.\n    if (typeof attrName === 'number') break;\n\n    if (inputs.hasOwnProperty(attrName as string)) {\n      if (inputsToStore === null) inputsToStore = [];\n      inputsToStore.push(attrName as string, inputs[attrName as string], attrs[i + 1] as string);\n    }\n\n    i += 2;\n  }\n  return inputsToStore;\n}\n\n//////////////////////////\n//// ViewContainer & View\n//////////////////////////\n\n// Not sure why I need to do `any` here but TS complains later.\nconst LContainerArray: any = class LContainer extends Array {};\n\n/**\n * Creates a LContainer, either from a container instruction, or for a ViewContainerRef.\n *\n * @param hostNative The host element for the LContainer\n * @param hostTNode The host TNode for the LContainer\n * @param currentView The parent view of the LContainer\n * @param native The native comment element\n * @param isForViewContainerRef Optional a flag indicating the ViewContainerRef case\n * @returns LContainer\n */\nexport function createLContainer(\n    hostNative: RElement|RComment|LView, currentView: LView, native: RComment,\n    tNode: TNode): LContainer {\n  ngDevMode && assertLView(currentView);\n  // https://jsperf.com/array-literal-vs-new-array-really\n  const lContainer: LContainer = new (ngDevMode ? LContainerArray : Array)(\n      hostNative,   // host native\n      true,         // Boolean `true` in this position signifies that this is an `LContainer`\n      false,        // has transplanted views\n      currentView,  // parent\n      null,         // next\n      0,            // transplanted views to refresh count\n      tNode,        // t_host\n      native,       // native,\n      null,         // view refs\n      null,         // moved views\n  );\n  ngDevMode &&\n      assertEqual(\n          lContainer.length, CONTAINER_HEADER_OFFSET,\n          'Should allocate correct number of slots for LContainer header.');\n  ngDevMode && attachLContainerDebug(lContainer);\n  return lContainer;\n}\n\n/**\n * Goes over embedded views (ones created through ViewContainerRef APIs) and refreshes\n * them by executing an associated template function.\n */\nfunction refreshEmbeddedViews(lView: LView) {\n  for (let lContainer = getFirstLContainer(lView); lContainer !== null;\n       lContainer = getNextLContainer(lContainer)) {\n    for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n      const embeddedLView = lContainer[i];\n      const embeddedTView = embeddedLView[TVIEW];\n      ngDevMode && assertDefined(embeddedTView, 'TView must be allocated');\n      if (viewAttachedToChangeDetector(embeddedLView)) {\n        refreshView(embeddedTView, embeddedLView, embeddedTView.template, embeddedLView[CONTEXT]!);\n      }\n    }\n  }\n}\n\n/**\n * Mark transplanted views as needing to be refreshed at their insertion points.\n *\n * @param lView The `LView` that may have transplanted views.\n */\nfunction markTransplantedViewsForRefresh(lView: LView) {\n  for (let lContainer = getFirstLContainer(lView); lContainer !== null;\n       lContainer = getNextLContainer(lContainer)) {\n    if (!lContainer[HAS_TRANSPLANTED_VIEWS]) continue;\n\n    const movedViews = lContainer[MOVED_VIEWS]!;\n    ngDevMode && assertDefined(movedViews, 'Transplanted View flags set but missing MOVED_VIEWS');\n    for (let i = 0; i < movedViews.length; i++) {\n      const movedLView = movedViews[i]!;\n      const insertionLContainer = movedLView[PARENT] as LContainer;\n      ngDevMode && assertLContainer(insertionLContainer);\n      // We don't want to increment the counter if the moved LView was already marked for\n      // refresh.\n      if ((movedLView[FLAGS] & LViewFlags.RefreshTransplantedView) === 0) {\n        updateTransplantedViewCount(insertionLContainer, 1);\n      }\n      // Note, it is possible that the `movedViews` is tracking views that are transplanted *and*\n      // those that aren't (declaration component === insertion component). In the latter case,\n      // it's fine to add the flag, as we will clear it immediately in\n      // `refreshEmbeddedViews` for the view currently being refreshed.\n      movedLView[FLAGS] |= LViewFlags.RefreshTransplantedView;\n    }\n  }\n}\n\n/////////////\n\n/**\n * Refreshes components by entering the component view and processing its bindings, queries, etc.\n *\n * @param componentHostIdx  Element index in LView[] (adjusted for HEADER_OFFSET)\n */\nfunction refreshComponent(hostLView: LView, componentHostIdx: number): void {\n  ngDevMode && assertEqual(isCreationMode(hostLView), false, 'Should be run in update mode');\n  const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);\n  // Only attached components that are CheckAlways or OnPush and dirty should be refreshed\n  if (viewAttachedToChangeDetector(componentView)) {\n    const tView = componentView[TVIEW];\n    if (componentView[FLAGS] & (LViewFlags.CheckAlways | LViewFlags.Dirty)) {\n      refreshView(tView, componentView, tView.template, componentView[CONTEXT]);\n    } else if (componentView[TRANSPLANTED_VIEWS_TO_REFRESH] > 0) {\n      // Only attached components that are CheckAlways or OnPush and dirty should be refreshed\n      refreshContainsDirtyView(componentView);\n    }\n  }\n}\n\n/**\n * Refreshes all transplanted views marked with `LViewFlags.RefreshTransplantedView` that are\n * children or descendants of the given lView.\n *\n * @param lView The lView which contains descendant transplanted views that need to be refreshed.\n */\nfunction refreshContainsDirtyView(lView: LView) {\n  for (let lContainer = getFirstLContainer(lView); lContainer !== null;\n       lContainer = getNextLContainer(lContainer)) {\n    for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n      const embeddedLView = lContainer[i];\n      if (embeddedLView[FLAGS] & LViewFlags.RefreshTransplantedView) {\n        const embeddedTView = embeddedLView[TVIEW];\n        ngDevMode && assertDefined(embeddedTView, 'TView must be allocated');\n        refreshView(embeddedTView, embeddedLView, embeddedTView.template, embeddedLView[CONTEXT]!);\n      } else if (embeddedLView[TRANSPLANTED_VIEWS_TO_REFRESH] > 0) {\n        refreshContainsDirtyView(embeddedLView);\n      }\n    }\n  }\n\n  const tView = lView[TVIEW];\n  // Refresh child component views.\n  const components = tView.components;\n  if (components !== null) {\n    for (let i = 0; i < components.length; i++) {\n      const componentView = getComponentLViewByIndex(components[i], lView);\n      // Only attached components that are CheckAlways or OnPush and dirty should be refreshed\n      if (viewAttachedToChangeDetector(componentView) &&\n          componentView[TRANSPLANTED_VIEWS_TO_REFRESH] > 0) {\n        refreshContainsDirtyView(componentView);\n      }\n    }\n  }\n}\n\nfunction renderComponent(hostLView: LView, componentHostIdx: number) {\n  ngDevMode && assertEqual(isCreationMode(hostLView), true, 'Should be run in creation mode');\n  const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);\n  const componentTView = componentView[TVIEW];\n  syncViewWithBlueprint(componentTView, componentView);\n  renderView(componentTView, componentView, componentView[CONTEXT]);\n}\n\n/**\n * Syncs an LView instance with its blueprint if they have gotten out of sync.\n *\n * Typically, blueprints and their view instances should always be in sync, so the loop here\n * will be skipped. However, consider this case of two components side-by-side:\n *\n * App template:\n * ```\n * <comp></comp>\n * <comp></comp>\n * ```\n *\n * The following will happen:\n * 1. App template begins processing.\n * 2. First <comp> is matched as a component and its LView is created.\n * 3. Second <comp> is matched as a component and its LView is created.\n * 4. App template completes processing, so it's time to check child templates.\n * 5. First <comp> template is checked. It has a directive, so its def is pushed to blueprint.\n * 6. Second <comp> template is checked. Its blueprint has been updated by the first\n * <comp> template, but its LView was created before this update, so it is out of sync.\n *\n * Note that embedded views inside ngFor loops will never be out of sync because these views\n * are processed as soon as they are created.\n *\n * @param tView The `TView` that contains the blueprint for syncing\n * @param lView The view to sync\n */\nfunction syncViewWithBlueprint(tView: TView, lView: LView) {\n  for (let i = lView.length; i < tView.blueprint.length; i++) {\n    lView.push(tView.blueprint[i]);\n  }\n}\n\n/**\n * Adds LView or LContainer to the end of the current view tree.\n *\n * This structure will be used to traverse through nested views to remove listeners\n * and call onDestroy callbacks.\n *\n * @param lView The view where LView or LContainer should be added\n * @param adjustedHostIndex Index of the view's host node in LView[], adjusted for header\n * @param lViewOrLContainer The LView or LContainer to add to the view tree\n * @returns The state passed in\n */\nexport function addToViewTree<T extends LView|LContainer>(lView: LView, lViewOrLContainer: T): T {\n  // TODO(benlesh/misko): This implementation is incorrect, because it always adds the LContainer\n  // to the end of the queue, which means if the developer retrieves the LContainers from RNodes out\n  // of order, the change detection will run out of order, as the act of retrieving the the\n  // LContainer from the RNode is what adds it to the queue.\n  if (lView[CHILD_HEAD]) {\n    lView[CHILD_TAIL]![NEXT] = lViewOrLContainer;\n  } else {\n    lView[CHILD_HEAD] = lViewOrLContainer;\n  }\n  lView[CHILD_TAIL] = lViewOrLContainer;\n  return lViewOrLContainer;\n}\n\n///////////////////////////////\n//// Change detection\n///////////////////////////////\n\n\n/**\n * Marks current view and all ancestors dirty.\n *\n * Returns the root view because it is found as a byproduct of marking the view tree\n * dirty, and can be used by methods that consume markViewDirty() to easily schedule\n * change detection. Otherwise, such methods would need to traverse up the view tree\n * an additional time to get the root view and schedule a tick on it.\n *\n * @param lView The starting LView to mark dirty\n * @returns the root LView\n */\nexport function markViewDirty(lView: LView): LView|null {\n  while (lView) {\n    lView[FLAGS] |= LViewFlags.Dirty;\n    const parent = getLViewParent(lView);\n    // Stop traversing up as soon as you find a root view that wasn't attached to any container\n    if (isRootView(lView) && !parent) {\n      return lView;\n    }\n    // continue otherwise\n    lView = parent!;\n  }\n  return null;\n}\n\n\n/**\n * Used to schedule change detection on the whole application.\n *\n * Unlike `tick`, `scheduleTick` coalesces multiple calls into one change detection run.\n * It is usually called indirectly by calling `markDirty` when the view needs to be\n * re-rendered.\n *\n * Typically `scheduleTick` uses `requestAnimationFrame` to coalesce multiple\n * `scheduleTick` requests. The scheduling function can be overridden in\n * `renderComponent`'s `scheduler` option.\n */\nexport function scheduleTick(rootContext: RootContext, flags: RootContextFlags) {\n  const nothingScheduled = rootContext.flags === RootContextFlags.Empty;\n  if (nothingScheduled && rootContext.clean == _CLEAN_PROMISE) {\n    // https://github.com/angular/angular/issues/39296\n    // should only attach the flags when really scheduling a tick\n    rootContext.flags |= flags;\n    let res: null|((val: null) => void);\n    rootContext.clean = new Promise<null>((r) => res = r);\n    rootContext.scheduler(() => {\n      if (rootContext.flags & RootContextFlags.DetectChanges) {\n        rootContext.flags &= ~RootContextFlags.DetectChanges;\n        tickRootContext(rootContext);\n      }\n\n      if (rootContext.flags & RootContextFlags.FlushPlayers) {\n        rootContext.flags &= ~RootContextFlags.FlushPlayers;\n        const playerHandler = rootContext.playerHandler;\n        if (playerHandler) {\n          playerHandler.flushPlayers();\n        }\n      }\n\n      rootContext.clean = _CLEAN_PROMISE;\n      res!(null);\n    });\n  }\n}\n\nexport function tickRootContext(rootContext: RootContext) {\n  for (let i = 0; i < rootContext.components.length; i++) {\n    const rootComponent = rootContext.components[i];\n    const lView = readPatchedLView(rootComponent);\n    // We might not have an `LView` if the component was destroyed.\n    if (lView !== null) {\n      const tView = lView[TVIEW];\n      renderComponentOrTemplate(tView, lView, tView.template, rootComponent);\n    }\n  }\n}\n\nexport function detectChangesInternal<T>(tView: TView, lView: LView, context: T) {\n  const rendererFactory = lView[RENDERER_FACTORY];\n  if (rendererFactory.begin) rendererFactory.begin();\n  try {\n    refreshView(tView, lView, tView.template, context);\n  } catch (error) {\n    handleError(lView, error);\n    throw error;\n  } finally {\n    if (rendererFactory.end) rendererFactory.end();\n  }\n}\n\n/**\n * Synchronously perform change detection on a root view and its components.\n *\n * @param lView The view which the change detection should be performed on.\n */\nexport function detectChangesInRootView(lView: LView): void {\n  tickRootContext(lView[CONTEXT] as RootContext);\n}\n\nexport function checkNoChangesInternal<T>(tView: TView, view: LView, context: T) {\n  setIsInCheckNoChangesMode(true);\n  try {\n    detectChangesInternal(tView, view, context);\n  } finally {\n    setIsInCheckNoChangesMode(false);\n  }\n}\n\n/**\n * Checks the change detector on a root view and its components, and throws if any changes are\n * detected.\n *\n * This is used in development mode to verify that running change detection doesn't\n * introduce other changes.\n *\n * @param lView The view which the change detection should be checked on.\n */\nexport function checkNoChangesInRootView(lView: LView): void {\n  setIsInCheckNoChangesMode(true);\n  try {\n    detectChangesInRootView(lView);\n  } finally {\n    setIsInCheckNoChangesMode(false);\n  }\n}\n\nfunction executeViewQueryFn<T>(\n    flags: RenderFlags, viewQueryFn: ViewQueriesFunction<T>, component: T): void {\n  ngDevMode && assertDefined(viewQueryFn, 'View queries function to execute must be defined.');\n  setCurrentQueryIndex(0);\n  viewQueryFn(flags, component);\n}\n\n\n///////////////////////////////\n//// Bindings & interpolations\n///////////////////////////////\n\n/**\n * Stores meta-data for a property binding to be used by TestBed's `DebugElement.properties`.\n *\n * In order to support TestBed's `DebugElement.properties` we need to save, for each binding:\n * - a bound property name;\n * - a static parts of interpolated strings;\n *\n * A given property metadata is saved at the binding's index in the `TView.data` (in other words, a\n * property binding metadata will be stored in `TView.data` at the same index as a bound value in\n * `LView`). Metadata are represented as `INTERPOLATION_DELIMITER`-delimited string with the\n * following format:\n * - `propertyName` for bound properties;\n * - `propertyName�prefix�interpolation_static_part1�..interpolation_static_partN�suffix` for\n * interpolated properties.\n *\n * @param tData `TData` where meta-data will be saved;\n * @param tNode `TNode` that is a target of the binding;\n * @param propertyName bound property name;\n * @param bindingIndex binding index in `LView`\n * @param interpolationParts static interpolation parts (for property interpolations)\n */\nexport function storePropertyBindingMetadata(\n    tData: TData, tNode: TNode, propertyName: string, bindingIndex: number,\n    ...interpolationParts: string[]) {\n  // Binding meta-data are stored only the first time a given property instruction is processed.\n  // Since we don't have a concept of the \"first update pass\" we need to check for presence of the\n  // binding meta-data to decide if one should be stored (or if was stored already).\n  if (tData[bindingIndex] === null) {\n    if (tNode.inputs == null || !tNode.inputs[propertyName]) {\n      const propBindingIdxs = tNode.propertyBindings || (tNode.propertyBindings = []);\n      propBindingIdxs.push(bindingIndex);\n      let bindingMetadata = propertyName;\n      if (interpolationParts.length > 0) {\n        bindingMetadata +=\n            INTERPOLATION_DELIMITER + interpolationParts.join(INTERPOLATION_DELIMITER);\n      }\n      tData[bindingIndex] = bindingMetadata;\n    }\n  }\n}\n\nexport const CLEAN_PROMISE = _CLEAN_PROMISE;\n\nexport function getOrCreateLViewCleanup(view: LView): any[] {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return view[CLEANUP] || (view[CLEANUP] = ngDevMode ? new LCleanup() : []);\n}\n\nexport function getOrCreateTViewCleanup(tView: TView): any[] {\n  return tView.cleanup || (tView.cleanup = ngDevMode ? new TCleanup() : []);\n}\n\n/**\n * There are cases where the sub component's renderer needs to be included\n * instead of the current renderer (see the componentSyntheticHost* instructions).\n */\nexport function loadComponentRenderer(\n    currentDef: DirectiveDef<any>|null, tNode: TNode, lView: LView): Renderer {\n  // TODO(FW-2043): the `currentDef` is null when host bindings are invoked while creating root\n  // component (see packages/core/src/render3/component.ts). This is not consistent with the process\n  // of creating inner components, when current directive index is available in the state. In order\n  // to avoid relying on current def being `null` (thus special-casing root component creation), the\n  // process of creating root component should be unified with the process of creating inner\n  // components.\n  if (currentDef === null || isComponentDef(currentDef)) {\n    lView = unwrapLView(lView[tNode.index])!;\n  }\n  return lView[RENDERER];\n}\n\n/** Handles an error thrown in an LView. */\nexport function handleError(lView: LView, error: any): void {\n  const injector = lView[INJECTOR];\n  const errorHandler = injector ? injector.get(ErrorHandler, null) : null;\n  errorHandler && errorHandler.handleError(error);\n}\n\n/**\n * Set the inputs of directives at the current node to corresponding value.\n *\n * @param tView The current TView\n * @param lView the `LView` which contains the directives.\n * @param inputs mapping between the public \"input\" name and privately-known,\n *        possibly minified, property names to write to.\n * @param value Value to set.\n */\nexport function setInputsForProperty(\n    tView: TView, lView: LView, inputs: PropertyAliasValue, publicName: string, value: any): void {\n  for (let i = 0; i < inputs.length;) {\n    const index = inputs[i++] as number;\n    const privateName = inputs[i++] as string;\n    const instance = lView[index];\n    ngDevMode && assertIndexInRange(lView, index);\n    const def = tView.data[index] as DirectiveDef<any>;\n    if (def.setInput !== null) {\n      def.setInput!(instance, value, publicName, privateName);\n    } else {\n      instance[privateName] = value;\n    }\n  }\n}\n\n/**\n * Updates a text binding at a given index in a given LView.\n */\nexport function textBindingInternal(lView: LView, index: number, value: string): void {\n  ngDevMode && assertString(value, 'Value should be a string');\n  ngDevMode && assertNotSame(value, NO_CHANGE as any, 'value should not be NO_CHANGE');\n  ngDevMode && assertIndexInRange(lView, index);\n  const element = getNativeByIndex(index, lView) as any as RText;\n  ngDevMode && assertDefined(element, 'native element should exist');\n  updateTextNode(lView[RENDERER], element, value);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {concatStringsWithSpace} from '../../util/stringify';\nimport {assertFirstCreatePass} from '../assert';\nimport {AttributeMarker, TAttributes, TNode} from '../interfaces/node';\nimport {getTView} from '../state';\n\n/**\n * Compute the static styling (class/style) from `TAttributes`.\n *\n * This function should be called during `firstCreatePass` only.\n *\n * @param tNode The `TNode` into which the styling information should be loaded.\n * @param attrs `TAttributes` containing the styling information.\n * @param writeToHost Where should the resulting static styles be written?\n *   - `false` Write to `TNode.stylesWithoutHost` / `TNode.classesWithoutHost`\n *   - `true` Write to `TNode.styles` / `TNode.classes`\n */\nexport function computeStaticStyling(\n    tNode: TNode, attrs: TAttributes|null, writeToHost: boolean): void {\n  ngDevMode &&\n      assertFirstCreatePass(getTView(), 'Expecting to be called in first template pass only');\n  let styles: string|null = writeToHost ? tNode.styles : null;\n  let classes: string|null = writeToHost ? tNode.classes : null;\n  let mode: AttributeMarker|0 = 0;\n  if (attrs !== null) {\n    for (let i = 0; i < attrs.length; i++) {\n      const value = attrs[i];\n      if (typeof value === 'number') {\n        mode = value;\n      } else if (mode == AttributeMarker.Classes) {\n        classes = concatStringsWithSpace(classes, value as string);\n      } else if (mode == AttributeMarker.Styles) {\n        const style = value as string;\n        const styleValue = attrs[++i] as string;\n        styles = concatStringsWithSpace(styles, style + ': ' + styleValue + ';');\n      }\n    }\n  }\n  writeToHost ? tNode.styles = styles : tNode.stylesWithoutHost = styles;\n  writeToHost ? tNode.classes = classes : tNode.classesWithoutHost = classes;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertParentView} from './assert';\nimport {icuContainerIterate} from './i18n/i18n_tree_shaking';\nimport {CONTAINER_HEADER_OFFSET} from './interfaces/container';\nimport {TIcuContainerNode, TNode, TNodeType} from './interfaces/node';\nimport {RNode} from './interfaces/renderer_dom';\nimport {isLContainer} from './interfaces/type_checks';\nimport {DECLARATION_COMPONENT_VIEW, LView, T_HOST, TVIEW, TView} from './interfaces/view';\nimport {assertTNodeType} from './node_assert';\nimport {getProjectionNodes} from './node_manipulation';\nimport {getLViewParent} from './util/view_traversal_utils';\nimport {unwrapRNode} from './util/view_utils';\n\n\n\nexport function collectNativeNodes(\n    tView: TView, lView: LView, tNode: TNode|null, result: any[],\n    isProjection: boolean = false): any[] {\n  while (tNode !== null) {\n    ngDevMode &&\n        assertTNodeType(\n            tNode,\n            TNodeType.AnyRNode | TNodeType.AnyContainer | TNodeType.Projection | TNodeType.Icu);\n\n    const lNode = lView[tNode.index];\n    if (lNode !== null) {\n      result.push(unwrapRNode(lNode));\n    }\n\n    // A given lNode can represent either a native node or a LContainer (when it is a host of a\n    // ViewContainerRef). When we find a LContainer we need to descend into it to collect root nodes\n    // from the views in this container.\n    if (isLContainer(lNode)) {\n      for (let i = CONTAINER_HEADER_OFFSET; i < lNode.length; i++) {\n        const lViewInAContainer = lNode[i];\n        const lViewFirstChildTNode = lViewInAContainer[TVIEW].firstChild;\n        if (lViewFirstChildTNode !== null) {\n          collectNativeNodes(\n              lViewInAContainer[TVIEW], lViewInAContainer, lViewFirstChildTNode, result);\n        }\n      }\n    }\n\n    const tNodeType = tNode.type;\n    if (tNodeType & TNodeType.ElementContainer) {\n      collectNativeNodes(tView, lView, tNode.child, result);\n    } else if (tNodeType & TNodeType.Icu) {\n      const nextRNode = icuContainerIterate(tNode as TIcuContainerNode, lView);\n      let rNode: RNode|null;\n      while (rNode = nextRNode()) {\n        result.push(rNode);\n      }\n    } else if (tNodeType & TNodeType.Projection) {\n      const nodesInSlot = getProjectionNodes(lView, tNode);\n      if (Array.isArray(nodesInSlot)) {\n        result.push(...nodesInSlot);\n      } else {\n        const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW])!;\n        ngDevMode && assertParentView(parentView);\n        collectNativeNodes(parentView[TVIEW], parentView, nodesInSlot, result, true);\n      }\n    }\n    tNode = isProjection ? tNode.projectionNext : tNode.next;\n  }\n\n  return result;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ChangeDetectorRef as viewEngine_ChangeDetectorRef} from '../change_detection/change_detector_ref';\nimport {RuntimeError, RuntimeErrorCode} from '../errors';\nimport {EmbeddedViewRef as viewEngine_EmbeddedViewRef, InternalViewRef as viewEngine_InternalViewRef, ViewRefTracker} from '../linker/view_ref';\nimport {removeFromArray} from '../util/array_utils';\nimport {assertEqual} from '../util/assert';\n\nimport {collectNativeNodes} from './collect_native_nodes';\nimport {checkNoChangesInRootView, checkNoChangesInternal, detectChangesInRootView, detectChangesInternal, markViewDirty, storeCleanupWithContext} from './instructions/shared';\nimport {CONTAINER_HEADER_OFFSET, VIEW_REFS} from './interfaces/container';\nimport {isLContainer} from './interfaces/type_checks';\nimport {CONTEXT, FLAGS, LView, LViewFlags, PARENT, TVIEW} from './interfaces/view';\nimport {destroyLView, detachView, renderDetachView} from './node_manipulation';\n\n\n\n// Needed due to tsickle downleveling where multiple `implements` with classes creates\n// multiple @extends in Closure annotations, which is illegal. This workaround fixes\n// the multiple @extends by making the annotation @implements instead\nexport interface viewEngine_ChangeDetectorRef_interface extends viewEngine_ChangeDetectorRef {}\n\nexport class ViewRef<T> implements viewEngine_EmbeddedViewRef<T>, viewEngine_InternalViewRef,\n                                   viewEngine_ChangeDetectorRef_interface {\n  private _appRef: ViewRefTracker|null = null;\n  private _attachedToViewContainer = false;\n\n  get rootNodes(): any[] {\n    const lView = this._lView;\n    const tView = lView[TVIEW];\n    return collectNativeNodes(tView, lView, tView.firstChild, []);\n  }\n\n  constructor(\n      /**\n       * This represents `LView` associated with the component when ViewRef is a ChangeDetectorRef.\n       *\n       * When ViewRef is created for a dynamic component, this also represents the `LView` for the\n       * component.\n       *\n       * For a \"regular\" ViewRef created for an embedded view, this is the `LView` for the embedded\n       * view.\n       *\n       * @internal\n       */\n      public _lView: LView,\n\n      /**\n       * This represents the `LView` associated with the point where `ChangeDetectorRef` was\n       * requested.\n       *\n       * This may be different from `_lView` if the `_cdRefInjectingView` is an embedded view.\n       */\n      private _cdRefInjectingView?: LView) {}\n\n  get context(): T {\n    return this._lView[CONTEXT] as unknown as T;\n  }\n\n  set context(value: T) {\n    this._lView[CONTEXT] = value as unknown as {};\n  }\n\n  get destroyed(): boolean {\n    return (this._lView[FLAGS] & LViewFlags.Destroyed) === LViewFlags.Destroyed;\n  }\n\n  destroy(): void {\n    if (this._appRef) {\n      this._appRef.detachView(this);\n    } else if (this._attachedToViewContainer) {\n      const parent = this._lView[PARENT];\n      if (isLContainer(parent)) {\n        const viewRefs = parent[VIEW_REFS] as ViewRef<unknown>[] | null;\n        const index = viewRefs ? viewRefs.indexOf(this) : -1;\n        if (index > -1) {\n          ngDevMode &&\n              assertEqual(\n                  index, parent.indexOf(this._lView) - CONTAINER_HEADER_OFFSET,\n                  'An attached view should be in the same position within its container as its ViewRef in the VIEW_REFS array.');\n          detachView(parent, index);\n          removeFromArray(viewRefs!, index);\n        }\n      }\n      this._attachedToViewContainer = false;\n    }\n    destroyLView(this._lView[TVIEW], this._lView);\n  }\n\n  onDestroy(callback: Function) {\n    storeCleanupWithContext(this._lView[TVIEW], this._lView, null, callback);\n  }\n\n  /**\n   * Marks a view and all of its ancestors dirty.\n   *\n   * This can be used to ensure an {@link ChangeDetectionStrategy#OnPush OnPush} component is\n   * checked when it needs to be re-rendered but the two normal triggers haven't marked it\n   * dirty (i.e. inputs haven't changed and events haven't fired in the view).\n   *\n   * <!-- TODO: Add a link to a chapter on OnPush components -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Component({\n   *   selector: 'app-root',\n   *   template: `Number of ticks: {{numberOfTicks}}`\n   *   changeDetection: ChangeDetectionStrategy.OnPush,\n   * })\n   * class AppComponent {\n   *   numberOfTicks = 0;\n   *\n   *   constructor(private ref: ChangeDetectorRef) {\n   *     setInterval(() => {\n   *       this.numberOfTicks++;\n   *       // the following is required, otherwise the view will not be updated\n   *       this.ref.markForCheck();\n   *     }, 1000);\n   *   }\n   * }\n   * ```\n   */\n  markForCheck(): void {\n    markViewDirty(this._cdRefInjectingView || this._lView);\n  }\n\n  /**\n   * Detaches the view from the change detection tree.\n   *\n   * Detached views will not be checked during change detection runs until they are\n   * re-attached, even if they are dirty. `detach` can be used in combination with\n   * {@link ChangeDetectorRef#detectChanges detectChanges} to implement local change\n   * detection checks.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example defines a component with a large list of readonly data.\n   * Imagine the data changes constantly, many times per second. For performance reasons,\n   * we want to check and update the list every five seconds. We can do that by detaching\n   * the component's change detector and doing a local check every five seconds.\n   *\n   * ```typescript\n   * class DataProvider {\n   *   // in a real application the returned data will be different every time\n   *   get data() {\n   *     return [1,2,3,4,5];\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'giant-list',\n   *   template: `\n   *     <li *ngFor=\"let d of dataProvider.data\">Data {{d}}</li>\n   *   `,\n   * })\n   * class GiantList {\n   *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {\n   *     ref.detach();\n   *     setInterval(() => {\n   *       this.ref.detectChanges();\n   *     }, 5000);\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'app',\n   *   providers: [DataProvider],\n   *   template: `\n   *     <giant-list><giant-list>\n   *   `,\n   * })\n   * class App {\n   * }\n   * ```\n   */\n  detach(): void {\n    this._lView[FLAGS] &= ~LViewFlags.Attached;\n  }\n\n  /**\n   * Re-attaches a view to the change detection tree.\n   *\n   * This can be used to re-attach views that were previously detached from the tree\n   * using {@link ChangeDetectorRef#detach detach}. Views are attached to the tree by default.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example creates a component displaying `live` data. The component will detach\n   * its change detector from the main change detector tree when the component's live property\n   * is set to false.\n   *\n   * ```typescript\n   * class DataProvider {\n   *   data = 1;\n   *\n   *   constructor() {\n   *     setInterval(() => {\n   *       this.data = this.data * 2;\n   *     }, 500);\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'live-data',\n   *   inputs: ['live'],\n   *   template: 'Data: {{dataProvider.data}}'\n   * })\n   * class LiveData {\n   *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {}\n   *\n   *   set live(value) {\n   *     if (value) {\n   *       this.ref.reattach();\n   *     } else {\n   *       this.ref.detach();\n   *     }\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'app-root',\n   *   providers: [DataProvider],\n   *   template: `\n   *     Live Update: <input type=\"checkbox\" [(ngModel)]=\"live\">\n   *     <live-data [live]=\"live\"><live-data>\n   *   `,\n   * })\n   * class AppComponent {\n   *   live = true;\n   * }\n   * ```\n   */\n  reattach(): void {\n    this._lView[FLAGS] |= LViewFlags.Attached;\n  }\n\n  /**\n   * Checks the view and its children.\n   *\n   * This can also be used in combination with {@link ChangeDetectorRef#detach detach} to implement\n   * local change detection checks.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example defines a component with a large list of readonly data.\n   * Imagine, the data changes constantly, many times per second. For performance reasons,\n   * we want to check and update the list every five seconds.\n   *\n   * We can do that by detaching the component's change detector and doing a local change detection\n   * check every five seconds.\n   *\n   * See {@link ChangeDetectorRef#detach detach} for more information.\n   */\n  detectChanges(): void {\n    detectChangesInternal(this._lView[TVIEW], this._lView, this.context as unknown as {});\n  }\n\n  /**\n   * Checks the change detector and its children, and throws if any changes are detected.\n   *\n   * This is used in development mode to verify that running change detection doesn't\n   * introduce other changes.\n   */\n  checkNoChanges(): void {\n    if (ngDevMode) {\n      checkNoChangesInternal(this._lView[TVIEW], this._lView, this.context as unknown as {});\n    }\n  }\n\n  attachToViewContainerRef() {\n    if (this._appRef) {\n      throw new RuntimeError(\n          RuntimeErrorCode.VIEW_ALREADY_ATTACHED,\n          ngDevMode && 'This view is already attached directly to the ApplicationRef!');\n    }\n    this._attachedToViewContainer = true;\n  }\n\n  detachFromAppRef() {\n    this._appRef = null;\n    renderDetachView(this._lView[TVIEW], this._lView);\n  }\n\n  attachToAppRef(appRef: ViewRefTracker) {\n    if (this._attachedToViewContainer) {\n      throw new RuntimeError(\n          RuntimeErrorCode.VIEW_ALREADY_ATTACHED,\n          ngDevMode && 'This view is already attached to a ViewContainer!');\n    }\n    this._appRef = appRef;\n  }\n}\n\n/** @internal */\nexport class RootViewRef<T> extends ViewRef<T> {\n  constructor(public _view: LView) {\n    super(_view);\n  }\n\n  override detectChanges(): void {\n    detectChangesInRootView(this._view);\n  }\n\n  override checkNoChanges(): void {\n    if (ngDevMode) {\n      checkNoChangesInRootView(this._view);\n    }\n  }\n\n  override get context(): T {\n    return null!;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ChangeDetectorRef as ViewEngine_ChangeDetectorRef} from '../change_detection/change_detector_ref';\nimport {Injector} from '../di/injector';\nimport {InjectFlags} from '../di/interface/injector';\nimport {ProviderToken} from '../di/provider_token';\nimport {EnvironmentInjector} from '../di/r3_injector';\nimport {RuntimeError, RuntimeErrorCode} from '../errors';\nimport {Type} from '../interface/type';\nimport {ComponentFactory as viewEngine_ComponentFactory, ComponentRef as AbstractComponentRef} from '../linker/component_factory';\nimport {ComponentFactoryResolver as viewEngine_ComponentFactoryResolver} from '../linker/component_factory_resolver';\nimport {createElementRef, ElementRef as viewEngine_ElementRef} from '../linker/element_ref';\nimport {NgModuleRef as viewEngine_NgModuleRef} from '../linker/ng_module_factory';\nimport {RendererFactory2} from '../render/api';\nimport {Sanitizer} from '../sanitization/sanitizer';\nimport {assertDefined, assertIndexInRange} from '../util/assert';\nimport {VERSION} from '../version';\nimport {NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR} from '../view/provider_flags';\n\nimport {assertComponentType} from './assert';\nimport {getComponentDef} from './definition';\nimport {diPublicInInjector, getOrCreateNodeInjectorForNode, NodeInjector} from './di';\nimport {throwProviderNotFoundError} from './errors_di';\nimport {registerPostOrderHooks} from './hooks';\nimport {reportUnknownPropertyError} from './instructions/element_validation';\nimport {addToViewTree, CLEAN_PROMISE, createLView, createTView, getOrCreateTComponentView, getOrCreateTNode, initTNodeFlags, instantiateRootComponent, invokeHostBindingsInCreationMode, locateHostElement, markAsComponentHost, markDirtyIfOnPush, registerHostBindingOpCodes, renderView, setInputsForProperty} from './instructions/shared';\nimport {ComponentDef, RenderFlags} from './interfaces/definition';\nimport {PropertyAliasValue, TContainerNode, TElementContainerNode, TElementNode, TNode, TNodeType} from './interfaces/node';\nimport {PlayerHandler} from './interfaces/player';\nimport {Renderer, RendererFactory} from './interfaces/renderer';\nimport {RElement, RNode} from './interfaces/renderer_dom';\nimport {CONTEXT, HEADER_OFFSET, LView, LViewFlags, RootContext, RootContextFlags, TVIEW, TViewType} from './interfaces/view';\nimport {MATH_ML_NAMESPACE, SVG_NAMESPACE} from './namespaces';\nimport {createElementNode, writeDirectClass, writeDirectStyle} from './node_manipulation';\nimport {extractAttrsAndClassesFromSelector, stringifyCSSSelectorList} from './node_selector_matcher';\nimport {enterView, getCurrentTNode, getLView, leaveView, setSelectedIndex} from './state';\nimport {computeStaticStyling} from './styling/static_styling';\nimport {setUpAttributes} from './util/attrs_utils';\nimport {defaultScheduler} from './util/misc_utils';\nimport {stringifyForError} from './util/stringify_utils';\nimport {getRootContext} from './util/view_traversal_utils';\nimport {getTNode} from './util/view_utils';\nimport {RootViewRef, ViewRef} from './view_ref';\n\nexport class ComponentFactoryResolver extends viewEngine_ComponentFactoryResolver {\n  /**\n   * @param ngModule The NgModuleRef to which all resolved factories are bound.\n   */\n  constructor(private ngModule?: viewEngine_NgModuleRef<any>) {\n    super();\n  }\n\n  override resolveComponentFactory<T>(component: Type<T>): viewEngine_ComponentFactory<T> {\n    ngDevMode && assertComponentType(component);\n    const componentDef = getComponentDef(component)!;\n    return new ComponentFactory(componentDef, this.ngModule);\n  }\n}\n\nfunction toRefArray(map: {[key: string]: string}): {propName: string; templateName: string;}[] {\n  const array: {propName: string; templateName: string;}[] = [];\n  for (let nonMinified in map) {\n    if (map.hasOwnProperty(nonMinified)) {\n      const minified = map[nonMinified];\n      array.push({propName: minified, templateName: nonMinified});\n    }\n  }\n  return array;\n}\n\nfunction getNamespace(elementName: string): string|null {\n  const name = elementName.toLowerCase();\n  return name === 'svg' ? SVG_NAMESPACE : (name === 'math' ? MATH_ML_NAMESPACE : null);\n}\n\n/**\n * Injector that looks up a value using a specific injector, before falling back to the module\n * injector. Used primarily when creating components or embedded views dynamically.\n */\nclass ChainedInjector implements Injector {\n  constructor(private injector: Injector, private parentInjector: Injector) {}\n\n  get<T>(token: ProviderToken<T>, notFoundValue?: T, flags?: InjectFlags): T {\n    const value = this.injector.get<T|typeof NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR>(\n        token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR, flags);\n\n    if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR ||\n        notFoundValue === (NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR as unknown as T)) {\n      // Return the value from the root element injector when\n      // - it provides it\n      //   (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)\n      // - the module injector should not be checked\n      //   (notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)\n      return value as T;\n    }\n\n    return this.parentInjector.get(token, notFoundValue, flags);\n  }\n}\n\n/**\n * Render3 implementation of {@link viewEngine_ComponentFactory}.\n */\nexport class ComponentFactory<T> extends viewEngine_ComponentFactory<T> {\n  override selector: string;\n  override componentType: Type<any>;\n  override ngContentSelectors: string[];\n  isBoundToModule: boolean;\n\n  override get inputs(): {propName: string; templateName: string;}[] {\n    return toRefArray(this.componentDef.inputs);\n  }\n\n  override get outputs(): {propName: string; templateName: string;}[] {\n    return toRefArray(this.componentDef.outputs);\n  }\n\n  /**\n   * @param componentDef The component definition.\n   * @param ngModule The NgModuleRef to which the factory is bound.\n   */\n  constructor(\n      private componentDef: ComponentDef<any>, private ngModule?: viewEngine_NgModuleRef<any>) {\n    super();\n    this.componentType = componentDef.type;\n    this.selector = stringifyCSSSelectorList(componentDef.selectors);\n    this.ngContentSelectors =\n        componentDef.ngContentSelectors ? componentDef.ngContentSelectors : [];\n    this.isBoundToModule = !!ngModule;\n  }\n\n  override create(\n      injector: Injector, projectableNodes?: any[][]|undefined, rootSelectorOrNode?: any,\n      environmentInjector?: viewEngine_NgModuleRef<any>|EnvironmentInjector|\n      undefined): AbstractComponentRef<T> {\n    environmentInjector = environmentInjector || this.ngModule;\n\n    let realEnvironmentInjector = environmentInjector instanceof EnvironmentInjector ?\n        environmentInjector :\n        environmentInjector?.injector;\n\n    if (realEnvironmentInjector && this.componentDef.getStandaloneInjector !== null) {\n      realEnvironmentInjector = this.componentDef.getStandaloneInjector(realEnvironmentInjector) ||\n          realEnvironmentInjector;\n    }\n\n    const rootViewInjector =\n        realEnvironmentInjector ? new ChainedInjector(injector, realEnvironmentInjector) : injector;\n\n    const rendererFactory = rootViewInjector.get(RendererFactory2, null);\n    if (rendererFactory === null) {\n      throw new RuntimeError(\n          RuntimeErrorCode.RENDERER_NOT_FOUND,\n          ngDevMode &&\n              'Angular was not able to inject a renderer (RendererFactory2). ' +\n                  'Likely this is due to a broken DI hierarchy. ' +\n                  'Make sure that any injector used to create this component has a correct parent.');\n    }\n    const sanitizer = rootViewInjector.get(Sanitizer, null);\n\n    const hostRenderer = rendererFactory.createRenderer(null, this.componentDef);\n    // Determine a tag name used for creating host elements when this component is created\n    // dynamically. Default to 'div' if this component did not specify any tag name in its selector.\n    const elementName = this.componentDef.selectors[0][0] as string || 'div';\n    const hostRNode = rootSelectorOrNode ?\n        locateHostElement(hostRenderer, rootSelectorOrNode, this.componentDef.encapsulation) :\n        createElementNode(\n            rendererFactory.createRenderer(null, this.componentDef), elementName,\n            getNamespace(elementName));\n\n    const rootFlags = this.componentDef.onPush ? LViewFlags.Dirty | LViewFlags.IsRoot :\n                                                 LViewFlags.CheckAlways | LViewFlags.IsRoot;\n    const rootContext = createRootContext();\n\n    // Create the root view. Uses empty TView and ContentTemplate.\n    const rootTView = createTView(TViewType.Root, null, null, 1, 0, null, null, null, null, null);\n    const rootLView = createLView(\n        null, rootTView, rootContext, rootFlags, null, null, rendererFactory, hostRenderer,\n        sanitizer, rootViewInjector, null);\n\n    // rootView is the parent when bootstrapping\n    // TODO(misko): it looks like we are entering view here but we don't really need to as\n    // `renderView` does that. However as the code is written it is needed because\n    // `createRootComponentView` and `createRootComponent` both read global state. Fixing those\n    // issues would allow us to drop this.\n    enterView(rootLView);\n\n    let component: T;\n    let tElementNode: TElementNode;\n\n    try {\n      const componentView = createRootComponentView(\n          hostRNode, this.componentDef, rootLView, rendererFactory, hostRenderer);\n      if (hostRNode) {\n        if (rootSelectorOrNode) {\n          setUpAttributes(hostRenderer, hostRNode, ['ng-version', VERSION.full]);\n        } else {\n          // If host element is created as a part of this function call (i.e. `rootSelectorOrNode`\n          // is not defined), also apply attributes and classes extracted from component selector.\n          // Extract attributes and classes from the first selector only to match VE behavior.\n          const {attrs, classes} =\n              extractAttrsAndClassesFromSelector(this.componentDef.selectors[0]);\n          if (attrs) {\n            setUpAttributes(hostRenderer, hostRNode, attrs);\n          }\n          if (classes && classes.length > 0) {\n            writeDirectClass(hostRenderer, hostRNode, classes.join(' '));\n          }\n        }\n      }\n\n      tElementNode = getTNode(rootTView, HEADER_OFFSET) as TElementNode;\n\n      if (projectableNodes !== undefined) {\n        const projection: (TNode|RNode[]|null)[] = tElementNode.projection = [];\n        for (let i = 0; i < this.ngContentSelectors.length; i++) {\n          const nodesforSlot = projectableNodes[i];\n          // Projectable nodes can be passed as array of arrays or an array of iterables (ngUpgrade\n          // case). Here we do normalize passed data structure to be an array of arrays to avoid\n          // complex checks down the line.\n          // We also normalize the length of the passed in projectable nodes (to match the number of\n          // <ng-container> slots defined by a component).\n          projection.push(nodesforSlot != null ? Array.from(nodesforSlot) : null);\n        }\n      }\n\n      // TODO: should LifecycleHooksFeature and other host features be generated by the compiler and\n      // executed here?\n      // Angular 5 reference: https://stackblitz.com/edit/lifecycle-hooks-vcref\n      component = createRootComponent(\n          componentView, this.componentDef, rootLView, rootContext, [LifecycleHooksFeature]);\n      renderView(rootTView, rootLView, null);\n    } finally {\n      leaveView();\n    }\n\n    return new ComponentRef(\n        this.componentType, component, createElementRef(tElementNode, rootLView), rootLView,\n        tElementNode);\n  }\n}\n\nconst componentFactoryResolver: ComponentFactoryResolver = new ComponentFactoryResolver();\n\n/**\n * Creates a ComponentFactoryResolver and stores it on the injector. Or, if the\n * ComponentFactoryResolver\n * already exists, retrieves the existing ComponentFactoryResolver.\n *\n * @returns The ComponentFactoryResolver instance to use\n */\nexport function injectComponentFactoryResolver(): viewEngine_ComponentFactoryResolver {\n  return componentFactoryResolver;\n}\n\n/**\n * Represents an instance of a Component created via a {@link ComponentFactory}.\n *\n * `ComponentRef` provides access to the Component Instance as well other objects related to this\n * Component Instance and allows you to destroy the Component Instance via the {@link #destroy}\n * method.\n *\n */\nexport class ComponentRef<T> extends AbstractComponentRef<T> {\n  override instance: T;\n  override hostView: ViewRef<T>;\n  override changeDetectorRef: ViewEngine_ChangeDetectorRef;\n  override componentType: Type<T>;\n\n  constructor(\n      componentType: Type<T>, instance: T, public location: viewEngine_ElementRef,\n      private _rootLView: LView,\n      private _tNode: TElementNode|TContainerNode|TElementContainerNode) {\n    super();\n    this.instance = instance;\n    this.hostView = this.changeDetectorRef = new RootViewRef<T>(_rootLView);\n    this.componentType = componentType;\n  }\n\n  override setInput(name: string, value: unknown): void {\n    const inputData = this._tNode.inputs;\n    let dataValue: PropertyAliasValue|undefined;\n    if (inputData !== null && (dataValue = inputData[name])) {\n      const lView = this._rootLView;\n      setInputsForProperty(lView[TVIEW], lView, dataValue, name, value);\n      markDirtyIfOnPush(lView, this._tNode.index);\n    } else {\n      if (ngDevMode) {\n        const cmpNameForError = stringifyForError(this.componentType);\n        let message =\n            `Can't set value of the '${name}' input on the '${cmpNameForError}' component. `;\n        message += `Make sure that the '${\n            name}' property is annotated with @Input() or a mapped @Input('${name}') exists.`;\n        reportUnknownPropertyError(message);\n      }\n    }\n  }\n\n  override get injector(): Injector {\n    return new NodeInjector(this._tNode, this._rootLView);\n  }\n\n  override destroy(): void {\n    this.hostView.destroy();\n  }\n\n  override onDestroy(callback: () => void): void {\n    this.hostView.onDestroy(callback);\n  }\n}\n\n\n\n/** Options that control how the component should be bootstrapped. */\nexport interface CreateComponentOptions {\n  /** Which renderer factory to use. */\n  rendererFactory?: RendererFactory;\n\n  /** A custom sanitizer instance */\n  sanitizer?: Sanitizer;\n\n  /** A custom animation player handler */\n  playerHandler?: PlayerHandler;\n\n  /**\n   * Host element on which the component will be bootstrapped. If not specified,\n   * the component definition's `tag` is used to query the existing DOM for the\n   * element to bootstrap.\n   */\n  host?: RElement|string;\n\n  /** Module injector for the component. If unspecified, the injector will be NULL_INJECTOR. */\n  injector?: Injector;\n\n  /**\n   * List of features to be applied to the created component. Features are simply\n   * functions that decorate a component with a certain behavior.\n   *\n   * Typically, the features in this list are features that cannot be added to the\n   * other features list in the component definition because they rely on other factors.\n   *\n   * Example: `LifecycleHooksFeature` is a function that adds lifecycle hook capabilities\n   * to root components in a tree-shakable way. It cannot be added to the component\n   * features list because there's no way of knowing when the component will be used as\n   * a root component.\n   */\n  hostFeatures?: HostFeature[];\n\n  /**\n   * A function which is used to schedule change detection work in the future.\n   *\n   * When marking components as dirty, it is necessary to schedule the work of\n   * change detection in the future. This is done to coalesce multiple\n   * {@link markDirty} calls into a single changed detection processing.\n   *\n   * The default value of the scheduler is the `requestAnimationFrame` function.\n   *\n   * It is also useful to override this function for testing purposes.\n   */\n  scheduler?: (work: () => void) => void;\n}\n\n/** See CreateComponentOptions.hostFeatures */\ntype HostFeature = (<T>(component: T, componentDef: ComponentDef<T>) => void);\n\n// TODO: A hack to not pull in the NullInjector from @angular/core.\nexport const NULL_INJECTOR: Injector = {\n  get: (token: any, notFoundValue?: any) => {\n    throwProviderNotFoundError(token, 'NullInjector');\n  }\n};\n\n/**\n * Creates the root component view and the root component node.\n *\n * @param rNode Render host element.\n * @param def ComponentDef\n * @param rootView The parent view where the host node is stored\n * @param rendererFactory Factory to be used for creating child renderers.\n * @param hostRenderer The current renderer\n * @param sanitizer The sanitizer, if provided\n *\n * @returns Component view created\n */\nexport function createRootComponentView(\n    rNode: RElement|null, def: ComponentDef<any>, rootView: LView, rendererFactory: RendererFactory,\n    hostRenderer: Renderer, sanitizer?: Sanitizer|null): LView {\n  const tView = rootView[TVIEW];\n  const index = HEADER_OFFSET;\n  ngDevMode && assertIndexInRange(rootView, index);\n  rootView[index] = rNode;\n  // '#host' is added here as we don't know the real host DOM name (we don't want to read it) and at\n  // the same time we want to communicate the debug `TNode` that this is a special `TNode`\n  // representing a host element.\n  const tNode: TElementNode = getOrCreateTNode(tView, index, TNodeType.Element, '#host', null);\n  const mergedAttrs = tNode.mergedAttrs = def.hostAttrs;\n  if (mergedAttrs !== null) {\n    computeStaticStyling(tNode, mergedAttrs, true);\n    if (rNode !== null) {\n      setUpAttributes(hostRenderer, rNode, mergedAttrs);\n      if (tNode.classes !== null) {\n        writeDirectClass(hostRenderer, rNode, tNode.classes);\n      }\n      if (tNode.styles !== null) {\n        writeDirectStyle(hostRenderer, rNode, tNode.styles);\n      }\n    }\n  }\n\n  const viewRenderer = rendererFactory.createRenderer(rNode, def);\n  const componentView = createLView(\n      rootView, getOrCreateTComponentView(def), null,\n      def.onPush ? LViewFlags.Dirty : LViewFlags.CheckAlways, rootView[index], tNode,\n      rendererFactory, viewRenderer, sanitizer || null, null, null);\n\n  if (tView.firstCreatePass) {\n    diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, rootView), tView, def.type);\n    markAsComponentHost(tView, tNode);\n    initTNodeFlags(tNode, rootView.length, 1);\n  }\n\n  addToViewTree(rootView, componentView);\n\n  // Store component view at node index, with node as the HOST\n  return rootView[index] = componentView;\n}\n\n/**\n * Creates a root component and sets it up with features and host bindings.Shared by\n * renderComponent() and ViewContainerRef.createComponent().\n */\nexport function createRootComponent<T>(\n    componentView: LView, componentDef: ComponentDef<T>, rootLView: LView, rootContext: RootContext,\n    hostFeatures: HostFeature[]|null): any {\n  const tView = rootLView[TVIEW];\n  // Create directive instance with factory() and store at next index in viewData\n  const component = instantiateRootComponent(tView, rootLView, componentDef);\n\n  rootContext.components.push(component);\n  componentView[CONTEXT] = component;\n\n  if (hostFeatures !== null) {\n    for (const feature of hostFeatures) {\n      feature(component, componentDef);\n    }\n  }\n\n  // We want to generate an empty QueryList for root content queries for backwards\n  // compatibility with ViewEngine.\n  if (componentDef.contentQueries) {\n    const tNode = getCurrentTNode()!;\n    ngDevMode && assertDefined(tNode, 'TNode expected');\n    componentDef.contentQueries(RenderFlags.Create, component, tNode.directiveStart);\n  }\n\n  const rootTNode = getCurrentTNode()!;\n  ngDevMode && assertDefined(rootTNode, 'tNode should have been already created');\n  if (tView.firstCreatePass &&\n      (componentDef.hostBindings !== null || componentDef.hostAttrs !== null)) {\n    setSelectedIndex(rootTNode.index);\n\n    const rootTView = rootLView[TVIEW];\n    registerHostBindingOpCodes(\n        rootTView, rootTNode, rootLView, rootTNode.directiveStart, rootTNode.directiveEnd,\n        componentDef);\n\n    invokeHostBindingsInCreationMode(componentDef, component);\n  }\n  return component;\n}\n\n\nexport function createRootContext(\n    scheduler?: (workFn: () => void) => void, playerHandler?: PlayerHandler|null): RootContext {\n  return {\n    components: [],\n    scheduler: scheduler || defaultScheduler,\n    clean: CLEAN_PROMISE,\n    playerHandler: playerHandler || null,\n    flags: RootContextFlags.Empty\n  };\n}\n\n/**\n * Used to enable lifecycle hooks on the root component.\n *\n * Include this feature when calling `renderComponent` if the root component\n * you are rendering has lifecycle hooks defined. Otherwise, the hooks won't\n * be called properly.\n *\n * Example:\n *\n * ```\n * renderComponent(AppComponent, {hostFeatures: [LifecycleHooksFeature]});\n * ```\n */\nexport function LifecycleHooksFeature(): void {\n  const tNode = getCurrentTNode()!;\n  ngDevMode && assertDefined(tNode, 'TNode is required');\n  registerPostOrderHooks(getLView()[TVIEW], tNode);\n}\n\n/**\n * Wait on component until it is rendered.\n *\n * This function returns a `Promise` which is resolved when the component's\n * change detection is executed. This is determined by finding the scheduler\n * associated with the `component`'s render tree and waiting until the scheduler\n * flushes. If nothing is scheduled, the function returns a resolved promise.\n *\n * Example:\n * ```\n * await whenRendered(myComponent);\n * ```\n *\n * @param component Component to wait upon\n * @returns Promise which resolves when the component is rendered.\n */\nexport function whenRendered(component: any): Promise<null> {\n  return getRootContext(component).clean;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {RuntimeError, RuntimeErrorCode} from '../../errors';\nimport {Type, Writable} from '../../interface/type';\nimport {EMPTY_ARRAY, EMPTY_OBJ} from '../../util/empty';\nimport {fillProperties} from '../../util/property';\nimport {ComponentDef, ContentQueriesFunction, DirectiveDef, DirectiveDefFeature, HostBindingsFunction, RenderFlags, ViewQueriesFunction} from '../interfaces/definition';\nimport {TAttributes} from '../interfaces/node';\nimport {isComponentDef} from '../interfaces/type_checks';\nimport {mergeHostAttrs} from '../util/attrs_utils';\nimport {stringifyForError} from '../util/stringify_utils';\n\nexport function getSuperType(type: Type<any>): Type<any>&\n    {ɵcmp?: ComponentDef<any>, ɵdir?: DirectiveDef<any>} {\n  return Object.getPrototypeOf(type.prototype).constructor;\n}\n\ntype WritableDef = Writable<DirectiveDef<any>|ComponentDef<any>>;\n\n/**\n * Merges the definition from a super class to a sub class.\n * @param definition The definition that is a SubClass of another directive of component\n *\n * @codeGenApi\n */\nexport function ɵɵInheritDefinitionFeature(definition: DirectiveDef<any>|ComponentDef<any>): void {\n  let superType = getSuperType(definition.type);\n  let shouldInheritFields = true;\n  const inheritanceChain: WritableDef[] = [definition];\n\n  while (superType) {\n    let superDef: DirectiveDef<any>|ComponentDef<any>|undefined = undefined;\n    if (isComponentDef(definition)) {\n      // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n      superDef = superType.ɵcmp || superType.ɵdir;\n    } else {\n      if (superType.ɵcmp) {\n        throw new RuntimeError(\n            RuntimeErrorCode.INVALID_INHERITANCE,\n            ngDevMode &&\n                `Directives cannot inherit Components. Directive ${\n                    stringifyForError(definition.type)} is attempting to extend component ${\n                    stringifyForError(superType)}`);\n      }\n      // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n      superDef = superType.ɵdir;\n    }\n\n    if (superDef) {\n      if (shouldInheritFields) {\n        inheritanceChain.push(superDef);\n        // Some fields in the definition may be empty, if there were no values to put in them that\n        // would've justified object creation. Unwrap them if necessary.\n        const writeableDef = definition as WritableDef;\n        writeableDef.inputs = maybeUnwrapEmpty(definition.inputs);\n        writeableDef.declaredInputs = maybeUnwrapEmpty(definition.declaredInputs);\n        writeableDef.outputs = maybeUnwrapEmpty(definition.outputs);\n\n        // Merge hostBindings\n        const superHostBindings = superDef.hostBindings;\n        superHostBindings && inheritHostBindings(definition, superHostBindings);\n\n        // Merge queries\n        const superViewQuery = superDef.viewQuery;\n        const superContentQueries = superDef.contentQueries;\n        superViewQuery && inheritViewQuery(definition, superViewQuery);\n        superContentQueries && inheritContentQueries(definition, superContentQueries);\n\n        // Merge inputs and outputs\n        fillProperties(definition.inputs, superDef.inputs);\n        fillProperties(definition.declaredInputs, superDef.declaredInputs);\n        fillProperties(definition.outputs, superDef.outputs);\n\n        // Merge animations metadata.\n        // If `superDef` is a Component, the `data` field is present (defaults to an empty object).\n        if (isComponentDef(superDef) && superDef.data.animation) {\n          // If super def is a Component, the `definition` is also a Component, since Directives can\n          // not inherit Components (we throw an error above and cannot reach this code).\n          const defData = (definition as ComponentDef<any>).data;\n          defData.animation = (defData.animation || []).concat(superDef.data.animation);\n        }\n      }\n\n      // Run parent features\n      const features = superDef.features;\n      if (features) {\n        for (let i = 0; i < features.length; i++) {\n          const feature = features[i];\n          if (feature && feature.ngInherit) {\n            (feature as DirectiveDefFeature)(definition);\n          }\n          // If `InheritDefinitionFeature` is a part of the current `superDef`, it means that this\n          // def already has all the necessary information inherited from its super class(es), so we\n          // can stop merging fields from super classes. However we need to iterate through the\n          // prototype chain to look for classes that might contain other \"features\" (like\n          // NgOnChanges), which we should invoke for the original `definition`. We set the\n          // `shouldInheritFields` flag to indicate that, essentially skipping fields inheritance\n          // logic and only invoking functions from the \"features\" list.\n          if (feature === ɵɵInheritDefinitionFeature) {\n            shouldInheritFields = false;\n          }\n        }\n      }\n    }\n\n    superType = Object.getPrototypeOf(superType);\n  }\n  mergeHostAttrsAcrossInheritance(inheritanceChain);\n}\n\n/**\n * Merge the `hostAttrs` and `hostVars` from the inherited parent to the base class.\n *\n * @param inheritanceChain A list of `WritableDefs` starting at the top most type and listing\n * sub-types in order. For each type take the `hostAttrs` and `hostVars` and merge it with the child\n * type.\n */\nfunction mergeHostAttrsAcrossInheritance(inheritanceChain: WritableDef[]) {\n  let hostVars: number = 0;\n  let hostAttrs: TAttributes|null = null;\n  // We process the inheritance order from the base to the leaves here.\n  for (let i = inheritanceChain.length - 1; i >= 0; i--) {\n    const def = inheritanceChain[i];\n    // For each `hostVars`, we need to add the superclass amount.\n    def.hostVars = (hostVars += def.hostVars);\n    // for each `hostAttrs` we need to merge it with superclass.\n    def.hostAttrs =\n        mergeHostAttrs(def.hostAttrs, hostAttrs = mergeHostAttrs(hostAttrs, def.hostAttrs));\n  }\n}\n\nfunction maybeUnwrapEmpty<T>(value: T[]): T[];\nfunction maybeUnwrapEmpty<T>(value: T): T;\nfunction maybeUnwrapEmpty(value: any): any {\n  if (value === EMPTY_OBJ) {\n    return {};\n  } else if (value === EMPTY_ARRAY) {\n    return [];\n  } else {\n    return value;\n  }\n}\n\nfunction inheritViewQuery(definition: WritableDef, superViewQuery: ViewQueriesFunction<any>) {\n  const prevViewQuery = definition.viewQuery;\n  if (prevViewQuery) {\n    definition.viewQuery = (rf, ctx) => {\n      superViewQuery(rf, ctx);\n      prevViewQuery(rf, ctx);\n    };\n  } else {\n    definition.viewQuery = superViewQuery;\n  }\n}\n\nfunction inheritContentQueries(\n    definition: WritableDef, superContentQueries: ContentQueriesFunction<any>) {\n  const prevContentQueries = definition.contentQueries;\n  if (prevContentQueries) {\n    definition.contentQueries = (rf, ctx, directiveIndex) => {\n      superContentQueries(rf, ctx, directiveIndex);\n      prevContentQueries(rf, ctx, directiveIndex);\n    };\n  } else {\n    definition.contentQueries = superContentQueries;\n  }\n}\n\nfunction inheritHostBindings(\n    definition: WritableDef, superHostBindings: HostBindingsFunction<any>) {\n  const prevHostBindings = definition.hostBindings;\n  if (prevHostBindings) {\n    definition.hostBindings = (rf: RenderFlags, ctx: any) => {\n      superHostBindings(rf, ctx);\n      prevHostBindings(rf, ctx);\n    };\n  } else {\n    definition.hostBindings = superHostBindings;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ComponentDef, DirectiveDef} from '../interfaces/definition';\nimport {isComponentDef} from '../interfaces/type_checks';\n\nimport {getSuperType} from './inherit_definition_feature';\n\n/**\n * Fields which exist on either directive or component definitions, and need to be copied from\n * parent to child classes by the `ɵɵCopyDefinitionFeature`.\n */\nconst COPY_DIRECTIVE_FIELDS: (keyof DirectiveDef<unknown>)[] = [\n  // The child class should use the providers of its parent.\n  'providersResolver',\n\n  // Not listed here are any fields which are handled by the `ɵɵInheritDefinitionFeature`, such\n  // as inputs, outputs, and host binding functions.\n];\n\n/**\n * Fields which exist only on component definitions, and need to be copied from parent to child\n * classes by the `ɵɵCopyDefinitionFeature`.\n *\n * The type here allows any field of `ComponentDef` which is not also a property of `DirectiveDef`,\n * since those should go in `COPY_DIRECTIVE_FIELDS` above.\n */\nconst COPY_COMPONENT_FIELDS: Exclude<keyof ComponentDef<unknown>, keyof DirectiveDef<unknown>>[] = [\n  // The child class should use the template function of its parent, including all template\n  // semantics.\n  'template',\n  'decls',\n  'consts',\n  'vars',\n  'onPush',\n  'ngContentSelectors',\n\n  // The child class should use the CSS styles of its parent, including all styling semantics.\n  'styles',\n  'encapsulation',\n\n  // The child class should be checked by the runtime in the same way as its parent.\n  'schemas',\n];\n\n/**\n * Copies the fields not handled by the `ɵɵInheritDefinitionFeature` from the supertype of a\n * definition.\n *\n * This exists primarily to support ngcc migration of an existing View Engine pattern, where an\n * entire decorator is inherited from a parent to a child class. When ngcc detects this case, it\n * generates a skeleton definition on the child class, and applies this feature.\n *\n * The `ɵɵCopyDefinitionFeature` then copies any needed fields from the parent class' definition,\n * including things like the component template function.\n *\n * @param definition The definition of a child class which inherits from a parent class with its\n * own definition.\n *\n * @codeGenApi\n */\nexport function ɵɵCopyDefinitionFeature(definition: DirectiveDef<any>|ComponentDef<any>): void {\n  let superType = getSuperType(definition.type)!;\n\n  let superDef: DirectiveDef<any>|ComponentDef<any>|undefined = undefined;\n  if (isComponentDef(definition)) {\n    // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n    superDef = superType.ɵcmp!;\n  } else {\n    // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n    superDef = superType.ɵdir!;\n  }\n\n  // Needed because `definition` fields are readonly.\n  const defAny = (definition as any);\n\n  // Copy over any fields that apply to either directives or components.\n  for (const field of COPY_DIRECTIVE_FIELDS) {\n    defAny[field] = superDef[field];\n  }\n\n  if (isComponentDef(superDef)) {\n    // Copy over any component-specific fields.\n    for (const field of COPY_COMPONENT_FIELDS) {\n      defAny[field] = superDef[field];\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {global as _global} from './global';\n\n// When Symbol.iterator doesn't exist, retrieves the key used in es6-shim\ndeclare const Symbol: any;\nlet _symbolIterator: any = null;\nexport function getSymbolIterator(): string|symbol {\n  if (!_symbolIterator) {\n    const Symbol = _global['Symbol'];\n    if (Symbol && Symbol.iterator) {\n      _symbolIterator = Symbol.iterator;\n    } else {\n      // es6-shim specific logic\n      const keys = Object.getOwnPropertyNames(Map.prototype);\n      for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        if (key !== 'entries' && key !== 'size' &&\n            (Map as any).prototype[key] === Map.prototype['entries']) {\n          _symbolIterator = key;\n        }\n      }\n    }\n  }\n  return _symbolIterator;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getSymbolIterator} from './symbol';\n\n\nexport function isIterable(obj: any): obj is Iterable<any> {\n  return obj !== null && typeof obj === 'object' && (obj as any)[getSymbolIterator()] !== undefined;\n}\n\nexport function isListLikeIterable(obj: any): boolean {\n  if (!isJsObject(obj)) return false;\n  return Array.isArray(obj) ||\n      (!(obj instanceof Map) &&      // JS Map are iterables but return entries as [k, v]\n       getSymbolIterator() in obj);  // JS Iterable have a Symbol.iterator prop\n}\n\nexport function areIterablesEqual(\n    a: any, b: any, comparator: (a: any, b: any) => boolean): boolean {\n  const iterator1 = a[getSymbolIterator()]();\n  const iterator2 = b[getSymbolIterator()]();\n\n  while (true) {\n    const item1 = iterator1.next();\n    const item2 = iterator2.next();\n    if (item1.done && item2.done) return true;\n    if (item1.done || item2.done) return false;\n    if (!comparator(item1.value, item2.value)) return false;\n  }\n}\n\nexport function iterateListLike(obj: any, fn: (p: any) => any) {\n  if (Array.isArray(obj)) {\n    for (let i = 0; i < obj.length; i++) {\n      fn(obj[i]);\n    }\n  } else {\n    const iterator = obj[getSymbolIterator()]();\n    let item: any;\n    while (!((item = iterator.next()).done)) {\n      fn(item.value);\n    }\n  }\n}\n\nexport function isJsObject(o: any): boolean {\n  return o !== null && (typeof o === 'function' || typeof o === 'object');\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {areIterablesEqual, isListLikeIterable} from './iterable';\n\nexport function devModeEqual(a: any, b: any): boolean {\n  const isListLikeIterableA = isListLikeIterable(a);\n  const isListLikeIterableB = isListLikeIterable(b);\n  if (isListLikeIterableA && isListLikeIterableB) {\n    return areIterablesEqual(a, b, devModeEqual);\n  } else {\n    const isAObject = a && (typeof a === 'object' || typeof a === 'function');\n    const isBObject = b && (typeof b === 'object' || typeof b === 'function');\n    if (!isListLikeIterableA && isAObject && !isListLikeIterableB && isBObject) {\n      return true;\n    } else {\n      return Object.is(a, b);\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertIndexInRange, assertLessThan, assertNotSame} from '../util/assert';\nimport {devModeEqual} from '../util/comparison';\n\nimport {getExpressionChangedErrorDetails, throwErrorIfNoChangesMode} from './errors';\nimport {LView} from './interfaces/view';\nimport {isInCheckNoChangesMode} from './state';\nimport {NO_CHANGE} from './tokens';\n\n\n// TODO(misko): consider inlining\n/** Updates binding and returns the value. */\nexport function updateBinding(lView: LView, bindingIndex: number, value: any): any {\n  return lView[bindingIndex] = value;\n}\n\n\n/** Gets the current binding value. */\nexport function getBinding(lView: LView, bindingIndex: number): any {\n  ngDevMode && assertIndexInRange(lView, bindingIndex);\n  ngDevMode &&\n      assertNotSame(lView[bindingIndex], NO_CHANGE, 'Stored value should never be NO_CHANGE.');\n  return lView[bindingIndex];\n}\n\n/**\n * Updates binding if changed, then returns whether it was updated.\n *\n * This function also checks the `CheckNoChangesMode` and throws if changes are made.\n * Some changes (Objects/iterables) during `CheckNoChangesMode` are exempt to comply with VE\n * behavior.\n *\n * @param lView current `LView`\n * @param bindingIndex The binding in the `LView` to check\n * @param value New value to check against `lView[bindingIndex]`\n * @returns `true` if the bindings has changed. (Throws if binding has changed during\n *          `CheckNoChangesMode`)\n */\nexport function bindingUpdated(lView: LView, bindingIndex: number, value: any): boolean {\n  ngDevMode && assertNotSame(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');\n  ngDevMode &&\n      assertLessThan(bindingIndex, lView.length, `Slot should have been initialized to NO_CHANGE`);\n  const oldValue = lView[bindingIndex];\n\n  if (Object.is(oldValue, value)) {\n    return false;\n  } else {\n    if (ngDevMode && isInCheckNoChangesMode()) {\n      // View engine didn't report undefined values as changed on the first checkNoChanges pass\n      // (before the change detection was run).\n      const oldValueToCompare = oldValue !== NO_CHANGE ? oldValue : undefined;\n      if (!devModeEqual(oldValueToCompare, value)) {\n        const details =\n            getExpressionChangedErrorDetails(lView, bindingIndex, oldValueToCompare, value);\n        throwErrorIfNoChangesMode(\n            oldValue === NO_CHANGE, details.oldValue, details.newValue, details.propName);\n      }\n      // There was a change, but the `devModeEqual` decided that the change is exempt from an error.\n      // For this reason we exit as if no change. The early exit is needed to prevent the changed\n      // value to be written into `LView` (If we would write the new value that we would not see it\n      // as change on next CD.)\n      return false;\n    }\n    lView[bindingIndex] = value;\n    return true;\n  }\n}\n\n/** Updates 2 bindings if changed, then returns whether either was updated. */\nexport function bindingUpdated2(lView: LView, bindingIndex: number, exp1: any, exp2: any): boolean {\n  const different = bindingUpdated(lView, bindingIndex, exp1);\n  return bindingUpdated(lView, bindingIndex + 1, exp2) || different;\n}\n\n/** Updates 3 bindings if changed, then returns whether any was updated. */\nexport function bindingUpdated3(\n    lView: LView, bindingIndex: number, exp1: any, exp2: any, exp3: any): boolean {\n  const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);\n  return bindingUpdated(lView, bindingIndex + 2, exp3) || different;\n}\n\n/** Updates 4 bindings if changed, then returns whether any was updated. */\nexport function bindingUpdated4(\n    lView: LView, bindingIndex: number, exp1: any, exp2: any, exp3: any, exp4: any): boolean {\n  const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);\n  return bindingUpdated2(lView, bindingIndex + 2, exp3, exp4) || different;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {bindingUpdated} from '../bindings';\nimport {SanitizerFn} from '../interfaces/sanitization';\nimport {getLView, getSelectedTNode, getTView, nextBindingIndex} from '../state';\nimport {elementAttributeInternal, storePropertyBindingMetadata} from './shared';\n\n\n\n/**\n * Updates the value of or removes a bound attribute on an Element.\n *\n * Used in the case of `[attr.title]=\"value\"`\n *\n * @param name name The name of the attribute.\n * @param value value The attribute is removed when value is `null` or `undefined`.\n *                  Otherwise the attribute value is set to the stringified value.\n * @param sanitizer An optional function used to sanitize the value.\n * @param namespace Optional namespace to use when setting the attribute.\n *\n * @codeGenApi\n */\nexport function ɵɵattribute(\n    name: string, value: any, sanitizer?: SanitizerFn|null,\n    namespace?: string): typeof ɵɵattribute {\n  const lView = getLView();\n  const bindingIndex = nextBindingIndex();\n  if (bindingUpdated(lView, bindingIndex, value)) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, 'attr.' + name, bindingIndex);\n  }\n  return ɵɵattribute;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertEqual, assertLessThan} from '../../util/assert';\nimport {bindingUpdated, bindingUpdated2, bindingUpdated3, bindingUpdated4} from '../bindings';\nimport {LView} from '../interfaces/view';\nimport {getBindingIndex, incrementBindingIndex, nextBindingIndex, setBindingIndex} from '../state';\nimport {NO_CHANGE} from '../tokens';\nimport {renderStringify} from '../util/stringify_utils';\n\n\n\n/**\n * Create interpolation bindings with a variable number of expressions.\n *\n * If there are 1 to 8 expressions `interpolation1()` to `interpolation8()` should be used instead.\n * Those are faster because there is no need to create an array of expressions and iterate over it.\n *\n * `values`:\n * - has static text at even indexes,\n * - has evaluated expressions at odd indexes.\n *\n * Returns the concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nexport function interpolationV(lView: LView, values: any[]): string|NO_CHANGE {\n  ngDevMode && assertLessThan(2, values.length, 'should have at least 3 values');\n  ngDevMode && assertEqual(values.length % 2, 1, 'should have an odd number of values');\n  let isBindingUpdated = false;\n  let bindingIndex = getBindingIndex();\n\n  for (let i = 1; i < values.length; i += 2) {\n    // Check if bindings (odd indexes) have changed\n    isBindingUpdated = bindingUpdated(lView, bindingIndex++, values[i]) || isBindingUpdated;\n  }\n  setBindingIndex(bindingIndex);\n\n  if (!isBindingUpdated) {\n    return NO_CHANGE;\n  }\n\n  // Build the updated content\n  let content = values[0];\n  for (let i = 1; i < values.length; i += 2) {\n    content += renderStringify(values[i]) + values[i + 1];\n  }\n\n  return content;\n}\n\n/**\n * Creates an interpolation binding with 1 expression.\n *\n * @param prefix static value used for concatenation only.\n * @param v0 value checked for change.\n * @param suffix static value used for concatenation only.\n */\nexport function interpolation1(lView: LView, prefix: string, v0: any, suffix: string): string|\n    NO_CHANGE {\n  const different = bindingUpdated(lView, nextBindingIndex(), v0);\n  return different ? prefix + renderStringify(v0) + suffix : NO_CHANGE;\n}\n\n/**\n * Creates an interpolation binding with 2 expressions.\n */\nexport function interpolation2(\n    lView: LView, prefix: string, v0: any, i0: string, v1: any, suffix: string): string|NO_CHANGE {\n  const bindingIndex = getBindingIndex();\n  const different = bindingUpdated2(lView, bindingIndex, v0, v1);\n  incrementBindingIndex(2);\n\n  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + suffix : NO_CHANGE;\n}\n\n/**\n * Creates an interpolation binding with 3 expressions.\n */\nexport function interpolation3(\n    lView: LView, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any,\n    suffix: string): string|NO_CHANGE {\n  const bindingIndex = getBindingIndex();\n  const different = bindingUpdated3(lView, bindingIndex, v0, v1, v2);\n  incrementBindingIndex(3);\n\n  return different ?\n      prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + suffix :\n      NO_CHANGE;\n}\n\n/**\n * Create an interpolation binding with 4 expressions.\n */\nexport function interpolation4(\n    lView: LView, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, suffix: string): string|NO_CHANGE {\n  const bindingIndex = getBindingIndex();\n  const different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  incrementBindingIndex(4);\n\n  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 +\n          renderStringify(v2) + i2 + renderStringify(v3) + suffix :\n                     NO_CHANGE;\n}\n\n/**\n * Creates an interpolation binding with 5 expressions.\n */\nexport function interpolation5(\n    lView: LView, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, suffix: string): string|NO_CHANGE {\n  const bindingIndex = getBindingIndex();\n  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  different = bindingUpdated(lView, bindingIndex + 4, v4) || different;\n  incrementBindingIndex(5);\n\n  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 +\n          renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + suffix :\n                     NO_CHANGE;\n}\n\n/**\n * Creates an interpolation binding with 6 expressions.\n */\nexport function interpolation6(\n    lView: LView, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, suffix: string): string|NO_CHANGE {\n  const bindingIndex = getBindingIndex();\n  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  different = bindingUpdated2(lView, bindingIndex + 4, v4, v5) || different;\n  incrementBindingIndex(6);\n\n  return different ?\n      prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 +\n          renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + suffix :\n      NO_CHANGE;\n}\n\n/**\n * Creates an interpolation binding with 7 expressions.\n */\nexport function interpolation7(\n    lView: LView, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string): string|\n    NO_CHANGE {\n  const bindingIndex = getBindingIndex();\n  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  different = bindingUpdated3(lView, bindingIndex + 4, v4, v5, v6) || different;\n  incrementBindingIndex(7);\n\n  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 +\n          renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 +\n          renderStringify(v5) + i5 + renderStringify(v6) + suffix :\n                     NO_CHANGE;\n}\n\n/**\n * Creates an interpolation binding with 8 expressions.\n */\nexport function interpolation8(\n    lView: LView, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string): string|NO_CHANGE {\n  const bindingIndex = getBindingIndex();\n  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  different = bindingUpdated4(lView, bindingIndex + 4, v4, v5, v6, v7) || different;\n  incrementBindingIndex(8);\n\n  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 +\n          renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 +\n          renderStringify(v5) + i5 + renderStringify(v6) + i6 + renderStringify(v7) + suffix :\n                     NO_CHANGE;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {SanitizerFn} from '../interfaces/sanitization';\nimport {getBindingIndex, getLView, getSelectedTNode, getTView} from '../state';\nimport {NO_CHANGE} from '../tokens';\nimport {interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV} from './interpolation';\nimport {elementAttributeInternal, storePropertyBindingMetadata} from './shared';\n\n\n\n/**\n *\n * Update an interpolated attribute on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate1('title', 'prefix', v0, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵattributeInterpolate1(\n    attrName: string, prefix: string, v0: any, suffix: string, sanitizer?: SanitizerFn,\n    namespace?: string): typeof ɵɵattributeInterpolate1 {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 1, prefix, suffix);\n  }\n  return ɵɵattributeInterpolate1;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate2('title', 'prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵattributeInterpolate2(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, suffix: string,\n    sanitizer?: SanitizerFn, namespace?: string): typeof ɵɵattributeInterpolate2 {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 2, prefix, i0, suffix);\n  }\n  return ɵɵattributeInterpolate2;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate3(\n * 'title', 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵattributeInterpolate3(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any,\n    suffix: string, sanitizer?: SanitizerFn, namespace?: string): typeof ɵɵattributeInterpolate3 {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 3, prefix, i0, i1,\n            suffix);\n  }\n  return ɵɵattributeInterpolate3;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate4(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵattributeInterpolate4(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, suffix: string, sanitizer?: SanitizerFn,\n    namespace?: string): typeof ɵɵattributeInterpolate4 {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 4, prefix, i0, i1, i2,\n            suffix);\n  }\n  return ɵɵattributeInterpolate4;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate5(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵattributeInterpolate5(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, suffix: string, sanitizer?: SanitizerFn,\n    namespace?: string): typeof ɵɵattributeInterpolate5 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 5, prefix, i0, i1, i2,\n            i3, suffix);\n  }\n  return ɵɵattributeInterpolate5;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate6(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵattributeInterpolate6(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, suffix: string, sanitizer?: SanitizerFn,\n    namespace?: string): typeof ɵɵattributeInterpolate6 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 6, prefix, i0, i1, i2,\n            i3, i4, suffix);\n  }\n  return ɵɵattributeInterpolate6;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate7(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵattributeInterpolate7(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string,\n    sanitizer?: SanitizerFn, namespace?: string): typeof ɵɵattributeInterpolate7 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 7, prefix, i0, i1, i2,\n            i3, i4, i5, suffix);\n  }\n  return ɵɵattributeInterpolate7;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate8(\n *  'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵattributeInterpolate8(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string, sanitizer?: SanitizerFn, namespace?: string): typeof ɵɵattributeInterpolate8 {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(\n      lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 8, prefix, i0, i1, i2,\n            i3, i4, i5, i6, suffix);\n  }\n  return ɵɵattributeInterpolate8;\n}\n\n/**\n * Update an interpolated attribute on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolateV(\n *  'title', ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *\n * @param attrName The name of the attribute to update.\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵattributeInterpolateV(\n    attrName: string, values: any[], sanitizer?: SanitizerFn,\n    namespace?: string): typeof ɵɵattributeInterpolateV {\n  const lView = getLView();\n  const interpolated = interpolationV(lView, values);\n  if (interpolated !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolated, sanitizer, namespace);\n    if (ngDevMode) {\n      const interpolationInBetween = [values[0]];  // prefix\n      for (let i = 2; i < values.length; i += 2) {\n        interpolationInBetween.push(values[i]);\n      }\n      storePropertyBindingMetadata(\n          getTView().data, tNode, 'attr.' + attrName,\n          getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);\n    }\n  }\n  return ɵɵattributeInterpolateV;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDefined} from '../../util/assert';\nimport {getComponentViewByInstance} from '../context_discovery';\nimport {CONTEXT, RootContext, RootContextFlags, TVIEW} from '../interfaces/view';\nimport {getRootView} from '../util/view_traversal_utils';\n\nimport {detectChangesInternal, markViewDirty, scheduleTick, tickRootContext} from './shared';\n\n/**\n * Synchronously perform change detection on a component (and possibly its sub-components).\n *\n * This function triggers change detection in a synchronous way on a component.\n *\n * @param component The component which the change detection should be performed on.\n */\nexport function detectChanges(component: {}): void {\n  const view = getComponentViewByInstance(component);\n  detectChangesInternal(view[TVIEW], view, component);\n}\n\n/**\n * Marks the component as dirty (needing change detection). Marking a component dirty will\n * schedule a change detection on it at some point in the future.\n *\n * Marking an already dirty component as dirty won't do anything. Only one outstanding change\n * detection can be scheduled per component tree.\n *\n * @param component Component to mark as dirty.\n */\nexport function markDirty(component: {}): void {\n  ngDevMode && assertDefined(component, 'component');\n  const rootView = markViewDirty(getComponentViewByInstance(component))!;\n\n  ngDevMode && assertDefined(rootView[CONTEXT], 'rootContext should be defined');\n  scheduleTick(rootView[CONTEXT] as RootContext, RootContextFlags.DetectChanges);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {assertFirstCreatePass} from '../assert';\nimport {attachPatchData} from '../context_discovery';\nimport {registerPostOrderHooks} from '../hooks';\nimport {ComponentTemplate} from '../interfaces/definition';\nimport {LocalRefExtractor, TAttributes, TContainerNode, TNodeType} from '../interfaces/node';\nimport {isDirectiveHost} from '../interfaces/type_checks';\nimport {HEADER_OFFSET, LView, RENDERER, TView, TViewType} from '../interfaces/view';\nimport {appendChild} from '../node_manipulation';\nimport {getLView, getTView, setCurrentTNode} from '../state';\nimport {getConstant} from '../util/view_utils';\nimport {addToViewTree, createDirectivesInstances, createLContainer, createTView, getOrCreateTNode, resolveDirectives, saveResolvedLocalsInData} from './shared';\n\n\n\nfunction templateFirstCreatePass(\n    index: number, tView: TView, lView: LView, templateFn: ComponentTemplate<any>|null,\n    decls: number, vars: number, tagName?: string|null, attrsIndex?: number|null,\n    localRefsIndex?: number|null): TContainerNode {\n  ngDevMode && assertFirstCreatePass(tView);\n  ngDevMode && ngDevMode.firstCreatePass++;\n  const tViewConsts = tView.consts;\n  // TODO(pk): refactor getOrCreateTNode to have the \"create\" only version\n  const tNode = getOrCreateTNode(\n      tView, index, TNodeType.Container, tagName || null,\n      getConstant<TAttributes>(tViewConsts, attrsIndex));\n\n  resolveDirectives(tView, lView, tNode, getConstant<string[]>(tViewConsts, localRefsIndex));\n  registerPostOrderHooks(tView, tNode);\n\n  const embeddedTView = tNode.tViews = createTView(\n      TViewType.Embedded, tNode, templateFn, decls, vars, tView.directiveRegistry,\n      tView.pipeRegistry, null, tView.schemas, tViewConsts);\n\n  if (tView.queries !== null) {\n    tView.queries.template(tView, tNode);\n    embeddedTView.queries = tView.queries.embeddedTView(tNode);\n  }\n\n  return tNode;\n}\n\n/**\n * Creates an LContainer for an ng-template (dynamically-inserted view), e.g.\n *\n * <ng-template #foo>\n *    <div></div>\n * </ng-template>\n *\n * @param index The index of the container in the data array\n * @param templateFn Inline template\n * @param decls The number of nodes, local refs, and pipes for this template\n * @param vars The number of bindings for this template\n * @param tagName The name of the container element, if applicable\n * @param attrsIndex Index of template attributes in the `consts` array.\n * @param localRefs Index of the local references in the `consts` array.\n * @param localRefExtractor A function which extracts local-refs values from the template.\n *        Defaults to the current element associated with the local-ref.\n *\n * @codeGenApi\n */\nexport function ɵɵtemplate(\n    index: number, templateFn: ComponentTemplate<any>|null, decls: number, vars: number,\n    tagName?: string|null, attrsIndex?: number|null, localRefsIndex?: number|null,\n    localRefExtractor?: LocalRefExtractor) {\n  const lView = getLView();\n  const tView = getTView();\n  const adjustedIndex = index + HEADER_OFFSET;\n\n  const tNode = tView.firstCreatePass ? templateFirstCreatePass(\n                                            adjustedIndex, tView, lView, templateFn, decls, vars,\n                                            tagName, attrsIndex, localRefsIndex) :\n                                        tView.data[adjustedIndex] as TContainerNode;\n  setCurrentTNode(tNode, false);\n\n  const comment = lView[RENDERER].createComment(ngDevMode ? 'container' : '');\n  appendChild(tView, lView, comment, tNode);\n  attachPatchData(comment, lView);\n\n  addToViewTree(lView, lView[adjustedIndex] = createLContainer(comment, lView, comment, tNode));\n\n  if (isDirectiveHost(tNode)) {\n    createDirectivesInstances(tView, lView, tNode);\n  }\n\n  if (localRefsIndex != null) {\n    saveResolvedLocalsInData(lView, tNode, localRefExtractor);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {HEADER_OFFSET, LView, TView} from '../interfaces/view';\nimport {getContextLView} from '../state';\nimport {load} from '../util/view_utils';\n\n\n/** Store a value in the `data` at a given `index`. */\nexport function store<T>(tView: TView, lView: LView, index: number, value: T): void {\n  // We don't store any static data for local variables, so the first time\n  // we see the template, we should store as null to avoid a sparse array\n  if (index >= tView.data.length) {\n    tView.data[index] = null;\n    tView.blueprint[index] = null;\n  }\n  lView[index] = value;\n}\n\n/**\n * Retrieves a local reference from the current contextViewData.\n *\n * If the reference to retrieve is in a parent view, this instruction is used in conjunction\n * with a nextContext() call, which walks up the tree and updates the contextViewData instance.\n *\n * @param index The index of the local ref in contextViewData.\n *\n * @codeGenApi\n */\nexport function ɵɵreference<T>(index: number) {\n  const contextLView = getContextLView();\n  return load<T>(contextLView, HEADER_OFFSET + index);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {bindingUpdated} from '../bindings';\nimport {TNode} from '../interfaces/node';\nimport {SanitizerFn} from '../interfaces/sanitization';\nimport {LView, RENDERER, TView} from '../interfaces/view';\nimport {getLView, getSelectedTNode, getTView, nextBindingIndex} from '../state';\n\nimport {elementPropertyInternal, setInputsForProperty, storePropertyBindingMetadata} from './shared';\n\n\n/**\n * Update a property on a selected element.\n *\n * Operates on the element selected by index via the {@link select} instruction.\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled\n *\n * @param propName Name of property. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n * @returns This function returns itself so that it may be chained\n * (e.g. `property('name', ctx.name)('title', ctx.title)`)\n *\n * @codeGenApi\n */\nexport function ɵɵproperty<T>(\n    propName: string, value: T, sanitizer?: SanitizerFn|null): typeof ɵɵproperty {\n  const lView = getLView();\n  const bindingIndex = nextBindingIndex();\n  if (bindingUpdated(lView, bindingIndex, value)) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, false);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);\n  }\n  return ɵɵproperty;\n}\n\n/**\n * Given `<div style=\"...\" my-dir>` and `MyDir` with `@Input('style')` we need to write to\n * directive input.\n */\nexport function setDirectiveInputsWhichShadowsStyling(\n    tView: TView, tNode: TNode, lView: LView, value: any, isClassBased: boolean) {\n  const inputs = tNode.inputs!;\n  const property = isClassBased ? 'class' : 'style';\n  // We support both 'class' and `className` hence the fallback.\n  setInputsForProperty(tView, lView, inputs[property], property, value);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDefined, assertEqual, assertIndexInRange} from '../../util/assert';\nimport {assertFirstCreatePass, assertHasParent} from '../assert';\nimport {attachPatchData} from '../context_discovery';\nimport {registerPostOrderHooks} from '../hooks';\nimport {hasClassInput, hasStyleInput, TAttributes, TElementNode, TNodeFlags, TNodeType} from '../interfaces/node';\nimport {RElement} from '../interfaces/renderer_dom';\nimport {isContentQueryHost, isDirectiveHost} from '../interfaces/type_checks';\nimport {HEADER_OFFSET, LView, RENDERER, TView} from '../interfaces/view';\nimport {assertTNodeType} from '../node_assert';\nimport {appendChild, createElementNode, writeDirectClass, writeDirectStyle} from '../node_manipulation';\nimport {decreaseElementDepthCount, getBindingIndex, getCurrentTNode, getElementDepthCount, getLView, getNamespace, getTView, increaseElementDepthCount, isCurrentTNodeParent, setCurrentTNode, setCurrentTNodeAsNotParent} from '../state';\nimport {computeStaticStyling} from '../styling/static_styling';\nimport {setUpAttributes} from '../util/attrs_utils';\nimport {getConstant} from '../util/view_utils';\n\nimport {validateElementIsKnown} from './element_validation';\nimport {setDirectiveInputsWhichShadowsStyling} from './property';\nimport {createDirectivesInstances, executeContentQueries, getOrCreateTNode, resolveDirectives, saveResolvedLocalsInData} from './shared';\n\n\nfunction elementStartFirstCreatePass(\n    index: number, tView: TView, lView: LView, native: RElement, name: string,\n    attrsIndex?: number|null, localRefsIndex?: number): TElementNode {\n  ngDevMode && assertFirstCreatePass(tView);\n  ngDevMode && ngDevMode.firstCreatePass++;\n\n  const tViewConsts = tView.consts;\n  const attrs = getConstant<TAttributes>(tViewConsts, attrsIndex);\n  const tNode = getOrCreateTNode(tView, index, TNodeType.Element, name, attrs);\n\n  const hasDirectives =\n      resolveDirectives(tView, lView, tNode, getConstant<string[]>(tViewConsts, localRefsIndex));\n  if (ngDevMode) {\n    validateElementIsKnown(native, lView, tNode.value, tView.schemas, hasDirectives);\n  }\n\n  if (tNode.attrs !== null) {\n    computeStaticStyling(tNode, tNode.attrs, false);\n  }\n\n  if (tNode.mergedAttrs !== null) {\n    computeStaticStyling(tNode, tNode.mergedAttrs, true);\n  }\n\n  if (tView.queries !== null) {\n    tView.queries.elementStart(tView, tNode);\n  }\n\n  return tNode;\n}\n\n/**\n * Create DOM element. The instruction must later be followed by `elementEnd()` call.\n *\n * @param index Index of the element in the LView array\n * @param name Name of the DOM Node\n * @param attrsIndex Index of the element's attributes in the `consts` array.\n * @param localRefsIndex Index of the element's local references in the `consts` array.\n * @returns This function returns itself so that it may be chained.\n *\n * Attributes and localRefs are passed as an array of strings where elements with an even index\n * hold an attribute name and elements with an odd index hold an attribute value, ex.:\n * ['id', 'warning5', 'class', 'alert']\n *\n * @codeGenApi\n */\nexport function ɵɵelementStart(\n    index: number, name: string, attrsIndex?: number|null,\n    localRefsIndex?: number): typeof ɵɵelementStart {\n  const lView = getLView();\n  const tView = getTView();\n  const adjustedIndex = HEADER_OFFSET + index;\n\n  ngDevMode &&\n      assertEqual(\n          getBindingIndex(), tView.bindingStartIndex,\n          'elements should be created before any bindings');\n  ngDevMode && assertIndexInRange(lView, adjustedIndex);\n\n  const renderer = lView[RENDERER];\n  const native = lView[adjustedIndex] = createElementNode(renderer, name, getNamespace());\n  const tNode = tView.firstCreatePass ?\n      elementStartFirstCreatePass(\n          adjustedIndex, tView, lView, native, name, attrsIndex, localRefsIndex) :\n      tView.data[adjustedIndex] as TElementNode;\n  setCurrentTNode(tNode, true);\n\n  const mergedAttrs = tNode.mergedAttrs;\n  if (mergedAttrs !== null) {\n    setUpAttributes(renderer, native, mergedAttrs);\n  }\n  const classes = tNode.classes;\n  if (classes !== null) {\n    writeDirectClass(renderer, native, classes);\n  }\n  const styles = tNode.styles;\n  if (styles !== null) {\n    writeDirectStyle(renderer, native, styles);\n  }\n\n  if ((tNode.flags & TNodeFlags.isDetached) !== TNodeFlags.isDetached) {\n    // In the i18n case, the translation may have removed this element, so only add it if it is not\n    // detached. See `TNodeType.Placeholder` and `LFrame.inI18n` for more context.\n    appendChild(tView, lView, native, tNode);\n  }\n\n  // any immediate children of a component or template container must be pre-emptively\n  // monkey-patched with the component view data so that the element can be inspected\n  // later on using any element discovery utility methods (see `element_discovery.ts`)\n  if (getElementDepthCount() === 0) {\n    attachPatchData(native, lView);\n  }\n  increaseElementDepthCount();\n\n\n  if (isDirectiveHost(tNode)) {\n    createDirectivesInstances(tView, lView, tNode);\n    executeContentQueries(tView, tNode, lView);\n  }\n  if (localRefsIndex !== null) {\n    saveResolvedLocalsInData(lView, tNode);\n  }\n  return ɵɵelementStart;\n}\n\n/**\n * Mark the end of the element.\n * @returns This function returns itself so that it may be chained.\n *\n * @codeGenApi\n */\nexport function ɵɵelementEnd(): typeof ɵɵelementEnd {\n  let currentTNode = getCurrentTNode()!;\n  ngDevMode && assertDefined(currentTNode, 'No parent node to close.');\n  if (isCurrentTNodeParent()) {\n    setCurrentTNodeAsNotParent();\n  } else {\n    ngDevMode && assertHasParent(getCurrentTNode());\n    currentTNode = currentTNode.parent!;\n    setCurrentTNode(currentTNode, false);\n  }\n\n  const tNode = currentTNode;\n  ngDevMode && assertTNodeType(tNode, TNodeType.AnyRNode);\n\n\n  decreaseElementDepthCount();\n\n  const tView = getTView();\n  if (tView.firstCreatePass) {\n    registerPostOrderHooks(tView, currentTNode);\n    if (isContentQueryHost(currentTNode)) {\n      tView.queries!.elementEnd(currentTNode);\n    }\n  }\n\n  if (tNode.classesWithoutHost != null && hasClassInput(tNode)) {\n    setDirectiveInputsWhichShadowsStyling(tView, tNode, getLView(), tNode.classesWithoutHost, true);\n  }\n\n  if (tNode.stylesWithoutHost != null && hasStyleInput(tNode)) {\n    setDirectiveInputsWhichShadowsStyling(tView, tNode, getLView(), tNode.stylesWithoutHost, false);\n  }\n  return ɵɵelementEnd;\n}\n\n/**\n * Creates an empty element using {@link elementStart} and {@link elementEnd}\n *\n * @param index Index of the element in the data array\n * @param name Name of the DOM Node\n * @param attrsIndex Index of the element's attributes in the `consts` array.\n * @param localRefsIndex Index of the element's local references in the `consts` array.\n * @returns This function returns itself so that it may be chained.\n *\n * @codeGenApi\n */\nexport function ɵɵelement(\n    index: number, name: string, attrsIndex?: number|null,\n    localRefsIndex?: number): typeof ɵɵelement {\n  ɵɵelementStart(index, name, attrsIndex, localRefsIndex);\n  ɵɵelementEnd();\n  return ɵɵelement;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {assertEqual, assertIndexInRange} from '../../util/assert';\nimport {assertHasParent} from '../assert';\nimport {attachPatchData} from '../context_discovery';\nimport {registerPostOrderHooks} from '../hooks';\nimport {TAttributes, TElementContainerNode, TNodeType} from '../interfaces/node';\nimport {isContentQueryHost, isDirectiveHost} from '../interfaces/type_checks';\nimport {HEADER_OFFSET, LView, RENDERER, TView} from '../interfaces/view';\nimport {assertTNodeType} from '../node_assert';\nimport {appendChild} from '../node_manipulation';\nimport {getBindingIndex, getCurrentTNode, getLView, getTView, isCurrentTNodeParent, setCurrentTNode, setCurrentTNodeAsNotParent} from '../state';\nimport {computeStaticStyling} from '../styling/static_styling';\nimport {getConstant} from '../util/view_utils';\n\nimport {createDirectivesInstances, executeContentQueries, getOrCreateTNode, resolveDirectives, saveResolvedLocalsInData} from './shared';\n\nfunction elementContainerStartFirstCreatePass(\n    index: number, tView: TView, lView: LView, attrsIndex?: number|null,\n    localRefsIndex?: number): TElementContainerNode {\n  ngDevMode && ngDevMode.firstCreatePass++;\n\n  const tViewConsts = tView.consts;\n  const attrs = getConstant<TAttributes>(tViewConsts, attrsIndex);\n  const tNode = getOrCreateTNode(tView, index, TNodeType.ElementContainer, 'ng-container', attrs);\n\n  // While ng-container doesn't necessarily support styling, we use the style context to identify\n  // and execute directives on the ng-container.\n  if (attrs !== null) {\n    computeStaticStyling(tNode, attrs, true);\n  }\n\n  const localRefs = getConstant<string[]>(tViewConsts, localRefsIndex);\n  resolveDirectives(tView, lView, tNode, localRefs);\n\n  if (tView.queries !== null) {\n    tView.queries.elementStart(tView, tNode);\n  }\n\n  return tNode;\n}\n\n/**\n * Creates a logical container for other nodes (<ng-container>) backed by a comment node in the DOM.\n * The instruction must later be followed by `elementContainerEnd()` call.\n *\n * @param index Index of the element in the LView array\n * @param attrsIndex Index of the container attributes in the `consts` array.\n * @param localRefsIndex Index of the container's local references in the `consts` array.\n * @returns This function returns itself so that it may be chained.\n *\n * Even if this instruction accepts a set of attributes no actual attribute values are propagated to\n * the DOM (as a comment node can't have attributes). Attributes are here only for directive\n * matching purposes and setting initial inputs of directives.\n *\n * @codeGenApi\n */\nexport function ɵɵelementContainerStart(\n    index: number, attrsIndex?: number|null,\n    localRefsIndex?: number): typeof ɵɵelementContainerStart {\n  const lView = getLView();\n  const tView = getTView();\n  const adjustedIndex = index + HEADER_OFFSET;\n\n  ngDevMode && assertIndexInRange(lView, adjustedIndex);\n  ngDevMode &&\n      assertEqual(\n          getBindingIndex(), tView.bindingStartIndex,\n          'element containers should be created before any bindings');\n\n  const tNode = tView.firstCreatePass ?\n      elementContainerStartFirstCreatePass(\n          adjustedIndex, tView, lView, attrsIndex, localRefsIndex) :\n      tView.data[adjustedIndex] as TElementContainerNode;\n  setCurrentTNode(tNode, true);\n\n  ngDevMode && ngDevMode.rendererCreateComment++;\n  const native = lView[adjustedIndex] =\n      lView[RENDERER].createComment(ngDevMode ? 'ng-container' : '');\n  appendChild(tView, lView, native, tNode);\n  attachPatchData(native, lView);\n\n  if (isDirectiveHost(tNode)) {\n    createDirectivesInstances(tView, lView, tNode);\n    executeContentQueries(tView, tNode, lView);\n  }\n\n  if (localRefsIndex != null) {\n    saveResolvedLocalsInData(lView, tNode);\n  }\n\n  return ɵɵelementContainerStart;\n}\n\n/**\n * Mark the end of the <ng-container>.\n * @returns This function returns itself so that it may be chained.\n *\n * @codeGenApi\n */\nexport function ɵɵelementContainerEnd(): typeof ɵɵelementContainerEnd {\n  let currentTNode = getCurrentTNode()!;\n  const tView = getTView();\n  if (isCurrentTNodeParent()) {\n    setCurrentTNodeAsNotParent();\n  } else {\n    ngDevMode && assertHasParent(currentTNode);\n    currentTNode = currentTNode.parent!;\n    setCurrentTNode(currentTNode, false);\n  }\n\n  ngDevMode && assertTNodeType(currentTNode, TNodeType.ElementContainer);\n\n  if (tView.firstCreatePass) {\n    registerPostOrderHooks(tView, currentTNode);\n    if (isContentQueryHost(currentTNode)) {\n      tView.queries!.elementEnd(currentTNode);\n    }\n  }\n  return ɵɵelementContainerEnd;\n}\n\n/**\n * Creates an empty logical container using {@link elementContainerStart}\n * and {@link elementContainerEnd}\n *\n * @param index Index of the element in the LView array\n * @param attrsIndex Index of the container attributes in the `consts` array.\n * @param localRefsIndex Index of the container's local references in the `consts` array.\n * @returns This function returns itself so that it may be chained.\n *\n * @codeGenApi\n */\nexport function ɵɵelementContainer(\n    index: number, attrsIndex?: number|null, localRefsIndex?: number): typeof ɵɵelementContainer {\n  ɵɵelementContainerStart(index, attrsIndex, localRefsIndex);\n  ɵɵelementContainerEnd();\n  return ɵɵelementContainer;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {OpaqueViewState} from '../interfaces/view';\nimport {getLView} from '../state';\n\n/**\n * Returns the current OpaqueViewState instance.\n *\n * Used in conjunction with the restoreView() instruction to save a snapshot\n * of the current view and restore it when listeners are invoked. This allows\n * walking the declaration view tree in listeners to get vars from parent views.\n *\n * @codeGenApi\n */\nexport function ɵɵgetCurrentView(): OpaqueViewState {\n  return getLView() as any as OpaqueViewState;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Observable, Subscribable} from 'rxjs';\n\n/**\n * Determine if the argument is shaped like a Promise\n */\nexport function isPromise<T = any>(obj: any): obj is Promise<T> {\n  // allow any Promise/A+ compliant thenable.\n  // It's up to the caller to ensure that obj.then conforms to the spec\n  return !!obj && typeof obj.then === 'function';\n}\n\n/**\n * Determine if the argument is a Subscribable\n */\nexport function isSubscribable(obj: any|Subscribable<any>): obj is Subscribable<any> {\n  return !!obj && typeof obj.subscribe === 'function';\n}\n\n/**\n * Determine if the argument is an Observable\n *\n * Strictly this tests that the `obj` is `Subscribable`, since `Observable`\n * types need additional methods, such as `lift()`. But it is adequate for our\n * needs since within the Angular framework code we only ever need to use the\n * `subscribe()` method, and RxJS has mechanisms to wrap `Subscribable` objects\n * into `Observable` as needed.\n */\nexport const isObservable =\n    isSubscribable as ((obj: any|Observable<any>) => obj is Observable<any>);\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {assertIndexInRange} from '../../util/assert';\nimport {isObservable} from '../../util/lang';\nimport {PropertyAliasValue, TNode, TNodeFlags, TNodeType} from '../interfaces/node';\nimport {GlobalTargetResolver, Renderer} from '../interfaces/renderer';\nimport {RElement} from '../interfaces/renderer_dom';\nimport {isDirectiveHost} from '../interfaces/type_checks';\nimport {CLEANUP, CONTEXT, LView, RENDERER, TView} from '../interfaces/view';\nimport {assertTNodeType} from '../node_assert';\nimport {profiler, ProfilerEvent} from '../profiler';\nimport {getCurrentDirectiveDef, getCurrentTNode, getLView, getTView} from '../state';\nimport {getComponentLViewByIndex, getNativeByTNode, unwrapRNode} from '../util/view_utils';\n\nimport {getOrCreateLViewCleanup, getOrCreateTViewCleanup, handleError, loadComponentRenderer, markViewDirty} from './shared';\n\n\n\n/**\n * Adds an event listener to the current node.\n *\n * If an output exists on one of the node's directives, it also subscribes to the output\n * and saves the subscription for later cleanup.\n *\n * @param eventName Name of the event\n * @param listenerFn The function to be called when event emits\n * @param useCapture Whether or not to use capture in event listener\n * @param eventTargetResolver Function that returns global target information in case this listener\n * should be attached to a global object like window, document or body\n *\n * @codeGenApi\n */\nexport function ɵɵlistener(\n    eventName: string, listenerFn: (e?: any) => any, useCapture?: boolean,\n    eventTargetResolver?: GlobalTargetResolver): typeof ɵɵlistener {\n  const lView = getLView<{}|null>();\n  const tView = getTView();\n  const tNode = getCurrentTNode()!;\n  listenerInternal(\n      tView, lView, lView[RENDERER], tNode, eventName, listenerFn, !!useCapture,\n      eventTargetResolver);\n  return ɵɵlistener;\n}\n\n/**\n * Registers a synthetic host listener (e.g. `(@foo.start)`) on a component or directive.\n *\n * This instruction is for compatibility purposes and is designed to ensure that a\n * synthetic host listener (e.g. `@HostListener('@foo.start')`) properly gets rendered\n * in the component's renderer. Normally all host listeners are evaluated with the\n * parent component's renderer, but, in the case of animation @triggers, they need\n * to be evaluated with the sub component's renderer (because that's where the\n * animation triggers are defined).\n *\n * Do not use this instruction as a replacement for `listener`. This instruction\n * only exists to ensure compatibility with the ViewEngine's host binding behavior.\n *\n * @param eventName Name of the event\n * @param listenerFn The function to be called when event emits\n * @param useCapture Whether or not to use capture in event listener\n * @param eventTargetResolver Function that returns global target information in case this listener\n * should be attached to a global object like window, document or body\n *\n * @codeGenApi\n */\nexport function ɵɵsyntheticHostListener(\n    eventName: string, listenerFn: (e?: any) => any): typeof ɵɵsyntheticHostListener {\n  const tNode = getCurrentTNode()!;\n  const lView = getLView<{}|null>();\n  const tView = getTView();\n  const currentDef = getCurrentDirectiveDef(tView.data);\n  const renderer = loadComponentRenderer(currentDef, tNode, lView);\n  listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn, false);\n  return ɵɵsyntheticHostListener;\n}\n\n/**\n * A utility function that checks if a given element has already an event handler registered for an\n * event with a specified name. The TView.cleanup data structure is used to find out which events\n * are registered for a given element.\n */\nfunction findExistingListener(\n    tView: TView, lView: LView, eventName: string, tNodeIdx: number): ((e?: any) => any)|null {\n  const tCleanup = tView.cleanup;\n  if (tCleanup != null) {\n    for (let i = 0; i < tCleanup.length - 1; i += 2) {\n      const cleanupEventName = tCleanup[i];\n      if (cleanupEventName === eventName && tCleanup[i + 1] === tNodeIdx) {\n        // We have found a matching event name on the same node but it might not have been\n        // registered yet, so we must explicitly verify entries in the LView cleanup data\n        // structures.\n        const lCleanup = lView[CLEANUP]!;\n        const listenerIdxInLCleanup = tCleanup[i + 2];\n        return lCleanup.length > listenerIdxInLCleanup ? lCleanup[listenerIdxInLCleanup] : null;\n      }\n      // TView.cleanup can have a mix of 4-elements entries (for event handler cleanups) or\n      // 2-element entries (for directive and queries destroy hooks). As such we can encounter\n      // blocks of 4 or 2 items in the tView.cleanup and this is why we iterate over 2 elements\n      // first and jump another 2 elements if we detect listeners cleanup (4 elements). Also check\n      // documentation of TView.cleanup for more details of this data structure layout.\n      if (typeof cleanupEventName === 'string') {\n        i += 2;\n      }\n    }\n  }\n  return null;\n}\n\nfunction listenerInternal(\n    tView: TView, lView: LView<{}|null>, renderer: Renderer, tNode: TNode, eventName: string,\n    listenerFn: (e?: any) => any, useCapture: boolean,\n    eventTargetResolver?: GlobalTargetResolver): void {\n  const isTNodeDirectiveHost = isDirectiveHost(tNode);\n  const firstCreatePass = tView.firstCreatePass;\n  const tCleanup: false|any[] = firstCreatePass && getOrCreateTViewCleanup(tView);\n  const context = lView[CONTEXT];\n\n  // When the ɵɵlistener instruction was generated and is executed we know that there is either a\n  // native listener or a directive output on this element. As such we we know that we will have to\n  // register a listener and store its cleanup function on LView.\n  const lCleanup = getOrCreateLViewCleanup(lView);\n\n  ngDevMode && assertTNodeType(tNode, TNodeType.AnyRNode | TNodeType.AnyContainer);\n\n  let processOutputs = true;\n\n  // Adding a native event listener is applicable when:\n  // - The corresponding TNode represents a DOM element.\n  // - The event target has a resolver (usually resulting in a global object,\n  //   such as `window` or `document`).\n  if ((tNode.type & TNodeType.AnyRNode) || eventTargetResolver) {\n    const native = getNativeByTNode(tNode, lView) as RElement;\n    const target = eventTargetResolver ? eventTargetResolver(native) : native;\n    const lCleanupIndex = lCleanup.length;\n    const idxOrTargetGetter = eventTargetResolver ?\n        (_lView: LView) => eventTargetResolver(unwrapRNode(_lView[tNode.index])) :\n        tNode.index;\n\n    // In order to match current behavior, native DOM event listeners must be added for all\n    // events (including outputs).\n\n    // There might be cases where multiple directives on the same element try to register an event\n    // handler function for the same event. In this situation we want to avoid registration of\n    // several native listeners as each registration would be intercepted by NgZone and\n    // trigger change detection. This would mean that a single user action would result in several\n    // change detections being invoked. To avoid this situation we want to have only one call to\n    // native handler registration (for the same element and same type of event).\n    //\n    // In order to have just one native event handler in presence of multiple handler functions,\n    // we just register a first handler function as a native event listener and then chain\n    // (coalesce) other handler functions on top of the first native handler function.\n    let existingListener = null;\n    // Please note that the coalescing described here doesn't happen for events specifying an\n    // alternative target (ex. (document:click)) - this is to keep backward compatibility with the\n    // view engine.\n    // Also, we don't have to search for existing listeners is there are no directives\n    // matching on a given node as we can't register multiple event handlers for the same event in\n    // a template (this would mean having duplicate attributes).\n    if (!eventTargetResolver && isTNodeDirectiveHost) {\n      existingListener = findExistingListener(tView, lView, eventName, tNode.index);\n    }\n    if (existingListener !== null) {\n      // Attach a new listener to coalesced listeners list, maintaining the order in which\n      // listeners are registered. For performance reasons, we keep a reference to the last\n      // listener in that list (in `__ngLastListenerFn__` field), so we can avoid going through\n      // the entire set each time we need to add a new listener.\n      const lastListenerFn = (<any>existingListener).__ngLastListenerFn__ || existingListener;\n      lastListenerFn.__ngNextListenerFn__ = listenerFn;\n      (<any>existingListener).__ngLastListenerFn__ = listenerFn;\n      processOutputs = false;\n    } else {\n      listenerFn = wrapListener(tNode, lView, context, listenerFn, false /** preventDefault */);\n      const cleanupFn = renderer.listen(target as RElement, eventName, listenerFn);\n      ngDevMode && ngDevMode.rendererAddEventListener++;\n\n      lCleanup.push(listenerFn, cleanupFn);\n      tCleanup && tCleanup.push(eventName, idxOrTargetGetter, lCleanupIndex, lCleanupIndex + 1);\n    }\n\n  } else {\n    // Even if there is no native listener to add, we still need to wrap the listener so that OnPush\n    // ancestors are marked dirty when an event occurs.\n    listenerFn = wrapListener(tNode, lView, context, listenerFn, false /** preventDefault */);\n  }\n\n  // subscribe to directive outputs\n  const outputs = tNode.outputs;\n  let props: PropertyAliasValue|undefined;\n  if (processOutputs && outputs !== null && (props = outputs[eventName])) {\n    const propsLength = props.length;\n    if (propsLength) {\n      for (let i = 0; i < propsLength; i += 2) {\n        const index = props[i] as number;\n        ngDevMode && assertIndexInRange(lView, index);\n        const minifiedName = props[i + 1];\n        const directiveInstance = lView[index];\n        const output = directiveInstance[minifiedName];\n\n        if (ngDevMode && !isObservable(output)) {\n          throw new Error(`@Output ${minifiedName} not initialized in '${\n              directiveInstance.constructor.name}'.`);\n        }\n\n        const subscription = output.subscribe(listenerFn);\n        const idx = lCleanup.length;\n        lCleanup.push(listenerFn, subscription);\n        tCleanup && tCleanup.push(eventName, tNode.index, idx, -(idx + 1));\n      }\n    }\n  }\n}\n\nfunction executeListenerWithErrorHandling(\n    lView: LView, context: {}|null, listenerFn: (e?: any) => any, e: any): boolean {\n  try {\n    profiler(ProfilerEvent.OutputStart, context, listenerFn);\n    // Only explicitly returning false from a listener should preventDefault\n    return listenerFn(e) !== false;\n  } catch (error) {\n    handleError(lView, error);\n    return false;\n  } finally {\n    profiler(ProfilerEvent.OutputEnd, context, listenerFn);\n  }\n}\n\n/**\n * Wraps an event listener with a function that marks ancestors dirty and prevents default behavior,\n * if applicable.\n *\n * @param tNode The TNode associated with this listener\n * @param lView The LView that contains this listener\n * @param listenerFn The listener function to call\n * @param wrapWithPreventDefault Whether or not to prevent default behavior\n * (the procedural renderer does this already, so in those cases, we should skip)\n */\nfunction wrapListener(\n    tNode: TNode, lView: LView<{}|null>, context: {}|null, listenerFn: (e?: any) => any,\n    wrapWithPreventDefault: boolean): EventListener {\n  // Note: we are performing most of the work in the listener function itself\n  // to optimize listener registration.\n  return function wrapListenerIn_markDirtyAndPreventDefault(e: any) {\n    // Ivy uses `Function` as a special token that allows us to unwrap the function\n    // so that it can be invoked programmatically by `DebugNode.triggerEventHandler`.\n    if (e === Function) {\n      return listenerFn;\n    }\n\n    // In order to be backwards compatible with View Engine, events on component host nodes\n    // must also mark the component view itself dirty (i.e. the view that it owns).\n    const startView = tNode.flags & TNodeFlags.isComponentHost ?\n        getComponentLViewByIndex(tNode.index, lView) :\n        lView;\n    markViewDirty(startView);\n\n    let result = executeListenerWithErrorHandling(lView, context, listenerFn, e);\n    // A just-invoked listener function might have coalesced listeners so we need to check for\n    // their presence and invoke as needed.\n    let nextListenerFn = (<any>wrapListenerIn_markDirtyAndPreventDefault).__ngNextListenerFn__;\n    while (nextListenerFn) {\n      // We should prevent default if any of the listeners explicitly return false\n      result = executeListenerWithErrorHandling(lView, context, nextListenerFn, e) && result;\n      nextListenerFn = (<any>nextListenerFn).__ngNextListenerFn__;\n    }\n\n    if (wrapWithPreventDefault && result === false) {\n      e.preventDefault();\n      // Necessary for legacy browsers that don't support preventDefault (e.g. IE)\n      e.returnValue = false;\n    }\n\n    return result;\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport {ɵɵnamespaceHTML, ɵɵnamespaceMathML, ɵɵnamespaceSVG} from '../state';\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {nextContextImpl} from '../state';\n\n/**\n * Retrieves a context at the level specified and saves it as the global, contextViewData.\n * Will get the next level up if level is not specified.\n *\n * This is used to save contexts of parent views so they can be bound in embedded views, or\n * in conjunction with reference() to bind a ref from a parent view.\n *\n * @param level The relative level of the view from which to grab context compared to contextVewData\n * @returns context\n *\n * @codeGenApi\n */\nexport function ɵɵnextContext<T = any>(level: number = 1): T {\n  return nextContextImpl(level);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {newArray} from '../../util/array_utils';\nimport {TAttributes, TElementNode, TNode, TNodeFlags, TNodeType} from '../interfaces/node';\nimport {ProjectionSlots} from '../interfaces/projection';\nimport {DECLARATION_COMPONENT_VIEW, HEADER_OFFSET, T_HOST} from '../interfaces/view';\nimport {applyProjection} from '../node_manipulation';\nimport {getProjectAsAttrValue, isNodeMatchingSelectorList, isSelectorInSelectorList} from '../node_selector_matcher';\nimport {getLView, getTView, setCurrentTNodeAsNotParent} from '../state';\nimport {getOrCreateTNode} from './shared';\n\n\n\n/**\n * Checks a given node against matching projection slots and returns the\n * determined slot index. Returns \"null\" if no slot matched the given node.\n *\n * This function takes into account the parsed ngProjectAs selector from the\n * node's attributes. If present, it will check whether the ngProjectAs selector\n * matches any of the projection slot selectors.\n */\nexport function matchingProjectionSlotIndex(tNode: TNode, projectionSlots: ProjectionSlots): number|\n    null {\n  let wildcardNgContentIndex = null;\n  const ngProjectAsAttrVal = getProjectAsAttrValue(tNode);\n  for (let i = 0; i < projectionSlots.length; i++) {\n    const slotValue = projectionSlots[i];\n    // The last wildcard projection slot should match all nodes which aren't matching\n    // any selector. This is necessary to be backwards compatible with view engine.\n    if (slotValue === '*') {\n      wildcardNgContentIndex = i;\n      continue;\n    }\n    // If we ran into an `ngProjectAs` attribute, we should match its parsed selector\n    // to the list of selectors, otherwise we fall back to matching against the node.\n    if (ngProjectAsAttrVal === null ?\n            isNodeMatchingSelectorList(tNode, slotValue, /* isProjectionMode */ true) :\n            isSelectorInSelectorList(ngProjectAsAttrVal, slotValue)) {\n      return i;  // first matching selector \"captures\" a given node\n    }\n  }\n  return wildcardNgContentIndex;\n}\n\n/**\n * Instruction to distribute projectable nodes among <ng-content> occurrences in a given template.\n * It takes all the selectors from the entire component's template and decides where\n * each projected node belongs (it re-distributes nodes among \"buckets\" where each \"bucket\" is\n * backed by a selector).\n *\n * This function requires CSS selectors to be provided in 2 forms: parsed (by a compiler) and text,\n * un-parsed form.\n *\n * The parsed form is needed for efficient matching of a node against a given CSS selector.\n * The un-parsed, textual form is needed for support of the ngProjectAs attribute.\n *\n * Having a CSS selector in 2 different formats is not ideal, but alternatives have even more\n * drawbacks:\n * - having only a textual form would require runtime parsing of CSS selectors;\n * - we can't have only a parsed as we can't re-construct textual form from it (as entered by a\n * template author).\n *\n * @param projectionSlots? A collection of projection slots. A projection slot can be based\n *        on a parsed CSS selectors or set to the wildcard selector (\"*\") in order to match\n *        all nodes which do not match any selector. If not specified, a single wildcard\n *        selector projection slot will be defined.\n *\n * @codeGenApi\n */\nexport function ɵɵprojectionDef(projectionSlots?: ProjectionSlots): void {\n  const componentNode = getLView()[DECLARATION_COMPONENT_VIEW][T_HOST] as TElementNode;\n\n  if (!componentNode.projection) {\n    // If no explicit projection slots are defined, fall back to a single\n    // projection slot with the wildcard selector.\n    const numProjectionSlots = projectionSlots ? projectionSlots.length : 1;\n    const projectionHeads: (TNode|null)[] = componentNode.projection =\n        newArray(numProjectionSlots, null! as TNode);\n    const tails: (TNode|null)[] = projectionHeads.slice();\n\n    let componentChild: TNode|null = componentNode.child;\n\n    while (componentChild !== null) {\n      const slotIndex =\n          projectionSlots ? matchingProjectionSlotIndex(componentChild, projectionSlots) : 0;\n\n      if (slotIndex !== null) {\n        if (tails[slotIndex]) {\n          tails[slotIndex]!.projectionNext = componentChild;\n        } else {\n          projectionHeads[slotIndex] = componentChild;\n        }\n        tails[slotIndex] = componentChild;\n      }\n\n      componentChild = componentChild.next;\n    }\n  }\n}\n\n\n/**\n * Inserts previously re-distributed projected nodes. This instruction must be preceded by a call\n * to the projectionDef instruction.\n *\n * @param nodeIndex\n * @param selectorIndex:\n *        - 0 when the selector is `*` (or unspecified as this is the default value),\n *        - 1 based index of the selector from the {@link projectionDef}\n *\n * @codeGenApi\n */\nexport function ɵɵprojection(\n    nodeIndex: number, selectorIndex: number = 0, attrs?: TAttributes): void {\n  const lView = getLView();\n  const tView = getTView();\n  const tProjectionNode =\n      getOrCreateTNode(tView, HEADER_OFFSET + nodeIndex, TNodeType.Projection, null, attrs || null);\n\n  // We can't use viewData[HOST_NODE] because projection nodes can be nested in embedded views.\n  if (tProjectionNode.projection === null) tProjectionNode.projection = selectorIndex;\n\n  // `<ng-content>` has no content\n  setCurrentTNodeAsNotParent();\n\n  if ((tProjectionNode.flags & TNodeFlags.isDetached) !== TNodeFlags.isDetached) {\n    // re-distribution of projectable nodes is stored on a component's view level\n    applyProjection(tView, lView, tProjectionNode);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {SanitizerFn} from '../interfaces/sanitization';\nimport {RENDERER} from '../interfaces/view';\nimport {getBindingIndex, getLView, getSelectedTNode, getTView} from '../state';\nimport {NO_CHANGE} from '../tokens';\n\nimport {interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV} from './interpolation';\nimport {elementPropertyInternal, storePropertyBindingMetadata} from './shared';\n\n\n/**\n *\n * Update an interpolated property on an element with a lone bound value\n *\n * Used when the value passed to a property has 1 interpolated value in it, an no additional text\n * surrounds that interpolated value:\n *\n * ```html\n * <div title=\"{{v0}}\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate('title', v0);\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵpropertyInterpolate(\n    propName: string, v0: any, sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolate {\n  ɵɵpropertyInterpolate1(propName, '', v0, '', sanitizer);\n  return ɵɵpropertyInterpolate;\n}\n\n\n/**\n *\n * Update an interpolated property on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate1('title', 'prefix', v0, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵpropertyInterpolate1(\n    propName: string, prefix: string, v0: any, suffix: string,\n    sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolate1 {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 1, prefix, suffix);\n  }\n  return ɵɵpropertyInterpolate1;\n}\n\n/**\n *\n * Update an interpolated property on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate2('title', 'prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵpropertyInterpolate2(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, suffix: string,\n    sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolate2 {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 2, prefix, i0, suffix);\n  }\n  return ɵɵpropertyInterpolate2;\n}\n\n/**\n *\n * Update an interpolated property on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate3(\n * 'title', 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵpropertyInterpolate3(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any,\n    suffix: string, sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolate3 {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 3, prefix, i0, i1, suffix);\n  }\n  return ɵɵpropertyInterpolate3;\n}\n\n/**\n *\n * Update an interpolated property on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate4(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵpropertyInterpolate4(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, suffix: string, sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolate4 {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 4, prefix, i0, i1, i2, suffix);\n  }\n  return ɵɵpropertyInterpolate4;\n}\n\n/**\n *\n * Update an interpolated property on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate5(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵpropertyInterpolate5(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, suffix: string,\n    sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolate5 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 5, prefix, i0, i1, i2, i3, suffix);\n  }\n  return ɵɵpropertyInterpolate5;\n}\n\n/**\n *\n * Update an interpolated property on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate6(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵpropertyInterpolate6(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, suffix: string,\n    sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolate6 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 6, prefix, i0, i1, i2, i3, i4, suffix);\n  }\n  return ɵɵpropertyInterpolate6;\n}\n\n/**\n *\n * Update an interpolated property on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate7(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵpropertyInterpolate7(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string,\n    sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolate7 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 7, prefix, i0, i1, i2, i3, i4, i5,\n            suffix);\n  }\n  return ɵɵpropertyInterpolate7;\n}\n\n/**\n *\n * Update an interpolated property on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate8(\n *  'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵpropertyInterpolate8(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string, sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolate8 {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(\n      lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 8, prefix, i0, i1, i2, i3, i4, i5, i6,\n            suffix);\n  }\n  return ɵɵpropertyInterpolate8;\n}\n\n/**\n * Update an interpolated property on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolateV(\n *  'title', ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update.\n * @param values The collection of values and the strings in between those values, beginning with a\n * string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵpropertyInterpolateV(\n    propName: string, values: any[], sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolateV {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    if (ngDevMode) {\n      const interpolationInBetween = [values[0]];  // prefix\n      for (let i = 2; i < values.length; i += 2) {\n        interpolationInBetween.push(values[i]);\n      }\n      storePropertyBindingMetadata(\n          tView.data, tNode, propName, getBindingIndex() - interpolationInBetween.length + 1,\n          ...interpolationInBetween);\n    }\n  }\n  return ɵɵpropertyInterpolateV;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {KeyValueArray, keyValueArrayIndexOf} from '../../util/array_utils';\nimport {assertEqual, assertIndexInRange, assertNotEqual} from '../../util/assert';\nimport {assertFirstUpdatePass} from '../assert';\nimport {TNode} from '../interfaces/node';\nimport {getTStylingRangeNext, getTStylingRangePrev, setTStylingRangeNext, setTStylingRangeNextDuplicate, setTStylingRangePrev, setTStylingRangePrevDuplicate, toTStylingRange, TStylingKey, TStylingKeyPrimitive, TStylingRange} from '../interfaces/styling';\nimport {TData} from '../interfaces/view';\nimport {getTView} from '../state';\n\n\n/**\n * NOTE: The word `styling` is used interchangeably as style or class styling.\n *\n * This file contains code to link styling instructions together so that they can be replayed in\n * priority order. The file exists because Ivy styling instruction execution order does not match\n * that of the priority order. The purpose of this code is to create a linked list so that the\n * instructions can be traversed in priority order when computing the styles.\n *\n * Assume we are dealing with the following code:\n * ```\n * @Component({\n *   template: `\n *     <my-cmp [style]=\" {color: '#001'} \"\n *             [style.color]=\" #002 \"\n *             dir-style-color-1\n *             dir-style-color-2> `\n * })\n * class ExampleComponent {\n *   static ngComp = ... {\n *     ...\n *     // Compiler ensures that `ɵɵstyleProp` is after `ɵɵstyleMap`\n *     ɵɵstyleMap({color: '#001'});\n *     ɵɵstyleProp('color', '#002');\n *     ...\n *   }\n * }\n *\n * @Directive({\n *   selector: `[dir-style-color-1]',\n * })\n * class Style1Directive {\n *   @HostBinding('style') style = {color: '#005'};\n *   @HostBinding('style.color') color = '#006';\n *\n *   static ngDir = ... {\n *     ...\n *     // Compiler ensures that `ɵɵstyleProp` is after `ɵɵstyleMap`\n *     ɵɵstyleMap({color: '#005'});\n *     ɵɵstyleProp('color', '#006');\n *     ...\n *   }\n * }\n *\n * @Directive({\n *   selector: `[dir-style-color-2]',\n * })\n * class Style2Directive {\n *   @HostBinding('style') style = {color: '#007'};\n *   @HostBinding('style.color') color = '#008';\n *\n *   static ngDir = ... {\n *     ...\n *     // Compiler ensures that `ɵɵstyleProp` is after `ɵɵstyleMap`\n *     ɵɵstyleMap({color: '#007'});\n *     ɵɵstyleProp('color', '#008');\n *     ...\n *   }\n * }\n *\n * @Directive({\n *   selector: `my-cmp',\n * })\n * class MyComponent {\n *   @HostBinding('style') style = {color: '#003'};\n *   @HostBinding('style.color') color = '#004';\n *\n *   static ngComp = ... {\n *     ...\n *     // Compiler ensures that `ɵɵstyleProp` is after `ɵɵstyleMap`\n *     ɵɵstyleMap({color: '#003'});\n *     ɵɵstyleProp('color', '#004');\n *     ...\n *   }\n * }\n * ```\n *\n * The Order of instruction execution is:\n *\n * NOTE: the comment binding location is for illustrative purposes only.\n *\n * ```\n * // Template: (ExampleComponent)\n *     ɵɵstyleMap({color: '#001'});   // Binding index: 10\n *     ɵɵstyleProp('color', '#002');  // Binding index: 12\n * // MyComponent\n *     ɵɵstyleMap({color: '#003'});   // Binding index: 20\n *     ɵɵstyleProp('color', '#004');  // Binding index: 22\n * // Style1Directive\n *     ɵɵstyleMap({color: '#005'});   // Binding index: 24\n *     ɵɵstyleProp('color', '#006');  // Binding index: 26\n * // Style2Directive\n *     ɵɵstyleMap({color: '#007'});   // Binding index: 28\n *     ɵɵstyleProp('color', '#008');  // Binding index: 30\n * ```\n *\n * The correct priority order of concatenation is:\n *\n * ```\n * // MyComponent\n *     ɵɵstyleMap({color: '#003'});   // Binding index: 20\n *     ɵɵstyleProp('color', '#004');  // Binding index: 22\n * // Style1Directive\n *     ɵɵstyleMap({color: '#005'});   // Binding index: 24\n *     ɵɵstyleProp('color', '#006');  // Binding index: 26\n * // Style2Directive\n *     ɵɵstyleMap({color: '#007'});   // Binding index: 28\n *     ɵɵstyleProp('color', '#008');  // Binding index: 30\n * // Template: (ExampleComponent)\n *     ɵɵstyleMap({color: '#001'});   // Binding index: 10\n *     ɵɵstyleProp('color', '#002');  // Binding index: 12\n * ```\n *\n * What color should be rendered?\n *\n * Once the items are correctly sorted in the list, the answer is simply the last item in the\n * concatenation list which is `#002`.\n *\n * To do so we keep a linked list of all of the bindings which pertain to this element.\n * Notice that the bindings are inserted in the order of execution, but the `TView.data` allows\n * us to traverse them in the order of priority.\n *\n * |Idx|`TView.data`|`LView`          | Notes\n * |---|------------|-----------------|--------------\n * |...|            |                 |\n * |10 |`null`      |`{color: '#001'}`| `ɵɵstyleMap('color', {color: '#001'})`\n * |11 |`30 | 12`   | ...             |\n * |12 |`color`     |`'#002'`         | `ɵɵstyleProp('color', '#002')`\n * |13 |`10 | 0`    | ...             |\n * |...|            |                 |\n * |20 |`null`      |`{color: '#003'}`| `ɵɵstyleMap('color', {color: '#003'})`\n * |21 |`0 | 22`    | ...             |\n * |22 |`color`     |`'#004'`         | `ɵɵstyleProp('color', '#004')`\n * |23 |`20 | 24`   | ...             |\n * |24 |`null`      |`{color: '#005'}`| `ɵɵstyleMap('color', {color: '#005'})`\n * |25 |`22 | 26`   | ...             |\n * |26 |`color`     |`'#006'`         | `ɵɵstyleProp('color', '#006')`\n * |27 |`24 | 28`   | ...             |\n * |28 |`null`      |`{color: '#007'}`| `ɵɵstyleMap('color', {color: '#007'})`\n * |29 |`26 | 30`   | ...             |\n * |30 |`color`     |`'#008'`         | `ɵɵstyleProp('color', '#008')`\n * |31 |`28 | 10`   | ...             |\n *\n * The above data structure allows us to re-concatenate the styling no matter which data binding\n * changes.\n *\n * NOTE: in addition to keeping track of next/previous index the `TView.data` also stores prev/next\n * duplicate bit. The duplicate bit if true says there either is a binding with the same name or\n * there is a map (which may contain the name). This information is useful in knowing if other\n * styles with higher priority need to be searched for overwrites.\n *\n * NOTE: See `should support example in 'tnode_linked_list.ts' documentation` in\n * `tnode_linked_list_spec.ts` for working example.\n */\nlet __unused_const_as_closure_does_not_like_standalone_comment_blocks__: undefined;\n\n/**\n * Insert new `tStyleValue` at `TData` and link existing style bindings such that we maintain linked\n * list of styles and compute the duplicate flag.\n *\n * Note: this function is executed during `firstUpdatePass` only to populate the `TView.data`.\n *\n * The function works by keeping track of `tStylingRange` which contains two pointers pointing to\n * the head/tail of the template portion of the styles.\n *  - if `isHost === false` (we are template) then insertion is at tail of `TStylingRange`\n *  - if `isHost === true` (we are host binding) then insertion is at head of `TStylingRange`\n *\n * @param tData The `TData` to insert into.\n * @param tNode `TNode` associated with the styling element.\n * @param tStylingKey See `TStylingKey`.\n * @param index location of where `tStyleValue` should be stored (and linked into list.)\n * @param isHostBinding `true` if the insertion is for a `hostBinding`. (insertion is in front of\n *               template.)\n * @param isClassBinding True if the associated `tStylingKey` as a `class` styling.\n *                       `tNode.classBindings` should be used (or `tNode.styleBindings` otherwise.)\n */\nexport function insertTStylingBinding(\n    tData: TData, tNode: TNode, tStylingKeyWithStatic: TStylingKey, index: number,\n    isHostBinding: boolean, isClassBinding: boolean): void {\n  ngDevMode && assertFirstUpdatePass(getTView());\n  let tBindings = isClassBinding ? tNode.classBindings : tNode.styleBindings;\n  let tmplHead = getTStylingRangePrev(tBindings);\n  let tmplTail = getTStylingRangeNext(tBindings);\n\n  tData[index] = tStylingKeyWithStatic;\n  let isKeyDuplicateOfStatic = false;\n  let tStylingKey: TStylingKeyPrimitive;\n  if (Array.isArray(tStylingKeyWithStatic)) {\n    // We are case when the `TStylingKey` contains static fields as well.\n    const staticKeyValueArray = tStylingKeyWithStatic as KeyValueArray<any>;\n    tStylingKey = staticKeyValueArray[1];  // unwrap.\n    // We need to check if our key is present in the static so that we can mark it as duplicate.\n    if (tStylingKey === null ||\n        keyValueArrayIndexOf(staticKeyValueArray, tStylingKey as string) > 0) {\n      // tStylingKey is present in the statics, need to mark it as duplicate.\n      isKeyDuplicateOfStatic = true;\n    }\n  } else {\n    tStylingKey = tStylingKeyWithStatic;\n  }\n  if (isHostBinding) {\n    // We are inserting host bindings\n\n    // If we don't have template bindings then `tail` is 0.\n    const hasTemplateBindings = tmplTail !== 0;\n    // This is important to know because that means that the `head` can't point to the first\n    // template bindings (there are none.) Instead the head points to the tail of the template.\n    if (hasTemplateBindings) {\n      // template head's \"prev\" will point to last host binding or to 0 if no host bindings yet\n      const previousNode = getTStylingRangePrev(tData[tmplHead + 1] as TStylingRange);\n      tData[index + 1] = toTStylingRange(previousNode, tmplHead);\n      // if a host binding has already been registered, we need to update the next of that host\n      // binding to point to this one\n      if (previousNode !== 0) {\n        // We need to update the template-tail value to point to us.\n        tData[previousNode + 1] =\n            setTStylingRangeNext(tData[previousNode + 1] as TStylingRange, index);\n      }\n      // The \"previous\" of the template binding head should point to this host binding\n      tData[tmplHead + 1] = setTStylingRangePrev(tData[tmplHead + 1] as TStylingRange, index);\n    } else {\n      tData[index + 1] = toTStylingRange(tmplHead, 0);\n      // if a host binding has already been registered, we need to update the next of that host\n      // binding to point to this one\n      if (tmplHead !== 0) {\n        // We need to update the template-tail value to point to us.\n        tData[tmplHead + 1] = setTStylingRangeNext(tData[tmplHead + 1] as TStylingRange, index);\n      }\n      // if we don't have template, the head points to template-tail, and needs to be advanced.\n      tmplHead = index;\n    }\n  } else {\n    // We are inserting in template section.\n    // We need to set this binding's \"previous\" to the current template tail\n    tData[index + 1] = toTStylingRange(tmplTail, 0);\n    ngDevMode &&\n        assertEqual(\n            tmplHead !== 0 && tmplTail === 0, false,\n            'Adding template bindings after hostBindings is not allowed.');\n    if (tmplHead === 0) {\n      tmplHead = index;\n    } else {\n      // We need to update the previous value \"next\" to point to this binding\n      tData[tmplTail + 1] = setTStylingRangeNext(tData[tmplTail + 1] as TStylingRange, index);\n    }\n    tmplTail = index;\n  }\n\n  // Now we need to update / compute the duplicates.\n  // Starting with our location search towards head (least priority)\n  if (isKeyDuplicateOfStatic) {\n    tData[index + 1] = setTStylingRangePrevDuplicate(tData[index + 1] as TStylingRange);\n  }\n  markDuplicates(tData, tStylingKey, index, true, isClassBinding);\n  markDuplicates(tData, tStylingKey, index, false, isClassBinding);\n  markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding);\n\n  tBindings = toTStylingRange(tmplHead, tmplTail);\n  if (isClassBinding) {\n    tNode.classBindings = tBindings;\n  } else {\n    tNode.styleBindings = tBindings;\n  }\n}\n\n/**\n * Look into the residual styling to see if the current `tStylingKey` is duplicate of residual.\n *\n * @param tNode `TNode` where the residual is stored.\n * @param tStylingKey `TStylingKey` to store.\n * @param tData `TData` associated with the current `LView`.\n * @param index location of where `tStyleValue` should be stored (and linked into list.)\n * @param isClassBinding True if the associated `tStylingKey` as a `class` styling.\n *                       `tNode.classBindings` should be used (or `tNode.styleBindings` otherwise.)\n */\nfunction markDuplicateOfResidualStyling(\n    tNode: TNode, tStylingKey: TStylingKey, tData: TData, index: number, isClassBinding: boolean) {\n  const residual = isClassBinding ? tNode.residualClasses : tNode.residualStyles;\n  if (residual != null /* or undefined */ && typeof tStylingKey == 'string' &&\n      keyValueArrayIndexOf(residual, tStylingKey) >= 0) {\n    // We have duplicate in the residual so mark ourselves as duplicate.\n    tData[index + 1] = setTStylingRangeNextDuplicate(tData[index + 1] as TStylingRange);\n  }\n}\n\n\n/**\n * Marks `TStyleValue`s as duplicates if another style binding in the list has the same\n * `TStyleValue`.\n *\n * NOTE: this function is intended to be called twice once with `isPrevDir` set to `true` and once\n * with it set to `false` to search both the previous as well as next items in the list.\n *\n * No duplicate case\n * ```\n *   [style.color]\n *   [style.width.px] <<- index\n *   [style.height.px]\n * ```\n *\n * In the above case adding `[style.width.px]` to the existing `[style.color]` produces no\n * duplicates because `width` is not found in any other part of the linked list.\n *\n * Duplicate case\n * ```\n *   [style.color]\n *   [style.width.em]\n *   [style.width.px] <<- index\n * ```\n * In the above case adding `[style.width.px]` will produce a duplicate with `[style.width.em]`\n * because `width` is found in the chain.\n *\n * Map case 1\n * ```\n *   [style.width.px]\n *   [style.color]\n *   [style]  <<- index\n * ```\n * In the above case adding `[style]` will produce a duplicate with any other bindings because\n * `[style]` is a Map and as such is fully dynamic and could produce `color` or `width`.\n *\n * Map case 2\n * ```\n *   [style]\n *   [style.width.px]\n *   [style.color]  <<- index\n * ```\n * In the above case adding `[style.color]` will produce a duplicate because there is already a\n * `[style]` binding which is a Map and as such is fully dynamic and could produce `color` or\n * `width`.\n *\n * NOTE: Once `[style]` (Map) is added into the system all things are mapped as duplicates.\n * NOTE: We use `style` as example, but same logic is applied to `class`es as well.\n *\n * @param tData `TData` where the linked list is stored.\n * @param tStylingKey `TStylingKeyPrimitive` which contains the value to compare to other keys in\n *        the linked list.\n * @param index Starting location in the linked list to search from\n * @param isPrevDir Direction.\n *        - `true` for previous (lower priority);\n *        - `false` for next (higher priority).\n */\nfunction markDuplicates(\n    tData: TData, tStylingKey: TStylingKeyPrimitive, index: number, isPrevDir: boolean,\n    isClassBinding: boolean) {\n  const tStylingAtIndex = tData[index + 1] as TStylingRange;\n  const isMap = tStylingKey === null;\n  let cursor =\n      isPrevDir ? getTStylingRangePrev(tStylingAtIndex) : getTStylingRangeNext(tStylingAtIndex);\n  let foundDuplicate = false;\n  // We keep iterating as long as we have a cursor\n  // AND either:\n  // - we found what we are looking for, OR\n  // - we are a map in which case we have to continue searching even after we find what we were\n  //   looking for since we are a wild card and everything needs to be flipped to duplicate.\n  while (cursor !== 0 && (foundDuplicate === false || isMap)) {\n    ngDevMode && assertIndexInRange(tData, cursor);\n    const tStylingValueAtCursor = tData[cursor] as TStylingKey;\n    const tStyleRangeAtCursor = tData[cursor + 1] as TStylingRange;\n    if (isStylingMatch(tStylingValueAtCursor, tStylingKey)) {\n      foundDuplicate = true;\n      tData[cursor + 1] = isPrevDir ? setTStylingRangeNextDuplicate(tStyleRangeAtCursor) :\n                                      setTStylingRangePrevDuplicate(tStyleRangeAtCursor);\n    }\n    cursor = isPrevDir ? getTStylingRangePrev(tStyleRangeAtCursor) :\n                         getTStylingRangeNext(tStyleRangeAtCursor);\n  }\n  if (foundDuplicate) {\n    // if we found a duplicate, than mark ourselves.\n    tData[index + 1] = isPrevDir ? setTStylingRangePrevDuplicate(tStylingAtIndex) :\n                                   setTStylingRangeNextDuplicate(tStylingAtIndex);\n  }\n}\n\n/**\n * Determines if two `TStylingKey`s are a match.\n *\n * When computing whether a binding contains a duplicate, we need to compare if the instruction\n * `TStylingKey` has a match.\n *\n * Here are examples of `TStylingKey`s which match given `tStylingKeyCursor` is:\n * - `color`\n *    - `color`    // Match another color\n *    - `null`     // That means that `tStylingKey` is a `classMap`/`styleMap` instruction\n *    - `['', 'color', 'other', true]` // wrapped `color` so match\n *    - `['', null, 'other', true]`       // wrapped `null` so match\n *    - `['', 'width', 'color', 'value']` // wrapped static value contains a match on `'color'`\n * - `null`       // `tStylingKeyCursor` always match as it is `classMap`/`styleMap` instruction\n *\n * @param tStylingKeyCursor\n * @param tStylingKey\n */\nfunction isStylingMatch(tStylingKeyCursor: TStylingKey, tStylingKey: TStylingKeyPrimitive) {\n  ngDevMode &&\n      assertNotEqual(\n          Array.isArray(tStylingKey), true, 'Expected that \\'tStylingKey\\' has been unwrapped');\n  if (\n      tStylingKeyCursor === null ||  // If the cursor is `null` it means that we have map at that\n                                     // location so we must assume that we have a match.\n      tStylingKey == null ||  // If `tStylingKey` is `null` then it is a map therefor assume that it\n                              // contains a match.\n      (Array.isArray(tStylingKeyCursor) ? tStylingKeyCursor[1] : tStylingKeyCursor) ===\n          tStylingKey  // If the keys match explicitly than we are a match.\n  ) {\n    return true;\n  } else if (Array.isArray(tStylingKeyCursor) && typeof tStylingKey === 'string') {\n    // if we did not find a match, but `tStylingKeyCursor` is `KeyValueArray` that means cursor has\n    // statics and we need to check those as well.\n    return keyValueArrayIndexOf(tStylingKeyCursor, tStylingKey) >=\n        0;  // see if we are matching the key\n  }\n  return false;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertEqual, throwError} from '../../util/assert';\nimport {CharCode} from '../../util/char_code';\n\n/**\n * Stores the locations of key/value indexes while parsing styling.\n *\n * In case of `cssText` parsing the indexes are like so:\n * ```\n *   \"key1: value1; key2: value2; key3: value3\"\n *                  ^   ^ ^     ^             ^\n *                  |   | |     |             +-- textEnd\n *                  |   | |     +---------------- valueEnd\n *                  |   | +---------------------- value\n *                  |   +------------------------ keyEnd\n *                  +---------------------------- key\n * ```\n *\n * In case of `className` parsing the indexes are like so:\n * ```\n *   \"key1 key2 key3\"\n *         ^   ^    ^\n *         |   |    +-- textEnd\n *         |   +------------------------ keyEnd\n *         +---------------------------- key\n * ```\n * NOTE: `value` and `valueEnd` are used only for styles, not classes.\n */\ninterface ParserState {\n  textEnd: number;\n  key: number;\n  keyEnd: number;\n  value: number;\n  valueEnd: number;\n}\n// Global state of the parser. (This makes parser non-reentrant, but that is not an issue)\nconst parserState: ParserState = {\n  textEnd: 0,\n  key: 0,\n  keyEnd: 0,\n  value: 0,\n  valueEnd: 0,\n};\n\n/**\n * Retrieves the last parsed `key` of style.\n * @param text the text to substring the key from.\n */\nexport function getLastParsedKey(text: string): string {\n  return text.substring(parserState.key, parserState.keyEnd);\n}\n\n/**\n * Retrieves the last parsed `value` of style.\n * @param text the text to substring the key from.\n */\nexport function getLastParsedValue(text: string): string {\n  return text.substring(parserState.value, parserState.valueEnd);\n}\n\n/**\n * Initializes `className` string for parsing and parses the first token.\n *\n * This function is intended to be used in this format:\n * ```\n * for (let i = parseClassName(text); i >= 0; i = parseClassNameNext(text, i)) {\n *   const key = getLastParsedKey();\n *   ...\n * }\n * ```\n * @param text `className` to parse\n * @returns index where the next invocation of `parseClassNameNext` should resume.\n */\nexport function parseClassName(text: string): number {\n  resetParserState(text);\n  return parseClassNameNext(text, consumeWhitespace(text, 0, parserState.textEnd));\n}\n\n/**\n * Parses next `className` token.\n *\n * This function is intended to be used in this format:\n * ```\n * for (let i = parseClassName(text); i >= 0; i = parseClassNameNext(text, i)) {\n *   const key = getLastParsedKey();\n *   ...\n * }\n * ```\n *\n * @param text `className` to parse\n * @param index where the parsing should resume.\n * @returns index where the next invocation of `parseClassNameNext` should resume.\n */\nexport function parseClassNameNext(text: string, index: number): number {\n  const end = parserState.textEnd;\n  if (end === index) {\n    return -1;\n  }\n  index = parserState.keyEnd = consumeClassToken(text, parserState.key = index, end);\n  return consumeWhitespace(text, index, end);\n}\n\n/**\n * Initializes `cssText` string for parsing and parses the first key/values.\n *\n * This function is intended to be used in this format:\n * ```\n * for (let i = parseStyle(text); i >= 0; i = parseStyleNext(text, i))) {\n *   const key = getLastParsedKey();\n *   const value = getLastParsedValue();\n *   ...\n * }\n * ```\n * @param text `cssText` to parse\n * @returns index where the next invocation of `parseStyleNext` should resume.\n */\nexport function parseStyle(text: string): number {\n  resetParserState(text);\n  return parseStyleNext(text, consumeWhitespace(text, 0, parserState.textEnd));\n}\n\n/**\n * Parses the next `cssText` key/values.\n *\n * This function is intended to be used in this format:\n * ```\n * for (let i = parseStyle(text); i >= 0; i = parseStyleNext(text, i))) {\n *   const key = getLastParsedKey();\n *   const value = getLastParsedValue();\n *   ...\n * }\n *\n * @param text `cssText` to parse\n * @param index where the parsing should resume.\n * @returns index where the next invocation of `parseStyleNext` should resume.\n */\nexport function parseStyleNext(text: string, startIndex: number): number {\n  const end = parserState.textEnd;\n  let index = parserState.key = consumeWhitespace(text, startIndex, end);\n  if (end === index) {\n    // we reached an end so just quit\n    return -1;\n  }\n  index = parserState.keyEnd = consumeStyleKey(text, index, end);\n  index = consumeSeparator(text, index, end, CharCode.COLON);\n  index = parserState.value = consumeWhitespace(text, index, end);\n  index = parserState.valueEnd = consumeStyleValue(text, index, end);\n  return consumeSeparator(text, index, end, CharCode.SEMI_COLON);\n}\n\n/**\n * Reset the global state of the styling parser.\n * @param text The styling text to parse.\n */\nexport function resetParserState(text: string): void {\n  parserState.key = 0;\n  parserState.keyEnd = 0;\n  parserState.value = 0;\n  parserState.valueEnd = 0;\n  parserState.textEnd = text.length;\n}\n\n/**\n * Returns index of next non-whitespace character.\n *\n * @param text Text to scan\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index of next non-whitespace character (May be the same as `start` if no whitespace at\n *          that location.)\n */\nexport function consumeWhitespace(text: string, startIndex: number, endIndex: number): number {\n  while (startIndex < endIndex && text.charCodeAt(startIndex) <= CharCode.SPACE) {\n    startIndex++;\n  }\n  return startIndex;\n}\n\n/**\n * Returns index of last char in class token.\n *\n * @param text Text to scan\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index after last char in class token.\n */\nexport function consumeClassToken(text: string, startIndex: number, endIndex: number): number {\n  while (startIndex < endIndex && text.charCodeAt(startIndex) > CharCode.SPACE) {\n    startIndex++;\n  }\n  return startIndex;\n}\n\n/**\n * Consumes all of the characters belonging to style key and token.\n *\n * @param text Text to scan\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index after last style key character.\n */\nexport function consumeStyleKey(text: string, startIndex: number, endIndex: number): number {\n  let ch: number;\n  while (startIndex < endIndex &&\n         ((ch = text.charCodeAt(startIndex)) === CharCode.DASH || ch === CharCode.UNDERSCORE ||\n          ((ch & CharCode.UPPER_CASE) >= CharCode.A && (ch & CharCode.UPPER_CASE) <= CharCode.Z) ||\n          (ch >= CharCode.ZERO && ch <= CharCode.NINE))) {\n    startIndex++;\n  }\n  return startIndex;\n}\n\n/**\n * Consumes all whitespace and the separator `:` after the style key.\n *\n * @param text Text to scan\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index after separator and surrounding whitespace.\n */\nexport function consumeSeparator(\n    text: string, startIndex: number, endIndex: number, separator: number): number {\n  startIndex = consumeWhitespace(text, startIndex, endIndex);\n  if (startIndex < endIndex) {\n    if (ngDevMode && text.charCodeAt(startIndex) !== separator) {\n      malformedStyleError(text, String.fromCharCode(separator), startIndex);\n    }\n    startIndex++;\n  }\n  return startIndex;\n}\n\n\n/**\n * Consumes style value honoring `url()` and `\"\"` text.\n *\n * @param text Text to scan\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index after last style value character.\n */\nexport function consumeStyleValue(text: string, startIndex: number, endIndex: number): number {\n  let ch1 = -1;  // 1st previous character\n  let ch2 = -1;  // 2nd previous character\n  let ch3 = -1;  // 3rd previous character\n  let i = startIndex;\n  let lastChIndex = i;\n  while (i < endIndex) {\n    const ch: number = text.charCodeAt(i++);\n    if (ch === CharCode.SEMI_COLON) {\n      return lastChIndex;\n    } else if (ch === CharCode.DOUBLE_QUOTE || ch === CharCode.SINGLE_QUOTE) {\n      lastChIndex = i = consumeQuotedText(text, ch, i, endIndex);\n    } else if (\n        startIndex ===\n            i - 4 &&  // We have seen only 4 characters so far \"URL(\" (Ignore \"foo_URL()\")\n        ch3 === CharCode.U &&\n        ch2 === CharCode.R && ch1 === CharCode.L && ch === CharCode.OPEN_PAREN) {\n      lastChIndex = i = consumeQuotedText(text, CharCode.CLOSE_PAREN, i, endIndex);\n    } else if (ch > CharCode.SPACE) {\n      // if we have a non-whitespace character then capture its location\n      lastChIndex = i;\n    }\n    ch3 = ch2;\n    ch2 = ch1;\n    ch1 = ch & CharCode.UPPER_CASE;\n  }\n  return lastChIndex;\n}\n\n/**\n * Consumes all of the quoted characters.\n *\n * @param text Text to scan\n * @param quoteCharCode CharCode of either `\"` or `'` quote or `)` for `url(...)`.\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index after quoted characters.\n */\nexport function consumeQuotedText(\n    text: string, quoteCharCode: number, startIndex: number, endIndex: number): number {\n  let ch1 = -1;  // 1st previous character\n  let index = startIndex;\n  while (index < endIndex) {\n    const ch = text.charCodeAt(index++);\n    if (ch == quoteCharCode && ch1 !== CharCode.BACK_SLASH) {\n      return index;\n    }\n    if (ch == CharCode.BACK_SLASH && ch1 === CharCode.BACK_SLASH) {\n      // two back slashes cancel each other out. For example `\"\\\\\"` should properly end the\n      // quotation. (It should not assume that the last `\"` is escaped.)\n      ch1 = 0;\n    } else {\n      ch1 = ch;\n    }\n  }\n  throw ngDevMode ? malformedStyleError(text, String.fromCharCode(quoteCharCode), endIndex) :\n                    new Error();\n}\n\nfunction malformedStyleError(text: string, expecting: string, index: number): never {\n  ngDevMode && assertEqual(typeof text === 'string', true, 'String expected here');\n  throw throwError(\n      `Malformed style at location ${index} in string '` + text.substring(0, index) + '[>>' +\n      text.substring(index, index + 1) + '<<]' + text.slice(index + 1) +\n      `'. Expecting '${expecting}'.`);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SafeValue, unwrapSafeValue} from '../../sanitization/bypass';\nimport {KeyValueArray, keyValueArrayGet, keyValueArraySet} from '../../util/array_utils';\nimport {assertDefined, assertEqual, assertLessThan, assertNotEqual, throwError} from '../../util/assert';\nimport {EMPTY_ARRAY} from '../../util/empty';\nimport {concatStringsWithSpace, stringify} from '../../util/stringify';\nimport {assertFirstUpdatePass} from '../assert';\nimport {bindingUpdated} from '../bindings';\nimport {DirectiveDef} from '../interfaces/definition';\nimport {AttributeMarker, TAttributes, TNode, TNodeFlags, TNodeType} from '../interfaces/node';\nimport {Renderer} from '../interfaces/renderer';\nimport {RElement} from '../interfaces/renderer_dom';\nimport {getTStylingRangeNext, getTStylingRangeNextDuplicate, getTStylingRangePrev, getTStylingRangePrevDuplicate, TStylingKey, TStylingRange} from '../interfaces/styling';\nimport {LView, RENDERER, TData, TView} from '../interfaces/view';\nimport {applyStyling} from '../node_manipulation';\nimport {getCurrentDirectiveDef, getLView, getSelectedIndex, getTView, incrementBindingIndex} from '../state';\nimport {insertTStylingBinding} from '../styling/style_binding_list';\nimport {getLastParsedKey, getLastParsedValue, parseClassName, parseClassNameNext, parseStyle, parseStyleNext} from '../styling/styling_parser';\nimport {NO_CHANGE} from '../tokens';\nimport {getNativeByIndex} from '../util/view_utils';\n\nimport {setDirectiveInputsWhichShadowsStyling} from './property';\n\n\n/**\n * Update a style binding on an element with the provided value.\n *\n * If the style value is falsy then it will be removed from the element\n * (or assigned a different value depending if there are any styles placed\n * on the element with `styleMap` or any static styles that are\n * present from when the element was created with `styling`).\n *\n * Note that the styling element is updated as part of `stylingApply`.\n *\n * @param prop A valid CSS property.\n * @param value New value to write (`null` or an empty string to remove).\n * @param suffix Optional suffix. Used with scalar values to add unit such as `px`.\n *\n * Note that this will apply the provided style value to the host element if this function is called\n * within a host binding function.\n *\n * @codeGenApi\n */\nexport function ɵɵstyleProp(\n    prop: string, value: string|number|SafeValue|undefined|null,\n    suffix?: string|null): typeof ɵɵstyleProp {\n  checkStylingProperty(prop, value, suffix, false);\n  return ɵɵstyleProp;\n}\n\n/**\n * Update a class binding on an element with the provided value.\n *\n * This instruction is meant to handle the `[class.foo]=\"exp\"` case and,\n * therefore, the class binding itself must already be allocated using\n * `styling` within the creation block.\n *\n * @param prop A valid CSS class (only one).\n * @param value A true/false value which will turn the class on or off.\n *\n * Note that this will apply the provided class value to the host element if this function\n * is called within a host binding function.\n *\n * @codeGenApi\n */\nexport function ɵɵclassProp(className: string, value: boolean|undefined|null): typeof ɵɵclassProp {\n  checkStylingProperty(className, value, null, true);\n  return ɵɵclassProp;\n}\n\n\n/**\n * Update style bindings using an object literal on an element.\n *\n * This instruction is meant to apply styling via the `[style]=\"exp\"` template bindings.\n * When styles are applied to the element they will then be updated with respect to\n * any styles/classes set via `styleProp`. If any styles are set to falsy\n * then they will be removed from the element.\n *\n * Note that the styling instruction will not be applied until `stylingApply` is called.\n *\n * @param styles A key/value style map of the styles that will be applied to the given element.\n *        Any missing styles (that have already been applied to the element beforehand) will be\n *        removed (unset) from the element's styling.\n *\n * Note that this will apply the provided styleMap value to the host element if this function\n * is called within a host binding.\n *\n * @codeGenApi\n */\nexport function ɵɵstyleMap(styles: {[styleName: string]: any}|string|undefined|null): void {\n  checkStylingMap(styleKeyValueArraySet, styleStringParser, styles, false);\n}\n\n\n/**\n * Parse text as style and add values to KeyValueArray.\n *\n * This code is pulled out to a separate function so that it can be tree shaken away if it is not\n * needed. It is only referenced from `ɵɵstyleMap`.\n *\n * @param keyValueArray KeyValueArray to add parsed values to.\n * @param text text to parse.\n */\nexport function styleStringParser(keyValueArray: KeyValueArray<any>, text: string): void {\n  for (let i = parseStyle(text); i >= 0; i = parseStyleNext(text, i)) {\n    styleKeyValueArraySet(keyValueArray, getLastParsedKey(text), getLastParsedValue(text));\n  }\n}\n\n\n/**\n * Update class bindings using an object literal or class-string on an element.\n *\n * This instruction is meant to apply styling via the `[class]=\"exp\"` template bindings.\n * When classes are applied to the element they will then be updated with\n * respect to any styles/classes set via `classProp`. If any\n * classes are set to falsy then they will be removed from the element.\n *\n * Note that the styling instruction will not be applied until `stylingApply` is called.\n * Note that this will the provided classMap value to the host element if this function is called\n * within a host binding.\n *\n * @param classes A key/value map or string of CSS classes that will be added to the\n *        given element. Any missing classes (that have already been applied to the element\n *        beforehand) will be removed (unset) from the element's list of CSS classes.\n *\n * @codeGenApi\n */\nexport function ɵɵclassMap(classes: {[className: string]: boolean|undefined|null}|string|undefined|\n                           null): void {\n  checkStylingMap(keyValueArraySet, classStringParser, classes, true);\n}\n\n/**\n * Parse text as class and add values to KeyValueArray.\n *\n * This code is pulled out to a separate function so that it can be tree shaken away if it is not\n * needed. It is only referenced from `ɵɵclassMap`.\n *\n * @param keyValueArray KeyValueArray to add parsed values to.\n * @param text text to parse.\n */\nexport function classStringParser(keyValueArray: KeyValueArray<any>, text: string): void {\n  for (let i = parseClassName(text); i >= 0; i = parseClassNameNext(text, i)) {\n    keyValueArraySet(keyValueArray, getLastParsedKey(text), true);\n  }\n}\n\n/**\n * Common code between `ɵɵclassProp` and `ɵɵstyleProp`.\n *\n * @param prop property name.\n * @param value binding value.\n * @param suffix suffix for the property (e.g. `em` or `px`)\n * @param isClassBased `true` if `class` change (`false` if `style`)\n */\nexport function checkStylingProperty(\n    prop: string, value: any|NO_CHANGE, suffix: string|undefined|null,\n    isClassBased: boolean): void {\n  const lView = getLView();\n  const tView = getTView();\n  // Styling instructions use 2 slots per binding.\n  // 1. one for the value / TStylingKey\n  // 2. one for the intermittent-value / TStylingRange\n  const bindingIndex = incrementBindingIndex(2);\n  if (tView.firstUpdatePass) {\n    stylingFirstUpdatePass(tView, prop, bindingIndex, isClassBased);\n  }\n  if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {\n    const tNode = tView.data[getSelectedIndex()] as TNode;\n    updateStyling(\n        tView, tNode, lView, lView[RENDERER], prop,\n        lView[bindingIndex + 1] = normalizeSuffix(value, suffix), isClassBased, bindingIndex);\n  }\n}\n\n/**\n * Common code between `ɵɵclassMap` and `ɵɵstyleMap`.\n *\n * @param keyValueArraySet (See `keyValueArraySet` in \"util/array_utils\") Gets passed in as a\n *        function so that `style` can be processed. This is done for tree shaking purposes.\n * @param stringParser Parser used to parse `value` if `string`. (Passed in as `style` and `class`\n *        have different parsers.)\n * @param value bound value from application\n * @param isClassBased `true` if `class` change (`false` if `style`)\n */\nexport function checkStylingMap(\n    keyValueArraySet: (keyValueArray: KeyValueArray<any>, key: string, value: any) => void,\n    stringParser: (styleKeyValueArray: KeyValueArray<any>, text: string) => void,\n    value: any|NO_CHANGE, isClassBased: boolean): void {\n  const tView = getTView();\n  const bindingIndex = incrementBindingIndex(2);\n  if (tView.firstUpdatePass) {\n    stylingFirstUpdatePass(tView, null, bindingIndex, isClassBased);\n  }\n  const lView = getLView();\n  if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {\n    // `getSelectedIndex()` should be here (rather than in instruction) so that it is guarded by the\n    // if so as not to read unnecessarily.\n    const tNode = tView.data[getSelectedIndex()] as TNode;\n    if (hasStylingInputShadow(tNode, isClassBased) && !isInHostBindings(tView, bindingIndex)) {\n      if (ngDevMode) {\n        // verify that if we are shadowing then `TData` is appropriately marked so that we skip\n        // processing this binding in styling resolution.\n        const tStylingKey = tView.data[bindingIndex];\n        assertEqual(\n            Array.isArray(tStylingKey) ? tStylingKey[1] : tStylingKey, false,\n            'Styling linked list shadow input should be marked as \\'false\\'');\n      }\n      // VE does not concatenate the static portion like we are doing here.\n      // Instead VE just ignores the static completely if dynamic binding is present.\n      // Because of locality we have already set the static portion because we don't know if there\n      // is a dynamic portion until later. If we would ignore the static portion it would look like\n      // the binding has removed it. This would confuse `[ngStyle]`/`[ngClass]` to do the wrong\n      // thing as it would think that the static portion was removed. For this reason we\n      // concatenate it so that `[ngStyle]`/`[ngClass]`  can continue to work on changed.\n      let staticPrefix = isClassBased ? tNode.classesWithoutHost : tNode.stylesWithoutHost;\n      ngDevMode && isClassBased === false && staticPrefix !== null &&\n          assertEqual(\n              staticPrefix.endsWith(';'), true, 'Expecting static portion to end with \\';\\'');\n      if (staticPrefix !== null) {\n        // We want to make sure that falsy values of `value` become empty strings.\n        value = concatStringsWithSpace(staticPrefix, value ? value : '');\n      }\n      // Given `<div [style] my-dir>` such that `my-dir` has `@Input('style')`.\n      // This takes over the `[style]` binding. (Same for `[class]`)\n      setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased);\n    } else {\n      updateStylingMap(\n          tView, tNode, lView, lView[RENDERER], lView[bindingIndex + 1],\n          lView[bindingIndex + 1] = toStylingKeyValueArray(keyValueArraySet, stringParser, value),\n          isClassBased, bindingIndex);\n    }\n  }\n}\n\n/**\n * Determines when the binding is in `hostBindings` section\n *\n * @param tView Current `TView`\n * @param bindingIndex index of binding which we would like if it is in `hostBindings`\n */\nfunction isInHostBindings(tView: TView, bindingIndex: number): boolean {\n  // All host bindings are placed after the expando section.\n  return bindingIndex >= tView.expandoStartIndex;\n}\n\n/**\n * Collects the necessary information to insert the binding into a linked list of style bindings\n * using `insertTStylingBinding`.\n *\n * @param tView `TView` where the binding linked list will be stored.\n * @param tStylingKey Property/key of the binding.\n * @param bindingIndex Index of binding associated with the `prop`\n * @param isClassBased `true` if `class` change (`false` if `style`)\n */\nfunction stylingFirstUpdatePass(\n    tView: TView, tStylingKey: TStylingKey, bindingIndex: number, isClassBased: boolean): void {\n  ngDevMode && assertFirstUpdatePass(tView);\n  const tData = tView.data;\n  if (tData[bindingIndex + 1] === null) {\n    // The above check is necessary because we don't clear first update pass until first successful\n    // (no exception) template execution. This prevents the styling instruction from double adding\n    // itself to the list.\n    // `getSelectedIndex()` should be here (rather than in instruction) so that it is guarded by the\n    // if so as not to read unnecessarily.\n    const tNode = tData[getSelectedIndex()] as TNode;\n    ngDevMode && assertDefined(tNode, 'TNode expected');\n    const isHostBindings = isInHostBindings(tView, bindingIndex);\n    if (hasStylingInputShadow(tNode, isClassBased) && tStylingKey === null && !isHostBindings) {\n      // `tStylingKey === null` implies that we are either `[style]` or `[class]` binding.\n      // If there is a directive which uses `@Input('style')` or `@Input('class')` than\n      // we need to neutralize this binding since that directive is shadowing it.\n      // We turn this into a noop by setting the key to `false`\n      tStylingKey = false;\n    }\n    tStylingKey = wrapInStaticStylingKey(tData, tNode, tStylingKey, isClassBased);\n    insertTStylingBinding(tData, tNode, tStylingKey, bindingIndex, isHostBindings, isClassBased);\n  }\n}\n\n/**\n * Adds static styling information to the binding if applicable.\n *\n * The linked list of styles not only stores the list and keys, but also stores static styling\n * information on some of the keys. This function determines if the key should contain the styling\n * information and computes it.\n *\n * See `TStylingStatic` for more details.\n *\n * @param tData `TData` where the linked list is stored.\n * @param tNode `TNode` for which the styling is being computed.\n * @param stylingKey `TStylingKeyPrimitive` which may need to be wrapped into `TStylingKey`\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nexport function wrapInStaticStylingKey(\n    tData: TData, tNode: TNode, stylingKey: TStylingKey, isClassBased: boolean): TStylingKey {\n  const hostDirectiveDef = getCurrentDirectiveDef(tData);\n  let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;\n  if (hostDirectiveDef === null) {\n    // We are in template node.\n    // If template node already had styling instruction then it has already collected the static\n    // styling and there is no need to collect them again. We know that we are the first styling\n    // instruction because the `TNode.*Bindings` points to 0 (nothing has been inserted yet).\n    const isFirstStylingInstructionInTemplate =\n        (isClassBased ? tNode.classBindings : tNode.styleBindings) as any as number === 0;\n    if (isFirstStylingInstructionInTemplate) {\n      // It would be nice to be able to get the statics from `mergeAttrs`, however, at this point\n      // they are already merged and it would not be possible to figure which property belongs where\n      // in the priority.\n      stylingKey = collectStylingFromDirectives(null, tData, tNode, stylingKey, isClassBased);\n      stylingKey = collectStylingFromTAttrs(stylingKey, tNode.attrs, isClassBased);\n      // We know that if we have styling binding in template we can't have residual.\n      residual = null;\n    }\n  } else {\n    // We are in host binding node and there was no binding instruction in template node.\n    // This means that we need to compute the residual.\n    const directiveStylingLast = tNode.directiveStylingLast;\n    const isFirstStylingInstructionInHostBinding =\n        directiveStylingLast === -1 || tData[directiveStylingLast] !== hostDirectiveDef;\n    if (isFirstStylingInstructionInHostBinding) {\n      stylingKey =\n          collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased);\n      if (residual === null) {\n        // - If `null` than either:\n        //    - Template styling instruction already ran and it has consumed the static\n        //      styling into its `TStylingKey` and so there is no need to update residual. Instead\n        //      we need to update the `TStylingKey` associated with the first template node\n        //      instruction. OR\n        //    - Some other styling instruction ran and determined that there are no residuals\n        let templateStylingKey = getTemplateHeadTStylingKey(tData, tNode, isClassBased);\n        if (templateStylingKey !== undefined && Array.isArray(templateStylingKey)) {\n          // Only recompute if `templateStylingKey` had static values. (If no static value found\n          // then there is nothing to do since this operation can only produce less static keys, not\n          // more.)\n          templateStylingKey = collectStylingFromDirectives(\n              null, tData, tNode, templateStylingKey[1] /* unwrap previous statics */,\n              isClassBased);\n          templateStylingKey =\n              collectStylingFromTAttrs(templateStylingKey, tNode.attrs, isClassBased);\n          setTemplateHeadTStylingKey(tData, tNode, isClassBased, templateStylingKey);\n        }\n      } else {\n        // We only need to recompute residual if it is not `null`.\n        // - If existing residual (implies there was no template styling). This means that some of\n        //   the statics may have moved from the residual to the `stylingKey` and so we have to\n        //   recompute.\n        // - If `undefined` this is the first time we are running.\n        residual = collectResidual(tData, tNode, isClassBased);\n      }\n    }\n  }\n  if (residual !== undefined) {\n    isClassBased ? (tNode.residualClasses = residual) : (tNode.residualStyles = residual);\n  }\n  return stylingKey;\n}\n\n/**\n * Retrieve the `TStylingKey` for the template styling instruction.\n *\n * This is needed since `hostBinding` styling instructions are inserted after the template\n * instruction. While the template instruction needs to update the residual in `TNode` the\n * `hostBinding` instructions need to update the `TStylingKey` of the template instruction because\n * the template instruction is downstream from the `hostBindings` instructions.\n *\n * @param tData `TData` where the linked list is stored.\n * @param tNode `TNode` for which the styling is being computed.\n * @param isClassBased `true` if `class` (`false` if `style`)\n * @return `TStylingKey` if found or `undefined` if not found.\n */\nfunction getTemplateHeadTStylingKey(tData: TData, tNode: TNode, isClassBased: boolean): TStylingKey|\n    undefined {\n  const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;\n  if (getTStylingRangeNext(bindings) === 0) {\n    // There does not seem to be a styling instruction in the `template`.\n    return undefined;\n  }\n  return tData[getTStylingRangePrev(bindings)] as TStylingKey;\n}\n\n/**\n * Update the `TStylingKey` of the first template instruction in `TNode`.\n *\n * Logically `hostBindings` styling instructions are of lower priority than that of the template.\n * However, they execute after the template styling instructions. This means that they get inserted\n * in front of the template styling instructions.\n *\n * If we have a template styling instruction and a new `hostBindings` styling instruction is\n * executed it means that it may need to steal static fields from the template instruction. This\n * method allows us to update the first template instruction `TStylingKey` with a new value.\n *\n * Assume:\n * ```\n * <div my-dir style=\"color: red\" [style.color]=\"tmplExp\"></div>\n *\n * @Directive({\n *   host: {\n *     'style': 'width: 100px',\n *     '[style.color]': 'dirExp',\n *   }\n * })\n * class MyDir {}\n * ```\n *\n * when `[style.color]=\"tmplExp\"` executes it creates this data structure.\n * ```\n *  ['', 'color', 'color', 'red', 'width', '100px'],\n * ```\n *\n * The reason for this is that the template instruction does not know if there are styling\n * instructions and must assume that there are none and must collect all of the static styling.\n * (both\n * `color' and 'width`)\n *\n * When `'[style.color]': 'dirExp',` executes we need to insert a new data into the linked list.\n * ```\n *  ['', 'color', 'width', '100px'],  // newly inserted\n *  ['', 'color', 'color', 'red', 'width', '100px'], // this is wrong\n * ```\n *\n * Notice that the template statics is now wrong as it incorrectly contains `width` so we need to\n * update it like so:\n * ```\n *  ['', 'color', 'width', '100px'],\n *  ['', 'color', 'color', 'red'],    // UPDATE\n * ```\n *\n * @param tData `TData` where the linked list is stored.\n * @param tNode `TNode` for which the styling is being computed.\n * @param isClassBased `true` if `class` (`false` if `style`)\n * @param tStylingKey New `TStylingKey` which is replacing the old one.\n */\nfunction setTemplateHeadTStylingKey(\n    tData: TData, tNode: TNode, isClassBased: boolean, tStylingKey: TStylingKey): void {\n  const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;\n  ngDevMode &&\n      assertNotEqual(\n          getTStylingRangeNext(bindings), 0,\n          'Expecting to have at least one template styling binding.');\n  tData[getTStylingRangePrev(bindings)] = tStylingKey;\n}\n\n/**\n * Collect all static values after the current `TNode.directiveStylingLast` index.\n *\n * Collect the remaining styling information which has not yet been collected by an existing\n * styling instruction.\n *\n * @param tData `TData` where the `DirectiveDefs` are stored.\n * @param tNode `TNode` which contains the directive range.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nfunction collectResidual(tData: TData, tNode: TNode, isClassBased: boolean): KeyValueArray<any>|\n    null {\n  let residual: KeyValueArray<any>|null|undefined = undefined;\n  const directiveEnd = tNode.directiveEnd;\n  ngDevMode &&\n      assertNotEqual(\n          tNode.directiveStylingLast, -1,\n          'By the time this function gets called at least one hostBindings-node styling instruction must have executed.');\n  // We add `1 + tNode.directiveStart` because we need to skip the current directive (as we are\n  // collecting things after the last `hostBindings` directive which had a styling instruction.)\n  for (let i = 1 + tNode.directiveStylingLast; i < directiveEnd; i++) {\n    const attrs = (tData[i] as DirectiveDef<any>).hostAttrs;\n    residual = collectStylingFromTAttrs(residual, attrs, isClassBased) as KeyValueArray<any>| null;\n  }\n  return collectStylingFromTAttrs(residual, tNode.attrs, isClassBased) as KeyValueArray<any>| null;\n}\n\n/**\n * Collect the static styling information with lower priority than `hostDirectiveDef`.\n *\n * (This is opposite of residual styling.)\n *\n * @param hostDirectiveDef `DirectiveDef` for which we want to collect lower priority static\n *        styling. (Or `null` if template styling)\n * @param tData `TData` where the linked list is stored.\n * @param tNode `TNode` for which the styling is being computed.\n * @param stylingKey Existing `TStylingKey` to update or wrap.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nfunction collectStylingFromDirectives(\n    hostDirectiveDef: DirectiveDef<any>|null, tData: TData, tNode: TNode, stylingKey: TStylingKey,\n    isClassBased: boolean): TStylingKey {\n  // We need to loop because there can be directives which have `hostAttrs` but don't have\n  // `hostBindings` so this loop catches up to the current directive..\n  let currentDirective: DirectiveDef<any>|null = null;\n  const directiveEnd = tNode.directiveEnd;\n  let directiveStylingLast = tNode.directiveStylingLast;\n  if (directiveStylingLast === -1) {\n    directiveStylingLast = tNode.directiveStart;\n  } else {\n    directiveStylingLast++;\n  }\n  while (directiveStylingLast < directiveEnd) {\n    currentDirective = tData[directiveStylingLast] as DirectiveDef<any>;\n    ngDevMode && assertDefined(currentDirective, 'expected to be defined');\n    stylingKey = collectStylingFromTAttrs(stylingKey, currentDirective.hostAttrs, isClassBased);\n    if (currentDirective === hostDirectiveDef) break;\n    directiveStylingLast++;\n  }\n  if (hostDirectiveDef !== null) {\n    // we only advance the styling cursor if we are collecting data from host bindings.\n    // Template executes before host bindings and so if we would update the index,\n    // host bindings would not get their statics.\n    tNode.directiveStylingLast = directiveStylingLast;\n  }\n  return stylingKey;\n}\n\n/**\n * Convert `TAttrs` into `TStylingStatic`.\n *\n * @param stylingKey existing `TStylingKey` to update or wrap.\n * @param attrs `TAttributes` to process.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nfunction collectStylingFromTAttrs(\n    stylingKey: TStylingKey|undefined, attrs: TAttributes|null,\n    isClassBased: boolean): TStylingKey {\n  const desiredMarker = isClassBased ? AttributeMarker.Classes : AttributeMarker.Styles;\n  let currentMarker = AttributeMarker.ImplicitAttributes;\n  if (attrs !== null) {\n    for (let i = 0; i < attrs.length; i++) {\n      const item = attrs[i] as number | string;\n      if (typeof item === 'number') {\n        currentMarker = item;\n      } else {\n        if (currentMarker === desiredMarker) {\n          if (!Array.isArray(stylingKey)) {\n            stylingKey = stylingKey === undefined ? [] : ['', stylingKey] as any;\n          }\n          keyValueArraySet(\n              stylingKey as KeyValueArray<any>, item, isClassBased ? true : attrs[++i]);\n        }\n      }\n    }\n  }\n  return stylingKey === undefined ? null : stylingKey;\n}\n\n/**\n * Convert user input to `KeyValueArray`.\n *\n * This function takes user input which could be `string`, Object literal, or iterable and converts\n * it into a consistent representation. The output of this is `KeyValueArray` (which is an array\n * where\n * even indexes contain keys and odd indexes contain values for those keys).\n *\n * The advantage of converting to `KeyValueArray` is that we can perform diff in an input\n * independent\n * way.\n * (ie we can compare `foo bar` to `['bar', 'baz'] and determine a set of changes which need to be\n * applied)\n *\n * The fact that `KeyValueArray` is sorted is very important because it allows us to compute the\n * difference in linear fashion without the need to allocate any additional data.\n *\n * For example if we kept this as a `Map` we would have to iterate over previous `Map` to determine\n * which values need to be deleted, over the new `Map` to determine additions, and we would have to\n * keep additional `Map` to keep track of duplicates or items which have not yet been visited.\n *\n * @param keyValueArraySet (See `keyValueArraySet` in \"util/array_utils\") Gets passed in as a\n *        function so that `style` can be processed. This is done\n *        for tree shaking purposes.\n * @param stringParser The parser is passed in so that it will be tree shakable. See\n *        `styleStringParser` and `classStringParser`\n * @param value The value to parse/convert to `KeyValueArray`\n */\nexport function toStylingKeyValueArray(\n    keyValueArraySet: (keyValueArray: KeyValueArray<any>, key: string, value: any) => void,\n    stringParser: (styleKeyValueArray: KeyValueArray<any>, text: string) => void,\n    value: string|string[]|{[key: string]: any}|SafeValue|null|undefined): KeyValueArray<any> {\n  if (value == null /*|| value === undefined */ || value === '') return EMPTY_ARRAY as any;\n  const styleKeyValueArray: KeyValueArray<any> = [] as any;\n  const unwrappedValue = unwrapSafeValue(value) as string | string[] | {[key: string]: any};\n  if (Array.isArray(unwrappedValue)) {\n    for (let i = 0; i < unwrappedValue.length; i++) {\n      keyValueArraySet(styleKeyValueArray, unwrappedValue[i], true);\n    }\n  } else if (typeof unwrappedValue === 'object') {\n    for (const key in unwrappedValue) {\n      if (unwrappedValue.hasOwnProperty(key)) {\n        keyValueArraySet(styleKeyValueArray, key, unwrappedValue[key]);\n      }\n    }\n  } else if (typeof unwrappedValue === 'string') {\n    stringParser(styleKeyValueArray, unwrappedValue);\n  } else {\n    ngDevMode &&\n        throwError('Unsupported styling type ' + typeof unwrappedValue + ': ' + unwrappedValue);\n  }\n  return styleKeyValueArray;\n}\n\n/**\n * Set a `value` for a `key`.\n *\n * See: `keyValueArraySet` for details\n *\n * @param keyValueArray KeyValueArray to add to.\n * @param key Style key to add.\n * @param value The value to set.\n */\nexport function styleKeyValueArraySet(keyValueArray: KeyValueArray<any>, key: string, value: any) {\n  keyValueArraySet(keyValueArray, key, unwrapSafeValue(value));\n}\n\n/**\n * Update map based styling.\n *\n * Map based styling could be anything which contains more than one binding. For example `string`,\n * or object literal. Dealing with all of these types would complicate the logic so\n * instead this function expects that the complex input is first converted into normalized\n * `KeyValueArray`. The advantage of normalization is that we get the values sorted, which makes it\n * very cheap to compute deltas between the previous and current value.\n *\n * @param tView Associated `TView.data` contains the linked list of binding priorities.\n * @param tNode `TNode` where the binding is located.\n * @param lView `LView` contains the values associated with other styling binding at this `TNode`.\n * @param renderer Renderer to use if any updates.\n * @param oldKeyValueArray Previous value represented as `KeyValueArray`\n * @param newKeyValueArray Current value represented as `KeyValueArray`\n * @param isClassBased `true` if `class` (`false` if `style`)\n * @param bindingIndex Binding index of the binding.\n */\nfunction updateStylingMap(\n    tView: TView, tNode: TNode, lView: LView, renderer: Renderer,\n    oldKeyValueArray: KeyValueArray<any>, newKeyValueArray: KeyValueArray<any>,\n    isClassBased: boolean, bindingIndex: number) {\n  if (oldKeyValueArray as KeyValueArray<any>| NO_CHANGE === NO_CHANGE) {\n    // On first execution the oldKeyValueArray is NO_CHANGE => treat it as empty KeyValueArray.\n    oldKeyValueArray = EMPTY_ARRAY as any;\n  }\n  let oldIndex = 0;\n  let newIndex = 0;\n  let oldKey: string|null = 0 < oldKeyValueArray.length ? oldKeyValueArray[0] : null;\n  let newKey: string|null = 0 < newKeyValueArray.length ? newKeyValueArray[0] : null;\n  while (oldKey !== null || newKey !== null) {\n    ngDevMode && assertLessThan(oldIndex, 999, 'Are we stuck in infinite loop?');\n    ngDevMode && assertLessThan(newIndex, 999, 'Are we stuck in infinite loop?');\n    const oldValue =\n        oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex + 1] : undefined;\n    const newValue =\n        newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex + 1] : undefined;\n    let setKey: string|null = null;\n    let setValue: any = undefined;\n    if (oldKey === newKey) {\n      // UPDATE: Keys are equal => new value is overwriting old value.\n      oldIndex += 2;\n      newIndex += 2;\n      if (oldValue !== newValue) {\n        setKey = newKey;\n        setValue = newValue;\n      }\n    } else if (newKey === null || oldKey !== null && oldKey < newKey!) {\n      // DELETE: oldKey key is missing or we did not find the oldKey in the newValue\n      // (because the keyValueArray is sorted and `newKey` is found later alphabetically).\n      // `\"background\" < \"color\"` so we need to delete `\"background\"` because it is not found in the\n      // new array.\n      oldIndex += 2;\n      setKey = oldKey;\n    } else {\n      // CREATE: newKey's is earlier alphabetically than oldKey's (or no oldKey) => we have new key.\n      // `\"color\" > \"background\"` so we need to add `color` because it is in new array but not in\n      // old array.\n      ngDevMode && assertDefined(newKey, 'Expecting to have a valid key');\n      newIndex += 2;\n      setKey = newKey;\n      setValue = newValue;\n    }\n    if (setKey !== null) {\n      updateStyling(tView, tNode, lView, renderer, setKey, setValue, isClassBased, bindingIndex);\n    }\n    oldKey = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex] : null;\n    newKey = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex] : null;\n  }\n}\n\n/**\n * Update a simple (property name) styling.\n *\n * This function takes `prop` and updates the DOM to that value. The function takes the binding\n * value as well as binding priority into consideration to determine which value should be written\n * to DOM. (For example it may be determined that there is a higher priority overwrite which blocks\n * the DOM write, or if the value goes to `undefined` a lower priority overwrite may be consulted.)\n *\n * @param tView Associated `TView.data` contains the linked list of binding priorities.\n * @param tNode `TNode` where the binding is located.\n * @param lView `LView` contains the values associated with other styling binding at this `TNode`.\n * @param renderer Renderer to use if any updates.\n * @param prop Either style property name or a class name.\n * @param value Either style value for `prop` or `true`/`false` if `prop` is class.\n * @param isClassBased `true` if `class` (`false` if `style`)\n * @param bindingIndex Binding index of the binding.\n */\nfunction updateStyling(\n    tView: TView, tNode: TNode, lView: LView, renderer: Renderer, prop: string,\n    value: string|undefined|null|boolean, isClassBased: boolean, bindingIndex: number) {\n  if (!(tNode.type & TNodeType.AnyRNode)) {\n    // It is possible to have styling on non-elements (such as ng-container).\n    // This is rare, but it does happen. In such a case, just ignore the binding.\n    return;\n  }\n  const tData = tView.data;\n  const tRange = tData[bindingIndex + 1] as TStylingRange;\n  const higherPriorityValue = getTStylingRangeNextDuplicate(tRange) ?\n      findStylingValue(tData, tNode, lView, prop, getTStylingRangeNext(tRange), isClassBased) :\n      undefined;\n  if (!isStylingValuePresent(higherPriorityValue)) {\n    // We don't have a next duplicate, or we did not find a duplicate value.\n    if (!isStylingValuePresent(value)) {\n      // We should delete current value or restore to lower priority value.\n      if (getTStylingRangePrevDuplicate(tRange)) {\n        // We have a possible prev duplicate, let's retrieve it.\n        value = findStylingValue(tData, null, lView, prop, bindingIndex, isClassBased);\n      }\n    }\n    const rNode = getNativeByIndex(getSelectedIndex(), lView) as RElement;\n    applyStyling(renderer, isClassBased, rNode, prop, value);\n  }\n}\n\n/**\n * Search for styling value with higher priority which is overwriting current value, or a\n * value of lower priority to which we should fall back if the value is `undefined`.\n *\n * When value is being applied at a location, related values need to be consulted.\n * - If there is a higher priority binding, we should be using that one instead.\n *   For example `<div  [style]=\"{color:exp1}\" [style.color]=\"exp2\">` change to `exp1`\n *   requires that we check `exp2` to see if it is set to value other than `undefined`.\n * - If there is a lower priority binding and we are changing to `undefined`\n *   For example `<div  [style]=\"{color:exp1}\" [style.color]=\"exp2\">` change to `exp2` to\n *   `undefined` requires that we check `exp1` (and static values) and use that as new value.\n *\n * NOTE: The styling stores two values.\n * 1. The raw value which came from the application is stored at `index + 0` location. (This value\n *    is used for dirty checking).\n * 2. The normalized value is stored at `index + 1`.\n *\n * @param tData `TData` used for traversing the priority.\n * @param tNode `TNode` to use for resolving static styling. Also controls search direction.\n *   - `TNode` search next and quit as soon as `isStylingValuePresent(value)` is true.\n *      If no value found consult `tNode.residualStyle`/`tNode.residualClass` for default value.\n *   - `null` search prev and go all the way to end. Return last value where\n *     `isStylingValuePresent(value)` is true.\n * @param lView `LView` used for retrieving the actual values.\n * @param prop Property which we are interested in.\n * @param index Starting index in the linked list of styling bindings where the search should start.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nfunction findStylingValue(\n    tData: TData, tNode: TNode|null, lView: LView, prop: string, index: number,\n    isClassBased: boolean): any {\n  // `TNode` to use for resolving static styling. Also controls search direction.\n  //   - `TNode` search next and quit as soon as `isStylingValuePresent(value)` is true.\n  //      If no value found consult `tNode.residualStyle`/`tNode.residualClass` for default value.\n  //   - `null` search prev and go all the way to end. Return last value where\n  //     `isStylingValuePresent(value)` is true.\n  const isPrevDirection = tNode === null;\n  let value: any = undefined;\n  while (index > 0) {\n    const rawKey = tData[index] as TStylingKey;\n    const containsStatics = Array.isArray(rawKey);\n    // Unwrap the key if we contain static values.\n    const key = containsStatics ? (rawKey as string[])[1] : rawKey;\n    const isStylingMap = key === null;\n    let valueAtLViewIndex = lView[index + 1];\n    if (valueAtLViewIndex === NO_CHANGE) {\n      // In firstUpdatePass the styling instructions create a linked list of styling.\n      // On subsequent passes it is possible for a styling instruction to try to read a binding\n      // which\n      // has not yet executed. In that case we will find `NO_CHANGE` and we should assume that\n      // we have `undefined` (or empty array in case of styling-map instruction) instead. This\n      // allows the resolution to apply the value (which may later be overwritten when the\n      // binding actually executes.)\n      valueAtLViewIndex = isStylingMap ? EMPTY_ARRAY : undefined;\n    }\n    let currentValue = isStylingMap ? keyValueArrayGet(valueAtLViewIndex, prop) :\n                                      (key === prop ? valueAtLViewIndex : undefined);\n    if (containsStatics && !isStylingValuePresent(currentValue)) {\n      currentValue = keyValueArrayGet(rawKey as KeyValueArray<any>, prop);\n    }\n    if (isStylingValuePresent(currentValue)) {\n      value = currentValue;\n      if (isPrevDirection) {\n        return value;\n      }\n    }\n    const tRange = tData[index + 1] as TStylingRange;\n    index = isPrevDirection ? getTStylingRangePrev(tRange) : getTStylingRangeNext(tRange);\n  }\n  if (tNode !== null) {\n    // in case where we are going in next direction AND we did not find anything, we need to\n    // consult residual styling\n    let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;\n    if (residual != null /** OR residual !=== undefined */) {\n      value = keyValueArrayGet(residual!, prop);\n    }\n  }\n  return value;\n}\n\n/**\n * Determines if the binding value should be used (or if the value is 'undefined' and hence priority\n * resolution should be used.)\n *\n * @param value Binding style value.\n */\nfunction isStylingValuePresent(value: any): boolean {\n  // Currently only `undefined` value is considered non-binding. That is `undefined` says I don't\n  // have an opinion as to what this binding should be and you should consult other bindings by\n  // priority to determine the valid value.\n  // This is extracted into a single function so that we have a single place to control this.\n  return value !== undefined;\n}\n\n/**\n * Normalizes and/or adds a suffix to the value.\n *\n * If value is `null`/`undefined` no suffix is added\n * @param value\n * @param suffix\n */\nfunction normalizeSuffix(value: any, suffix: string|undefined|null): string|null|undefined|boolean {\n  if (value == null /** || value === undefined */) {\n    // do nothing\n  } else if (typeof suffix === 'string') {\n    value = value + suffix;\n  } else if (typeof value === 'object') {\n    value = stringify(unwrapSafeValue(value));\n  }\n  return value;\n}\n\n\n/**\n * Tests if the `TNode` has input shadow.\n *\n * An input shadow is when a directive steals (shadows) the input by using `@Input('style')` or\n * `@Input('class')` as input.\n *\n * @param tNode `TNode` which we would like to see if it has shadow.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nexport function hasStylingInputShadow(tNode: TNode, isClassBased: boolean) {\n  return (tNode.flags & (isClassBased ? TNodeFlags.hasClassInput : TNodeFlags.hasStyleInput)) !== 0;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {assertEqual, assertIndexInRange} from '../../util/assert';\nimport {TElementNode, TNodeType} from '../interfaces/node';\nimport {HEADER_OFFSET, RENDERER, T_HOST} from '../interfaces/view';\nimport {appendChild, createTextNode} from '../node_manipulation';\nimport {getBindingIndex, getLView, getTView, setCurrentTNode} from '../state';\n\nimport {getOrCreateTNode} from './shared';\n\n\n\n/**\n * Create static text node\n *\n * @param index Index of the node in the data array\n * @param value Static string value to write.\n *\n * @codeGenApi\n */\nexport function ɵɵtext(index: number, value: string = ''): void {\n  const lView = getLView();\n  const tView = getTView();\n  const adjustedIndex = index + HEADER_OFFSET;\n\n  ngDevMode &&\n      assertEqual(\n          getBindingIndex(), tView.bindingStartIndex,\n          'text nodes should be created before any bindings');\n  ngDevMode && assertIndexInRange(lView, adjustedIndex);\n\n  const tNode = tView.firstCreatePass ?\n      getOrCreateTNode(tView, adjustedIndex, TNodeType.Text, value, null) :\n      tView.data[adjustedIndex] as TElementNode;\n\n  const textNative = lView[adjustedIndex] = createTextNode(lView[RENDERER], value);\n  appendChild(tView, lView, textNative, tNode);\n\n  // Text nodes are self closing.\n  setCurrentTNode(tNode, false);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {getLView, getSelectedIndex} from '../state';\nimport {NO_CHANGE} from '../tokens';\n\nimport {interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV} from './interpolation';\nimport {textBindingInternal} from './shared';\n\n\n/**\n *\n * Update text content with a lone bound value\n *\n * Used when a text node has 1 interpolated value in it, an no additional text\n * surrounds that interpolated value:\n *\n * ```html\n * <div>{{v0}}</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate(v0);\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nexport function ɵɵtextInterpolate(v0: any): typeof ɵɵtextInterpolate {\n  ɵɵtextInterpolate1('', v0, '');\n  return ɵɵtextInterpolate;\n}\n\n\n/**\n *\n * Update text content with single bound value surrounded by other text.\n *\n * Used when a text node has 1 interpolated value in it:\n *\n * ```html\n * <div>prefix{{v0}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate1('prefix', v0, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nexport function ɵɵtextInterpolate1(\n    prefix: string, v0: any, suffix: string): typeof ɵɵtextInterpolate1 {\n  const lView = getLView();\n  const interpolated = interpolation1(lView, prefix, v0, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated as string);\n  }\n  return ɵɵtextInterpolate1;\n}\n\n/**\n *\n * Update text content with 2 bound values surrounded by other text.\n *\n * Used when a text node has 2 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate2('prefix', v0, '-', v1, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nexport function ɵɵtextInterpolate2(\n    prefix: string, v0: any, i0: string, v1: any, suffix: string): typeof ɵɵtextInterpolate2 {\n  const lView = getLView();\n  const interpolated = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated as string);\n  }\n  return ɵɵtextInterpolate2;\n}\n\n/**\n *\n * Update text content with 3 bound values surrounded by other text.\n *\n * Used when a text node has 3 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate3(\n * 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nexport function ɵɵtextInterpolate3(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any,\n    suffix: string): typeof ɵɵtextInterpolate3 {\n  const lView = getLView();\n  const interpolated = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated as string);\n  }\n  return ɵɵtextInterpolate3;\n}\n\n/**\n *\n * Update text content with 4 bound values surrounded by other text.\n *\n * Used when a text node has 4 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate4(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see ɵɵtextInterpolateV\n * @codeGenApi\n */\nexport function ɵɵtextInterpolate4(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    suffix: string): typeof ɵɵtextInterpolate4 {\n  const lView = getLView();\n  const interpolated = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated as string);\n  }\n  return ɵɵtextInterpolate4;\n}\n\n/**\n *\n * Update text content with 5 bound values surrounded by other text.\n *\n * Used when a text node has 5 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate5(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nexport function ɵɵtextInterpolate5(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, suffix: string): typeof ɵɵtextInterpolate5 {\n  const lView = getLView();\n  const interpolated = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated as string);\n  }\n  return ɵɵtextInterpolate5;\n}\n\n/**\n *\n * Update text content with 6 bound values surrounded by other text.\n *\n * Used when a text node has 6 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate6(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change. @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nexport function ɵɵtextInterpolate6(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, suffix: string): typeof ɵɵtextInterpolate6 {\n  const lView = getLView();\n  const interpolated =\n      interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated as string);\n  }\n  return ɵɵtextInterpolate6;\n}\n\n/**\n *\n * Update text content with 7 bound values surrounded by other text.\n *\n * Used when a text node has 7 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate7(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nexport function ɵɵtextInterpolate7(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any,\n    suffix: string): typeof ɵɵtextInterpolate7 {\n  const lView = getLView();\n  const interpolated =\n      interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated as string);\n  }\n  return ɵɵtextInterpolate7;\n}\n\n/**\n *\n * Update text content with 8 bound values surrounded by other text.\n *\n * Used when a text node has 8 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate8(\n *  'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nexport function ɵɵtextInterpolate8(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string): typeof ɵɵtextInterpolate8 {\n  const lView = getLView();\n  const interpolated = interpolation8(\n      lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated as string);\n  }\n  return ɵɵtextInterpolate8;\n}\n\n/**\n * Update text content with 9 or more bound values other surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolateV(\n *  ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *.\n * @param values The collection of values and the strings in between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n *\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵtextInterpolateV(values: any[]): typeof ɵɵtextInterpolateV {\n  const lView = getLView();\n  const interpolated = interpolationV(lView, values);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated as string);\n  }\n  return ɵɵtextInterpolateV;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {keyValueArraySet} from '../../util/array_utils';\nimport {getLView} from '../state';\nimport {interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV} from './interpolation';\nimport {checkStylingMap, classStringParser} from './styling';\n\n\n\n/**\n *\n * Update an interpolated class on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate1('prefix', v0, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate1(prefix: string, v0: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate2('prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate2(\n    prefix: string, v0: any, i0: string, v1: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate3(\n * 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate3(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate4(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate4(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate5(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate5(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate6(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate6(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate7(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate7(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate8(\n *  'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate8(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(\n      lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n * Update an interpolated class on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolateV(\n *  ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *.\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolateV(values: any[]): void {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getLView} from '../state';\nimport {interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV} from './interpolation';\nimport {ɵɵstyleMap} from './styling';\n\n\n/**\n *\n * Update an interpolated style on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div style=\"key: {{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate1('key: ', v0, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵstyleMapInterpolate1(prefix: string, v0: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate2('key: ', v0, '; key1: ', v1, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵstyleMapInterpolate2(\n    prefix: string, v0: any, i0: string, v1: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key2: {{v1}}; key2: {{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate3(\n *     'key: ', v0, '; key1: ', v1, '; key2: ', v2, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵstyleMapInterpolate3(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate4(\n *     'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵstyleMapInterpolate4(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate5(\n *     'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵstyleMapInterpolate5(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}};\n *             key5: {{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate6(\n *    'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *    'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵstyleMapInterpolate6(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}; key5: {{v5}};\n *             key6: {{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate7(\n *    'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *    '; key6: ', v6, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵstyleMapInterpolate7(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}; key5: {{v5}};\n *             key6: {{v6}}; key7: {{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate8(\n *    'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *    '; key6: ', v6, '; key7: ', v7, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵstyleMapInterpolate8(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(\n      lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n\n/**\n * Update an interpolated style on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  class=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}; key5: {{v5}};\n *         key6: {{v6}}; key7: {{v7}}; key8: {{v8}}; key9: {{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolateV(\n *    ['key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *     '; key6: ', v6, '; key7: ', v7, '; key8: ', v8, '; key9: ', v9, 'suffix']);\n * ```\n *.\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '; key2: ', value1, '; key2: ', value2, ..., value99, 'suffix']`)\n * @codeGenApi\n */\nexport function ɵɵstyleMapInterpolateV(values: any[]): void {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n  ɵɵstyleMap(interpolatedValue);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getLView,} from '../state';\nimport {interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV} from './interpolation';\nimport {checkStylingProperty} from './styling';\n\n\n/**\n *\n * Update an interpolated style property on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate1(0, 'prefix', v0, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵstylePropInterpolate1(\n    prop: string, prefix: string, v0: any, suffix: string,\n    valueSuffix?: string|null): typeof ɵɵstylePropInterpolate1 {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate1;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate2(0, 'prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵstylePropInterpolate2(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, suffix: string,\n    valueSuffix?: string|null): typeof ɵɵstylePropInterpolate2 {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate2;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate3(0, 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵstylePropInterpolate3(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, suffix: string,\n    valueSuffix?: string|null): typeof ɵɵstylePropInterpolate3 {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate3;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate4(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵstylePropInterpolate4(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, suffix: string, valueSuffix?: string|null): typeof ɵɵstylePropInterpolate4 {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate4;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate5(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵstylePropInterpolate5(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, suffix: string,\n    valueSuffix?: string|null): typeof ɵɵstylePropInterpolate5 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate5;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate6(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵstylePropInterpolate6(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, suffix: string,\n    valueSuffix?: string|null): typeof ɵɵstylePropInterpolate6 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate6;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate7(\n *    0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵstylePropInterpolate7(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string,\n    valueSuffix?: string|null): typeof ɵɵstylePropInterpolate7 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate7;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate8(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6,\n * '-', v7, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵstylePropInterpolate8(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string, valueSuffix?: string|null): typeof ɵɵstylePropInterpolate8 {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(\n      lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate8;\n}\n\n/**\n * Update an interpolated style property on an element with 9 or more bound values surrounded by\n * text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\">\n * </div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolateV(\n *  0, ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`..\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵstylePropInterpolateV(\n    prop: string, values: any[], valueSuffix?: string|null): typeof ɵɵstylePropInterpolateV {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolateV;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {bindingUpdated} from '../bindings';\nimport {SanitizerFn} from '../interfaces/sanitization';\nimport {RENDERER} from '../interfaces/view';\nimport {getCurrentDirectiveDef, getLView, getSelectedTNode, getTView, nextBindingIndex} from '../state';\nimport {NO_CHANGE} from '../tokens';\n\nimport {elementPropertyInternal, loadComponentRenderer, storePropertyBindingMetadata} from './shared';\n\n/**\n * Update a property on a host element. Only applies to native node properties, not inputs.\n *\n * Operates on the element selected by index via the {@link select} instruction.\n *\n * @param propName Name of property. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n * @returns This function returns itself so that it may be chained\n * (e.g. `property('name', ctx.name)('title', ctx.title)`)\n *\n * @codeGenApi\n */\nexport function ɵɵhostProperty<T>(\n    propName: string, value: T, sanitizer?: SanitizerFn|null): typeof ɵɵhostProperty {\n  const lView = getLView();\n  const bindingIndex = nextBindingIndex();\n  if (bindingUpdated(lView, bindingIndex, value)) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, true);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);\n  }\n  return ɵɵhostProperty;\n}\n\n\n/**\n * Updates a synthetic host binding (e.g. `[@foo]`) on a component or directive.\n *\n * This instruction is for compatibility purposes and is designed to ensure that a\n * synthetic host binding (e.g. `@HostBinding('@foo')`) properly gets rendered in\n * the component's renderer. Normally all host bindings are evaluated with the parent\n * component's renderer, but, in the case of animation @triggers, they need to be\n * evaluated with the sub component's renderer (because that's where the animation\n * triggers are defined).\n *\n * Do not use this instruction as a replacement for `elementProperty`. This instruction\n * only exists to ensure compatibility with the ViewEngine's host binding behavior.\n *\n * @param index The index of the element to update in the data array\n * @param propName Name of property. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n *\n * @codeGenApi\n */\nexport function ɵɵsyntheticHostProperty<T>(\n    propName: string, value: T|NO_CHANGE,\n    sanitizer?: SanitizerFn|null): typeof ɵɵsyntheticHostProperty {\n  const lView = getLView();\n  const bindingIndex = nextBindingIndex();\n  if (bindingUpdated(lView, bindingIndex, value)) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    const currentDef = getCurrentDirectiveDef(tView.data);\n    const renderer = loadComponentRenderer(currentDef, tNode, lView);\n    elementPropertyInternal(tView, tNode, lView, propName, value, renderer, sanitizer, true);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);\n  }\n  return ɵɵsyntheticHostProperty;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {global} from './global';\n\ndeclare global {\n  const ngI18nClosureMode: boolean;\n}\n\n/**\n * NOTE: changes to the `ngI18nClosureMode` name must be synced with `compiler-cli/src/tooling.ts`.\n */\nif (typeof ngI18nClosureMode === 'undefined') {\n  // These property accesses can be ignored because ngI18nClosureMode will be set to false\n  // when optimizing code and the whole if statement will be dropped.\n  // Make sure to refer to ngI18nClosureMode as ['ngI18nClosureMode'] for closure.\n  // NOTE: we need to have it in IIFE so that the tree-shaker is happy.\n  (function() {\n    // tslint:disable-next-line:no-toplevel-property-access\n    global['ngI18nClosureMode'] =\n        // TODO(FW-1250): validate that this actually, you know, works.\n        // tslint:disable-next-line:no-toplevel-property-access\n        typeof goog !== 'undefined' && typeof goog.getMsg === 'function';\n  })();\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// THIS CODE IS GENERATED - DO NOT MODIFY.\nconst u = undefined;\n\nfunction plural(val: number): number {\nconst n = val, i = Math.floor(Math.abs(val)), v = val.toString().replace(/^[^.]*\\.?/, '').length;\n\nif (i === 1 && v === 0)\n    return 1;\nreturn 5;\n}\n\nexport default [\"en\",[[\"a\",\"p\"],[\"AM\",\"PM\"],u],[[\"AM\",\"PM\"],u,u],[[\"S\",\"M\",\"T\",\"W\",\"T\",\"F\",\"S\"],[\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\"],[\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"],[\"Su\",\"Mo\",\"Tu\",\"We\",\"Th\",\"Fr\",\"Sa\"]],u,[[\"J\",\"F\",\"M\",\"A\",\"M\",\"J\",\"J\",\"A\",\"S\",\"O\",\"N\",\"D\"],[\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"],[\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"]],u,[[\"B\",\"A\"],[\"BC\",\"AD\"],[\"Before Christ\",\"Anno Domini\"]],0,[6,0],[\"M/d/yy\",\"MMM d, y\",\"MMMM d, y\",\"EEEE, MMMM d, y\"],[\"h:mm a\",\"h:mm:ss a\",\"h:mm:ss a z\",\"h:mm:ss a zzzz\"],[\"{1}, {0}\",u,\"{1} 'at' {0}\",u],[\".\",\",\",\";\",\"%\",\"+\",\"-\",\"E\",\"×\",\"‰\",\"∞\",\"NaN\",\":\"],[\"#,##0.###\",\"#,##0%\",\"¤#,##0.00\",\"#E0\"],\"USD\",\"$\",\"US Dollar\",{},\"ltr\", plural];\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {RuntimeError, RuntimeErrorCode} from '../errors';\nimport {global} from '../util/global';\n\nimport localeEn from './locale_en';\n\n/**\n * This const is used to store the locale data registered with `registerLocaleData`\n */\nlet LOCALE_DATA: {[localeId: string]: any} = {};\n\n/**\n * Register locale data to be used internally by Angular. See the\n * [\"I18n guide\"](guide/i18n-common-format-data-locale) to know how to import additional locale\n * data.\n *\n * The signature `registerLocaleData(data: any, extraData?: any)` is deprecated since v5.1\n */\nexport function registerLocaleData(data: any, localeId?: string|any, extraData?: any): void {\n  if (typeof localeId !== 'string') {\n    extraData = localeId;\n    localeId = data[LocaleDataIndex.LocaleId];\n  }\n\n  localeId = localeId.toLowerCase().replace(/_/g, '-');\n\n  LOCALE_DATA[localeId] = data;\n\n  if (extraData) {\n    LOCALE_DATA[localeId][LocaleDataIndex.ExtraData] = extraData;\n  }\n}\n\n/**\n * Finds the locale data for a given locale.\n *\n * @param locale The locale code.\n * @returns The locale data.\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n-overview)\n */\nexport function findLocaleData(locale: string): any {\n  const normalizedLocale = normalizeLocale(locale);\n\n  let match = getLocaleData(normalizedLocale);\n  if (match) {\n    return match;\n  }\n\n  // let's try to find a parent locale\n  const parentLocale = normalizedLocale.split('-')[0];\n  match = getLocaleData(parentLocale);\n  if (match) {\n    return match;\n  }\n\n  if (parentLocale === 'en') {\n    return localeEn;\n  }\n\n  throw new RuntimeError(\n      RuntimeErrorCode.MISSING_LOCALE_DATA,\n      ngDevMode && `Missing locale data for the locale \"${locale}\".`);\n}\n\n/**\n * Retrieves the default currency code for the given locale.\n *\n * The default is defined as the first currency which is still in use.\n *\n * @param locale The code of the locale whose currency code we want.\n * @returns The code of the default currency for the given locale.\n *\n */\nexport function getLocaleCurrencyCode(locale: string): string|null {\n  const data = findLocaleData(locale);\n  return data[LocaleDataIndex.CurrencyCode] || null;\n}\n\n/**\n * Retrieves the plural function used by ICU expressions to determine the plural case to use\n * for a given locale.\n * @param locale A locale code for the locale format rules to use.\n * @returns The plural function for the locale.\n * @see `NgPlural`\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n-overview)\n */\nexport function getLocalePluralCase(locale: string): (value: number) => number {\n  const data = findLocaleData(locale);\n  return data[LocaleDataIndex.PluralCase];\n}\n\n\n\n/**\n * Helper function to get the given `normalizedLocale` from `LOCALE_DATA`\n * or from the global `ng.common.locale`.\n */\nexport function getLocaleData(normalizedLocale: string): any {\n  if (!(normalizedLocale in LOCALE_DATA)) {\n    LOCALE_DATA[normalizedLocale] = global.ng && global.ng.common && global.ng.common.locales &&\n        global.ng.common.locales[normalizedLocale];\n  }\n  return LOCALE_DATA[normalizedLocale];\n}\n\n/**\n * Helper function to remove all the locale data from `LOCALE_DATA`.\n */\nexport function unregisterAllLocaleData() {\n  LOCALE_DATA = {};\n}\n\n/**\n * Index of each type of locale data from the locale data array\n */\nexport enum LocaleDataIndex {\n  LocaleId = 0,\n  DayPeriodsFormat,\n  DayPeriodsStandalone,\n  DaysFormat,\n  DaysStandalone,\n  MonthsFormat,\n  MonthsStandalone,\n  Eras,\n  FirstDayOfWeek,\n  WeekendRange,\n  DateFormat,\n  TimeFormat,\n  DateTimeFormat,\n  NumberSymbols,\n  NumberFormats,\n  CurrencyCode,\n  CurrencySymbol,\n  CurrencyName,\n  Currencies,\n  Directionality,\n  PluralCase,\n  ExtraData\n}\n\n/**\n * Index of each type of locale data from the extra locale data array\n */\nexport const enum ExtraLocaleDataIndex {\n  ExtraDayPeriodFormats = 0,\n  ExtraDayPeriodStandalone,\n  ExtraDayPeriodsRules\n}\n\n/**\n * Index of each value in currency data (used to describe CURRENCIES_EN in currencies.ts)\n */\nexport const enum CurrencyIndex {\n  Symbol = 0,\n  SymbolNarrow,\n  NbOfDigits\n}\n\n/**\n * Returns the canonical form of a locale name - lowercase with `_` replaced with `-`.\n */\nfunction normalizeLocale(locale: string): string {\n  return locale.toLowerCase().replace(/_/g, '-');\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getLocalePluralCase} from './locale_data_api';\n\nconst pluralMapping = ['zero', 'one', 'two', 'few', 'many'];\n\n/**\n * Returns the plural case based on the locale\n */\nexport function getPluralCase(value: string, locale: string): string {\n  const plural = getLocalePluralCase(locale)(parseInt(value, 10));\n  const result = pluralMapping[plural];\n  return (result !== undefined) ? result : 'other';\n}\n\n/**\n * The locale id that the application is using by default (for translations and ICU expressions).\n */\nexport const DEFAULT_LOCALE_ID = 'en-US';\n\n/**\n * USD currency code that the application uses by default for CurrencyPipe when no\n * DEFAULT_CURRENCY_CODE is provided.\n */\nexport const USD_CURRENCY_CODE = 'USD';\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SanitizerFn} from './sanitization';\n\n\n/**\n * Stores a list of nodes which need to be removed.\n *\n * Numbers are indexes into the `LView`\n * - index > 0: `removeRNode(lView[0])`\n * - index < 0: `removeICU(~lView[0])`\n */\nexport interface I18nRemoveOpCodes extends Array<number> {\n  __brand__: 'I18nRemoveOpCodes';\n}\n\n/**\n * `I18nMutateOpCode` defines OpCodes for `I18nMutateOpCodes` array.\n *\n * OpCodes are efficient operations which can be applied to the DOM to update it. (For example to\n * update to a new ICU case requires that we clean up previous elements and create new ones.)\n *\n * OpCodes contain three parts:\n *  1) Parent node index offset. (p)\n *  2) Reference node index offset. (r)\n *  3) The instruction to execute. (i)\n *\n * pppp pppp pppp pppp rrrr rrrr rrrr riii\n * 3322 2222 2222 1111 1111 1110 0000 0000\n * 1098 7654 3210 9876 5432 1098 7654 3210\n *\n * ```\n * var parent = lView[opCode >>> SHIFT_PARENT];\n * var refNode = lView[((opCode & MASK_REF) >>> SHIFT_REF)];\n * var instruction = opCode & MASK_OPCODE;\n * ```\n *\n * See: `I18nCreateOpCodes` for example of usage.\n */\nexport const enum IcuCreateOpCode {\n  /**\n   * Stores shift amount for bits 17-3 that contain reference index.\n   */\n  SHIFT_REF = 1,\n  /**\n   * Stores shift amount for bits 31-17 that contain parent index.\n   */\n  SHIFT_PARENT = 17,\n  /**\n   * Mask for OpCode\n   */\n  MASK_INSTRUCTION = 0b1,\n\n  /**\n   * Mask for the Reference node (bits 16-3)\n   */\n  MASK_REF = 0b11111111111111110,\n  //           11111110000000000\n  //           65432109876543210\n\n  /**\n   * Instruction to append the current node to `PARENT`.\n   */\n  AppendChild = 0b0,\n\n  /**\n   * Instruction to set the attribute of a node.\n   */\n  Attr = 0b1,\n}\n\n\n/**\n * Array storing OpCode for dynamically creating `i18n` blocks.\n *\n * Example:\n * ```ts\n * <I18nCreateOpCode>[\n *   // For adding text nodes\n *   // ---------------------\n *   // Equivalent to:\n *   //   lView[1].appendChild(lView[0] = document.createTextNode('xyz'));\n *   'xyz', 0, 1 << SHIFT_PARENT | 0 << SHIFT_REF | AppendChild,\n *\n *   // For adding element nodes\n *   // ---------------------\n *   // Equivalent to:\n *   //   lView[1].appendChild(lView[0] = document.createElement('div'));\n *   ELEMENT_MARKER, 'div', 0, 1 << SHIFT_PARENT | 0 << SHIFT_REF | AppendChild,\n *\n *   // For adding comment nodes\n *   // ---------------------\n *   // Equivalent to:\n *   //   lView[1].appendChild(lView[0] = document.createComment(''));\n *   ICU_MARKER, '', 0, 1 << SHIFT_PARENT | 0 << SHIFT_REF | AppendChild,\n *\n *   // For moving existing nodes to a different location\n *   // --------------------------------------------------\n *   // Equivalent to:\n *   //   const node = lView[1];\n *   //   lView[2].appendChild(node);\n *   1 << SHIFT_REF | Select, 2 << SHIFT_PARENT | 0 << SHIFT_REF | AppendChild,\n *\n *   // For removing existing nodes\n *   // --------------------------------------------------\n *   //   const node = lView[1];\n *   //   removeChild(tView.data(1), node, lView);\n *   1 << SHIFT_REF | Remove,\n *\n *   // For writing attributes\n *   // --------------------------------------------------\n *   //   const node = lView[1];\n *   //   node.setAttribute('attr', 'value');\n *   1 << SHIFT_REF | Attr, 'attr', 'value'\n * ];\n * ```\n */\nexport interface IcuCreateOpCodes extends Array<number|string|ELEMENT_MARKER|ICU_MARKER|null>,\n                                          I18nDebug {\n  __brand__: 'I18nCreateOpCodes';\n}\n\nexport const enum I18nUpdateOpCode {\n  /**\n   * Stores shift amount for bits 17-2 that contain reference index.\n   */\n  SHIFT_REF = 2,\n  /**\n   * Mask for OpCode\n   */\n  MASK_OPCODE = 0b11,\n\n  /**\n   * Instruction to update a text node.\n   */\n  Text = 0b00,\n  /**\n   * Instruction to update a attribute of a node.\n   */\n  Attr = 0b01,\n  /**\n   * Instruction to switch the current ICU case.\n   */\n  IcuSwitch = 0b10,\n  /**\n   * Instruction to update the current ICU case.\n   */\n  IcuUpdate = 0b11,\n}\n\n/**\n * Marks that the next string is an element name.\n *\n * See `I18nMutateOpCodes` documentation.\n */\nexport const ELEMENT_MARKER: ELEMENT_MARKER = {\n  marker: 'element'\n};\nexport interface ELEMENT_MARKER {\n  marker: 'element';\n}\n\n/**\n * Marks that the next string is comment text need for ICU.\n *\n * See `I18nMutateOpCodes` documentation.\n */\nexport const ICU_MARKER: ICU_MARKER = {\n  marker: 'ICU'\n};\n\nexport interface ICU_MARKER {\n  marker: 'ICU';\n}\n\nexport interface I18nDebug {\n  /**\n   * Human readable representation of the OpCode arrays.\n   *\n   * NOTE: This property only exists if `ngDevMode` is set to `true` and it is not present in\n   * production. Its presence is purely to help debug issue in development, and should not be relied\n   * on in production application.\n   */\n  debug?: string[];\n}\n\n/**\n * Array storing OpCode for dynamically creating `i18n` translation DOM elements.\n *\n * This array creates a sequence of `Text` and `Comment` (as ICU anchor) DOM elements. It consists\n * of a pair of `number` and `string` pairs which encode the operations for the creation of the\n * translated block.\n *\n * The number is shifted and encoded according to `I18nCreateOpCode`\n *\n * Pseudocode:\n * ```\n * const i18nCreateOpCodes = [\n *   10 << I18nCreateOpCode.SHIFT, \"Text Node add to DOM\",\n *   11 << I18nCreateOpCode.SHIFT | I18nCreateOpCode.COMMENT, \"Comment Node add to DOM\",\n *   12 << I18nCreateOpCode.SHIFT | I18nCreateOpCode.APPEND_LATER, \"Text Node added later\"\n * ];\n *\n * for(var i=0; i<i18nCreateOpCodes.length; i++) {\n *   const opcode = i18NCreateOpCodes[i++];\n *   const index = opcode >> I18nCreateOpCode.SHIFT;\n *   const text = i18NCreateOpCodes[i];\n *   let node: Text|Comment;\n *   if (opcode & I18nCreateOpCode.COMMENT === I18nCreateOpCode.COMMENT) {\n *     node = lView[~index] = document.createComment(text);\n *   } else {\n *     node = lView[index] = document.createText(text);\n *   }\n *   if (opcode & I18nCreateOpCode.APPEND_EAGERLY !== I18nCreateOpCode.APPEND_EAGERLY) {\n *     parentNode.appendChild(node);\n *   }\n * }\n * ```\n */\nexport interface I18nCreateOpCodes extends Array<number|string>, I18nDebug {\n  __brand__: 'I18nCreateOpCodes';\n}\n\n/**\n * See `I18nCreateOpCodes`\n */\nexport enum I18nCreateOpCode {\n  /**\n   * Number of bits to shift index so that it can be combined with the `APPEND_EAGERLY` and\n   * `COMMENT`.\n   */\n  SHIFT = 2,\n\n  /**\n   * Should the node be appended to parent immediately after creation.\n   */\n  APPEND_EAGERLY = 0b01,\n\n  /**\n   * If set the node should be comment (rather than a text) node.\n   */\n  COMMENT = 0b10,\n}\n\n\n/**\n * Stores DOM operations which need to be applied to update DOM render tree due to changes in\n * expressions.\n *\n * The basic idea is that `i18nExp` OpCodes capture expression changes and update a change\n * mask bit. (Bit 1 for expression 1, bit 2 for expression 2 etc..., bit 32 for expression 32 and\n * higher.) The OpCodes then compare its own change mask against the expression change mask to\n * determine if the OpCodes should execute.\n *\n * NOTE: 32nd bit is special as it says 32nd or higher. This way if we have more than 32 bindings\n * the code still works, but with lower efficiency. (it is unlikely that a translation would have\n * more than 32 bindings.)\n *\n * These OpCodes can be used by both the i18n block as well as ICU sub-block.\n *\n * ## Example\n *\n * Assume\n * ```ts\n *   if (rf & RenderFlags.Update) {\n *    i18nExp(ctx.exp1); // If changed set mask bit 1\n *    i18nExp(ctx.exp2); // If changed set mask bit 2\n *    i18nExp(ctx.exp3); // If changed set mask bit 3\n *    i18nExp(ctx.exp4); // If changed set mask bit 4\n *    i18nApply(0);            // Apply all changes by executing the OpCodes.\n *  }\n * ```\n * We can assume that each call to `i18nExp` sets an internal `changeMask` bit depending on the\n * index of `i18nExp`.\n *\n * ### OpCodes\n * ```ts\n * <I18nUpdateOpCodes>[\n *   // The following OpCodes represent: `<div i18n-title=\"pre{{exp1}}in{{exp2}}post\">`\n *   // If `changeMask & 0b11`\n *   //        has changed then execute update OpCodes.\n *   //        has NOT changed then skip `8` values and start processing next OpCodes.\n *   0b11, 8,\n *   // Concatenate `newValue = 'pre'+lView[bindIndex-4]+'in'+lView[bindIndex-3]+'post';`.\n *   'pre', -4, 'in', -3, 'post',\n *   // Update attribute: `elementAttribute(1, 'title', sanitizerFn(newValue));`\n *   1 << SHIFT_REF | Attr, 'title', sanitizerFn,\n *\n *   // The following OpCodes represent: `<div i18n>Hello {{exp3}}!\">`\n *   // If `changeMask & 0b100`\n *   //        has changed then execute update OpCodes.\n *   //        has NOT changed then skip `4` values and start processing next OpCodes.\n *   0b100, 4,\n *   // Concatenate `newValue = 'Hello ' + lView[bindIndex -2] + '!';`.\n *   'Hello ', -2, '!',\n *   // Update text: `lView[1].textContent = newValue;`\n *   1 << SHIFT_REF | Text,\n *\n *   // The following OpCodes represent: `<div i18n>{exp4, plural, ... }\">`\n *   // If `changeMask & 0b1000`\n *   //        has changed then execute update OpCodes.\n *   //        has NOT changed then skip `2` values and start processing next OpCodes.\n *   0b1000, 2,\n *   // Concatenate `newValue = lView[bindIndex -1];`.\n *   -1,\n *   // Switch ICU: `icuSwitchCase(lView[1], 0, newValue);`\n *   0 << SHIFT_ICU | 1 << SHIFT_REF | IcuSwitch,\n *\n *   // Note `changeMask & -1` is always true, so the IcuUpdate will always execute.\n *   -1, 1,\n *   // Update ICU: `icuUpdateCase(lView[1], 0);`\n *   0 << SHIFT_ICU | 1 << SHIFT_REF | IcuUpdate,\n *\n * ];\n * ```\n *\n */\nexport interface I18nUpdateOpCodes extends Array<string|number|SanitizerFn|null>, I18nDebug {\n  __brand__: 'I18nUpdateOpCodes';\n}\n\n/**\n * Store information for the i18n translation block.\n */\nexport interface TI18n {\n  /**\n   * A set of OpCodes which will create the Text Nodes and ICU anchors for the translation blocks.\n   *\n   * NOTE: The ICU anchors are filled in with ICU Update OpCode.\n   */\n  create: I18nCreateOpCodes;\n\n  /**\n   * A set of OpCodes which will be executed on each change detection to determine if any changes to\n   * DOM are required.\n   */\n  update: I18nUpdateOpCodes;\n}\n\n/**\n * Defines the ICU type of `select` or `plural`\n */\nexport const enum IcuType {\n  select = 0,\n  plural = 1,\n}\n\nexport interface TIcu {\n  /**\n   * Defines the ICU type of `select` or `plural`\n   */\n  type: IcuType;\n\n  /**\n   * Index in `LView` where the anchor node is stored. `<!-- ICU 0:0 -->`\n   */\n  anchorIdx: number;\n\n  /**\n   * Currently selected ICU case pointer.\n   *\n   * `lView[currentCaseLViewIndex]` stores the currently selected case. This is needed to know how\n   * to clean up the current case when transitioning no the new case.\n   *\n   * If the value stored is:\n   * `null`: No current case selected.\n   *   `<0`: A flag which means that the ICU just switched and that `icuUpdate` must be executed\n   *         regardless of the `mask`. (After the execution the flag is cleared)\n   *   `>=0` A currently selected case index.\n   */\n  currentCaseLViewIndex: number;\n\n  /**\n   * A list of case values which the current ICU will try to match.\n   *\n   * The last value is `other`\n   */\n  cases: any[];\n\n  /**\n   * A set of OpCodes to apply in order to build up the DOM render tree for the ICU\n   */\n  create: IcuCreateOpCodes[];\n\n  /**\n   * A set of OpCodes to apply in order to destroy the DOM render tree for the ICU.\n   */\n  remove: I18nRemoveOpCodes[];\n\n  /**\n   * A set of OpCodes to apply in order to update the DOM render tree for the ICU bindings.\n   */\n  update: I18nUpdateOpCodes[];\n}\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n\n/**\n * Parsed ICU expression\n */\nexport interface IcuExpression {\n  type: IcuType;\n  mainBinding: number;\n  cases: string[];\n  values: (string|IcuExpression)[][];\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DEFAULT_LOCALE_ID} from '../../i18n/localization';\nimport {assertDefined} from '../../util/assert';\n\n\n/**\n * The locale id that the application is currently using (for translations and ICU expressions).\n * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine\n * but is now defined as a global value.\n */\nlet LOCALE_ID = DEFAULT_LOCALE_ID;\n\n/**\n * Sets the locale id that will be used for translations and ICU expressions.\n * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine\n * but is now defined as a global value.\n *\n * @param localeId\n */\nexport function setLocaleId(localeId: string) {\n  assertDefined(localeId, `Expected localeId to be defined`);\n  if (typeof localeId === 'string') {\n    LOCALE_ID = localeId.toLowerCase().replace(/_/g, '-');\n  }\n}\n\n/**\n * Gets the locale id that will be used for translations and ICU expressions.\n * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine\n * but is now defined as a global value.\n */\nexport function getLocaleId(): string {\n  return LOCALE_ID;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDomNode, assertIndexInRange} from '../util/assert';\n\nimport {TNode, TNodeFlags, TNodeType} from './interfaces/node';\nimport {Renderer} from './interfaces/renderer';\nimport {RElement, RNode} from './interfaces/renderer_dom';\nimport {LView} from './interfaces/view';\nimport {getInsertInFrontOfRNodeWithNoI18n, nativeInsertBefore} from './node_manipulation';\nimport {unwrapRNode} from './util/view_utils';\n\n\n/**\n * Find a node in front of which `currentTNode` should be inserted (takes i18n into account).\n *\n * This method determines the `RNode` in front of which we should insert the `currentRNode`. This\n * takes `TNode.insertBeforeIndex` into account.\n *\n * @param parentTNode parent `TNode`\n * @param currentTNode current `TNode` (The node which we would like to insert into the DOM)\n * @param lView current `LView`\n */\nexport function getInsertInFrontOfRNodeWithI18n(\n    parentTNode: TNode, currentTNode: TNode, lView: LView): RNode|null {\n  const tNodeInsertBeforeIndex = currentTNode.insertBeforeIndex;\n  const insertBeforeIndex =\n      Array.isArray(tNodeInsertBeforeIndex) ? tNodeInsertBeforeIndex[0] : tNodeInsertBeforeIndex;\n  if (insertBeforeIndex === null) {\n    return getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView);\n  } else {\n    ngDevMode && assertIndexInRange(lView, insertBeforeIndex);\n    return unwrapRNode(lView[insertBeforeIndex]);\n  }\n}\n\n\n/**\n * Process `TNode.insertBeforeIndex` by adding i18n text nodes.\n *\n * See `TNode.insertBeforeIndex`\n */\nexport function processI18nInsertBefore(\n    renderer: Renderer, childTNode: TNode, lView: LView, childRNode: RNode|RNode[],\n    parentRElement: RElement|null): void {\n  const tNodeInsertBeforeIndex = childTNode.insertBeforeIndex;\n  if (Array.isArray(tNodeInsertBeforeIndex)) {\n    // An array indicates that there are i18n nodes that need to be added as children of this\n    // `childRNode`. These i18n nodes were created before this `childRNode` was available and so\n    // only now can be added. The first element of the array is the normal index where we should\n    // insert the `childRNode`. Additional elements are the extra nodes to be added as children of\n    // `childRNode`.\n    ngDevMode && assertDomNode(childRNode);\n    let i18nParent: RElement|null = childRNode as RElement;\n    let anchorRNode: RNode|null = null;\n    if (!(childTNode.type & TNodeType.AnyRNode)) {\n      anchorRNode = i18nParent;\n      i18nParent = parentRElement;\n    }\n    if (i18nParent !== null && (childTNode.flags & TNodeFlags.isComponentHost) === 0) {\n      for (let i = 1; i < tNodeInsertBeforeIndex.length; i++) {\n        // No need to `unwrapRNode` because all of the indexes point to i18n text nodes.\n        // see `assertDomNode` below.\n        const i18nChild = lView[tNodeInsertBeforeIndex[i]];\n        nativeInsertBefore(renderer, i18nParent, i18nChild, anchorRNode, false);\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertEqual} from '../../util/assert';\nimport {TNode, TNodeType} from '../interfaces/node';\nimport {setI18nHandling} from '../node_manipulation';\nimport {getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore} from '../node_manipulation_i18n';\n\n/**\n * Add `tNode` to `previousTNodes` list and update relevant `TNode`s in `previousTNodes` list\n * `tNode.insertBeforeIndex`.\n *\n * Things to keep in mind:\n * 1. All i18n text nodes are encoded as `TNodeType.Element` and are created eagerly by the\n *    `ɵɵi18nStart` instruction.\n * 2. All `TNodeType.Placeholder` `TNodes` are elements which will be created later by\n *    `ɵɵelementStart` instruction.\n * 3. `ɵɵelementStart` instruction will create `TNode`s in the ascending `TNode.index` order. (So a\n *    smaller index `TNode` is guaranteed to be created before a larger one)\n *\n * We use the above three invariants to determine `TNode.insertBeforeIndex`.\n *\n * In an ideal world `TNode.insertBeforeIndex` would always be `TNode.next.index`. However,\n * this will not work because `TNode.next.index` may be larger than `TNode.index` which means that\n * the next node is not yet created and therefore we can't insert in front of it.\n *\n * Rule1: `TNode.insertBeforeIndex = null` if `TNode.next === null` (Initial condition, as we don't\n *        know if there will be further `TNode`s inserted after.)\n * Rule2: If `previousTNode` is created after the `tNode` being inserted, then\n *        `previousTNode.insertBeforeNode = tNode.index` (So when a new `tNode` is added we check\n *        previous to see if we can update its `insertBeforeTNode`)\n *\n * See `TNode.insertBeforeIndex` for more context.\n *\n * @param previousTNodes A list of previous TNodes so that we can easily traverse `TNode`s in\n *     reverse order. (If `TNode` would have `previous` this would not be necessary.)\n * @param newTNode A TNode to add to the `previousTNodes` list.\n */\nexport function addTNodeAndUpdateInsertBeforeIndex(previousTNodes: TNode[], newTNode: TNode) {\n  // Start with Rule1\n  ngDevMode &&\n      assertEqual(newTNode.insertBeforeIndex, null, 'We expect that insertBeforeIndex is not set');\n\n  previousTNodes.push(newTNode);\n  if (previousTNodes.length > 1) {\n    for (let i = previousTNodes.length - 2; i >= 0; i--) {\n      const existingTNode = previousTNodes[i];\n      // Text nodes are created eagerly and so they don't need their `indexBeforeIndex` updated.\n      // It is safe to ignore them.\n      if (!isI18nText(existingTNode)) {\n        if (isNewTNodeCreatedBefore(existingTNode, newTNode) &&\n            getInsertBeforeIndex(existingTNode) === null) {\n          // If it was created before us in time, (and it does not yet have `insertBeforeIndex`)\n          // then add the `insertBeforeIndex`.\n          setInsertBeforeIndex(existingTNode, newTNode.index);\n        }\n      }\n    }\n  }\n}\n\nfunction isI18nText(tNode: TNode): boolean {\n  return !(tNode.type & TNodeType.Placeholder);\n}\n\nfunction isNewTNodeCreatedBefore(existingTNode: TNode, newTNode: TNode): boolean {\n  return isI18nText(newTNode) || existingTNode.index > newTNode.index;\n}\n\nfunction getInsertBeforeIndex(tNode: TNode): number|null {\n  const index = tNode.insertBeforeIndex;\n  return Array.isArray(index) ? index[0] : index;\n}\n\nfunction setInsertBeforeIndex(tNode: TNode, value: number): void {\n  const index = tNode.insertBeforeIndex;\n  if (Array.isArray(index)) {\n    // Array is stored if we have to insert child nodes. See `TNode.insertBeforeIndex`\n    index[0] = value;\n  } else {\n    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);\n    tNode.insertBeforeIndex = value;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertEqual, assertGreaterThan, assertGreaterThanOrEqual, throwError} from '../../util/assert';\nimport {assertTIcu, assertTNode} from '../assert';\nimport {createTNodeAtIndex} from '../instructions/shared';\nimport {IcuCreateOpCode, TIcu} from '../interfaces/i18n';\nimport {TIcuContainerNode, TNode, TNodeType} from '../interfaces/node';\nimport {LView, TView} from '../interfaces/view';\nimport {assertTNodeType} from '../node_assert';\nimport {setI18nHandling} from '../node_manipulation';\nimport {getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore} from '../node_manipulation_i18n';\nimport {addTNodeAndUpdateInsertBeforeIndex} from './i18n_insert_before_index';\n\n\n/**\n * Retrieve `TIcu` at a given `index`.\n *\n * The `TIcu` can be stored either directly (if it is nested ICU) OR\n * it is stored inside tho `TIcuContainer` if it is top level ICU.\n *\n * The reason for this is that the top level ICU need a `TNode` so that they are part of the render\n * tree, but nested ICU's have no TNode, because we don't know ahead of time if the nested ICU is\n * expressed (parent ICU may have selected a case which does not contain it.)\n *\n * @param tView Current `TView`.\n * @param index Index where the value should be read from.\n */\nexport function getTIcu(tView: TView, index: number): TIcu|null {\n  const value = tView.data[index] as null | TIcu | TIcuContainerNode | string;\n  if (value === null || typeof value === 'string') return null;\n  if (ngDevMode &&\n      !(value.hasOwnProperty('tViews') || value.hasOwnProperty('currentCaseLViewIndex'))) {\n    throwError('We expect to get \\'null\\'|\\'TIcu\\'|\\'TIcuContainer\\', but got: ' + value);\n  }\n  // Here the `value.hasOwnProperty('currentCaseLViewIndex')` is a polymorphic read as it can be\n  // either TIcu or TIcuContainerNode. This is not ideal, but we still think it is OK because it\n  // will be just two cases which fits into the browser inline cache (inline cache can take up to\n  // 4)\n  const tIcu = value.hasOwnProperty('currentCaseLViewIndex') ? value as TIcu :\n                                                               (value as TIcuContainerNode).value;\n  ngDevMode && assertTIcu(tIcu);\n  return tIcu;\n}\n\n/**\n * Store `TIcu` at a give `index`.\n *\n * The `TIcu` can be stored either directly (if it is nested ICU) OR\n * it is stored inside tho `TIcuContainer` if it is top level ICU.\n *\n * The reason for this is that the top level ICU need a `TNode` so that they are part of the render\n * tree, but nested ICU's have no TNode, because we don't know ahead of time if the nested ICU is\n * expressed (parent ICU may have selected a case which does not contain it.)\n *\n * @param tView Current `TView`.\n * @param index Index where the value should be stored at in `Tview.data`\n * @param tIcu The TIcu to store.\n */\nexport function setTIcu(tView: TView, index: number, tIcu: TIcu): void {\n  const tNode = tView.data[index] as null | TIcuContainerNode;\n  ngDevMode &&\n      assertEqual(\n          tNode === null || tNode.hasOwnProperty('tViews'), true,\n          'We expect to get \\'null\\'|\\'TIcuContainer\\'');\n  if (tNode === null) {\n    tView.data[index] = tIcu;\n  } else {\n    ngDevMode && assertTNodeType(tNode, TNodeType.Icu);\n    tNode.value = tIcu;\n  }\n}\n\n/**\n * Set `TNode.insertBeforeIndex` taking the `Array` into account.\n *\n * See `TNode.insertBeforeIndex`\n */\nexport function setTNodeInsertBeforeIndex(tNode: TNode, index: number) {\n  ngDevMode && assertTNode(tNode);\n  let insertBeforeIndex = tNode.insertBeforeIndex;\n  if (insertBeforeIndex === null) {\n    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);\n    insertBeforeIndex = tNode.insertBeforeIndex =\n        [null!/* may be updated to number later */, index];\n  } else {\n    assertEqual(Array.isArray(insertBeforeIndex), true, 'Expecting array here');\n    (insertBeforeIndex as number[]).push(index);\n  }\n}\n\n/**\n * Create `TNode.type=TNodeType.Placeholder` node.\n *\n * See `TNodeType.Placeholder` for more information.\n */\nexport function createTNodePlaceholder(\n    tView: TView, previousTNodes: TNode[], index: number): TNode {\n  const tNode = createTNodeAtIndex(tView, index, TNodeType.Placeholder, null, null);\n  addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tNode);\n  return tNode;\n}\n\n\n/**\n * Returns current ICU case.\n *\n * ICU cases are stored as index into the `TIcu.cases`.\n * At times it is necessary to communicate that the ICU case just switched and that next ICU update\n * should update all bindings regardless of the mask. In such a case the we store negative numbers\n * for cases which have just been switched. This function removes the negative flag.\n */\nexport function getCurrentICUCaseIndex(tIcu: TIcu, lView: LView) {\n  const currentCase: number|null = lView[tIcu.currentCaseLViewIndex];\n  return currentCase === null ? currentCase : (currentCase < 0 ? ~currentCase : currentCase);\n}\n\nexport function getParentFromIcuCreateOpCode(mergedCode: number): number {\n  return mergedCode >>> IcuCreateOpCode.SHIFT_PARENT;\n}\n\nexport function getRefFromIcuCreateOpCode(mergedCode: number): number {\n  return (mergedCode & IcuCreateOpCode.MASK_REF) >>> IcuCreateOpCode.SHIFT_REF;\n}\n\nexport function getInstructionFromIcuCreateOpCode(mergedCode: number): number {\n  return mergedCode & IcuCreateOpCode.MASK_INSTRUCTION;\n}\n\nexport function icuCreateOpCode(opCode: IcuCreateOpCode, parentIdx: number, refIdx: number) {\n  ngDevMode && assertGreaterThanOrEqual(parentIdx, 0, 'Missing parent index');\n  ngDevMode && assertGreaterThan(refIdx, 0, 'Missing ref index');\n  return opCode | parentIdx << IcuCreateOpCode.SHIFT_PARENT | refIdx << IcuCreateOpCode.SHIFT_REF;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {RuntimeError, RuntimeErrorCode} from '../../errors';\nimport {getPluralCase} from '../../i18n/localization';\nimport {assertDefined, assertDomNode, assertEqual, assertGreaterThan, assertIndexInRange, throwError} from '../../util/assert';\nimport {assertIndexInExpandoRange, assertTIcu} from '../assert';\nimport {attachPatchData} from '../context_discovery';\nimport {elementPropertyInternal, setElementAttribute} from '../instructions/shared';\nimport {ELEMENT_MARKER, I18nCreateOpCode, I18nCreateOpCodes, I18nUpdateOpCode, I18nUpdateOpCodes, ICU_MARKER, IcuCreateOpCode, IcuCreateOpCodes, IcuType, TI18n, TIcu} from '../interfaces/i18n';\nimport {TNode} from '../interfaces/node';\nimport {RElement, RNode, RText} from '../interfaces/renderer_dom';\nimport {SanitizerFn} from '../interfaces/sanitization';\nimport {HEADER_OFFSET, LView, RENDERER, TView} from '../interfaces/view';\nimport {createCommentNode, createElementNode, createTextNode, nativeInsertBefore, nativeParentNode, nativeRemoveNode, updateTextNode} from '../node_manipulation';\nimport {getBindingIndex} from '../state';\nimport {renderStringify} from '../util/stringify_utils';\nimport {getNativeByIndex, unwrapRNode} from '../util/view_utils';\n\nimport {getLocaleId} from './i18n_locale_id';\nimport {getCurrentICUCaseIndex, getParentFromIcuCreateOpCode, getRefFromIcuCreateOpCode, getTIcu} from './i18n_util';\n\n\n\n/**\n * Keep track of which input bindings in `ɵɵi18nExp` have changed.\n *\n * This is used to efficiently update expressions in i18n only when the corresponding input has\n * changed.\n *\n * 1) Each bit represents which of the `ɵɵi18nExp` has changed.\n * 2) There are 32 bits allowed in JS.\n * 3) Bit 32 is special as it is shared for all changes past 32. (In other words if you have more\n * than 32 `ɵɵi18nExp` then all changes past 32nd `ɵɵi18nExp` will be mapped to same bit. This means\n * that we may end up changing more than we need to. But i18n expressions with 32 bindings is rare\n * so in practice it should not be an issue.)\n */\nlet changeMask = 0b0;\n\n/**\n * Keeps track of which bit needs to be updated in `changeMask`\n *\n * This value gets incremented on every call to `ɵɵi18nExp`\n */\nlet changeMaskCounter = 0;\n\n/**\n * Keep track of which input bindings in `ɵɵi18nExp` have changed.\n *\n * `setMaskBit` gets invoked by each call to `ɵɵi18nExp`.\n *\n * @param hasChange did `ɵɵi18nExp` detect a change.\n */\nexport function setMaskBit(hasChange: boolean) {\n  if (hasChange) {\n    changeMask = changeMask | (1 << Math.min(changeMaskCounter, 31));\n  }\n  changeMaskCounter++;\n}\n\nexport function applyI18n(tView: TView, lView: LView, index: number) {\n  if (changeMaskCounter > 0) {\n    ngDevMode && assertDefined(tView, `tView should be defined`);\n    const tI18n = tView.data[index] as TI18n | I18nUpdateOpCodes;\n    // When `index` points to an `ɵɵi18nAttributes` then we have an array otherwise `TI18n`\n    const updateOpCodes: I18nUpdateOpCodes =\n        Array.isArray(tI18n) ? tI18n as I18nUpdateOpCodes : (tI18n as TI18n).update;\n    const bindingsStartIndex = getBindingIndex() - changeMaskCounter - 1;\n    applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask);\n  }\n  // Reset changeMask & maskBit to default for the next update cycle\n  changeMask = 0b0;\n  changeMaskCounter = 0;\n}\n\n\n/**\n * Apply `I18nCreateOpCodes` op-codes as stored in `TI18n.create`.\n *\n * Creates text (and comment) nodes which are internationalized.\n *\n * @param lView Current lView\n * @param createOpCodes Set of op-codes to apply\n * @param parentRNode Parent node (so that direct children can be added eagerly) or `null` if it is\n *     a root node.\n * @param insertInFrontOf DOM node that should be used as an anchor.\n */\nexport function applyCreateOpCodes(\n    lView: LView, createOpCodes: I18nCreateOpCodes, parentRNode: RElement|null,\n    insertInFrontOf: RElement|null): void {\n  const renderer = lView[RENDERER];\n  for (let i = 0; i < createOpCodes.length; i++) {\n    const opCode = createOpCodes[i++] as any;\n    const text = createOpCodes[i] as string;\n    const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;\n    const appendNow =\n        (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;\n    const index = opCode >>> I18nCreateOpCode.SHIFT;\n    let rNode = lView[index];\n    if (rNode === null) {\n      // We only create new DOM nodes if they don't already exist: If ICU switches case back to a\n      // case which was already instantiated, no need to create new DOM nodes.\n      rNode = lView[index] =\n          isComment ? renderer.createComment(text) : createTextNode(renderer, text);\n    }\n    if (appendNow && parentRNode !== null) {\n      nativeInsertBefore(renderer, parentRNode, rNode, insertInFrontOf, false);\n    }\n  }\n}\n\n/**\n * Apply `I18nMutateOpCodes` OpCodes.\n *\n * @param tView Current `TView`\n * @param mutableOpCodes Mutable OpCodes to process\n * @param lView Current `LView`\n * @param anchorRNode place where the i18n node should be inserted.\n */\nexport function applyMutableOpCodes(\n    tView: TView, mutableOpCodes: IcuCreateOpCodes, lView: LView, anchorRNode: RNode): void {\n  ngDevMode && assertDomNode(anchorRNode);\n  const renderer = lView[RENDERER];\n  // `rootIdx` represents the node into which all inserts happen.\n  let rootIdx: number|null = null;\n  // `rootRNode` represents the real node into which we insert. This can be different from\n  // `lView[rootIdx]` if we have projection.\n  //  - null we don't have a parent (as can be the case in when we are inserting into a root of\n  //    LView which has no parent.)\n  //  - `RElement` The element representing the root after taking projection into account.\n  let rootRNode!: RElement|null;\n  for (let i = 0; i < mutableOpCodes.length; i++) {\n    const opCode = mutableOpCodes[i];\n    if (typeof opCode == 'string') {\n      const textNodeIndex = mutableOpCodes[++i] as number;\n      if (lView[textNodeIndex] === null) {\n        ngDevMode && ngDevMode.rendererCreateTextNode++;\n        ngDevMode && assertIndexInRange(lView, textNodeIndex);\n        lView[textNodeIndex] = createTextNode(renderer, opCode);\n      }\n    } else if (typeof opCode == 'number') {\n      switch (opCode & IcuCreateOpCode.MASK_INSTRUCTION) {\n        case IcuCreateOpCode.AppendChild:\n          const parentIdx = getParentFromIcuCreateOpCode(opCode);\n          if (rootIdx === null) {\n            // The first operation should save the `rootIdx` because the first operation\n            // must insert into the root. (Only subsequent operations can insert into a dynamic\n            // parent)\n            rootIdx = parentIdx;\n            rootRNode = nativeParentNode(renderer, anchorRNode);\n          }\n          let insertInFrontOf: RNode|null;\n          let parentRNode: RElement|null;\n          if (parentIdx === rootIdx) {\n            insertInFrontOf = anchorRNode;\n            parentRNode = rootRNode;\n          } else {\n            insertInFrontOf = null;\n            parentRNode = unwrapRNode(lView[parentIdx]) as RElement;\n          }\n          // FIXME(misko): Refactor with `processI18nText`\n          if (parentRNode !== null) {\n            // This can happen if the `LView` we are adding to is not attached to a parent `LView`.\n            // In such a case there is no \"root\" we can attach to. This is fine, as we still need to\n            // create the elements. When the `LView` gets later added to a parent these \"root\" nodes\n            // get picked up and added.\n            ngDevMode && assertDomNode(parentRNode);\n            const refIdx = getRefFromIcuCreateOpCode(opCode);\n            ngDevMode && assertGreaterThan(refIdx, HEADER_OFFSET, 'Missing ref');\n            // `unwrapRNode` is not needed here as all of these point to RNodes as part of the i18n\n            // which can't have components.\n            const child = lView[refIdx] as RElement;\n            ngDevMode && assertDomNode(child);\n            nativeInsertBefore(renderer, parentRNode, child, insertInFrontOf, false);\n            const tIcu = getTIcu(tView, refIdx);\n            if (tIcu !== null && typeof tIcu === 'object') {\n              // If we just added a comment node which has ICU then that ICU may have already been\n              // rendered and therefore we need to re-add it here.\n              ngDevMode && assertTIcu(tIcu);\n              const caseIndex = getCurrentICUCaseIndex(tIcu, lView);\n              if (caseIndex !== null) {\n                applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, lView[tIcu.anchorIdx]);\n              }\n            }\n          }\n          break;\n        case IcuCreateOpCode.Attr:\n          const elementNodeIndex = opCode >>> IcuCreateOpCode.SHIFT_REF;\n          const attrName = mutableOpCodes[++i] as string;\n          const attrValue = mutableOpCodes[++i] as string;\n          // This code is used for ICU expressions only, since we don't support\n          // directives/components in ICUs, we don't need to worry about inputs here\n          setElementAttribute(\n              renderer, getNativeByIndex(elementNodeIndex, lView) as RElement, null, null, attrName,\n              attrValue, null);\n          break;\n        default:\n          if (ngDevMode) {\n            throw new RuntimeError(\n                RuntimeErrorCode.INVALID_I18N_STRUCTURE,\n                `Unable to determine the type of mutate operation for \"${opCode}\"`);\n          }\n      }\n    } else {\n      switch (opCode) {\n        case ICU_MARKER:\n          const commentValue = mutableOpCodes[++i] as string;\n          const commentNodeIndex = mutableOpCodes[++i] as number;\n          if (lView[commentNodeIndex] === null) {\n            ngDevMode &&\n                assertEqual(\n                    typeof commentValue, 'string',\n                    `Expected \"${commentValue}\" to be a comment node value`);\n            ngDevMode && ngDevMode.rendererCreateComment++;\n            ngDevMode && assertIndexInExpandoRange(lView, commentNodeIndex);\n            const commentRNode = lView[commentNodeIndex] =\n                createCommentNode(renderer, commentValue);\n            // FIXME(misko): Attaching patch data is only needed for the root (Also add tests)\n            attachPatchData(commentRNode, lView);\n          }\n          break;\n        case ELEMENT_MARKER:\n          const tagName = mutableOpCodes[++i] as string;\n          const elementNodeIndex = mutableOpCodes[++i] as number;\n          if (lView[elementNodeIndex] === null) {\n            ngDevMode &&\n                assertEqual(\n                    typeof tagName, 'string',\n                    `Expected \"${tagName}\" to be an element node tag name`);\n\n            ngDevMode && ngDevMode.rendererCreateElement++;\n            ngDevMode && assertIndexInExpandoRange(lView, elementNodeIndex);\n            const elementRNode = lView[elementNodeIndex] =\n                createElementNode(renderer, tagName, null);\n            // FIXME(misko): Attaching patch data is only needed for the root (Also add tests)\n            attachPatchData(elementRNode, lView);\n          }\n          break;\n        default:\n          ngDevMode &&\n              throwError(`Unable to determine the type of mutate operation for \"${opCode}\"`);\n      }\n    }\n  }\n}\n\n\n/**\n * Apply `I18nUpdateOpCodes` OpCodes\n *\n * @param tView Current `TView`\n * @param lView Current `LView`\n * @param updateOpCodes OpCodes to process\n * @param bindingsStartIndex Location of the first `ɵɵi18nApply`\n * @param changeMask Each bit corresponds to a `ɵɵi18nExp` (Counting backwards from\n *     `bindingsStartIndex`)\n */\nexport function applyUpdateOpCodes(\n    tView: TView, lView: LView, updateOpCodes: I18nUpdateOpCodes, bindingsStartIndex: number,\n    changeMask: number) {\n  for (let i = 0; i < updateOpCodes.length; i++) {\n    // bit code to check if we should apply the next update\n    const checkBit = updateOpCodes[i] as number;\n    // Number of opCodes to skip until next set of update codes\n    const skipCodes = updateOpCodes[++i] as number;\n    if (checkBit & changeMask) {\n      // The value has been updated since last checked\n      let value = '';\n      for (let j = i + 1; j <= (i + skipCodes); j++) {\n        const opCode = updateOpCodes[j];\n        if (typeof opCode == 'string') {\n          value += opCode;\n        } else if (typeof opCode == 'number') {\n          if (opCode < 0) {\n            // Negative opCode represent `i18nExp` values offset.\n            value += renderStringify(lView[bindingsStartIndex - opCode]);\n          } else {\n            const nodeIndex = (opCode >>> I18nUpdateOpCode.SHIFT_REF);\n            switch (opCode & I18nUpdateOpCode.MASK_OPCODE) {\n              case I18nUpdateOpCode.Attr:\n                const propName = updateOpCodes[++j] as string;\n                const sanitizeFn = updateOpCodes[++j] as SanitizerFn | null;\n                const tNodeOrTagName = tView.data[nodeIndex] as TNode | string;\n                ngDevMode && assertDefined(tNodeOrTagName, 'Experting TNode or string');\n                if (typeof tNodeOrTagName === 'string') {\n                  // IF we don't have a `TNode`, then we are an element in ICU (as ICU content does\n                  // not have TNode), in which case we know that there are no directives, and hence\n                  // we use attribute setting.\n                  setElementAttribute(\n                      lView[RENDERER], lView[nodeIndex], null, tNodeOrTagName, propName, value,\n                      sanitizeFn);\n                } else {\n                  elementPropertyInternal(\n                      tView, tNodeOrTagName, lView, propName, value, lView[RENDERER], sanitizeFn,\n                      false);\n                }\n                break;\n              case I18nUpdateOpCode.Text:\n                const rText = lView[nodeIndex] as RText | null;\n                rText !== null && updateTextNode(lView[RENDERER], rText, value);\n                break;\n              case I18nUpdateOpCode.IcuSwitch:\n                applyIcuSwitchCase(tView, getTIcu(tView, nodeIndex)!, lView, value);\n                break;\n              case I18nUpdateOpCode.IcuUpdate:\n                applyIcuUpdateCase(tView, getTIcu(tView, nodeIndex)!, bindingsStartIndex, lView);\n                break;\n            }\n          }\n        }\n      }\n    } else {\n      const opCode = updateOpCodes[i + 1] as number;\n      if (opCode > 0 && (opCode & I18nUpdateOpCode.MASK_OPCODE) === I18nUpdateOpCode.IcuUpdate) {\n        // Special case for the `icuUpdateCase`. It could be that the mask did not match, but\n        // we still need to execute `icuUpdateCase` because the case has changed recently due to\n        // previous `icuSwitchCase` instruction. (`icuSwitchCase` and `icuUpdateCase` always come in\n        // pairs.)\n        const nodeIndex = (opCode >>> I18nUpdateOpCode.SHIFT_REF);\n        const tIcu = getTIcu(tView, nodeIndex)!;\n        const currentIndex = lView[tIcu.currentCaseLViewIndex];\n        if (currentIndex < 0) {\n          applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView);\n        }\n      }\n    }\n    i += skipCodes;\n  }\n}\n\n/**\n * Apply OpCodes associated with updating an existing ICU.\n *\n * @param tView Current `TView`\n * @param tIcu Current `TIcu`\n * @param bindingsStartIndex Location of the first `ɵɵi18nApply`\n * @param lView Current `LView`\n */\nfunction applyIcuUpdateCase(tView: TView, tIcu: TIcu, bindingsStartIndex: number, lView: LView) {\n  ngDevMode && assertIndexInRange(lView, tIcu.currentCaseLViewIndex);\n  let activeCaseIndex = lView[tIcu.currentCaseLViewIndex];\n  if (activeCaseIndex !== null) {\n    let mask = changeMask;\n    if (activeCaseIndex < 0) {\n      // Clear the flag.\n      // Negative number means that the ICU was freshly created and we need to force the update.\n      activeCaseIndex = lView[tIcu.currentCaseLViewIndex] = ~activeCaseIndex;\n      // -1 is same as all bits on, which simulates creation since it marks all bits dirty\n      mask = -1;\n    }\n    applyUpdateOpCodes(tView, lView, tIcu.update[activeCaseIndex], bindingsStartIndex, mask);\n  }\n}\n\n/**\n * Apply OpCodes associated with switching a case on ICU.\n *\n * This involves tearing down existing case and than building up a new case.\n *\n * @param tView Current `TView`\n * @param tIcu Current `TIcu`\n * @param lView Current `LView`\n * @param value Value of the case to update to.\n */\nfunction applyIcuSwitchCase(tView: TView, tIcu: TIcu, lView: LView, value: string) {\n  // Rebuild a new case for this ICU\n  const caseIndex = getCaseIndex(tIcu, value);\n  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);\n  if (activeCaseIndex !== caseIndex) {\n    applyIcuSwitchCaseRemove(tView, tIcu, lView);\n    lView[tIcu.currentCaseLViewIndex] = caseIndex === null ? null : ~caseIndex;\n    if (caseIndex !== null) {\n      // Add the nodes for the new case\n      const anchorRNode = lView[tIcu.anchorIdx];\n      if (anchorRNode) {\n        ngDevMode && assertDomNode(anchorRNode);\n        applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, anchorRNode);\n      }\n    }\n  }\n}\n\n/**\n * Apply OpCodes associated with tearing ICU case.\n *\n * This involves tearing down existing case and than building up a new case.\n *\n * @param tView Current `TView`\n * @param tIcu Current `TIcu`\n * @param lView Current `LView`\n */\nfunction applyIcuSwitchCaseRemove(tView: TView, tIcu: TIcu, lView: LView) {\n  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);\n  if (activeCaseIndex !== null) {\n    const removeCodes = tIcu.remove[activeCaseIndex];\n    for (let i = 0; i < removeCodes.length; i++) {\n      const nodeOrIcuIndex = removeCodes[i] as number;\n      if (nodeOrIcuIndex > 0) {\n        // Positive numbers are `RNode`s.\n        const rNode = getNativeByIndex(nodeOrIcuIndex, lView);\n        rNode !== null && nativeRemoveNode(lView[RENDERER], rNode);\n      } else {\n        // Negative numbers are ICUs\n        applyIcuSwitchCaseRemove(tView, getTIcu(tView, ~nodeOrIcuIndex)!, lView);\n      }\n    }\n  }\n}\n\n\n/**\n * Returns the index of the current case of an ICU expression depending on the main binding value\n *\n * @param icuExpression\n * @param bindingValue The value of the main binding used by this ICU expression\n */\nfunction getCaseIndex(icuExpression: TIcu, bindingValue: string): number|null {\n  let index = icuExpression.cases.indexOf(bindingValue);\n  if (index === -1) {\n    switch (icuExpression.type) {\n      case IcuType.plural: {\n        const resolvedCase = getPluralCase(bindingValue, getLocaleId());\n        index = icuExpression.cases.indexOf(resolvedCase);\n        if (index === -1 && resolvedCase !== 'other') {\n          index = icuExpression.cases.indexOf('other');\n        }\n        break;\n      }\n      case IcuType.select: {\n        index = icuExpression.cases.indexOf('other');\n        break;\n      }\n    }\n  }\n  return index === -1 ? null : index;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDomNode, assertNumber, assertNumberInRange} from '../../util/assert';\nimport {EMPTY_ARRAY} from '../../util/empty';\nimport {assertTIcu, assertTNodeForLView} from '../assert';\nimport {getCurrentICUCaseIndex} from '../i18n/i18n_util';\nimport {I18nRemoveOpCodes, TIcu} from '../interfaces/i18n';\nimport {TIcuContainerNode} from '../interfaces/node';\nimport {RNode} from '../interfaces/renderer_dom';\nimport {LView, TVIEW} from '../interfaces/view';\n\nexport function loadIcuContainerVisitor() {\n  const _stack: any[] = [];\n  let _index: number = -1;\n  let _lView: LView;\n  let _removes: I18nRemoveOpCodes;\n\n  /**\n   * Retrieves a set of root nodes from `TIcu.remove`. Used by `TNodeType.ICUContainer`\n   * to determine which root belong to the ICU.\n   *\n   * Example of usage.\n   * ```\n   * const nextRNode = icuContainerIteratorStart(tIcuContainerNode, lView);\n   * let rNode: RNode|null;\n   * while(rNode = nextRNode()) {\n   *   console.log(rNode);\n   * }\n   * ```\n   *\n   * @param tIcuContainerNode Current `TIcuContainerNode`\n   * @param lView `LView` where the `RNode`s should be looked up.\n   */\n  function icuContainerIteratorStart(tIcuContainerNode: TIcuContainerNode, lView: LView): () =>\n      RNode | null {\n    _lView = lView;\n    while (_stack.length) _stack.pop();\n    ngDevMode && assertTNodeForLView(tIcuContainerNode, lView);\n    enterIcu(tIcuContainerNode.value, lView);\n    return icuContainerIteratorNext;\n  }\n\n  function enterIcu(tIcu: TIcu, lView: LView) {\n    _index = 0;\n    const currentCase = getCurrentICUCaseIndex(tIcu, lView);\n    if (currentCase !== null) {\n      ngDevMode && assertNumberInRange(currentCase, 0, tIcu.cases.length - 1);\n      _removes = tIcu.remove[currentCase];\n    } else {\n      _removes = EMPTY_ARRAY as any;\n    }\n  }\n\n\n  function icuContainerIteratorNext(): RNode|null {\n    if (_index < _removes.length) {\n      const removeOpCode = _removes[_index++] as number;\n      ngDevMode && assertNumber(removeOpCode, 'Expecting OpCode number');\n      if (removeOpCode > 0) {\n        const rNode = _lView[removeOpCode];\n        ngDevMode && assertDomNode(rNode);\n        return rNode;\n      } else {\n        _stack.push(_index, _removes);\n        // ICUs are represented by negative indices\n        const tIcuIndex = ~removeOpCode;\n        const tIcu = _lView[TVIEW].data[tIcuIndex] as TIcu;\n        ngDevMode && assertTIcu(tIcu);\n        enterIcu(tIcu, _lView);\n        return icuContainerIteratorNext();\n      }\n    } else {\n      if (_stack.length === 0) {\n        return null;\n      } else {\n        _removes = _stack.pop();\n        _index = _stack.pop();\n        return icuContainerIteratorNext();\n      }\n    }\n  }\n\n  return icuContainerIteratorStart;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertNumber, assertString} from '../../util/assert';\nimport {ELEMENT_MARKER, I18nCreateOpCode, I18nCreateOpCodes, I18nRemoveOpCodes, I18nUpdateOpCode, I18nUpdateOpCodes, ICU_MARKER, IcuCreateOpCode, IcuCreateOpCodes} from '../interfaces/i18n';\n\nimport {getInstructionFromIcuCreateOpCode, getParentFromIcuCreateOpCode, getRefFromIcuCreateOpCode} from './i18n_util';\n\n\n/**\n * Converts `I18nCreateOpCodes` array into a human readable format.\n *\n * This function is attached to the `I18nCreateOpCodes.debug` property if `ngDevMode` is enabled.\n * This function provides a human readable view of the opcodes. This is useful when debugging the\n * application as well as writing more readable tests.\n *\n * @param this `I18nCreateOpCodes` if attached as a method.\n * @param opcodes `I18nCreateOpCodes` if invoked as a function.\n */\nexport function i18nCreateOpCodesToString(\n    this: I18nCreateOpCodes|void, opcodes?: I18nCreateOpCodes): string[] {\n  const createOpCodes: I18nCreateOpCodes = opcodes || (Array.isArray(this) ? this : [] as any);\n  let lines: string[] = [];\n  for (let i = 0; i < createOpCodes.length; i++) {\n    const opCode = createOpCodes[i++] as any;\n    const text = createOpCodes[i] as string;\n    const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;\n    const appendNow =\n        (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;\n    const index = opCode >>> I18nCreateOpCode.SHIFT;\n    lines.push(`lView[${index}] = document.${isComment ? 'createComment' : 'createText'}(${\n        JSON.stringify(text)});`);\n    if (appendNow) {\n      lines.push(`parent.appendChild(lView[${index}]);`);\n    }\n  }\n  return lines;\n}\n\n/**\n * Converts `I18nUpdateOpCodes` array into a human readable format.\n *\n * This function is attached to the `I18nUpdateOpCodes.debug` property if `ngDevMode` is enabled.\n * This function provides a human readable view of the opcodes. This is useful when debugging the\n * application as well as writing more readable tests.\n *\n * @param this `I18nUpdateOpCodes` if attached as a method.\n * @param opcodes `I18nUpdateOpCodes` if invoked as a function.\n */\nexport function i18nUpdateOpCodesToString(\n    this: I18nUpdateOpCodes|void, opcodes?: I18nUpdateOpCodes): string[] {\n  const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));\n  let lines: string[] = [];\n\n  function consumeOpCode(value: number): string {\n    const ref = value >>> I18nUpdateOpCode.SHIFT_REF;\n    const opCode = value & I18nUpdateOpCode.MASK_OPCODE;\n    switch (opCode) {\n      case I18nUpdateOpCode.Text:\n        return `(lView[${ref}] as Text).textContent = $$$`;\n      case I18nUpdateOpCode.Attr:\n        const attrName = parser.consumeString();\n        const sanitizationFn = parser.consumeFunction();\n        const value = sanitizationFn ? `(${sanitizationFn})($$$)` : '$$$';\n        return `(lView[${ref}] as Element).setAttribute('${attrName}', ${value})`;\n      case I18nUpdateOpCode.IcuSwitch:\n        return `icuSwitchCase(${ref}, $$$)`;\n      case I18nUpdateOpCode.IcuUpdate:\n        return `icuUpdateCase(${ref})`;\n    }\n    throw new Error('unexpected OpCode');\n  }\n\n\n  while (parser.hasMore()) {\n    let mask = parser.consumeNumber();\n    let size = parser.consumeNumber();\n    const end = parser.i + size;\n    const statements: string[] = [];\n    let statement = '';\n    while (parser.i < end) {\n      let value = parser.consumeNumberOrString();\n      if (typeof value === 'string') {\n        statement += value;\n      } else if (value < 0) {\n        // Negative numbers are ref indexes\n        // Here `i` refers to current binding index. It is to signify that the value is relative,\n        // rather than absolute.\n        statement += '${lView[i' + value + ']}';\n      } else {\n        // Positive numbers are operations.\n        const opCodeText = consumeOpCode(value);\n        statements.push(opCodeText.replace('$$$', '`' + statement + '`') + ';');\n        statement = '';\n      }\n    }\n    lines.push(`if (mask & 0b${mask.toString(2)}) { ${statements.join(' ')} }`);\n  }\n  return lines;\n}\n\n/**\n * Converts `I18nCreateOpCodes` array into a human readable format.\n *\n * This function is attached to the `I18nCreateOpCodes.debug` if `ngDevMode` is enabled. This\n * function provides a human readable view of the opcodes. This is useful when debugging the\n * application as well as writing more readable tests.\n *\n * @param this `I18nCreateOpCodes` if attached as a method.\n * @param opcodes `I18nCreateOpCodes` if invoked as a function.\n */\nexport function icuCreateOpCodesToString(\n    this: IcuCreateOpCodes|void, opcodes?: IcuCreateOpCodes): string[] {\n  const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));\n  let lines: string[] = [];\n\n  function consumeOpCode(opCode: number): string {\n    const parent = getParentFromIcuCreateOpCode(opCode);\n    const ref = getRefFromIcuCreateOpCode(opCode);\n    switch (getInstructionFromIcuCreateOpCode(opCode)) {\n      case IcuCreateOpCode.AppendChild:\n        return `(lView[${parent}] as Element).appendChild(lView[${lastRef}])`;\n      case IcuCreateOpCode.Attr:\n        return `(lView[${ref}] as Element).setAttribute(\"${parser.consumeString()}\", \"${\n            parser.consumeString()}\")`;\n    }\n    throw new Error('Unexpected OpCode: ' + getInstructionFromIcuCreateOpCode(opCode));\n  }\n\n  let lastRef = -1;\n  while (parser.hasMore()) {\n    let value = parser.consumeNumberStringOrMarker();\n    if (value === ICU_MARKER) {\n      const text = parser.consumeString();\n      lastRef = parser.consumeNumber();\n      lines.push(`lView[${lastRef}] = document.createComment(\"${text}\")`);\n    } else if (value === ELEMENT_MARKER) {\n      const text = parser.consumeString();\n      lastRef = parser.consumeNumber();\n      lines.push(`lView[${lastRef}] = document.createElement(\"${text}\")`);\n    } else if (typeof value === 'string') {\n      lastRef = parser.consumeNumber();\n      lines.push(`lView[${lastRef}] = document.createTextNode(\"${value}\")`);\n    } else if (typeof value === 'number') {\n      const line = consumeOpCode(value);\n      line && lines.push(line);\n    } else {\n      throw new Error('Unexpected value');\n    }\n  }\n\n  return lines;\n}\n\n/**\n * Converts `I18nRemoveOpCodes` array into a human readable format.\n *\n * This function is attached to the `I18nRemoveOpCodes.debug` if `ngDevMode` is enabled. This\n * function provides a human readable view of the opcodes. This is useful when debugging the\n * application as well as writing more readable tests.\n *\n * @param this `I18nRemoveOpCodes` if attached as a method.\n * @param opcodes `I18nRemoveOpCodes` if invoked as a function.\n */\nexport function i18nRemoveOpCodesToString(\n    this: I18nRemoveOpCodes|void, opcodes?: I18nRemoveOpCodes): string[] {\n  const removeCodes = opcodes || (Array.isArray(this) ? this : []);\n  let lines: string[] = [];\n\n  for (let i = 0; i < removeCodes.length; i++) {\n    const nodeOrIcuIndex = removeCodes[i] as number;\n    if (nodeOrIcuIndex > 0) {\n      // Positive numbers are `RNode`s.\n      lines.push(`remove(lView[${nodeOrIcuIndex}])`);\n    } else {\n      // Negative numbers are ICUs\n      lines.push(`removeNestedICU(${~nodeOrIcuIndex})`);\n    }\n  }\n\n  return lines;\n}\n\n\nclass OpCodeParser {\n  i: number = 0;\n  codes: any[];\n\n  constructor(codes: any[]) {\n    this.codes = codes;\n  }\n\n  hasMore() {\n    return this.i < this.codes.length;\n  }\n\n  consumeNumber(): number {\n    let value = this.codes[this.i++];\n    assertNumber(value, 'expecting number in OpCode');\n    return value;\n  }\n\n  consumeString(): string {\n    let value = this.codes[this.i++];\n    assertString(value, 'expecting string in OpCode');\n    return value;\n  }\n\n  consumeFunction(): Function|null {\n    let value = this.codes[this.i++];\n    if (value === null || typeof value === 'function') {\n      return value;\n    }\n    throw new Error('expecting function in OpCode');\n  }\n\n  consumeNumberOrString(): number|string {\n    let value = this.codes[this.i++];\n    if (typeof value === 'string') {\n      return value;\n    }\n    assertNumber(value, 'expecting number or string in OpCode');\n    return value;\n  }\n\n  consumeNumberStringOrMarker(): number|string|ICU_MARKER|ELEMENT_MARKER {\n    let value = this.codes[this.i++];\n    if (typeof value === 'string' || typeof value === 'number' || value == ICU_MARKER ||\n        value == ELEMENT_MARKER) {\n      return value;\n    }\n    assertNumber(value, 'expecting number, string, ICU_MARKER or ELEMENT_MARKER in OpCode');\n    return value;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport '../../util/ng_dev_mode';\nimport '../../util/ng_i18n_closure_mode';\n\nimport {getTemplateContent, SRCSET_ATTRS, URI_ATTRS, VALID_ATTRS, VALID_ELEMENTS} from '../../sanitization/html_sanitizer';\nimport {getInertBodyHelper} from '../../sanitization/inert_body';\nimport {_sanitizeUrl, sanitizeSrcset} from '../../sanitization/url_sanitizer';\nimport {assertDefined, assertEqual, assertGreaterThanOrEqual, assertOneOf, assertString} from '../../util/assert';\nimport {CharCode} from '../../util/char_code';\nimport {loadIcuContainerVisitor} from '../instructions/i18n_icu_container_visitor';\nimport {allocExpando, createTNodeAtIndex} from '../instructions/shared';\nimport {getDocument} from '../interfaces/document';\nimport {ELEMENT_MARKER, I18nCreateOpCode, I18nCreateOpCodes, I18nRemoveOpCodes, I18nUpdateOpCode, I18nUpdateOpCodes, ICU_MARKER, IcuCreateOpCode, IcuCreateOpCodes, IcuExpression, IcuType, TI18n, TIcu} from '../interfaces/i18n';\nimport {TNode, TNodeType} from '../interfaces/node';\nimport {SanitizerFn} from '../interfaces/sanitization';\nimport {HEADER_OFFSET, LView, TView} from '../interfaces/view';\nimport {getCurrentParentTNode, getCurrentTNode, setCurrentTNode} from '../state';\nimport {attachDebugGetter} from '../util/debug_utils';\n\nimport {i18nCreateOpCodesToString, i18nRemoveOpCodesToString, i18nUpdateOpCodesToString, icuCreateOpCodesToString} from './i18n_debug';\nimport {addTNodeAndUpdateInsertBeforeIndex} from './i18n_insert_before_index';\nimport {ensureIcuContainerVisitorLoaded} from './i18n_tree_shaking';\nimport {createTNodePlaceholder, icuCreateOpCode, setTIcu, setTNodeInsertBeforeIndex} from './i18n_util';\n\n\n\nconst BINDING_REGEXP = /�(\\d+):?\\d*�/gi;\nconst ICU_REGEXP = /({\\s*�\\d+:?\\d*�\\s*,\\s*\\S{6}\\s*,[\\s\\S]*})/gi;\nconst NESTED_ICU = /�(\\d+)�/;\nconst ICU_BLOCK_REGEXP = /^\\s*(�\\d+:?\\d*�)\\s*,\\s*(select|plural)\\s*,/;\n\nconst MARKER = `�`;\nconst SUBTEMPLATE_REGEXP = /�\\/?\\*(\\d+:\\d+)�/gi;\nconst PH_REGEXP = /�(\\/?[#*]\\d+):?\\d*�/gi;\n\n/**\n * Angular Dart introduced &ngsp; as a placeholder for non-removable space, see:\n * https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart#L25-L32\n * In Angular Dart &ngsp; is converted to the 0xE500 PUA (Private Use Areas) unicode character\n * and later on replaced by a space. We are re-implementing the same idea here, since translations\n * might contain this special character.\n */\nconst NGSP_UNICODE_REGEXP = /\\uE500/g;\nfunction replaceNgsp(value: string): string {\n  return value.replace(NGSP_UNICODE_REGEXP, ' ');\n}\n\n/**\n * Create dynamic nodes from i18n translation block.\n *\n * - Text nodes are created synchronously\n * - TNodes are linked into tree lazily\n *\n * @param tView Current `TView`\n * @parentTNodeIndex index to the parent TNode of this i18n block\n * @param lView Current `LView`\n * @param index Index of `ɵɵi18nStart` instruction.\n * @param message Message to translate.\n * @param subTemplateIndex Index into the sub template of message translation. (ie in case of\n *     `ngIf`) (-1 otherwise)\n */\nexport function i18nStartFirstCreatePass(\n    tView: TView, parentTNodeIndex: number, lView: LView, index: number, message: string,\n    subTemplateIndex: number) {\n  const rootTNode = getCurrentParentTNode();\n  const createOpCodes: I18nCreateOpCodes = [] as any;\n  const updateOpCodes: I18nUpdateOpCodes = [] as any;\n  const existingTNodeStack: TNode[][] = [[]];\n  if (ngDevMode) {\n    attachDebugGetter(createOpCodes, i18nCreateOpCodesToString);\n    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n  }\n\n  message = getTranslationForTemplate(message, subTemplateIndex);\n  const msgParts = replaceNgsp(message).split(PH_REGEXP);\n  for (let i = 0; i < msgParts.length; i++) {\n    let value = msgParts[i];\n    if ((i & 1) === 0) {\n      // Even indexes are text (including bindings & ICU expressions)\n      const parts = i18nParseTextIntoPartsAndICU(value);\n      for (let j = 0; j < parts.length; j++) {\n        let part = parts[j];\n        if ((j & 1) === 0) {\n          // `j` is odd therefore `part` is string\n          const text = part as string;\n          ngDevMode && assertString(text, 'Parsed ICU part should be string');\n          if (text !== '') {\n            i18nStartFirstCreatePassProcessTextNode(\n                tView, rootTNode, existingTNodeStack[0], createOpCodes, updateOpCodes, lView, text);\n          }\n        } else {\n          // `j` is Even therefor `part` is an `ICUExpression`\n          const icuExpression: IcuExpression = part as IcuExpression;\n          // Verify that ICU expression has the right shape. Translations might contain invalid\n          // constructions (while original messages were correct), so ICU parsing at runtime may\n          // not succeed (thus `icuExpression` remains a string).\n          // Note: we intentionally retain the error here by not using `ngDevMode`, because\n          // the value can change based on the locale and users aren't guaranteed to hit\n          // an invalid string while they're developing.\n          if (typeof icuExpression !== 'object') {\n            throw new Error(`Unable to parse ICU expression in \"${message}\" message.`);\n          }\n          const icuContainerTNode = createTNodeAndAddOpCode(\n              tView, rootTNode, existingTNodeStack[0], lView, createOpCodes,\n              ngDevMode ? `ICU ${index}:${icuExpression.mainBinding}` : '', true);\n          const icuNodeIndex = icuContainerTNode.index;\n          ngDevMode &&\n              assertGreaterThanOrEqual(\n                  icuNodeIndex, HEADER_OFFSET, 'Index must be in absolute LView offset');\n          icuStart(tView, lView, updateOpCodes, parentTNodeIndex, icuExpression, icuNodeIndex);\n        }\n      }\n    } else {\n      // Odd indexes are placeholders (elements and sub-templates)\n      // At this point value is something like: '/#1:2' (originally coming from '�/#1:2�')\n      const isClosing = value.charCodeAt(0) === CharCode.SLASH;\n      const type = value.charCodeAt(isClosing ? 1 : 0);\n      ngDevMode && assertOneOf(type, CharCode.STAR, CharCode.HASH);\n      const index = HEADER_OFFSET + Number.parseInt(value.substring((isClosing ? 2 : 1)));\n      if (isClosing) {\n        existingTNodeStack.shift();\n        setCurrentTNode(getCurrentParentTNode()!, false);\n      } else {\n        const tNode = createTNodePlaceholder(tView, existingTNodeStack[0], index);\n        existingTNodeStack.unshift([]);\n        setCurrentTNode(tNode, true);\n      }\n    }\n  }\n\n  tView.data[index] = <TI18n>{\n    create: createOpCodes,\n    update: updateOpCodes,\n  };\n}\n\n/**\n * Allocate space in i18n Range add create OpCode instruction to create a text or comment node.\n *\n * @param tView Current `TView` needed to allocate space in i18n range.\n * @param rootTNode Root `TNode` of the i18n block. This node determines if the new TNode will be\n *     added as part of the `i18nStart` instruction or as part of the `TNode.insertBeforeIndex`.\n * @param existingTNodes internal state for `addTNodeAndUpdateInsertBeforeIndex`.\n * @param lView Current `LView` needed to allocate space in i18n range.\n * @param createOpCodes Array storing `I18nCreateOpCodes` where new opCodes will be added.\n * @param text Text to be added when the `Text` or `Comment` node will be created.\n * @param isICU true if a `Comment` node for ICU (instead of `Text`) node should be created.\n */\nfunction createTNodeAndAddOpCode(\n    tView: TView, rootTNode: TNode|null, existingTNodes: TNode[], lView: LView,\n    createOpCodes: I18nCreateOpCodes, text: string|null, isICU: boolean): TNode {\n  const i18nNodeIdx = allocExpando(tView, lView, 1, null);\n  let opCode = i18nNodeIdx << I18nCreateOpCode.SHIFT;\n  let parentTNode = getCurrentParentTNode();\n\n  if (rootTNode === parentTNode) {\n    // FIXME(misko): A null `parentTNode` should represent when we fall of the `LView` boundary.\n    // (there is no parent), but in some circumstances (because we are inconsistent about how we set\n    // `previousOrParentTNode`) it could point to `rootTNode` So this is a work around.\n    parentTNode = null;\n  }\n  if (parentTNode === null) {\n    // If we don't have a parent that means that we can eagerly add nodes.\n    // If we have a parent than these nodes can't be added now (as the parent has not been created\n    // yet) and instead the `parentTNode` is responsible for adding it. See\n    // `TNode.insertBeforeIndex`\n    opCode |= I18nCreateOpCode.APPEND_EAGERLY;\n  }\n  if (isICU) {\n    opCode |= I18nCreateOpCode.COMMENT;\n    ensureIcuContainerVisitorLoaded(loadIcuContainerVisitor);\n  }\n  createOpCodes.push(opCode, text === null ? '' : text);\n  // We store `{{?}}` so that when looking at debug `TNodeType.template` we can see where the\n  // bindings are.\n  const tNode = createTNodeAtIndex(\n      tView, i18nNodeIdx, isICU ? TNodeType.Icu : TNodeType.Text,\n      text === null ? (ngDevMode ? '{{?}}' : '') : text, null);\n  addTNodeAndUpdateInsertBeforeIndex(existingTNodes, tNode);\n  const tNodeIdx = tNode.index;\n  setCurrentTNode(tNode, false /* Text nodes are self closing */);\n  if (parentTNode !== null && rootTNode !== parentTNode) {\n    // We are a child of deeper node (rather than a direct child of `i18nStart` instruction.)\n    // We have to make sure to add ourselves to the parent.\n    setTNodeInsertBeforeIndex(parentTNode, tNodeIdx);\n  }\n  return tNode;\n}\n\n/**\n * Processes text node in i18n block.\n *\n * Text nodes can have:\n * - Create instruction in `createOpCodes` for creating the text node.\n * - Allocate spec for text node in i18n range of `LView`\n * - If contains binding:\n *    - bindings => allocate space in i18n range of `LView` to store the binding value.\n *    - populate `updateOpCodes` with update instructions.\n *\n * @param tView Current `TView`\n * @param rootTNode Root `TNode` of the i18n block. This node determines if the new TNode will\n *     be added as part of the `i18nStart` instruction or as part of the\n *     `TNode.insertBeforeIndex`.\n * @param existingTNodes internal state for `addTNodeAndUpdateInsertBeforeIndex`.\n * @param createOpCodes Location where the creation OpCodes will be stored.\n * @param lView Current `LView`\n * @param text The translated text (which may contain binding)\n */\nfunction i18nStartFirstCreatePassProcessTextNode(\n    tView: TView, rootTNode: TNode|null, existingTNodes: TNode[], createOpCodes: I18nCreateOpCodes,\n    updateOpCodes: I18nUpdateOpCodes, lView: LView, text: string): void {\n  const hasBinding = text.match(BINDING_REGEXP);\n  const tNode = createTNodeAndAddOpCode(\n      tView, rootTNode, existingTNodes, lView, createOpCodes, hasBinding ? null : text, false);\n  if (hasBinding) {\n    generateBindingUpdateOpCodes(updateOpCodes, text, tNode.index, null, 0, null);\n  }\n}\n\n/**\n * See `i18nAttributes` above.\n */\nexport function i18nAttributesFirstPass(tView: TView, index: number, values: string[]) {\n  const previousElement = getCurrentTNode()!;\n  const previousElementIndex = previousElement.index;\n  const updateOpCodes: I18nUpdateOpCodes = [] as any;\n  if (ngDevMode) {\n    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n  }\n  if (tView.firstCreatePass && tView.data[index] === null) {\n    for (let i = 0; i < values.length; i += 2) {\n      const attrName = values[i];\n      const message = values[i + 1];\n\n      if (message !== '') {\n        // Check if attribute value contains an ICU and throw an error if that's the case.\n        // ICUs in element attributes are not supported.\n        // Note: we intentionally retain the error here by not using `ngDevMode`, because\n        // the `value` can change based on the locale and users aren't guaranteed to hit\n        // an invalid string while they're developing.\n        if (ICU_REGEXP.test(message)) {\n          throw new Error(\n              `ICU expressions are not supported in attributes. Message: \"${message}\".`);\n        }\n\n        // i18n attributes that hit this code path are guaranteed to have bindings, because\n        // the compiler treats static i18n attributes as regular attribute bindings.\n        // Since this may not be the first i18n attribute on this element we need to pass in how\n        // many previous bindings there have already been.\n        generateBindingUpdateOpCodes(\n            updateOpCodes, message, previousElementIndex, attrName, countBindings(updateOpCodes),\n            null);\n      }\n    }\n    tView.data[index] = updateOpCodes;\n  }\n}\n\n\n/**\n * Generate the OpCodes to update the bindings of a string.\n *\n * @param updateOpCodes Place where the update opcodes will be stored.\n * @param str The string containing the bindings.\n * @param destinationNode Index of the destination node which will receive the binding.\n * @param attrName Name of the attribute, if the string belongs to an attribute.\n * @param sanitizeFn Sanitization function used to sanitize the string after update, if necessary.\n * @param bindingStart The lView index of the next expression that can be bound via an opCode.\n * @returns The mask value for these bindings\n */\nfunction generateBindingUpdateOpCodes(\n    updateOpCodes: I18nUpdateOpCodes, str: string, destinationNode: number, attrName: string|null,\n    bindingStart: number, sanitizeFn: SanitizerFn|null): number {\n  ngDevMode &&\n      assertGreaterThanOrEqual(\n          destinationNode, HEADER_OFFSET, 'Index must be in absolute LView offset');\n  const maskIndex = updateOpCodes.length;  // Location of mask\n  const sizeIndex = maskIndex + 1;         // location of size for skipping\n  updateOpCodes.push(null, null);          // Alloc space for mask and size\n  const startIndex = maskIndex + 2;        // location of first allocation.\n  if (ngDevMode) {\n    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n  }\n  const textParts = str.split(BINDING_REGEXP);\n  let mask = 0;\n\n  for (let j = 0; j < textParts.length; j++) {\n    const textValue = textParts[j];\n\n    if (j & 1) {\n      // Odd indexes are bindings\n      const bindingIndex = bindingStart + parseInt(textValue, 10);\n      updateOpCodes.push(-1 - bindingIndex);\n      mask = mask | toMaskBit(bindingIndex);\n    } else if (textValue !== '') {\n      // Even indexes are text\n      updateOpCodes.push(textValue);\n    }\n  }\n\n  updateOpCodes.push(\n      destinationNode << I18nUpdateOpCode.SHIFT_REF |\n      (attrName ? I18nUpdateOpCode.Attr : I18nUpdateOpCode.Text));\n  if (attrName) {\n    updateOpCodes.push(attrName, sanitizeFn);\n  }\n  updateOpCodes[maskIndex] = mask;\n  updateOpCodes[sizeIndex] = updateOpCodes.length - startIndex;\n  return mask;\n}\n\n/**\n * Count the number of bindings in the given `opCodes`.\n *\n * It could be possible to speed this up, by passing the number of bindings found back from\n * `generateBindingUpdateOpCodes()` to `i18nAttributesFirstPass()` but this would then require more\n * complexity in the code and/or transient objects to be created.\n *\n * Since this function is only called once when the template is instantiated, is trivial in the\n * first instance (since `opCodes` will be an empty array), and it is not common for elements to\n * contain multiple i18n bound attributes, it seems like this is a reasonable compromise.\n */\nfunction countBindings(opCodes: I18nUpdateOpCodes): number {\n  let count = 0;\n  for (let i = 0; i < opCodes.length; i++) {\n    const opCode = opCodes[i];\n    // Bindings are negative numbers.\n    if (typeof opCode === 'number' && opCode < 0) {\n      count++;\n    }\n  }\n  return count;\n}\n\n/**\n * Convert binding index to mask bit.\n *\n * Each index represents a single bit on the bit-mask. Because bit-mask only has 32 bits, we make\n * the 32nd bit share all masks for all bindings higher than 32. Since it is extremely rare to\n * have more than 32 bindings this will be hit very rarely. The downside of hitting this corner\n * case is that we will execute binding code more often than necessary. (penalty of performance)\n */\nfunction toMaskBit(bindingIndex: number): number {\n  return 1 << Math.min(bindingIndex, 31);\n}\n\nexport function isRootTemplateMessage(subTemplateIndex: number): subTemplateIndex is - 1 {\n  return subTemplateIndex === -1;\n}\n\n\n/**\n * Removes everything inside the sub-templates of a message.\n */\nfunction removeInnerTemplateTranslation(message: string): string {\n  let match;\n  let res = '';\n  let index = 0;\n  let inTemplate = false;\n  let tagMatched;\n\n  while ((match = SUBTEMPLATE_REGEXP.exec(message)) !== null) {\n    if (!inTemplate) {\n      res += message.substring(index, match.index + match[0].length);\n      tagMatched = match[1];\n      inTemplate = true;\n    } else {\n      if (match[0] === `${MARKER}/*${tagMatched}${MARKER}`) {\n        index = match.index;\n        inTemplate = false;\n      }\n    }\n  }\n\n  ngDevMode &&\n      assertEqual(\n          inTemplate, false,\n          `Tag mismatch: unable to find the end of the sub-template in the translation \"${\n              message}\"`);\n\n  res += message.slice(index);\n  return res;\n}\n\n\n/**\n * Extracts a part of a message and removes the rest.\n *\n * This method is used for extracting a part of the message associated with a template. A\n * translated message can span multiple templates.\n *\n * Example:\n * ```\n * <div i18n>Translate <span *ngIf>me</span>!</div>\n * ```\n *\n * @param message The message to crop\n * @param subTemplateIndex Index of the sub-template to extract. If undefined it returns the\n * external template and removes all sub-templates.\n */\nexport function getTranslationForTemplate(message: string, subTemplateIndex: number) {\n  if (isRootTemplateMessage(subTemplateIndex)) {\n    // We want the root template message, ignore all sub-templates\n    return removeInnerTemplateTranslation(message);\n  } else {\n    // We want a specific sub-template\n    const start =\n        message.indexOf(`:${subTemplateIndex}${MARKER}`) + 2 + subTemplateIndex.toString().length;\n    const end = message.search(new RegExp(`${MARKER}\\\\/\\\\*\\\\d+:${subTemplateIndex}${MARKER}`));\n    return removeInnerTemplateTranslation(message.substring(start, end));\n  }\n}\n\n/**\n * Generate the OpCodes for ICU expressions.\n *\n * @param icuExpression\n * @param index Index where the anchor is stored and an optional `TIcuContainerNode`\n *   - `lView[anchorIdx]` points to a `Comment` node representing the anchor for the ICU.\n *   - `tView.data[anchorIdx]` points to the `TIcuContainerNode` if ICU is root (`null` otherwise)\n */\nexport function icuStart(\n    tView: TView, lView: LView, updateOpCodes: I18nUpdateOpCodes, parentIdx: number,\n    icuExpression: IcuExpression, anchorIdx: number) {\n  ngDevMode && assertDefined(icuExpression, 'ICU expression must be defined');\n  let bindingMask = 0;\n  const tIcu: TIcu = {\n    type: icuExpression.type,\n    currentCaseLViewIndex: allocExpando(tView, lView, 1, null),\n    anchorIdx,\n    cases: [],\n    create: [],\n    remove: [],\n    update: []\n  };\n  addUpdateIcuSwitch(updateOpCodes, icuExpression, anchorIdx);\n  setTIcu(tView, anchorIdx, tIcu);\n  const values = icuExpression.values;\n  for (let i = 0; i < values.length; i++) {\n    // Each value is an array of strings & other ICU expressions\n    const valueArr = values[i];\n    const nestedIcus: IcuExpression[] = [];\n    for (let j = 0; j < valueArr.length; j++) {\n      const value = valueArr[j];\n      if (typeof value !== 'string') {\n        // It is an nested ICU expression\n        const icuIndex = nestedIcus.push(value as IcuExpression) - 1;\n        // Replace nested ICU expression by a comment node\n        valueArr[j] = `<!--�${icuIndex}�-->`;\n      }\n    }\n    bindingMask = parseIcuCase(\n                      tView, tIcu, lView, updateOpCodes, parentIdx, icuExpression.cases[i],\n                      valueArr.join(''), nestedIcus) |\n        bindingMask;\n  }\n  if (bindingMask) {\n    addUpdateIcuUpdate(updateOpCodes, bindingMask, anchorIdx);\n  }\n}\n\n/**\n * Parses text containing an ICU expression and produces a JSON object for it.\n * Original code from closure library, modified for Angular.\n *\n * @param pattern Text containing an ICU expression that needs to be parsed.\n *\n */\nexport function parseICUBlock(pattern: string): IcuExpression {\n  const cases = [];\n  const values: (string|IcuExpression)[][] = [];\n  let icuType = IcuType.plural;\n  let mainBinding = 0;\n  pattern = pattern.replace(ICU_BLOCK_REGEXP, function(str: string, binding: string, type: string) {\n    if (type === 'select') {\n      icuType = IcuType.select;\n    } else {\n      icuType = IcuType.plural;\n    }\n    mainBinding = parseInt(binding.slice(1), 10);\n    return '';\n  });\n\n  const parts = i18nParseTextIntoPartsAndICU(pattern) as string[];\n  // Looking for (key block)+ sequence. One of the keys has to be \"other\".\n  for (let pos = 0; pos < parts.length;) {\n    let key = parts[pos++].trim();\n    if (icuType === IcuType.plural) {\n      // Key can be \"=x\", we just want \"x\"\n      key = key.replace(/\\s*(?:=)?(\\w+)\\s*/, '$1');\n    }\n    if (key.length) {\n      cases.push(key);\n    }\n\n    const blocks = i18nParseTextIntoPartsAndICU(parts[pos++]) as string[];\n    if (cases.length > values.length) {\n      values.push(blocks);\n    }\n  }\n\n  // TODO(ocombe): support ICU expressions in attributes, see #21615\n  return {type: icuType, mainBinding: mainBinding, cases, values};\n}\n\n\n/**\n * Breaks pattern into strings and top level {...} blocks.\n * Can be used to break a message into text and ICU expressions, or to break an ICU expression\n * into keys and cases. Original code from closure library, modified for Angular.\n *\n * @param pattern (sub)Pattern to be broken.\n * @returns An `Array<string|IcuExpression>` where:\n *   - odd positions: `string` => text between ICU expressions\n *   - even positions: `ICUExpression` => ICU expression parsed into `ICUExpression` record.\n */\nexport function i18nParseTextIntoPartsAndICU(pattern: string): (string|IcuExpression)[] {\n  if (!pattern) {\n    return [];\n  }\n\n  let prevPos = 0;\n  const braceStack = [];\n  const results: (string|IcuExpression)[] = [];\n  const braces = /[{}]/g;\n  // lastIndex doesn't get set to 0 so we have to.\n  braces.lastIndex = 0;\n\n  let match;\n  while (match = braces.exec(pattern)) {\n    const pos = match.index;\n    if (match[0] == '}') {\n      braceStack.pop();\n\n      if (braceStack.length == 0) {\n        // End of the block.\n        const block = pattern.substring(prevPos, pos);\n        if (ICU_BLOCK_REGEXP.test(block)) {\n          results.push(parseICUBlock(block));\n        } else {\n          results.push(block);\n        }\n\n        prevPos = pos + 1;\n      }\n    } else {\n      if (braceStack.length == 0) {\n        const substring = pattern.substring(prevPos, pos);\n        results.push(substring);\n        prevPos = pos + 1;\n      }\n      braceStack.push('{');\n    }\n  }\n\n  const substring = pattern.substring(prevPos);\n  results.push(substring);\n  return results;\n}\n\n\n/**\n * Parses a node, its children and its siblings, and generates the mutate & update OpCodes.\n *\n */\nexport function parseIcuCase(\n    tView: TView, tIcu: TIcu, lView: LView, updateOpCodes: I18nUpdateOpCodes, parentIdx: number,\n    caseName: string, unsafeCaseHtml: string, nestedIcus: IcuExpression[]): number {\n  const create: IcuCreateOpCodes = [] as any;\n  const remove: I18nRemoveOpCodes = [] as any;\n  const update: I18nUpdateOpCodes = [] as any;\n  if (ngDevMode) {\n    attachDebugGetter(create, icuCreateOpCodesToString);\n    attachDebugGetter(remove, i18nRemoveOpCodesToString);\n    attachDebugGetter(update, i18nUpdateOpCodesToString);\n  }\n  tIcu.cases.push(caseName);\n  tIcu.create.push(create);\n  tIcu.remove.push(remove);\n  tIcu.update.push(update);\n\n  const inertBodyHelper = getInertBodyHelper(getDocument());\n  const inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeCaseHtml);\n  ngDevMode && assertDefined(inertBodyElement, 'Unable to generate inert body element');\n  const inertRootNode = getTemplateContent(inertBodyElement!) as Element || inertBodyElement;\n  if (inertRootNode) {\n    return walkIcuTree(\n        tView, tIcu, lView, updateOpCodes, create, remove, update, inertRootNode, parentIdx,\n        nestedIcus, 0);\n  } else {\n    return 0;\n  }\n}\n\nfunction walkIcuTree(\n    tView: TView, tIcu: TIcu, lView: LView, sharedUpdateOpCodes: I18nUpdateOpCodes,\n    create: IcuCreateOpCodes, remove: I18nRemoveOpCodes, update: I18nUpdateOpCodes,\n    parentNode: Element, parentIdx: number, nestedIcus: IcuExpression[], depth: number): number {\n  let bindingMask = 0;\n  let currentNode = parentNode.firstChild;\n  while (currentNode) {\n    const newIndex = allocExpando(tView, lView, 1, null);\n    switch (currentNode.nodeType) {\n      case Node.ELEMENT_NODE:\n        const element = currentNode as Element;\n        const tagName = element.tagName.toLowerCase();\n        if (VALID_ELEMENTS.hasOwnProperty(tagName)) {\n          addCreateNodeAndAppend(create, ELEMENT_MARKER, tagName, parentIdx, newIndex);\n          tView.data[newIndex] = tagName;\n          const elAttrs = element.attributes;\n          for (let i = 0; i < elAttrs.length; i++) {\n            const attr = elAttrs.item(i)!;\n            const lowerAttrName = attr.name.toLowerCase();\n            const hasBinding = !!attr.value.match(BINDING_REGEXP);\n            // we assume the input string is safe, unless it's using a binding\n            if (hasBinding) {\n              if (VALID_ATTRS.hasOwnProperty(lowerAttrName)) {\n                if (URI_ATTRS[lowerAttrName]) {\n                  generateBindingUpdateOpCodes(\n                      update, attr.value, newIndex, attr.name, 0, _sanitizeUrl);\n                } else if (SRCSET_ATTRS[lowerAttrName]) {\n                  generateBindingUpdateOpCodes(\n                      update, attr.value, newIndex, attr.name, 0, sanitizeSrcset);\n                } else {\n                  generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, null);\n                }\n              } else {\n                ngDevMode &&\n                    console.warn(\n                        `WARNING: ignoring unsafe attribute value ` +\n                        `${lowerAttrName} on element ${tagName} ` +\n                        `(see https://g.co/ng/security#xss)`);\n              }\n            } else {\n              addCreateAttribute(create, newIndex, attr);\n            }\n          }\n          // Parse the children of this node (if any)\n          bindingMask = walkIcuTree(\n                            tView, tIcu, lView, sharedUpdateOpCodes, create, remove, update,\n                            currentNode as Element, newIndex, nestedIcus, depth + 1) |\n              bindingMask;\n          addRemoveNode(remove, newIndex, depth);\n        }\n        break;\n      case Node.TEXT_NODE:\n        const value = currentNode.textContent || '';\n        const hasBinding = value.match(BINDING_REGEXP);\n        addCreateNodeAndAppend(create, null, hasBinding ? '' : value, parentIdx, newIndex);\n        addRemoveNode(remove, newIndex, depth);\n        if (hasBinding) {\n          bindingMask =\n              generateBindingUpdateOpCodes(update, value, newIndex, null, 0, null) | bindingMask;\n        }\n        break;\n      case Node.COMMENT_NODE:\n        // Check if the comment node is a placeholder for a nested ICU\n        const isNestedIcu = NESTED_ICU.exec(currentNode.textContent || '');\n        if (isNestedIcu) {\n          const nestedIcuIndex = parseInt(isNestedIcu[1], 10);\n          const icuExpression: IcuExpression = nestedIcus[nestedIcuIndex];\n          // Create the comment node that will anchor the ICU expression\n          addCreateNodeAndAppend(\n              create, ICU_MARKER, ngDevMode ? `nested ICU ${nestedIcuIndex}` : '', parentIdx,\n              newIndex);\n          icuStart(tView, lView, sharedUpdateOpCodes, parentIdx, icuExpression, newIndex);\n          addRemoveNestedIcu(remove, newIndex, depth);\n        }\n        break;\n    }\n    currentNode = currentNode.nextSibling;\n  }\n  return bindingMask;\n}\n\nfunction addRemoveNode(remove: I18nRemoveOpCodes, index: number, depth: number) {\n  if (depth === 0) {\n    remove.push(index);\n  }\n}\n\nfunction addRemoveNestedIcu(remove: I18nRemoveOpCodes, index: number, depth: number) {\n  if (depth === 0) {\n    remove.push(~index);  // remove ICU at `index`\n    remove.push(index);   // remove ICU comment at `index`\n  }\n}\n\nfunction addUpdateIcuSwitch(\n    update: I18nUpdateOpCodes, icuExpression: IcuExpression, index: number) {\n  update.push(\n      toMaskBit(icuExpression.mainBinding), 2, -1 - icuExpression.mainBinding,\n      index << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.IcuSwitch);\n}\n\nfunction addUpdateIcuUpdate(update: I18nUpdateOpCodes, bindingMask: number, index: number) {\n  update.push(bindingMask, 1, index << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.IcuUpdate);\n}\n\nfunction addCreateNodeAndAppend(\n    create: IcuCreateOpCodes, marker: null|ICU_MARKER|ELEMENT_MARKER, text: string,\n    appendToParentIdx: number, createAtIdx: number) {\n  if (marker !== null) {\n    create.push(marker);\n  }\n  create.push(\n      text, createAtIdx,\n      icuCreateOpCode(IcuCreateOpCode.AppendChild, appendToParentIdx, createAtIdx));\n}\n\nfunction addCreateAttribute(create: IcuCreateOpCodes, newIndex: number, attr: Attr) {\n  create.push(newIndex << IcuCreateOpCode.SHIFT_REF | IcuCreateOpCode.Attr, attr.name, attr.value);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// i18nPostprocess consts\nconst ROOT_TEMPLATE_ID = 0;\nconst PP_MULTI_VALUE_PLACEHOLDERS_REGEXP = /\\[(�.+?�?)\\]/;\nconst PP_PLACEHOLDERS_REGEXP = /\\[(�.+?�?)\\]|(�\\/?\\*\\d+:\\d+�)/g;\nconst PP_ICU_VARS_REGEXP = /({\\s*)(VAR_(PLURAL|SELECT)(_\\d+)?)(\\s*,)/g;\nconst PP_ICU_PLACEHOLDERS_REGEXP = /{([A-Z0-9_]+)}/g;\nconst PP_ICUS_REGEXP = /�I18N_EXP_(ICU(_\\d+)?)�/g;\nconst PP_CLOSE_TEMPLATE_REGEXP = /\\/\\*/;\nconst PP_TEMPLATE_ID_REGEXP = /\\d+\\:(\\d+)/;\n\n// Parsed placeholder structure used in postprocessing (within `i18nPostprocess` function)\n// Contains the following fields: [templateId, isCloseTemplateTag, placeholder]\ntype PostprocessPlaceholder = [number, boolean, string];\n\n\n/**\n * Handles message string post-processing for internationalization.\n *\n * Handles message string post-processing by transforming it from intermediate\n * format (that might contain some markers that we need to replace) to the final\n * form, consumable by i18nStart instruction. Post processing steps include:\n *\n * 1. Resolve all multi-value cases (like [�*1:1��#2:1�|�#4:1�|�5�])\n * 2. Replace all ICU vars (like \"VAR_PLURAL\")\n * 3. Replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n * 4. Replace all ICU references with corresponding values (like �ICU_EXP_ICU_1�)\n *    in case multiple ICUs have the same placeholder name\n *\n * @param message Raw translation string for post processing\n * @param replacements Set of replacements that should be applied\n *\n * @returns Transformed string that can be consumed by i18nStart instruction\n *\n * @codeGenApi\n */\nexport function i18nPostprocess(\n    message: string, replacements: {[key: string]: (string|string[])} = {}): string {\n  /**\n   * Step 1: resolve all multi-value placeholders like [�#5�|�*1:1��#2:1�|�#4:1�]\n   *\n   * Note: due to the way we process nested templates (BFS), multi-value placeholders are typically\n   * grouped by templates, for example: [�#5�|�#6�|�#1:1�|�#3:2�] where �#5� and �#6� belong to root\n   * template, �#1:1� belong to nested template with index 1 and �#1:2� - nested template with index\n   * 3. However in real templates the order might be different: i.e. �#1:1� and/or �#3:2� may go in\n   * front of �#6�. The post processing step restores the right order by keeping track of the\n   * template id stack and looks for placeholders that belong to the currently active template.\n   */\n  let result: string = message;\n  if (PP_MULTI_VALUE_PLACEHOLDERS_REGEXP.test(message)) {\n    const matches: {[key: string]: PostprocessPlaceholder[]} = {};\n    const templateIdsStack: number[] = [ROOT_TEMPLATE_ID];\n    result = result.replace(PP_PLACEHOLDERS_REGEXP, (m: any, phs: string, tmpl: string): string => {\n      const content = phs || tmpl;\n      const placeholders: PostprocessPlaceholder[] = matches[content] || [];\n      if (!placeholders.length) {\n        content.split('|').forEach((placeholder: string) => {\n          const match = placeholder.match(PP_TEMPLATE_ID_REGEXP);\n          const templateId = match ? parseInt(match[1], 10) : ROOT_TEMPLATE_ID;\n          const isCloseTemplateTag = PP_CLOSE_TEMPLATE_REGEXP.test(placeholder);\n          placeholders.push([templateId, isCloseTemplateTag, placeholder]);\n        });\n        matches[content] = placeholders;\n      }\n\n      if (!placeholders.length) {\n        throw new Error(`i18n postprocess: unmatched placeholder - ${content}`);\n      }\n\n      const currentTemplateId = templateIdsStack[templateIdsStack.length - 1];\n      let idx = 0;\n      // find placeholder index that matches current template id\n      for (let i = 0; i < placeholders.length; i++) {\n        if (placeholders[i][0] === currentTemplateId) {\n          idx = i;\n          break;\n        }\n      }\n      // update template id stack based on the current tag extracted\n      const [templateId, isCloseTemplateTag, placeholder] = placeholders[idx];\n      if (isCloseTemplateTag) {\n        templateIdsStack.pop();\n      } else if (currentTemplateId !== templateId) {\n        templateIdsStack.push(templateId);\n      }\n      // remove processed tag from the list\n      placeholders.splice(idx, 1);\n      return placeholder;\n    });\n  }\n\n  // return current result if no replacements specified\n  if (!Object.keys(replacements).length) {\n    return result;\n  }\n\n  /**\n   * Step 2: replace all ICU vars (like \"VAR_PLURAL\")\n   */\n  result = result.replace(PP_ICU_VARS_REGEXP, (match, start, key, _type, _idx, end): string => {\n    return replacements.hasOwnProperty(key) ? `${start}${replacements[key]}${end}` : match;\n  });\n\n  /**\n   * Step 3: replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n   */\n  result = result.replace(PP_ICU_PLACEHOLDERS_REGEXP, (match, key): string => {\n    return replacements.hasOwnProperty(key) ? replacements[key] as string : match;\n  });\n\n  /**\n   * Step 4: replace all ICU references with corresponding values (like �ICU_EXP_ICU_1�) in case\n   * multiple ICUs have the same placeholder name\n   */\n  result = result.replace(PP_ICUS_REGEXP, (match, key): string => {\n    if (replacements.hasOwnProperty(key)) {\n      const list = replacements[key] as string[];\n      if (!list.length) {\n        throw new Error(`i18n postprocess: unmatched ICU - ${match} with key: ${key}`);\n      }\n      return list.shift()!;\n    }\n    return match;\n  });\n\n  return result;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport '../../util/ng_dev_mode';\nimport '../../util/ng_i18n_closure_mode';\n\nimport {assertDefined} from '../../util/assert';\nimport {bindingUpdated} from '../bindings';\nimport {applyCreateOpCodes, applyI18n, setMaskBit} from '../i18n/i18n_apply';\nimport {i18nAttributesFirstPass, i18nStartFirstCreatePass} from '../i18n/i18n_parse';\nimport {i18nPostprocess} from '../i18n/i18n_postprocess';\nimport {TI18n} from '../interfaces/i18n';\nimport {TElementNode, TNodeType} from '../interfaces/node';\nimport {HEADER_OFFSET, T_HOST} from '../interfaces/view';\nimport {getClosestRElement} from '../node_manipulation';\nimport {getCurrentParentTNode, getLView, getTView, nextBindingIndex, setInI18nBlock} from '../state';\nimport {getConstant} from '../util/view_utils';\n\n/**\n * Marks a block of text as translatable.\n *\n * The instructions `i18nStart` and `i18nEnd` mark the translation block in the template.\n * The translation `message` is the value which is locale specific. The translation string may\n * contain placeholders which associate inner elements and sub-templates within the translation.\n *\n * The translation `message` placeholders are:\n * - `�{index}(:{block})�`: *Binding Placeholder*: Marks a location where an expression will be\n *   interpolated into. The placeholder `index` points to the expression binding index. An optional\n *   `block` that matches the sub-template in which it was declared.\n * - `�#{index}(:{block})�`/`�/#{index}(:{block})�`: *Element Placeholder*:  Marks the beginning\n *   and end of DOM element that were embedded in the original translation block. The placeholder\n *   `index` points to the element index in the template instructions set. An optional `block` that\n *   matches the sub-template in which it was declared.\n * - `�*{index}:{block}�`/`�/*{index}:{block}�`: *Sub-template Placeholder*: Sub-templates must be\n *   split up and translated separately in each angular template function. The `index` points to the\n *   `template` instruction index. A `block` that matches the sub-template in which it was declared.\n *\n * @param index A unique index of the translation in the static block.\n * @param messageIndex An index of the translation message from the `def.consts` array.\n * @param subTemplateIndex Optional sub-template index in the `message`.\n *\n * @codeGenApi\n */\nexport function ɵɵi18nStart(\n    index: number, messageIndex: number, subTemplateIndex: number = -1): void {\n  const tView = getTView();\n  const lView = getLView();\n  const adjustedIndex = HEADER_OFFSET + index;\n  ngDevMode && assertDefined(tView, `tView should be defined`);\n  const message = getConstant<string>(tView.consts, messageIndex)!;\n  const parentTNode = getCurrentParentTNode() as TElementNode | null;\n  if (tView.firstCreatePass) {\n    i18nStartFirstCreatePass(\n        tView, parentTNode === null ? 0 : parentTNode.index, lView, adjustedIndex, message,\n        subTemplateIndex);\n  }\n  const tI18n = tView.data[adjustedIndex] as TI18n;\n  const sameViewParentTNode = parentTNode === lView[T_HOST] ? null : parentTNode;\n  const parentRNode = getClosestRElement(tView, sameViewParentTNode, lView);\n  // If `parentTNode` is an `ElementContainer` than it has `<!--ng-container--->`.\n  // When we do inserts we have to make sure to insert in front of `<!--ng-container--->`.\n  const insertInFrontOf = parentTNode && (parentTNode.type & TNodeType.ElementContainer) ?\n      lView[parentTNode.index] :\n      null;\n  applyCreateOpCodes(lView, tI18n.create, parentRNode, insertInFrontOf);\n  setInI18nBlock(true);\n}\n\n\n\n/**\n * Translates a translation block marked by `i18nStart` and `i18nEnd`. It inserts the text/ICU nodes\n * into the render tree, moves the placeholder nodes and removes the deleted nodes.\n *\n * @codeGenApi\n */\nexport function ɵɵi18nEnd(): void {\n  setInI18nBlock(false);\n}\n\n/**\n *\n * Use this instruction to create a translation block that doesn't contain any placeholder.\n * It calls both {@link i18nStart} and {@link i18nEnd} in one instruction.\n *\n * The translation `message` is the value which is locale specific. The translation string may\n * contain placeholders which associate inner elements and sub-templates within the translation.\n *\n * The translation `message` placeholders are:\n * - `�{index}(:{block})�`: *Binding Placeholder*: Marks a location where an expression will be\n *   interpolated into. The placeholder `index` points to the expression binding index. An optional\n *   `block` that matches the sub-template in which it was declared.\n * - `�#{index}(:{block})�`/`�/#{index}(:{block})�`: *Element Placeholder*:  Marks the beginning\n *   and end of DOM element that were embedded in the original translation block. The placeholder\n *   `index` points to the element index in the template instructions set. An optional `block` that\n *   matches the sub-template in which it was declared.\n * - `�*{index}:{block}�`/`�/*{index}:{block}�`: *Sub-template Placeholder*: Sub-templates must be\n *   split up and translated separately in each angular template function. The `index` points to the\n *   `template` instruction index. A `block` that matches the sub-template in which it was declared.\n *\n * @param index A unique index of the translation in the static block.\n * @param messageIndex An index of the translation message from the `def.consts` array.\n * @param subTemplateIndex Optional sub-template index in the `message`.\n *\n * @codeGenApi\n */\nexport function ɵɵi18n(index: number, messageIndex: number, subTemplateIndex?: number): void {\n  ɵɵi18nStart(index, messageIndex, subTemplateIndex);\n  ɵɵi18nEnd();\n}\n\n/**\n * Marks a list of attributes as translatable.\n *\n * @param index A unique index in the static block\n * @param values\n *\n * @codeGenApi\n */\nexport function ɵɵi18nAttributes(index: number, attrsIndex: number): void {\n  const tView = getTView();\n  ngDevMode && assertDefined(tView, `tView should be defined`);\n  const attrs = getConstant<string[]>(tView.consts, attrsIndex)!;\n  i18nAttributesFirstPass(tView, index + HEADER_OFFSET, attrs);\n}\n\n\n/**\n * Stores the values of the bindings during each update cycle in order to determine if we need to\n * update the translated nodes.\n *\n * @param value The binding's value\n * @returns This function returns itself so that it may be chained\n * (e.g. `i18nExp(ctx.name)(ctx.title)`)\n *\n * @codeGenApi\n */\nexport function ɵɵi18nExp<T>(value: T): typeof ɵɵi18nExp {\n  const lView = getLView();\n  setMaskBit(bindingUpdated(lView, nextBindingIndex(), value));\n  return ɵɵi18nExp;\n}\n\n/**\n * Updates a translation block or an i18n attribute when the bindings have changed.\n *\n * @param index Index of either {@link i18nStart} (translation block) or {@link i18nAttributes}\n * (i18n attribute) on which it should update the content.\n *\n * @codeGenApi\n */\nexport function ɵɵi18nApply(index: number) {\n  applyI18n(getTView(), getLView(), index + HEADER_OFFSET);\n}\n\n/**\n * Handles message string post-processing for internationalization.\n *\n * Handles message string post-processing by transforming it from intermediate\n * format (that might contain some markers that we need to replace) to the final\n * form, consumable by i18nStart instruction. Post processing steps include:\n *\n * 1. Resolve all multi-value cases (like [�*1:1��#2:1�|�#4:1�|�5�])\n * 2. Replace all ICU vars (like \"VAR_PLURAL\")\n * 3. Replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n * 4. Replace all ICU references with corresponding values (like �ICU_EXP_ICU_1�)\n *    in case multiple ICUs have the same placeholder name\n *\n * @param message Raw translation string for post processing\n * @param replacements Set of replacements that should be applied\n *\n * @returns Transformed string that can be consumed by i18nStart instruction\n *\n * @codeGenApi\n */\nexport function ɵɵi18nPostprocess(\n    message: string, replacements: {[key: string]: (string|string[])} = {}): string {\n  return i18nPostprocess(message, replacements);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/*\n * This file re-exports all symbols contained in this directory.\n *\n * Why is this file not `index.ts`?\n *\n * There seems to be an inconsistent path resolution of an `index.ts` file\n * when only the parent directory is referenced. This could be due to the\n * node module resolution configuration differing from rollup and/or typescript.\n *\n * With commit\n * https://github.com/angular/angular/commit/d5e3f2c64bd13ce83e7c70788b7fc514ca4a9918\n * the `instructions.ts` file was moved to `instructions/instructions.ts` and an\n * `index.ts` file was used to re-export everything. Having had file names that were\n * importing from `instructions' directly (not the from the sub file or the `index.ts`\n * file) caused strange CI issues. `index.ts` had to be renamed to `all.ts` for this\n * to work.\n *\n * Jira Issue = FW-1184\n */\nexport * from './attribute';\nexport * from './attribute_interpolation';\nexport * from './change_detection';\nexport * from './template';\nexport * from './storage';\nexport * from './di';\nexport * from './di_attr';\nexport * from './element';\nexport * from './element_container';\nexport * from './get_current_view';\nexport * from './listener';\nexport * from './namespace';\nexport * from './next_context';\nexport * from './projection';\nexport * from './property';\nexport * from './property_interpolation';\nexport * from './advance';\nexport * from './styling';\nexport * from './text';\nexport * from './text_interpolation';\nexport * from './class_map_interpolation';\nexport * from './style_map_interpolation';\nexport * from './style_prop_interpolation';\nexport * from './host_property';\nexport * from './i18n';\nexport {ɵgetUnknownElementStrictMode, ɵsetUnknownElementStrictMode, ɵgetUnknownPropertyStrictMode, ɵsetUnknownPropertyStrictMode} from './element_validation';\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {resolveForwardRef} from '../di/forward_ref';\nimport {ClassProvider, Provider} from '../di/interface/provider';\nimport {isClassProvider, isTypeProvider} from '../di/provider_collection';\nimport {providerToFactory} from '../di/r3_injector';\nimport {assertDefined} from '../util/assert';\n\nimport {diPublicInInjector, getNodeInjectable, getOrCreateNodeInjectorForNode} from './di';\nimport {ɵɵdirectiveInject} from './instructions/all';\nimport {DirectiveDef} from './interfaces/definition';\nimport {NodeInjectorFactory} from './interfaces/injector';\nimport {TContainerNode, TDirectiveHostNode, TElementContainerNode, TElementNode, TNodeProviderIndexes} from './interfaces/node';\nimport {isComponentDef} from './interfaces/type_checks';\nimport {DestroyHookData, LView, TData, TVIEW, TView} from './interfaces/view';\nimport {getCurrentTNode, getLView, getTView} from './state';\n\n\n\n/**\n * Resolves the providers which are defined in the DirectiveDef.\n *\n * When inserting the tokens and the factories in their respective arrays, we can assume that\n * this method is called first for the component (if any), and then for other directives on the same\n * node.\n * As a consequence,the providers are always processed in that order:\n * 1) The view providers of the component\n * 2) The providers of the component\n * 3) The providers of the other directives\n * This matches the structure of the injectables arrays of a view (for each node).\n * So the tokens and the factories can be pushed at the end of the arrays, except\n * in one case for multi providers.\n *\n * @param def the directive definition\n * @param providers: Array of `providers`.\n * @param viewProviders: Array of `viewProviders`.\n */\nexport function providersResolver<T>(\n    def: DirectiveDef<T>, providers: Provider[], viewProviders: Provider[]): void {\n  const tView = getTView();\n  if (tView.firstCreatePass) {\n    const isComponent = isComponentDef(def);\n\n    // The list of view providers is processed first, and the flags are updated\n    resolveProvider(viewProviders, tView.data, tView.blueprint, isComponent, true);\n\n    // Then, the list of providers is processed, and the flags are updated\n    resolveProvider(providers, tView.data, tView.blueprint, isComponent, false);\n  }\n}\n\n/**\n * Resolves a provider and publishes it to the DI system.\n */\nfunction resolveProvider(\n    provider: Provider, tInjectables: TData, lInjectablesBlueprint: NodeInjectorFactory[],\n    isComponent: boolean, isViewProvider: boolean): void {\n  provider = resolveForwardRef(provider);\n  if (Array.isArray(provider)) {\n    // Recursively call `resolveProvider`\n    // Recursion is OK in this case because this code will not be in hot-path once we implement\n    // cloning of the initial state.\n    for (let i = 0; i < provider.length; i++) {\n      resolveProvider(\n          provider[i], tInjectables, lInjectablesBlueprint, isComponent, isViewProvider);\n    }\n  } else {\n    const tView = getTView();\n    const lView = getLView();\n    let token: any = isTypeProvider(provider) ? provider : resolveForwardRef(provider.provide);\n    let providerFactory: () => any = providerToFactory(provider);\n\n    const tNode = getCurrentTNode()!;\n    const beginIndex = tNode.providerIndexes & TNodeProviderIndexes.ProvidersStartIndexMask;\n    const endIndex = tNode.directiveStart;\n    const cptViewProvidersCount =\n        tNode.providerIndexes >> TNodeProviderIndexes.CptViewProvidersCountShift;\n\n    if (isTypeProvider(provider) || !provider.multi) {\n      // Single provider case: the factory is created and pushed immediately\n      const factory = new NodeInjectorFactory(providerFactory, isViewProvider, ɵɵdirectiveInject);\n      const existingFactoryIndex = indexOf(\n          token, tInjectables, isViewProvider ? beginIndex : beginIndex + cptViewProvidersCount,\n          endIndex);\n      if (existingFactoryIndex === -1) {\n        diPublicInInjector(\n            getOrCreateNodeInjectorForNode(\n                tNode as TElementNode | TContainerNode | TElementContainerNode, lView),\n            tView, token);\n        registerDestroyHooksIfSupported(tView, provider, tInjectables.length);\n        tInjectables.push(token);\n        tNode.directiveStart++;\n        tNode.directiveEnd++;\n        if (isViewProvider) {\n          tNode.providerIndexes += TNodeProviderIndexes.CptViewProvidersCountShifter;\n        }\n        lInjectablesBlueprint.push(factory);\n        lView.push(factory);\n      } else {\n        lInjectablesBlueprint[existingFactoryIndex] = factory;\n        lView[existingFactoryIndex] = factory;\n      }\n    } else {\n      // Multi provider case:\n      // We create a multi factory which is going to aggregate all the values.\n      // Since the output of such a factory depends on content or view injection,\n      // we create two of them, which are linked together.\n      //\n      // The first one (for view providers) is always in the first block of the injectables array,\n      // and the second one (for providers) is always in the second block.\n      // This is important because view providers have higher priority. When a multi token\n      // is being looked up, the view providers should be found first.\n      // Note that it is not possible to have a multi factory in the third block (directive block).\n      //\n      // The algorithm to process multi providers is as follows:\n      // 1) If the multi provider comes from the `viewProviders` of the component:\n      //   a) If the special view providers factory doesn't exist, it is created and pushed.\n      //   b) Else, the multi provider is added to the existing multi factory.\n      // 2) If the multi provider comes from the `providers` of the component or of another\n      // directive:\n      //   a) If the multi factory doesn't exist, it is created and provider pushed into it.\n      //      It is also linked to the multi factory for view providers, if it exists.\n      //   b) Else, the multi provider is added to the existing multi factory.\n\n      const existingProvidersFactoryIndex =\n          indexOf(token, tInjectables, beginIndex + cptViewProvidersCount, endIndex);\n      const existingViewProvidersFactoryIndex =\n          indexOf(token, tInjectables, beginIndex, beginIndex + cptViewProvidersCount);\n      const doesProvidersFactoryExist = existingProvidersFactoryIndex >= 0 &&\n          lInjectablesBlueprint[existingProvidersFactoryIndex];\n      const doesViewProvidersFactoryExist = existingViewProvidersFactoryIndex >= 0 &&\n          lInjectablesBlueprint[existingViewProvidersFactoryIndex];\n\n      if (isViewProvider && !doesViewProvidersFactoryExist ||\n          !isViewProvider && !doesProvidersFactoryExist) {\n        // Cases 1.a and 2.a\n        diPublicInInjector(\n            getOrCreateNodeInjectorForNode(\n                tNode as TElementNode | TContainerNode | TElementContainerNode, lView),\n            tView, token);\n        const factory = multiFactory(\n            isViewProvider ? multiViewProvidersFactoryResolver : multiProvidersFactoryResolver,\n            lInjectablesBlueprint.length, isViewProvider, isComponent, providerFactory);\n        if (!isViewProvider && doesViewProvidersFactoryExist) {\n          lInjectablesBlueprint[existingViewProvidersFactoryIndex].providerFactory = factory;\n        }\n        registerDestroyHooksIfSupported(tView, provider, tInjectables.length, 0);\n        tInjectables.push(token);\n        tNode.directiveStart++;\n        tNode.directiveEnd++;\n        if (isViewProvider) {\n          tNode.providerIndexes += TNodeProviderIndexes.CptViewProvidersCountShifter;\n        }\n        lInjectablesBlueprint.push(factory);\n        lView.push(factory);\n      } else {\n        // Cases 1.b and 2.b\n        const indexInFactory = multiFactoryAdd(\n            lInjectablesBlueprint!\n                [isViewProvider ? existingViewProvidersFactoryIndex :\n                                  existingProvidersFactoryIndex],\n            providerFactory, !isViewProvider && isComponent);\n        registerDestroyHooksIfSupported(\n            tView, provider,\n            existingProvidersFactoryIndex > -1 ? existingProvidersFactoryIndex :\n                                                 existingViewProvidersFactoryIndex,\n            indexInFactory);\n      }\n      if (!isViewProvider && isComponent && doesViewProvidersFactoryExist) {\n        lInjectablesBlueprint[existingViewProvidersFactoryIndex].componentProviders!++;\n      }\n    }\n  }\n}\n\n/**\n * Registers the `ngOnDestroy` hook of a provider, if the provider supports destroy hooks.\n * @param tView `TView` in which to register the hook.\n * @param provider Provider whose hook should be registered.\n * @param contextIndex Index under which to find the context for the hook when it's being invoked.\n * @param indexInFactory Only required for `multi` providers. Index of the provider in the multi\n * provider factory.\n */\nfunction registerDestroyHooksIfSupported(\n    tView: TView, provider: Exclude<Provider, any[]>, contextIndex: number,\n    indexInFactory?: number) {\n  const providerIsTypeProvider = isTypeProvider(provider);\n  const providerIsClassProvider = isClassProvider(provider);\n\n  if (providerIsTypeProvider || providerIsClassProvider) {\n    // Resolve forward references as `useClass` can hold a forward reference.\n    const classToken = providerIsClassProvider ? resolveForwardRef(provider.useClass) : provider;\n    const prototype = classToken.prototype;\n    const ngOnDestroy = prototype.ngOnDestroy;\n\n    if (ngOnDestroy) {\n      const hooks = tView.destroyHooks || (tView.destroyHooks = []);\n\n      if (!providerIsTypeProvider && ((provider as ClassProvider)).multi) {\n        ngDevMode &&\n            assertDefined(\n                indexInFactory, 'indexInFactory when registering multi factory destroy hook');\n        const existingCallbacksIndex = hooks.indexOf(contextIndex);\n\n        if (existingCallbacksIndex === -1) {\n          hooks.push(contextIndex, [indexInFactory, ngOnDestroy]);\n        } else {\n          (hooks[existingCallbacksIndex + 1] as DestroyHookData).push(indexInFactory!, ngOnDestroy);\n        }\n      } else {\n        hooks.push(contextIndex, ngOnDestroy);\n      }\n    }\n  }\n}\n\n/**\n * Add a factory in a multi factory.\n * @returns Index at which the factory was inserted.\n */\nfunction multiFactoryAdd(\n    multiFactory: NodeInjectorFactory, factory: () => any, isComponentProvider: boolean): number {\n  if (isComponentProvider) {\n    multiFactory.componentProviders!++;\n  }\n  return multiFactory.multi!.push(factory) - 1;\n}\n\n/**\n * Returns the index of item in the array, but only in the begin to end range.\n */\nfunction indexOf(item: any, arr: any[], begin: number, end: number) {\n  for (let i = begin; i < end; i++) {\n    if (arr[i] === item) return i;\n  }\n  return -1;\n}\n\n/**\n * Use this with `multi` `providers`.\n */\nfunction multiProvidersFactoryResolver(\n    this: NodeInjectorFactory, _: undefined, tData: TData, lData: LView,\n    tNode: TDirectiveHostNode): any[] {\n  return multiResolve(this.multi!, []);\n}\n\n/**\n * Use this with `multi` `viewProviders`.\n *\n * This factory knows how to concatenate itself with the existing `multi` `providers`.\n */\nfunction multiViewProvidersFactoryResolver(\n    this: NodeInjectorFactory, _: undefined, tData: TData, lView: LView,\n    tNode: TDirectiveHostNode): any[] {\n  const factories = this.multi!;\n  let result: any[];\n  if (this.providerFactory) {\n    const componentCount = this.providerFactory.componentProviders!;\n    const multiProviders =\n        getNodeInjectable(lView, lView[TVIEW], this.providerFactory!.index!, tNode);\n    // Copy the section of the array which contains `multi` `providers` from the component\n    result = multiProviders.slice(0, componentCount);\n    // Insert the `viewProvider` instances.\n    multiResolve(factories, result);\n    // Copy the section of the array which contains `multi` `providers` from other directives\n    for (let i = componentCount; i < multiProviders.length; i++) {\n      result.push(multiProviders[i]);\n    }\n  } else {\n    result = [];\n    // Insert the `viewProvider` instances.\n    multiResolve(factories, result);\n  }\n  return result;\n}\n\n/**\n * Maps an array of factories into an array of values.\n */\nfunction multiResolve(factories: Array<() => any>, result: any[]): any[] {\n  for (let i = 0; i < factories.length; i++) {\n    const factory = factories[i]! as () => null;\n    result.push(factory());\n  }\n  return result;\n}\n\n/**\n * Creates a multi factory.\n */\nfunction multiFactory(\n    factoryFn: (\n        this: NodeInjectorFactory, _: undefined, tData: TData, lData: LView,\n        tNode: TDirectiveHostNode) => any,\n    index: number, isViewProvider: boolean, isComponent: boolean,\n    f: () => any): NodeInjectorFactory {\n  const factory = new NodeInjectorFactory(factoryFn, isViewProvider, ɵɵdirectiveInject);\n  factory.multi = [];\n  factory.index = index;\n  factory.componentProviders = 0;\n  multiFactoryAdd(factory, f, isComponent && !isViewProvider);\n  return factory;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {ProcessProvidersFunction, Provider} from '../../di/interface/provider';\nimport {providersResolver} from '../di_setup';\nimport {DirectiveDef} from '../interfaces/definition';\n\n/**\n * This feature resolves the providers of a directive (or component),\n * and publish them into the DI system, making it visible to others for injection.\n *\n * For example:\n * ```ts\n * class ComponentWithProviders {\n *   constructor(private greeter: GreeterDE) {}\n *\n *   static ɵcmp = defineComponent({\n *     type: ComponentWithProviders,\n *     selectors: [['component-with-providers']],\n *    factory: () => new ComponentWithProviders(directiveInject(GreeterDE as any)),\n *    decls: 1,\n *    vars: 1,\n *    template: function(fs: RenderFlags, ctx: ComponentWithProviders) {\n *      if (fs & RenderFlags.Create) {\n *        ɵɵtext(0);\n *      }\n *      if (fs & RenderFlags.Update) {\n *        ɵɵtextInterpolate(ctx.greeter.greet());\n *      }\n *    },\n *    features: [ɵɵProvidersFeature([GreeterDE])]\n *  });\n * }\n * ```\n *\n * @param definition\n *\n * @codeGenApi\n */\nexport function ɵɵProvidersFeature<T>(providers: Provider[], viewProviders: Provider[] = []) {\n  return (definition: DirectiveDef<T>) => {\n    definition.providersResolver =\n        (def: DirectiveDef<T>, processProvidersFn?: ProcessProvidersFunction) => {\n          return providersResolver(\n              def,                                                             //\n              processProvidersFn ? processProvidersFn(providers) : providers,  //\n              viewProviders);\n        };\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '../di/injector';\nimport {EnvironmentInjector} from '../di/r3_injector';\nimport {Type} from '../interface/type';\n\nimport {ComponentFactoryResolver} from './component_factory_resolver';\n\n\n/**\n * Represents an instance of an `NgModule` created by an `NgModuleFactory`.\n * Provides access to the `NgModule` instance and related objects.\n *\n * @publicApi\n */\nexport abstract class NgModuleRef<T> {\n  /**\n   * The injector that contains all of the providers of the `NgModule`.\n   */\n  abstract get injector(): EnvironmentInjector;\n\n  /**\n   * The resolver that can retrieve component factories in a context of this module.\n   *\n   * Note: since v13, dynamic component creation via\n   * [`ViewContainerRef.createComponent`](api/core/ViewContainerRef#createComponent)\n   * does **not** require resolving component factory: component class can be used directly.\n   *\n   * @deprecated Angular no longer requires Component factories. Please use other APIs where\n   *     Component class can be used directly.\n   */\n  abstract get componentFactoryResolver(): ComponentFactoryResolver;\n\n  /**\n   * The `NgModule` instance.\n   */\n  abstract get instance(): T;\n\n  /**\n   * Destroys the module instance and all of the data structures associated with it.\n   */\n  abstract destroy(): void;\n\n  /**\n   * Registers a callback to be executed when the module is destroyed.\n   */\n  abstract onDestroy(callback: () => void): void;\n}\n\nexport interface InternalNgModuleRef<T> extends NgModuleRef<T> {\n  // Note: we are using the prefix _ as NgModuleData is an NgModuleRef and therefore directly\n  // exposed to the user.\n  _bootstrapComponents: Type<any>[];\n}\n\n/**\n * @publicApi\n *\n * @deprecated\n * This class was mostly used as a part of ViewEngine-based JIT API and is no longer needed in Ivy\n * JIT mode. See [JIT API changes due to ViewEngine deprecation](guide/deprecations#jit-api-changes)\n * for additional context. Angular provides APIs that accept NgModule classes directly (such as\n * [PlatformRef.bootstrapModule](api/core/PlatformRef#bootstrapModule) and\n * [createNgModule](api/core/createNgModule)), consider switching to those APIs instead of\n * using factory-based ones.\n */\nexport abstract class NgModuleFactory<T> {\n  abstract get moduleType(): Type<T>;\n  abstract create(parentInjector: Injector|null): NgModuleRef<T>;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {createInjectorWithoutInjectorInstances} from '../di/create_injector';\nimport {Injector} from '../di/injector';\nimport {INJECTOR} from '../di/injector_token';\nimport {InjectFlags} from '../di/interface/injector';\nimport {ImportedNgModuleProviders, Provider} from '../di/interface/provider';\nimport {EnvironmentInjector, getNullInjector, R3Injector} from '../di/r3_injector';\nimport {Type} from '../interface/type';\nimport {ComponentFactoryResolver as viewEngine_ComponentFactoryResolver} from '../linker/component_factory_resolver';\nimport {InternalNgModuleRef, NgModuleFactory as viewEngine_NgModuleFactory, NgModuleRef as viewEngine_NgModuleRef} from '../linker/ng_module_factory';\nimport {assertDefined} from '../util/assert';\nimport {stringify} from '../util/stringify';\n\nimport {ComponentFactoryResolver} from './component_ref';\nimport {getNgModuleDef} from './definition';\nimport {maybeUnwrapFn} from './util/misc_utils';\n\n/**\n * Returns a new NgModuleRef instance based on the NgModule class and parent injector provided.\n *\n * @param ngModule NgModule class.\n * @param parentInjector Optional injector instance to use as a parent for the module injector. If\n *     not provided, `NullInjector` will be used instead.\n * @returns NgModuleRef that represents an NgModule instance.\n *\n * @publicApi\n */\nexport function createNgModule<T>(\n    ngModule: Type<T>, parentInjector?: Injector): viewEngine_NgModuleRef<T> {\n  return new NgModuleRef<T>(ngModule, parentInjector ?? null);\n}\n\n/**\n * The `createNgModule` function alias for backwards-compatibility.\n * Please avoid using it directly and use `createNgModule` instead.\n *\n * @deprecated Use `createNgModule` instead.\n */\nexport const createNgModuleRef = createNgModule;\nexport class NgModuleRef<T> extends viewEngine_NgModuleRef<T> implements InternalNgModuleRef<T> {\n  // tslint:disable-next-line:require-internal-with-underscore\n  _bootstrapComponents: Type<any>[] = [];\n  // tslint:disable-next-line:require-internal-with-underscore\n  _r3Injector: R3Injector;\n  override instance: T;\n  destroyCbs: (() => void)[]|null = [];\n\n  // When bootstrapping a module we have a dependency graph that looks like this:\n  // ApplicationRef -> ComponentFactoryResolver -> NgModuleRef. The problem is that if the\n  // module being resolved tries to inject the ComponentFactoryResolver, it'll create a\n  // circular dependency which will result in a runtime error, because the injector doesn't\n  // exist yet. We work around the issue by creating the ComponentFactoryResolver ourselves\n  // and providing it, rather than letting the injector resolve it.\n  override readonly componentFactoryResolver: ComponentFactoryResolver =\n      new ComponentFactoryResolver(this);\n\n  constructor(ngModuleType: Type<T>, public _parent: Injector|null) {\n    super();\n    const ngModuleDef = getNgModuleDef(ngModuleType);\n    ngDevMode &&\n        assertDefined(\n            ngModuleDef,\n            `NgModule '${stringify(ngModuleType)}' is not a subtype of 'NgModuleType'.`);\n\n    this._bootstrapComponents = maybeUnwrapFn(ngModuleDef!.bootstrap);\n    this._r3Injector = createInjectorWithoutInjectorInstances(\n                           ngModuleType, _parent,\n                           [\n                             {provide: viewEngine_NgModuleRef, useValue: this}, {\n                               provide: viewEngine_ComponentFactoryResolver,\n                               useValue: this.componentFactoryResolver\n                             }\n                           ],\n                           stringify(ngModuleType), new Set(['environment'])) as R3Injector;\n\n    // We need to resolve the injector types separately from the injector creation, because\n    // the module might be trying to use this ref in its constructor for DI which will cause a\n    // circular error that will eventually error out, because the injector isn't created yet.\n    this._r3Injector.resolveInjectorInitializers();\n    this.instance = this._r3Injector.get(ngModuleType);\n  }\n\n  override get injector(): EnvironmentInjector {\n    return this._r3Injector;\n  }\n\n  override destroy(): void {\n    ngDevMode && assertDefined(this.destroyCbs, 'NgModule already destroyed');\n    const injector = this._r3Injector;\n    !injector.destroyed && injector.destroy();\n    this.destroyCbs!.forEach(fn => fn());\n    this.destroyCbs = null;\n  }\n  override onDestroy(callback: () => void): void {\n    ngDevMode && assertDefined(this.destroyCbs, 'NgModule already destroyed');\n    this.destroyCbs!.push(callback);\n  }\n}\n\nexport class NgModuleFactory<T> extends viewEngine_NgModuleFactory<T> {\n  constructor(public moduleType: Type<T>) {\n    super();\n  }\n\n  override create(parentInjector: Injector|null): viewEngine_NgModuleRef<T> {\n    return new NgModuleRef(this.moduleType, parentInjector);\n  }\n}\n\nclass EnvironmentNgModuleRefAdapter extends viewEngine_NgModuleRef<null> {\n  override readonly injector: EnvironmentInjector;\n  override readonly componentFactoryResolver: ComponentFactoryResolver =\n      new ComponentFactoryResolver(this);\n  override readonly instance = null;\n\n  constructor(\n      providers: Array<Provider|ImportedNgModuleProviders>, parent: EnvironmentInjector|null,\n      source: string|null) {\n    super();\n    const injector = new R3Injector(\n        [\n          ...providers,\n          {provide: viewEngine_NgModuleRef, useValue: this},\n          {provide: viewEngine_ComponentFactoryResolver, useValue: this.componentFactoryResolver},\n        ],\n        parent || getNullInjector(), source, new Set(['environment']));\n    this.injector = injector;\n    injector.resolveInjectorInitializers();\n  }\n\n  override destroy(): void {\n    this.injector.destroy();\n  }\n\n  override onDestroy(callback: () => void): void {\n    this.injector.onDestroy(callback);\n  }\n}\n\n/**\n * Create a new environment injector.\n *\n * Learn more about environment injectors in\n * [this guide](guide/standalone-components#environment-injectors).\n *\n * @param providers An array of providers.\n * @param parent A parent environment injector.\n * @param debugName An optional name for this injector instance, which will be used in error\n *     messages.\n *\n * @publicApi\n * @developerPreview\n */\nexport function createEnvironmentInjector(\n    providers: Array<Provider|ImportedNgModuleProviders>, parent: EnvironmentInjector,\n    debugName: string|null = null): EnvironmentInjector {\n  const adapter = new EnvironmentNgModuleRefAdapter(providers, parent, debugName);\n  return adapter.injector;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {ɵɵinject as inject} from '../../di/injector_compatibility';\nimport {ɵɵdefineInjectable as defineInjectable} from '../../di/interface/defs';\nimport {internalImportProvidersFrom} from '../../di/provider_collection';\nimport {EnvironmentInjector} from '../../di/r3_injector';\nimport {OnDestroy} from '../../interface/lifecycle_hooks';\nimport {ComponentDef} from '../interfaces/definition';\nimport {createEnvironmentInjector} from '../ng_module_ref';\n\n/**\n * A service used by the framework to create instances of standalone injectors. Those injectors are\n * created on demand in case of dynamic component instantiation and contain ambient providers\n * collected from the imports graph rooted at a given standalone component.\n */\nclass StandaloneService implements OnDestroy {\n  cachedInjectors = new Map<string, EnvironmentInjector|null>();\n\n  constructor(private _injector: EnvironmentInjector) {}\n\n  getOrCreateStandaloneInjector(componentDef: ComponentDef<unknown>): EnvironmentInjector|null {\n    if (!componentDef.standalone) {\n      return null;\n    }\n\n    if (!this.cachedInjectors.has(componentDef.id)) {\n      const providers = internalImportProvidersFrom(false, componentDef.type);\n      const standaloneInjector = providers.length > 0 ?\n          createEnvironmentInjector(\n              [providers], this._injector, `Standalone[${componentDef.type.name}]`) :\n          null;\n      this.cachedInjectors.set(componentDef.id, standaloneInjector);\n    }\n\n    return this.cachedInjectors.get(componentDef.id)!;\n  }\n\n  ngOnDestroy() {\n    try {\n      for (const injector of this.cachedInjectors.values()) {\n        if (injector !== null) {\n          injector.destroy();\n        }\n      }\n    } finally {\n      this.cachedInjectors.clear();\n    }\n  }\n\n  /** @nocollapse */\n  static ɵprov = /** @pureOrBreakMyCode */ defineInjectable({\n    token: StandaloneService,\n    providedIn: 'environment',\n    factory: () => new StandaloneService(inject(EnvironmentInjector)),\n  });\n}\n\n/**\n * A feature that acts as a setup code for the {@link StandaloneService}.\n *\n * The most important responsibility of this feature is to expose the \"getStandaloneInjector\"\n * function (an entry points to a standalone injector creation) on a component definition object. We\n * go through the features infrastructure to make sure that the standalone injector creation logic\n * is tree-shakable and not included in applications that don't use standalone components.\n *\n * @codeGenApi\n */\nexport function ɵɵStandaloneFeature(definition: ComponentDef<unknown>) {\n  definition.getStandaloneInjector = (parentInjector: EnvironmentInjector) => {\n    return parentInjector.get(StandaloneService).getOrCreateStandaloneInjector(definition);\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ChangeDetectionStrategy} from '../../change_detection/constants';\nimport {Injector} from '../../di/injector';\nimport {ViewEncapsulation} from '../../metadata/view';\nimport {assertEqual} from '../../util/assert';\nimport {assertLView} from '../assert';\nimport {discoverLocalRefs, getComponentAtNodeIndex, getDirectivesAtNodeIndex, getLContext, readPatchedLView} from '../context_discovery';\nimport {getComponentDef, getDirectiveDef} from '../definition';\nimport {NodeInjector} from '../di';\nimport {buildDebugNode} from '../instructions/lview_debug';\nimport {LContext} from '../interfaces/context';\nimport {DirectiveDef} from '../interfaces/definition';\nimport {TElementNode, TNode, TNodeProviderIndexes} from '../interfaces/node';\nimport {isLView} from '../interfaces/type_checks';\nimport {CLEANUP, CONTEXT, DebugNode, FLAGS, LView, LViewFlags, RootContext, T_HOST, TVIEW, TViewType} from '../interfaces/view';\n\nimport {stringifyForError} from './stringify_utils';\nimport {getLViewParent, getRootContext} from './view_traversal_utils';\nimport {getTNode, unwrapRNode} from './view_utils';\n\n\n\n/**\n * Retrieves the component instance associated with a given DOM element.\n *\n * @usageNotes\n * Given the following DOM structure:\n *\n * ```html\n * <app-root>\n *   <div>\n *     <child-comp></child-comp>\n *   </div>\n * </app-root>\n * ```\n *\n * Calling `getComponent` on `<child-comp>` will return the instance of `ChildComponent`\n * associated with this DOM element.\n *\n * Calling the function on `<app-root>` will return the `MyApp` instance.\n *\n *\n * @param element DOM element from which the component should be retrieved.\n * @returns Component instance associated with the element or `null` if there\n *    is no component associated with it.\n *\n * @publicApi\n * @globalApi ng\n */\nexport function getComponent<T>(element: Element): T|null {\n  ngDevMode && assertDomElement(element);\n  const context = getLContext(element);\n  if (context === null) return null;\n\n  if (context.component === undefined) {\n    const lView = context.lView;\n    if (lView === null) {\n      return null;\n    }\n    context.component = getComponentAtNodeIndex(context.nodeIndex, lView);\n  }\n\n  return context.component as unknown as T;\n}\n\n\n/**\n * If inside an embedded view (e.g. `*ngIf` or `*ngFor`), retrieves the context of the embedded\n * view that the element is part of. Otherwise retrieves the instance of the component whose view\n * owns the element (in this case, the result is the same as calling `getOwningComponent`).\n *\n * @param element Element for which to get the surrounding component instance.\n * @returns Instance of the component that is around the element or null if the element isn't\n *    inside any component.\n *\n * @publicApi\n * @globalApi ng\n */\nexport function getContext<T extends({} | RootContext)>(element: Element): T|null {\n  assertDomElement(element);\n  const context = getLContext(element)!;\n  const lView = context ? context.lView : null;\n  return lView === null ? null : lView[CONTEXT] as T;\n}\n\n/**\n * Retrieves the component instance whose view contains the DOM element.\n *\n * For example, if `<child-comp>` is used in the template of `<app-comp>`\n * (i.e. a `ViewChild` of `<app-comp>`), calling `getOwningComponent` on `<child-comp>`\n * would return `<app-comp>`.\n *\n * @param elementOrDir DOM element, component or directive instance\n *    for which to retrieve the root components.\n * @returns Component instance whose view owns the DOM element or null if the element is not\n *    part of a component view.\n *\n * @publicApi\n * @globalApi ng\n */\nexport function getOwningComponent<T>(elementOrDir: Element|{}): T|null {\n  const context = getLContext(elementOrDir)!;\n  let lView = context ? context.lView : null;\n  if (lView === null) return null;\n\n  let parent: LView|null;\n  while (lView[TVIEW].type === TViewType.Embedded && (parent = getLViewParent(lView)!)) {\n    lView = parent;\n  }\n  return lView[FLAGS] & LViewFlags.IsRoot ? null : lView[CONTEXT] as unknown as T;\n}\n\n/**\n * Retrieves all root components associated with a DOM element, directive or component instance.\n * Root components are those which have been bootstrapped by Angular.\n *\n * @param elementOrDir DOM element, component or directive instance\n *    for which to retrieve the root components.\n * @returns Root components associated with the target object.\n *\n * @publicApi\n * @globalApi ng\n */\nexport function getRootComponents(elementOrDir: Element|{}): {}[] {\n  const lView = readPatchedLView<{}>(elementOrDir);\n  return lView !== null ? [...getRootContext(lView).components as unknown as {}[]] : [];\n}\n\n/**\n * Retrieves an `Injector` associated with an element, component or directive instance.\n *\n * @param elementOrDir DOM element, component or directive instance for which to\n *    retrieve the injector.\n * @returns Injector associated with the element, component or directive instance.\n *\n * @publicApi\n * @globalApi ng\n */\nexport function getInjector(elementOrDir: Element|{}): Injector {\n  const context = getLContext(elementOrDir)!;\n  const lView = context ? context.lView : null;\n  if (lView === null) return Injector.NULL;\n\n  const tNode = lView[TVIEW].data[context.nodeIndex] as TElementNode;\n  return new NodeInjector(tNode, lView);\n}\n\n/**\n * Retrieve a set of injection tokens at a given DOM node.\n *\n * @param element Element for which the injection tokens should be retrieved.\n */\nexport function getInjectionTokens(element: Element): any[] {\n  const context = getLContext(element)!;\n  const lView = context ? context.lView : null;\n  if (lView === null) return [];\n  const tView = lView[TVIEW];\n  const tNode = tView.data[context.nodeIndex] as TNode;\n  const providerTokens: any[] = [];\n  const startIndex = tNode.providerIndexes & TNodeProviderIndexes.ProvidersStartIndexMask;\n  const endIndex = tNode.directiveEnd;\n  for (let i = startIndex; i < endIndex; i++) {\n    let value = tView.data[i];\n    if (isDirectiveDefHack(value)) {\n      // The fact that we sometimes store Type and sometimes DirectiveDef in this location is a\n      // design flaw.  We should always store same type so that we can be monomorphic. The issue\n      // is that for Components/Directives we store the def instead the type. The correct behavior\n      // is that we should always be storing injectable type in this location.\n      value = value.type;\n    }\n    providerTokens.push(value);\n  }\n  return providerTokens;\n}\n\n/**\n * Retrieves directive instances associated with a given DOM node. Does not include\n * component instances.\n *\n * @usageNotes\n * Given the following DOM structure:\n *\n * ```html\n * <app-root>\n *   <button my-button></button>\n *   <my-comp></my-comp>\n * </app-root>\n * ```\n *\n * Calling `getDirectives` on `<button>` will return an array with an instance of the `MyButton`\n * directive that is associated with the DOM node.\n *\n * Calling `getDirectives` on `<my-comp>` will return an empty array.\n *\n * @param node DOM node for which to get the directives.\n * @returns Array of directives associated with the node.\n *\n * @publicApi\n * @globalApi ng\n */\nexport function getDirectives(node: Node): {}[] {\n  // Skip text nodes because we can't have directives associated with them.\n  if (node instanceof Text) {\n    return [];\n  }\n\n  const context = getLContext(node)!;\n  const lView = context ? context.lView : null;\n  if (lView === null) {\n    return [];\n  }\n\n  const tView = lView[TVIEW];\n  const nodeIndex = context.nodeIndex;\n  if (!tView?.data[nodeIndex]) {\n    return [];\n  }\n  if (context.directives === undefined) {\n    context.directives = getDirectivesAtNodeIndex(nodeIndex, lView, false);\n  }\n\n  // The `directives` in this case are a named array called `LComponentView`. Clone the\n  // result so we don't expose an internal data structure in the user's console.\n  return context.directives === null ? [] : [...context.directives];\n}\n\n/**\n * Partial metadata for a given directive instance.\n * This information might be useful for debugging purposes or tooling.\n * Currently only `inputs` and `outputs` metadata is available.\n *\n * @publicApi\n */\nexport interface DirectiveDebugMetadata {\n  inputs: Record<string, string>;\n  outputs: Record<string, string>;\n}\n\n/**\n * Partial metadata for a given component instance.\n * This information might be useful for debugging purposes or tooling.\n * Currently the following fields are available:\n *  - inputs\n *  - outputs\n *  - encapsulation\n *  - changeDetection\n *\n * @publicApi\n */\nexport interface ComponentDebugMetadata extends DirectiveDebugMetadata {\n  encapsulation: ViewEncapsulation;\n  changeDetection: ChangeDetectionStrategy;\n}\n\n/**\n * Returns the debug (partial) metadata for a particular directive or component instance.\n * The function accepts an instance of a directive or component and returns the corresponding\n * metadata.\n *\n * @param directiveOrComponentInstance Instance of a directive or component\n * @returns metadata of the passed directive or component\n *\n * @publicApi\n * @globalApi ng\n */\nexport function getDirectiveMetadata(directiveOrComponentInstance: any): ComponentDebugMetadata|\n    DirectiveDebugMetadata|null {\n  const {constructor} = directiveOrComponentInstance;\n  if (!constructor) {\n    throw new Error('Unable to find the instance constructor');\n  }\n  // In case a component inherits from a directive, we may have component and directive metadata\n  // To ensure we don't get the metadata of the directive, we want to call `getComponentDef` first.\n  const componentDef = getComponentDef(constructor);\n  if (componentDef) {\n    return {\n      inputs: componentDef.inputs,\n      outputs: componentDef.outputs,\n      encapsulation: componentDef.encapsulation,\n      changeDetection: componentDef.onPush ? ChangeDetectionStrategy.OnPush :\n                                             ChangeDetectionStrategy.Default\n    };\n  }\n  const directiveDef = getDirectiveDef(constructor);\n  if (directiveDef) {\n    return {inputs: directiveDef.inputs, outputs: directiveDef.outputs};\n  }\n  return null;\n}\n\n/**\n * Retrieve map of local references.\n *\n * The references are retrieved as a map of local reference name to element or directive instance.\n *\n * @param target DOM element, component or directive instance for which to retrieve\n *    the local references.\n */\nexport function getLocalRefs(target: {}): {[key: string]: any} {\n  const context = getLContext(target);\n  if (context === null) return {};\n\n  if (context.localRefs === undefined) {\n    const lView = context.lView;\n    if (lView === null) {\n      return {};\n    }\n    context.localRefs = discoverLocalRefs(lView, context.nodeIndex);\n  }\n\n  return context.localRefs || {};\n}\n\n/**\n * Retrieves the host element of a component or directive instance.\n * The host element is the DOM element that matched the selector of the directive.\n *\n * @param componentOrDirective Component or directive instance for which the host\n *     element should be retrieved.\n * @returns Host element of the target.\n *\n * @publicApi\n * @globalApi ng\n */\nexport function getHostElement(componentOrDirective: {}): Element {\n  return getLContext(componentOrDirective)!.native as unknown as Element;\n}\n\n/**\n * Retrieves the rendered text for a given component.\n *\n * This function retrieves the host element of a component and\n * and then returns the `textContent` for that element. This implies\n * that the text returned will include re-projected content of\n * the component as well.\n *\n * @param component The component to return the content text for.\n */\nexport function getRenderedText(component: any): string {\n  const hostElement = getHostElement(component);\n  return hostElement.textContent || '';\n}\n\n/**\n * Event listener configuration returned from `getListeners`.\n * @publicApi\n */\nexport interface Listener {\n  /** Name of the event listener. */\n  name: string;\n  /** Element that the listener is bound to. */\n  element: Element;\n  /** Callback that is invoked when the event is triggered. */\n  callback: (value: any) => any;\n  /** Whether the listener is using event capturing. */\n  useCapture: boolean;\n  /**\n   * Type of the listener (e.g. a native DOM event or a custom @Output).\n   */\n  type: 'dom'|'output';\n}\n\n\n/**\n * Retrieves a list of event listeners associated with a DOM element. The list does include host\n * listeners, but it does not include event listeners defined outside of the Angular context\n * (e.g. through `addEventListener`).\n *\n * @usageNotes\n * Given the following DOM structure:\n *\n * ```html\n * <app-root>\n *   <div (click)=\"doSomething()\"></div>\n * </app-root>\n * ```\n *\n * Calling `getListeners` on `<div>` will return an object that looks as follows:\n *\n * ```ts\n * {\n *   name: 'click',\n *   element: <div>,\n *   callback: () => doSomething(),\n *   useCapture: false\n * }\n * ```\n *\n * @param element Element for which the DOM listeners should be retrieved.\n * @returns Array of event listeners on the DOM element.\n *\n * @publicApi\n * @globalApi ng\n */\nexport function getListeners(element: Element): Listener[] {\n  ngDevMode && assertDomElement(element);\n  const lContext = getLContext(element);\n  const lView = lContext === null ? null : lContext.lView;\n  if (lView === null) return [];\n\n  const tView = lView[TVIEW];\n  const lCleanup = lView[CLEANUP];\n  const tCleanup = tView.cleanup;\n  const listeners: Listener[] = [];\n  if (tCleanup && lCleanup) {\n    for (let i = 0; i < tCleanup.length;) {\n      const firstParam = tCleanup[i++];\n      const secondParam = tCleanup[i++];\n      if (typeof firstParam === 'string') {\n        const name: string = firstParam;\n        const listenerElement = unwrapRNode(lView[secondParam]) as any as Element;\n        const callback: (value: any) => any = lCleanup[tCleanup[i++]];\n        const useCaptureOrIndx = tCleanup[i++];\n        // if useCaptureOrIndx is boolean then report it as is.\n        // if useCaptureOrIndx is positive number then it in unsubscribe method\n        // if useCaptureOrIndx is negative number then it is a Subscription\n        const type =\n            (typeof useCaptureOrIndx === 'boolean' || useCaptureOrIndx >= 0) ? 'dom' : 'output';\n        const useCapture = typeof useCaptureOrIndx === 'boolean' ? useCaptureOrIndx : false;\n        if (element == listenerElement) {\n          listeners.push({element, name, callback, useCapture, type});\n        }\n      }\n    }\n  }\n  listeners.sort(sortListeners);\n  return listeners;\n}\n\nfunction sortListeners(a: Listener, b: Listener) {\n  if (a.name == b.name) return 0;\n  return a.name < b.name ? -1 : 1;\n}\n\n/**\n * This function should not exist because it is megamorphic and only mostly correct.\n *\n * See call site for more info.\n */\nfunction isDirectiveDefHack(obj: any): obj is DirectiveDef<any> {\n  return obj.type !== undefined && obj.template !== undefined && obj.declaredInputs !== undefined;\n}\n\n/**\n * Returns the attached `DebugNode` instance for an element in the DOM.\n *\n * @param element DOM element which is owned by an existing component's view.\n */\nexport function getDebugNode(element: Element): DebugNode|null {\n  if (ngDevMode && !(element instanceof Node)) {\n    throw new Error('Expecting instance of DOM Element');\n  }\n\n  const lContext = getLContext(element)!;\n  const lView = lContext ? lContext.lView : null;\n\n  if (lView === null) {\n    return null;\n  }\n\n  const nodeIndex = lContext.nodeIndex;\n  if (nodeIndex !== -1) {\n    const valueInLView = lView[nodeIndex];\n    // this means that value in the lView is a component with its own\n    // data. In this situation the TNode is not accessed at the same spot.\n    const tNode =\n        isLView(valueInLView) ? (valueInLView[T_HOST] as TNode) : getTNode(lView[TVIEW], nodeIndex);\n    ngDevMode &&\n        assertEqual(tNode.index, nodeIndex, 'Expecting that TNode at index is same as index');\n    return buildDebugNode(tNode, lView);\n  }\n\n  return null;\n}\n\n/**\n * Retrieve the component `LView` from component/element.\n *\n * NOTE: `LView` is a private and should not be leaked outside.\n *       Don't export this method to `ng.*` on window.\n *\n * @param target DOM element or component instance for which to retrieve the LView.\n */\nexport function getComponentLView(target: any): LView {\n  const lContext = getLContext(target)!;\n  const nodeIndx = lContext.nodeIndex;\n  const lView = lContext.lView!;\n  ngDevMode && assertLView(lView);\n  const componentLView = lView[nodeIndx];\n  ngDevMode && assertLView(componentLView);\n  return componentLView;\n}\n\n/** Asserts that a value is a DOM Element. */\nfunction assertDomElement(value: any) {\n  if (typeof Element !== 'undefined' && !(value instanceof Element)) {\n    throw new Error('Expecting instance of DOM Element');\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../interface/type';\nimport {noSideEffects} from '../util/closure';\n\ninterface TypeWithMetadata extends Type<any> {\n  decorators?: any[];\n  ctorParameters?: () => any[];\n  propDecorators?: {[field: string]: any};\n}\n\n/**\n * Adds decorator, constructor, and property metadata to a given type via static metadata fields\n * on the type.\n *\n * These metadata fields can later be read with Angular's `ReflectionCapabilities` API.\n *\n * Calls to `setClassMetadata` can be guarded by ngDevMode, resulting in the metadata assignments\n * being tree-shaken away during production builds.\n */\nexport function setClassMetadata(\n    type: Type<any>, decorators: any[]|null, ctorParameters: (() => any[])|null,\n    propDecorators: {[field: string]: any}|null): void {\n  return noSideEffects(() => {\n           const clazz = type as TypeWithMetadata;\n\n           if (decorators !== null) {\n             if (clazz.hasOwnProperty('decorators') && clazz.decorators !== undefined) {\n               clazz.decorators.push(...decorators);\n             } else {\n               clazz.decorators = decorators;\n             }\n           }\n           if (ctorParameters !== null) {\n             // Rather than merging, clobber the existing parameters. If other projects exist which\n             // use tsickle-style annotations and reflect over them in the same way, this could\n             // cause issues, but that is vanishingly unlikely.\n             clazz.ctorParameters = ctorParameters;\n           }\n           if (propDecorators !== null) {\n             // The property decorator objects are merged as it is possible different fields have\n             // different decorator types. Decorators on individual fields are not merged, as it's\n             // also incredibly unlikely that a field will be decorated both with an Angular\n             // decorator and a non-Angular decorator that's also been downleveled.\n             if (clazz.hasOwnProperty('propDecorators') && clazz.propDecorators !== undefined) {\n               clazz.propDecorators = {...clazz.propDecorators, ...propDecorators};\n             } else {\n               clazz.propDecorators = propDecorators;\n             }\n           }\n         }) as never;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertIndexInRange} from '../util/assert';\nimport {bindingUpdated, bindingUpdated2, bindingUpdated3, bindingUpdated4, getBinding, updateBinding} from './bindings';\nimport {LView} from './interfaces/view';\nimport {getBindingRoot, getLView} from './state';\nimport {NO_CHANGE} from './tokens';\n\n\n/**\n * Bindings for pure functions are stored after regular bindings.\n *\n * |-------decls------|---------vars---------|                 |----- hostVars (dir1) ------|\n * ------------------------------------------------------------------------------------------\n * | nodes/refs/pipes | bindings | fn slots  | injector | dir1 | host bindings | host slots |\n * ------------------------------------------------------------------------------------------\n *                    ^                      ^\n *      TView.bindingStartIndex      TView.expandoStartIndex\n *\n * Pure function instructions are given an offset from the binding root. Adding the offset to the\n * binding root gives the first index where the bindings are stored. In component views, the binding\n * root is the bindingStartIndex. In host bindings, the binding root is the expandoStartIndex +\n * any directive instances + any hostVars in directives evaluated before it.\n *\n * See VIEW_DATA.md for more information about host binding resolution.\n */\n\n/**\n * If the value hasn't been saved, calls the pure function to store and return the\n * value. If it has been saved, returns the saved value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn Function that returns a value\n * @param thisArg Optional calling context of pureFn\n * @returns value\n *\n * @codeGenApi\n */\nexport function ɵɵpureFunction0<T>(slotOffset: number, pureFn: () => T, thisArg?: any): T {\n  const bindingIndex = getBindingRoot() + slotOffset;\n  const lView = getLView();\n  return lView[bindingIndex] === NO_CHANGE ?\n      updateBinding(lView, bindingIndex, thisArg ? pureFn.call(thisArg) : pureFn()) :\n      getBinding(lView, bindingIndex);\n}\n\n/**\n * If the value of the provided exp has changed, calls the pure function to return\n * an updated value. Or if the value has not changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn Function that returns an updated value\n * @param exp Updated expression value\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nexport function ɵɵpureFunction1(\n    slotOffset: number, pureFn: (v: any) => any, exp: any, thisArg?: any): any {\n  return pureFunction1Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp, thisArg);\n}\n\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nexport function ɵɵpureFunction2(\n    slotOffset: number, pureFn: (v1: any, v2: any) => any, exp1: any, exp2: any,\n    thisArg?: any): any {\n  return pureFunction2Internal(\n      getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, thisArg);\n}\n\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nexport function ɵɵpureFunction3(\n    slotOffset: number, pureFn: (v1: any, v2: any, v3: any) => any, exp1: any, exp2: any, exp3: any,\n    thisArg?: any): any {\n  return pureFunction3Internal(\n      getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, thisArg);\n}\n\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nexport function ɵɵpureFunction4(\n    slotOffset: number, pureFn: (v1: any, v2: any, v3: any, v4: any) => any, exp1: any, exp2: any,\n    exp3: any, exp4: any, thisArg?: any): any {\n  return pureFunction4Internal(\n      getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg);\n}\n\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nexport function ɵɵpureFunction5(\n    slotOffset: number, pureFn: (v1: any, v2: any, v3: any, v4: any, v5: any) => any, exp1: any,\n    exp2: any, exp3: any, exp4: any, exp5: any, thisArg?: any): any {\n  const bindingIndex = getBindingRoot() + slotOffset;\n  const lView = getLView();\n  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\n  return bindingUpdated(lView, bindingIndex + 4, exp5) || different ?\n      updateBinding(\n          lView, bindingIndex + 5,\n          thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5) :\n                    pureFn(exp1, exp2, exp3, exp4, exp5)) :\n      getBinding(lView, bindingIndex + 5);\n}\n\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param exp6\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nexport function ɵɵpureFunction6(\n    slotOffset: number, pureFn: (v1: any, v2: any, v3: any, v4: any, v5: any, v6: any) => any,\n    exp1: any, exp2: any, exp3: any, exp4: any, exp5: any, exp6: any, thisArg?: any): any {\n  const bindingIndex = getBindingRoot() + slotOffset;\n  const lView = getLView();\n  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\n  return bindingUpdated2(lView, bindingIndex + 4, exp5, exp6) || different ?\n      updateBinding(\n          lView, bindingIndex + 6,\n          thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6) :\n                    pureFn(exp1, exp2, exp3, exp4, exp5, exp6)) :\n      getBinding(lView, bindingIndex + 6);\n}\n\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param exp6\n * @param exp7\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nexport function ɵɵpureFunction7(\n    slotOffset: number,\n    pureFn: (v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any) => any, exp1: any,\n    exp2: any, exp3: any, exp4: any, exp5: any, exp6: any, exp7: any, thisArg?: any): any {\n  const bindingIndex = getBindingRoot() + slotOffset;\n  const lView = getLView();\n  let different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\n  return bindingUpdated3(lView, bindingIndex + 4, exp5, exp6, exp7) || different ?\n      updateBinding(\n          lView, bindingIndex + 7,\n          thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7) :\n                    pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7)) :\n      getBinding(lView, bindingIndex + 7);\n}\n\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param exp6\n * @param exp7\n * @param exp8\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nexport function ɵɵpureFunction8(\n    slotOffset: number,\n    pureFn: (v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any, v8: any) => any,\n    exp1: any, exp2: any, exp3: any, exp4: any, exp5: any, exp6: any, exp7: any, exp8: any,\n    thisArg?: any): any {\n  const bindingIndex = getBindingRoot() + slotOffset;\n  const lView = getLView();\n  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\n  return bindingUpdated4(lView, bindingIndex + 4, exp5, exp6, exp7, exp8) || different ?\n      updateBinding(\n          lView, bindingIndex + 8,\n          thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8) :\n                    pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8)) :\n      getBinding(lView, bindingIndex + 8);\n}\n\n/**\n * pureFunction instruction that can support any number of bindings.\n *\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn A pure function that takes binding values and builds an object or array\n * containing those values.\n * @param exps An array of binding values\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nexport function ɵɵpureFunctionV(\n    slotOffset: number, pureFn: (...v: any[]) => any, exps: any[], thisArg?: any): any {\n  return pureFunctionVInternal(getLView(), getBindingRoot(), slotOffset, pureFn, exps, thisArg);\n}\n\n/**\n * Results of a pure function invocation are stored in LView in a dedicated slot that is initialized\n * to NO_CHANGE. In rare situations a pure pipe might throw an exception on the very first\n * invocation and not produce any valid results. In this case LView would keep holding the NO_CHANGE\n * value. The NO_CHANGE is not something that we can use in expressions / bindings thus we convert\n * it to `undefined`.\n */\nfunction getPureFunctionReturnValue(lView: LView, returnValueIndex: number) {\n  ngDevMode && assertIndexInRange(lView, returnValueIndex);\n  const lastReturnValue = lView[returnValueIndex];\n  return lastReturnValue === NO_CHANGE ? undefined : lastReturnValue;\n}\n\n/**\n * If the value of the provided exp has changed, calls the pure function to return\n * an updated value. Or if the value has not changed, returns cached value.\n *\n * @param lView LView in which the function is being executed.\n * @param bindingRoot Binding root index.\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn Function that returns an updated value\n * @param exp Updated expression value\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nexport function pureFunction1Internal(\n    lView: LView, bindingRoot: number, slotOffset: number, pureFn: (v: any) => any, exp: any,\n    thisArg?: any): any {\n  const bindingIndex = bindingRoot + slotOffset;\n  return bindingUpdated(lView, bindingIndex, exp) ?\n      updateBinding(lView, bindingIndex + 1, thisArg ? pureFn.call(thisArg, exp) : pureFn(exp)) :\n      getPureFunctionReturnValue(lView, bindingIndex + 1);\n}\n\n\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param lView LView in which the function is being executed.\n * @param bindingRoot Binding root index.\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nexport function pureFunction2Internal(\n    lView: LView, bindingRoot: number, slotOffset: number, pureFn: (v1: any, v2: any) => any,\n    exp1: any, exp2: any, thisArg?: any): any {\n  const bindingIndex = bindingRoot + slotOffset;\n  return bindingUpdated2(lView, bindingIndex, exp1, exp2) ?\n      updateBinding(\n          lView, bindingIndex + 2,\n          thisArg ? pureFn.call(thisArg, exp1, exp2) : pureFn(exp1, exp2)) :\n      getPureFunctionReturnValue(lView, bindingIndex + 2);\n}\n\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param lView LView in which the function is being executed.\n * @param bindingRoot Binding root index.\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nexport function pureFunction3Internal(\n    lView: LView, bindingRoot: number, slotOffset: number,\n    pureFn: (v1: any, v2: any, v3: any) => any, exp1: any, exp2: any, exp3: any,\n    thisArg?: any): any {\n  const bindingIndex = bindingRoot + slotOffset;\n  return bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) ?\n      updateBinding(\n          lView, bindingIndex + 3,\n          thisArg ? pureFn.call(thisArg, exp1, exp2, exp3) : pureFn(exp1, exp2, exp3)) :\n      getPureFunctionReturnValue(lView, bindingIndex + 3);\n}\n\n\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param lView LView in which the function is being executed.\n * @param bindingRoot Binding root index.\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n */\nexport function pureFunction4Internal(\n    lView: LView, bindingRoot: number, slotOffset: number,\n    pureFn: (v1: any, v2: any, v3: any, v4: any) => any, exp1: any, exp2: any, exp3: any, exp4: any,\n    thisArg?: any): any {\n  const bindingIndex = bindingRoot + slotOffset;\n  return bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) ?\n      updateBinding(\n          lView, bindingIndex + 4,\n          thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4) : pureFn(exp1, exp2, exp3, exp4)) :\n      getPureFunctionReturnValue(lView, bindingIndex + 4);\n}\n\n/**\n * pureFunction instruction that can support any number of bindings.\n *\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param lView LView in which the function is being executed.\n * @param bindingRoot Binding root index.\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn A pure function that takes binding values and builds an object or array\n * containing those values.\n * @param exps An array of binding values\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nexport function pureFunctionVInternal(\n    lView: LView, bindingRoot: number, slotOffset: number, pureFn: (...v: any[]) => any,\n    exps: any[], thisArg?: any): any {\n  let bindingIndex = bindingRoot + slotOffset;\n  let different = false;\n  for (let i = 0; i < exps.length; i++) {\n    bindingUpdated(lView, bindingIndex++, exps[i]) && (different = true);\n  }\n  return different ? updateBinding(lView, bindingIndex, pureFn.apply(thisArg, exps)) :\n                     getPureFunctionReturnValue(lView, bindingIndex);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {PipeTransform} from '../change_detection/pipe_transform';\nimport {setInjectImplementation} from '../di/inject_switch';\nimport {RuntimeError, RuntimeErrorCode} from '../errors';\nimport {Type} from '../interface/type';\n\nimport {getFactoryDef} from './definition_factory';\nimport {setIncludeViewProviders} from './di';\nimport {store, ɵɵdirectiveInject} from './instructions/all';\nimport {isHostComponentStandalone} from './instructions/element_validation';\nimport {PipeDef, PipeDefList} from './interfaces/definition';\nimport {CONTEXT, DECLARATION_COMPONENT_VIEW, HEADER_OFFSET, LView, TVIEW} from './interfaces/view';\nimport {pureFunction1Internal, pureFunction2Internal, pureFunction3Internal, pureFunction4Internal, pureFunctionVInternal} from './pure_function';\nimport {getBindingRoot, getLView, getTView} from './state';\nimport {load} from './util/view_utils';\n\n\n\n/**\n * Create a pipe.\n *\n * @param index Pipe index where the pipe will be stored.\n * @param pipeName The name of the pipe\n * @returns T the instance of the pipe.\n *\n * @codeGenApi\n */\nexport function ɵɵpipe(index: number, pipeName: string): any {\n  const tView = getTView();\n  let pipeDef: PipeDef<any>;\n  const adjustedIndex = index + HEADER_OFFSET;\n\n  if (tView.firstCreatePass) {\n    // The `getPipeDef` throws if a pipe with a given name is not found\n    // (so we use non-null assertion below).\n    pipeDef = getPipeDef(pipeName, tView.pipeRegistry)!;\n    tView.data[adjustedIndex] = pipeDef;\n    if (pipeDef.onDestroy) {\n      (tView.destroyHooks || (tView.destroyHooks = [])).push(adjustedIndex, pipeDef.onDestroy);\n    }\n  } else {\n    pipeDef = tView.data[adjustedIndex] as PipeDef<any>;\n  }\n\n  const pipeFactory = pipeDef.factory || (pipeDef.factory = getFactoryDef(pipeDef.type, true));\n  const previousInjectImplementation = setInjectImplementation(ɵɵdirectiveInject);\n  try {\n    // DI for pipes is supposed to behave like directives when placed on a component\n    // host node, which means that we have to disable access to `viewProviders`.\n    const previousIncludeViewProviders = setIncludeViewProviders(false);\n    const pipeInstance = pipeFactory();\n    setIncludeViewProviders(previousIncludeViewProviders);\n    store(tView, getLView(), adjustedIndex, pipeInstance);\n    return pipeInstance;\n  } finally {\n    // we have to restore the injector implementation in finally, just in case the creation of the\n    // pipe throws an error.\n    setInjectImplementation(previousInjectImplementation);\n  }\n}\n\n/**\n * Searches the pipe registry for a pipe with the given name. If one is found,\n * returns the pipe. Otherwise, an error is thrown because the pipe cannot be resolved.\n *\n * @param name Name of pipe to resolve\n * @param registry Full list of available pipes\n * @returns Matching PipeDef\n */\nfunction getPipeDef(name: string, registry: PipeDefList|null): PipeDef<any>|undefined {\n  if (registry) {\n    for (let i = registry.length - 1; i >= 0; i--) {\n      const pipeDef = registry[i];\n      if (name === pipeDef.name) {\n        return pipeDef;\n      }\n    }\n  }\n  if (ngDevMode) {\n    throw new RuntimeError(RuntimeErrorCode.PIPE_NOT_FOUND, getPipeNotFoundErrorMessage(name));\n  }\n}\n\n/**\n * Generates a helpful error message for the user when a pipe is not found.\n *\n * @param name Name of the missing pipe\n * @returns The error message\n */\nfunction getPipeNotFoundErrorMessage(name: string) {\n  const lView = getLView();\n  const declarationLView = lView[DECLARATION_COMPONENT_VIEW] as LView<Type<unknown>>;\n  const context = declarationLView[CONTEXT];\n  const hostIsStandalone = isHostComponentStandalone(lView);\n  const componentInfoMessage = context ? ` in the '${context.constructor.name}' component` : '';\n  const verifyMessage = `Verify that it is ${\n      hostIsStandalone ? 'included in the \\'@Component.imports\\' of this component' :\n                         'declared or imported in this module'}`;\n  const errorMessage =\n      `The pipe '${name}' could not be found${componentInfoMessage}. ${verifyMessage}`;\n  return errorMessage;\n}\n\n/**\n * Invokes a pipe with 1 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n *\n * @codeGenApi\n */\nexport function ɵɵpipeBind1(index: number, slotOffset: number, v1: any): any {\n  const adjustedIndex = index + HEADER_OFFSET;\n  const lView = getLView();\n  const pipeInstance = load<PipeTransform>(lView, adjustedIndex);\n  return isPure(lView, adjustedIndex) ?\n      pureFunction1Internal(\n          lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, pipeInstance) :\n      pipeInstance.transform(v1);\n}\n\n/**\n * Invokes a pipe with 2 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n * @param v2 2nd argument to {@link PipeTransform#transform}.\n *\n * @codeGenApi\n */\nexport function ɵɵpipeBind2(index: number, slotOffset: number, v1: any, v2: any): any {\n  const adjustedIndex = index + HEADER_OFFSET;\n  const lView = getLView();\n  const pipeInstance = load<PipeTransform>(lView, adjustedIndex);\n  return isPure(lView, adjustedIndex) ?\n      pureFunction2Internal(\n          lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, pipeInstance) :\n      pipeInstance.transform(v1, v2);\n}\n\n/**\n * Invokes a pipe with 3 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n * @param v2 2nd argument to {@link PipeTransform#transform}.\n * @param v3 4rd argument to {@link PipeTransform#transform}.\n *\n * @codeGenApi\n */\nexport function ɵɵpipeBind3(index: number, slotOffset: number, v1: any, v2: any, v3: any): any {\n  const adjustedIndex = index + HEADER_OFFSET;\n  const lView = getLView();\n  const pipeInstance = load<PipeTransform>(lView, adjustedIndex);\n  return isPure(lView, adjustedIndex) ?\n      pureFunction3Internal(\n          lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, v3, pipeInstance) :\n      pipeInstance.transform(v1, v2, v3);\n}\n\n/**\n * Invokes a pipe with 4 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n * @param v2 2nd argument to {@link PipeTransform#transform}.\n * @param v3 3rd argument to {@link PipeTransform#transform}.\n * @param v4 4th argument to {@link PipeTransform#transform}.\n *\n * @codeGenApi\n */\nexport function ɵɵpipeBind4(\n    index: number, slotOffset: number, v1: any, v2: any, v3: any, v4: any): any {\n  const adjustedIndex = index + HEADER_OFFSET;\n  const lView = getLView();\n  const pipeInstance = load<PipeTransform>(lView, adjustedIndex);\n  return isPure(lView, adjustedIndex) ? pureFunction4Internal(\n                                            lView, getBindingRoot(), slotOffset,\n                                            pipeInstance.transform, v1, v2, v3, v4, pipeInstance) :\n                                        pipeInstance.transform(v1, v2, v3, v4);\n}\n\n/**\n * Invokes a pipe with variable number of arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param values Array of arguments to pass to {@link PipeTransform#transform} method.\n *\n * @codeGenApi\n */\nexport function ɵɵpipeBindV(index: number, slotOffset: number, values: [any, ...any[]]): any {\n  const adjustedIndex = index + HEADER_OFFSET;\n  const lView = getLView();\n  const pipeInstance = load<PipeTransform>(lView, adjustedIndex);\n  return isPure(lView, adjustedIndex) ?\n      pureFunctionVInternal(\n          lView, getBindingRoot(), slotOffset, pipeInstance.transform, values, pipeInstance) :\n      pipeInstance.transform.apply(pipeInstance, values);\n}\n\nfunction isPure(lView: LView, index: number): boolean {\n  return (<PipeDef<any>>lView[TVIEW].data[index]).pure;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/// <reference types=\"rxjs\" />\n\nimport {PartialObserver, Subject, Subscription} from 'rxjs';\n\n/**\n * Use in components with the `@Output` directive to emit custom events\n * synchronously or asynchronously, and register handlers for those events\n * by subscribing to an instance.\n *\n * @usageNotes\n *\n * Extends\n * [RxJS `Subject`](https://rxjs.dev/api/index/class/Subject)\n * for Angular by adding the `emit()` method.\n *\n * In the following example, a component defines two output properties\n * that create event emitters. When the title is clicked, the emitter\n * emits an open or close event to toggle the current visibility state.\n *\n * ```html\n * @Component({\n *   selector: 'zippy',\n *   template: `\n *   <div class=\"zippy\">\n *     <div (click)=\"toggle()\">Toggle</div>\n *     <div [hidden]=\"!visible\">\n *       <ng-content></ng-content>\n *     </div>\n *  </div>`})\n * export class Zippy {\n *   visible: boolean = true;\n *   @Output() open: EventEmitter<any> = new EventEmitter();\n *   @Output() close: EventEmitter<any> = new EventEmitter();\n *\n *   toggle() {\n *     this.visible = !this.visible;\n *     if (this.visible) {\n *       this.open.emit(null);\n *     } else {\n *       this.close.emit(null);\n *     }\n *   }\n * }\n * ```\n *\n * Access the event object with the `$event` argument passed to the output event\n * handler:\n *\n * ```html\n * <zippy (open)=\"onOpen($event)\" (close)=\"onClose($event)\"></zippy>\n * ```\n *\n * @see [Observables in Angular](guide/observables-in-angular)\n * @publicApi\n */\nexport interface EventEmitter<T> extends Subject<T> {\n  /**\n   * @internal\n   */\n  __isAsync: boolean;\n\n  /**\n   * Creates an instance of this class that can\n   * deliver events synchronously or asynchronously.\n   *\n   * @param [isAsync=false] When true, deliver events asynchronously.\n   *\n   */\n  new(isAsync?: boolean): EventEmitter<T>;\n\n  /**\n   * Emits an event containing a given value.\n   * @param value The value to emit.\n   */\n  emit(value?: T): void;\n\n  /**\n   * Registers handlers for events emitted by this instance.\n   * @param next When supplied, a custom handler for emitted events.\n   * @param error When supplied, a custom handler for an error notification from this emitter.\n   * @param complete When supplied, a custom handler for a completion notification from this\n   *     emitter.\n   */\n  subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void):\n      Subscription;\n  /**\n   * Registers handlers for events emitted by this instance.\n   * @param observerOrNext When supplied, a custom handler for emitted events, or an observer\n   *     object.\n   * @param error When supplied, a custom handler for an error notification from this emitter.\n   * @param complete When supplied, a custom handler for a completion notification from this\n   *     emitter.\n   */\n  subscribe(observerOrNext?: any, error?: any, complete?: any): Subscription;\n}\n\nclass EventEmitter_ extends Subject<any> {\n  __isAsync: boolean;  // tslint:disable-line\n\n  constructor(isAsync: boolean = false) {\n    super();\n    this.__isAsync = isAsync;\n  }\n\n  emit(value?: any) {\n    super.next(value);\n  }\n\n  override subscribe(observerOrNext?: any, error?: any, complete?: any): Subscription {\n    let nextFn = observerOrNext;\n    let errorFn = error || (() => null);\n    let completeFn = complete;\n\n    if (observerOrNext && typeof observerOrNext === 'object') {\n      const observer = observerOrNext as PartialObserver<unknown>;\n      nextFn = observer.next?.bind(observer);\n      errorFn = observer.error?.bind(observer);\n      completeFn = observer.complete?.bind(observer);\n    }\n\n    if (this.__isAsync) {\n      errorFn = _wrapInTimeout(errorFn);\n\n      if (nextFn) {\n        nextFn = _wrapInTimeout(nextFn);\n      }\n\n      if (completeFn) {\n        completeFn = _wrapInTimeout(completeFn);\n      }\n    }\n\n    const sink = super.subscribe({next: nextFn, error: errorFn, complete: completeFn});\n\n    if (observerOrNext instanceof Subscription) {\n      observerOrNext.add(sink);\n    }\n\n    return sink;\n  }\n}\n\nfunction _wrapInTimeout(fn: (value: unknown) => any) {\n  return (value: unknown) => {\n    setTimeout(fn, undefined, value);\n  };\n}\n\n/**\n * @publicApi\n */\nexport const EventEmitter: {\n  new (isAsync?: boolean): EventEmitter<any>; new<T>(isAsync?: boolean): EventEmitter<T>;\n  readonly prototype: EventEmitter<any>;\n} = EventEmitter_ as any;\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Observable} from 'rxjs';\n\nimport {EventEmitter} from '../event_emitter';\nimport {arrayEquals, flatten} from '../util/array_utils';\nimport {getSymbolIterator} from '../util/symbol';\n\nfunction symbolIterator<T>(this: QueryList<T>): Iterator<T> {\n  return ((this as any as {_results: Array<T>})._results as any)[getSymbolIterator()]();\n}\n\n/**\n * An unmodifiable list of items that Angular keeps up to date when the state\n * of the application changes.\n *\n * The type of object that {@link ViewChildren}, {@link ContentChildren}, and {@link QueryList}\n * provide.\n *\n * Implements an iterable interface, therefore it can be used in both ES6\n * javascript `for (var i of items)` loops as well as in Angular templates with\n * `*ngFor=\"let i of myList\"`.\n *\n * Changes can be observed by subscribing to the changes `Observable`.\n *\n * NOTE: In the future this class will implement an `Observable` interface.\n *\n * @usageNotes\n * ### Example\n * ```typescript\n * @Component({...})\n * class Container {\n *   @ViewChildren(Item) items:QueryList<Item>;\n * }\n * ```\n *\n * @publicApi\n */\nexport class QueryList<T> implements Iterable<T> {\n  public readonly dirty = true;\n  private _results: Array<T> = [];\n  private _changesDetected: boolean = false;\n  private _changes: EventEmitter<QueryList<T>>|null = null;\n\n  readonly length: number = 0;\n  readonly first: T = undefined!;\n  readonly last: T = undefined!;\n\n  /**\n   * Returns `Observable` of `QueryList` notifying the subscriber of changes.\n   */\n  get changes(): Observable<any> {\n    return this._changes || (this._changes = new EventEmitter());\n  }\n\n  /**\n   * @param emitDistinctChangesOnly Whether `QueryList.changes` should fire only when actual change\n   *     has occurred. Or if it should fire when query is recomputed. (recomputing could resolve in\n   *     the same result)\n   */\n  constructor(private _emitDistinctChangesOnly: boolean = false) {\n    // This function should be declared on the prototype, but doing so there will cause the class\n    // declaration to have side-effects and become not tree-shakable. For this reason we do it in\n    // the constructor.\n    // [getSymbolIterator()](): Iterator<T> { ... }\n    const symbol = getSymbolIterator();\n    const proto = QueryList.prototype as any;\n    if (!proto[symbol]) proto[symbol] = symbolIterator;\n  }\n\n  /**\n   * Returns the QueryList entry at `index`.\n   */\n  get(index: number): T|undefined {\n    return this._results[index];\n  }\n\n  /**\n   * See\n   * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\n   */\n  map<U>(fn: (item: T, index: number, array: T[]) => U): U[] {\n    return this._results.map(fn);\n  }\n\n  /**\n   * See\n   * [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)\n   */\n  filter(fn: (item: T, index: number, array: T[]) => boolean): T[] {\n    return this._results.filter(fn);\n  }\n\n  /**\n   * See\n   * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)\n   */\n  find(fn: (item: T, index: number, array: T[]) => boolean): T|undefined {\n    return this._results.find(fn);\n  }\n\n  /**\n   * See\n   * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)\n   */\n  reduce<U>(fn: (prevValue: U, curValue: T, curIndex: number, array: T[]) => U, init: U): U {\n    return this._results.reduce(fn, init);\n  }\n\n  /**\n   * See\n   * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)\n   */\n  forEach(fn: (item: T, index: number, array: T[]) => void): void {\n    this._results.forEach(fn);\n  }\n\n  /**\n   * See\n   * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)\n   */\n  some(fn: (value: T, index: number, array: T[]) => boolean): boolean {\n    return this._results.some(fn);\n  }\n\n  /**\n   * Returns a copy of the internal results list as an Array.\n   */\n  toArray(): T[] {\n    return this._results.slice();\n  }\n\n  toString(): string {\n    return this._results.toString();\n  }\n\n  /**\n   * Updates the stored data of the query list, and resets the `dirty` flag to `false`, so that\n   * on change detection, it will not notify of changes to the queries, unless a new change\n   * occurs.\n   *\n   * @param resultsTree The query results to store\n   * @param identityAccessor Optional function for extracting stable object identity from a value\n   *    in the array. This function is executed for each element of the query result list while\n   *    comparing current query list with the new one (provided as a first argument of the `reset`\n   *    function) to detect if the lists are different. If the function is not provided, elements\n   *    are compared as is (without any pre-processing).\n   */\n  reset(resultsTree: Array<T|any[]>, identityAccessor?: (value: T) => unknown): void {\n    // Cast to `QueryListInternal` so that we can mutate fields which are readonly for the usage of\n    // QueryList (but not for QueryList itself.)\n    const self = this as QueryListInternal<T>;\n    (self as {dirty: boolean}).dirty = false;\n    const newResultFlat = flatten(resultsTree);\n    if (this._changesDetected = !arrayEquals(self._results, newResultFlat, identityAccessor)) {\n      self._results = newResultFlat;\n      self.length = newResultFlat.length;\n      self.last = newResultFlat[this.length - 1];\n      self.first = newResultFlat[0];\n    }\n  }\n\n  /**\n   * Triggers a change event by emitting on the `changes` {@link EventEmitter}.\n   */\n  notifyOnChanges(): void {\n    if (this._changes && (this._changesDetected || !this._emitDistinctChangesOnly))\n      this._changes.emit(this);\n  }\n\n  /** internal */\n  setDirty() {\n    (this as {dirty: boolean}).dirty = true;\n  }\n\n  /** internal */\n  destroy(): void {\n    (this.changes as EventEmitter<any>).complete();\n    (this.changes as EventEmitter<any>).unsubscribe();\n  }\n\n  // The implementation of `Symbol.iterator` should be declared here, but this would cause\n  // tree-shaking issues with `QueryList. So instead, it's added in the constructor (see comments\n  // there) and this declaration is left here to ensure that TypeScript considers QueryList to\n  // implement the Iterable interface. This is required for template type-checking of NgFor loops\n  // over QueryLists to work correctly, since QueryList must be assignable to NgIterable.\n  [Symbol.iterator]!: () => Iterator<T>;\n}\n\n/**\n * Internal set of APIs used by the framework. (not to be made public)\n */\ninterface QueryListInternal<T> extends QueryList<T> {\n  reset(a: any[]): void;\n  notifyOnChanges(): void;\n  length: number;\n  last: T;\n  first: T;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '../di/injector';\nimport {assertLContainer} from '../render3/assert';\nimport {createLView, renderView} from '../render3/instructions/shared';\nimport {TContainerNode, TNode, TNodeType} from '../render3/interfaces/node';\nimport {DECLARATION_LCONTAINER, LView, LViewFlags, QUERIES, TView} from '../render3/interfaces/view';\nimport {getCurrentTNode, getLView} from '../render3/state';\nimport {ViewRef as R3_ViewRef} from '../render3/view_ref';\nimport {assertDefined} from '../util/assert';\n\nimport {createElementRef, ElementRef} from './element_ref';\nimport {EmbeddedViewRef} from './view_ref';\n\n/**\n * Represents an embedded template that can be used to instantiate embedded views.\n * To instantiate embedded views based on a template, use the `ViewContainerRef`\n * method `createEmbeddedView()`.\n *\n * Access a `TemplateRef` instance by placing a directive on an `<ng-template>`\n * element (or directive prefixed with `*`). The `TemplateRef` for the embedded view\n * is injected into the constructor of the directive,\n * using the `TemplateRef` token.\n *\n * You can also use a `Query` to find a `TemplateRef` associated with\n * a component or a directive.\n *\n * @see `ViewContainerRef`\n * @see [Navigate the Component Tree with DI](guide/dependency-injection-navtree)\n *\n * @publicApi\n */\nexport abstract class TemplateRef<C> {\n  /**\n   * The anchor element in the parent view for this embedded view.\n   *\n   * The data-binding and injection contexts of embedded views created from this `TemplateRef`\n   * inherit from the contexts of this location.\n   *\n   * Typically new embedded views are attached to the view container of this location, but in\n   * advanced use-cases, the view can be attached to a different container while keeping the\n   * data-binding and injection context from the original location.\n   *\n   */\n  // TODO(i): rename to anchor or location\n  abstract readonly elementRef: ElementRef;\n\n  /**\n   * Instantiates an embedded view based on this template,\n   * and attaches it to the view container.\n   * @param context The data-binding context of the embedded view, as declared\n   * in the `<ng-template>` usage.\n   * @param injector Injector to be used within the embedded view.\n   * @returns The new embedded view object.\n   */\n  abstract createEmbeddedView(context: C, injector?: Injector): EmbeddedViewRef<C>;\n\n  /**\n   * @internal\n   * @nocollapse\n   */\n  static __NG_ELEMENT_ID__: () => TemplateRef<any>| null = injectTemplateRef;\n}\n\nconst ViewEngineTemplateRef = TemplateRef;\n\n// TODO(alxhub): combine interface and implementation. Currently this is challenging since something\n// in g3 depends on them being separate.\nconst R3TemplateRef = class TemplateRef<T> extends ViewEngineTemplateRef<T> {\n  constructor(\n      private _declarationLView: LView, private _declarationTContainer: TContainerNode,\n      public override elementRef: ElementRef) {\n    super();\n  }\n\n  override createEmbeddedView(context: T, injector?: Injector): EmbeddedViewRef<T> {\n    const embeddedTView = this._declarationTContainer.tViews as TView;\n    const embeddedLView = createLView(\n        this._declarationLView, embeddedTView, context, LViewFlags.CheckAlways, null,\n        embeddedTView.declTNode, null, null, null, null, injector || null);\n\n    const declarationLContainer = this._declarationLView[this._declarationTContainer.index];\n    ngDevMode && assertLContainer(declarationLContainer);\n    embeddedLView[DECLARATION_LCONTAINER] = declarationLContainer;\n\n    const declarationViewLQueries = this._declarationLView[QUERIES];\n    if (declarationViewLQueries !== null) {\n      embeddedLView[QUERIES] = declarationViewLQueries.createEmbeddedView(embeddedTView);\n    }\n\n    renderView(embeddedTView, embeddedLView, context);\n\n    return new R3_ViewRef<T>(embeddedLView);\n  }\n};\n\n/**\n * Creates a TemplateRef given a node.\n *\n * @returns The TemplateRef instance to use\n */\nexport function injectTemplateRef<T>(): TemplateRef<T>|null {\n  return createTemplateRef<T>(getCurrentTNode()!, getLView());\n}\n\n/**\n * Creates a TemplateRef and stores it on the injector.\n *\n * @param hostTNode The node on which a TemplateRef is requested\n * @param hostLView The `LView` to which the node belongs\n * @returns The TemplateRef instance or null if we can't create a TemplateRef on a given node type\n */\nexport function createTemplateRef<T>(hostTNode: TNode, hostLView: LView): TemplateRef<T>|null {\n  if (hostTNode.type & TNodeType.Container) {\n    ngDevMode && assertDefined(hostTNode.tViews, 'TView must be allocated');\n    return new R3TemplateRef(\n        hostLView, hostTNode as TContainerNode, createElementRef(hostTNode, hostLView));\n  }\n  return null;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '../di/injector';\nimport {EnvironmentInjector} from '../di/r3_injector';\nimport {isType, Type} from '../interface/type';\nimport {assertNodeInjector} from '../render3/assert';\nimport {ComponentFactory as R3ComponentFactory} from '../render3/component_ref';\nimport {getComponentDef} from '../render3/definition';\nimport {getParentInjectorLocation, NodeInjector} from '../render3/di';\nimport {addToViewTree, createLContainer} from '../render3/instructions/shared';\nimport {CONTAINER_HEADER_OFFSET, LContainer, NATIVE, VIEW_REFS} from '../render3/interfaces/container';\nimport {NodeInjectorOffset} from '../render3/interfaces/injector';\nimport {TContainerNode, TDirectiveHostNode, TElementContainerNode, TElementNode, TNodeType} from '../render3/interfaces/node';\nimport {RComment, RElement} from '../render3/interfaces/renderer_dom';\nimport {isLContainer} from '../render3/interfaces/type_checks';\nimport {LView, PARENT, RENDERER, T_HOST, TVIEW} from '../render3/interfaces/view';\nimport {assertTNodeType} from '../render3/node_assert';\nimport {addViewToContainer, destroyLView, detachView, getBeforeNodeForView, insertView, nativeInsertBefore, nativeNextSibling, nativeParentNode} from '../render3/node_manipulation';\nimport {getCurrentTNode, getLView} from '../render3/state';\nimport {getParentInjectorIndex, getParentInjectorView, hasParentInjector} from '../render3/util/injector_utils';\nimport {getNativeByTNode, unwrapRNode, viewAttachedToContainer} from '../render3/util/view_utils';\nimport {ViewRef as R3ViewRef} from '../render3/view_ref';\nimport {addToArray, removeFromArray} from '../util/array_utils';\nimport {assertDefined, assertEqual, assertGreaterThan, assertLessThan, throwError} from '../util/assert';\n\nimport {ComponentFactory, ComponentRef} from './component_factory';\nimport {createElementRef, ElementRef} from './element_ref';\nimport {NgModuleRef} from './ng_module_factory';\nimport {TemplateRef} from './template_ref';\nimport {EmbeddedViewRef, ViewRef} from './view_ref';\n/**\n * Represents a container where one or more views can be attached to a component.\n *\n * Can contain *host views* (created by instantiating a\n * component with the `createComponent()` method), and *embedded views*\n * (created by instantiating a `TemplateRef` with the `createEmbeddedView()` method).\n *\n * A view container instance can contain other view containers,\n * creating a [view hierarchy](guide/glossary#view-tree).\n *\n * @see `ComponentRef`\n * @see `EmbeddedViewRef`\n *\n * @publicApi\n */\nexport abstract class ViewContainerRef {\n  /**\n   * Anchor element that specifies the location of this container in the containing view.\n   * Each view container can have only one anchor element, and each anchor element\n   * can have only a single view container.\n   *\n   * Root elements of views attached to this container become siblings of the anchor element in\n   * the rendered view.\n   *\n   * Access the `ViewContainerRef` of an element by placing a `Directive` injected\n   * with `ViewContainerRef` on the element, or use a `ViewChild` query.\n   *\n   * <!-- TODO: rename to anchorElement -->\n   */\n  abstract get element(): ElementRef;\n\n  /**\n   * The [dependency injector](guide/glossary#injector) for this view container.\n   */\n  abstract get injector(): Injector;\n\n  /** @deprecated No replacement */\n  abstract get parentInjector(): Injector;\n\n  /**\n   * Destroys all views in this container.\n   */\n  abstract clear(): void;\n\n  /**\n   * Retrieves a view from this container.\n   * @param index The 0-based index of the view to retrieve.\n   * @returns The `ViewRef` instance, or null if the index is out of range.\n   */\n  abstract get(index: number): ViewRef|null;\n\n  /**\n   * Reports how many views are currently attached to this container.\n   * @returns The number of views.\n   */\n  abstract get length(): number;\n\n  /**\n   * Instantiates an embedded view and inserts it\n   * into this container.\n   * @param templateRef The HTML template that defines the view.\n   * @param context The data-binding context of the embedded view, as declared\n   * in the `<ng-template>` usage.\n   * @param options Extra configuration for the created view. Includes:\n   *  * index: The 0-based index at which to insert the new view into this container.\n   *           If not specified, appends the new view as the last entry.\n   *  * injector: Injector to be used within the embedded view.\n   *\n   * @returns The `ViewRef` instance for the newly created view.\n   */\n  abstract createEmbeddedView<C>(templateRef: TemplateRef<C>, context?: C, options?: {\n    index?: number,\n    injector?: Injector\n  }): EmbeddedViewRef<C>;\n\n  /**\n   * Instantiates an embedded view and inserts it\n   * into this container.\n   * @param templateRef The HTML template that defines the view.\n   * @param context The data-binding context of the embedded view, as declared\n   * in the `<ng-template>` usage.\n   * @param index The 0-based index at which to insert the new view into this container.\n   * If not specified, appends the new view as the last entry.\n   *\n   * @returns The `ViewRef` instance for the newly created view.\n   */\n  abstract createEmbeddedView<C>(templateRef: TemplateRef<C>, context?: C, index?: number):\n      EmbeddedViewRef<C>;\n\n  /**\n   * Instantiates a single component and inserts its host view into this container.\n   *\n   * @param componentType Component Type to use.\n   * @param options An object that contains extra parameters:\n   *  * index: the index at which to insert the new component's host view into this container.\n   *           If not specified, appends the new view as the last entry.\n   *  * injector: the injector to use as the parent for the new component.\n   *  * ngModuleRef: an NgModuleRef of the component's NgModule, you should almost always provide\n   *                 this to ensure that all expected providers are available for the component\n   *                 instantiation.\n   *  * environmentInjector: an EnvironmentInjector which will provide the component's environment.\n   *                 you should almost always provide this to ensure that all expected providers\n   *                 are available for the component instantiation. This option is intended to\n   *                 replace the `ngModuleRef` parameter.\n   *  * projectableNodes: list of DOM nodes that should be projected through\n   *                      [`<ng-content>`](api/core/ng-content) of the new component instance.\n   *\n   * @returns The new `ComponentRef` which contains the component instance and the host view.\n   */\n  abstract createComponent<C>(componentType: Type<C>, options?: {\n    index?: number,\n    injector?: Injector,\n    ngModuleRef?: NgModuleRef<unknown>,\n    environmentInjector?: EnvironmentInjector|NgModuleRef<unknown>,\n    projectableNodes?: Node[][],\n  }): ComponentRef<C>;\n\n  /**\n   * Instantiates a single component and inserts its host view into this container.\n   *\n   * @param componentFactory Component factory to use.\n   * @param index The index at which to insert the new component's host view into this container.\n   * If not specified, appends the new view as the last entry.\n   * @param injector The injector to use as the parent for the new component.\n   * @param projectableNodes List of DOM nodes that should be projected through\n   *     [`<ng-content>`](api/core/ng-content) of the new component instance.\n   * @param ngModuleRef An instance of the NgModuleRef that represent an NgModule.\n   * This information is used to retrieve corresponding NgModule injector.\n   *\n   * @returns The new `ComponentRef` which contains the component instance and the host view.\n   *\n   * @deprecated Angular no longer requires component factories to dynamically create components.\n   *     Use different signature of the `createComponent` method, which allows passing\n   *     Component class directly.\n   */\n  abstract createComponent<C>(\n      componentFactory: ComponentFactory<C>, index?: number, injector?: Injector,\n      projectableNodes?: any[][],\n      environmentInjector?: EnvironmentInjector|NgModuleRef<any>): ComponentRef<C>;\n\n  /**\n   * Inserts a view into this container.\n   * @param viewRef The view to insert.\n   * @param index The 0-based index at which to insert the view.\n   * If not specified, appends the new view as the last entry.\n   * @returns The inserted `ViewRef` instance.\n   *\n   */\n  abstract insert(viewRef: ViewRef, index?: number): ViewRef;\n\n  /**\n   * Moves a view to a new location in this container.\n   * @param viewRef The view to move.\n   * @param index The 0-based index of the new location.\n   * @returns The moved `ViewRef` instance.\n   */\n  abstract move(viewRef: ViewRef, currentIndex: number): ViewRef;\n\n  /**\n   * Returns the index of a view within the current container.\n   * @param viewRef The view to query.\n   * @returns The 0-based index of the view's position in this container,\n   * or `-1` if this container doesn't contain the view.\n   */\n  abstract indexOf(viewRef: ViewRef): number;\n\n  /**\n   * Destroys a view attached to this container\n   * @param index The 0-based index of the view to destroy.\n   * If not specified, the last view in the container is removed.\n   */\n  abstract remove(index?: number): void;\n\n  /**\n   * Detaches a view from this container without destroying it.\n   * Use along with `insert()` to move a view within the current container.\n   * @param index The 0-based index of the view to detach.\n   * If not specified, the last view in the container is detached.\n   */\n  abstract detach(index?: number): ViewRef|null;\n\n  /**\n   * @internal\n   * @nocollapse\n   */\n  static __NG_ELEMENT_ID__: () => ViewContainerRef = injectViewContainerRef;\n}\n\n/**\n * Creates a ViewContainerRef and stores it on the injector. Or, if the ViewContainerRef\n * already exists, retrieves the existing ViewContainerRef.\n *\n * @returns The ViewContainerRef instance to use\n */\nexport function injectViewContainerRef(): ViewContainerRef {\n  const previousTNode = getCurrentTNode() as TElementNode | TElementContainerNode | TContainerNode;\n  return createContainerRef(previousTNode, getLView());\n}\n\nconst VE_ViewContainerRef = ViewContainerRef;\n\n// TODO(alxhub): cleaning up this indirection triggers a subtle bug in Closure in g3. Once the fix\n// for that lands, this can be cleaned up.\nconst R3ViewContainerRef = class ViewContainerRef extends VE_ViewContainerRef {\n  constructor(\n      private _lContainer: LContainer,\n      private _hostTNode: TElementNode|TContainerNode|TElementContainerNode,\n  